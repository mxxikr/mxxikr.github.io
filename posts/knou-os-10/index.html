<!DOCTYPE html><html lang="en" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="ko"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="[운영 체제] 10강 - 페이지 교체 알고리즘" /><meta name="author" content="mxxikr" /><meta property="og:locale" content="en" /><meta name="description" content="💡해당 게시글은 방송통신대학교 김진욱 교수님의 &#39;운영 체제&#39; 강의를 개인 공부 목적으로 메모하였습니다." /><meta property="og:description" content="💡해당 게시글은 방송통신대학교 김진욱 교수님의 &#39;운영 체제&#39; 강의를 개인 공부 목적으로 메모하였습니다." /><link rel="canonical" href="https://mxxikr.github.io/posts/knou-os-10/" /><meta property="og:url" content="https://mxxikr.github.io/posts/knou-os-10/" /><meta property="og:site_name" content="MXXI.kr" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-05-02T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[운영 체제] 10강 - 페이지 교체 알고리즘" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@mxxikr" /><meta name="google-site-verification" content="jrB0ZGRmhAQ9sqzUNV-C9QdF0brDTEBfkBb9o7loUxc" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"mxxikr"},"dateModified":"2025-08-19T16:51:15+09:00","datePublished":"2025-05-02T00:00:00+09:00","description":"💡해당 게시글은 방송통신대학교 김진욱 교수님의 &#39;운영 체제&#39; 강의를 개인 공부 목적으로 메모하였습니다.","headline":"[운영 체제] 10강 - 페이지 교체 알고리즘","mainEntityOfPage":{"@type":"WebPage","@id":"https://mxxikr.github.io/posts/knou-os-10/"},"url":"https://mxxikr.github.io/posts/knou-os-10/"}</script><title>[운영 체제] 10강 - 페이지 교체 알고리즘 | MXXI.kr</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png?v=3"><link rel="icon" type="image/png" sizes="512x512" href="/assets/img/favicons/android-chrome-512x512.png?v=3"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-chrome-192x192.png?v=3"><link rel="icon" type="image/png" sizes="64x64" href="/assets/img/favicons/favicon-64x64.png?v=3"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png?v=3"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png?v=3"><link rel="manifest" href="/assets/img/favicons/site.webmanifest?v=3"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico?v=3"><meta name="apple-mobile-web-app-title" content="MXXI.kr"><meta name="application-name" content="MXXI.kr"><meta name="msapplication-TileColor" content="#c4beed"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml?v=2"><meta name="theme-color" content="#c4beed"> <script src="https://cdn.jsdelivr.net/npm/mermaid@9.3.0/dist/mermaid.min.js"></script> <script> document.addEventListener('DOMContentLoaded', function() { mermaid.initialize({ startOnLoad: true, theme: 'neutral', securityLevel: 'loose', flowchart: { curve: 'basis', padding: 15, nodeSpacing: 30, rankSpacing: 50, htmlLabels: true } }); // Mermaid 다이어그램 렌더링 후 스타일 적용 setTimeout(function() { document.querySelectorAll('.mermaid').forEach(function(element) { element.style.background = '#f8f9fa'; element.style.padding = '15px'; element.style.borderRadius = '8px'; element.style.marginTop = '10px'; element.style.marginBottom = '20px'; }); }, 1000); }); </script><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><link rel="dns-prefetch" href="//fonts.googleapis.com"><link rel="dns-prefetch" href="//fonts.gstatic.com"><link rel="dns-prefetch" href="//cdn.jsdelivr.net"><link rel="preload" href="/assets/css/style.css" as="style"><link rel="preload" href="/assets/js/apple-liquid-glass.js" as="script"> <script> // 개발 환경에서만 로딩 시간 체크 if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') { window.addEventListener('load', () => { if ('performance' in window) { const perfData = performance.getEntriesByType('navigation')[0]; const loadTime = perfData.loadEventEnd - perfData.loadEventStart; console.log('📊 Page loaded in:', loadTime + 'ms'); } }); } </script> <script> if ('serviceWorker' in navigator) { window.addEventListener('load', () => { navigator.serviceWorker.register('/sw.js') .then(registration => console.log('SW registered')) .catch(error => console.log('SW registration failed')); }); } </script> <script> (function() { 'use strict'; // Intersection Observer 지원 확인 if (!('IntersectionObserver' in window)) { // 폴백: 모든 이미지를 즉시 로드 const images = document.querySelectorAll('img[data-src]'); images.forEach(img => { img.src = img.dataset.src; img.removeAttribute('data-src'); }); return; } // 이미지 지연 로딩 설정 const imageObserver = new IntersectionObserver((entries, observer) => { entries.forEach(entry => { if (entry.isIntersecting) { const img = entry.target; // 이미지 로드 const loadImage = () => { const src = img.dataset.src; if (src) { img.src = src; img.classList.add('loaded'); img.removeAttribute('data-src'); } }; // 이미지 로드 완료 시 처리 img.onload = () => { img.classList.add('fade-in'); }; // 이미지 로드 에러 시 처리 img.onerror = () => { img.classList.add('error'); console.warn('Failed to load image:', img.dataset.src); }; loadImage(); observer.unobserve(img); } }); }, { rootMargin: '50px 0px', // 50px 전에 미리 로드 threshold: 0.01 }); // 모든 지연 로딩 이미지에 Observer 적용 const lazyImages = document.querySelectorAll('img[data-src]'); lazyImages.forEach(img => { imageObserver.observe(img); }); // 페이지 로드 완료 후 남은 이미지들 처리 window.addEventListener('load', () => { const remainingImages = document.querySelectorAll('img[data-src]'); remainingImages.forEach(img => { img.src = img.dataset.src; img.removeAttribute('data-src'); }); }); })(); </script><style> img[data-src] { opacity: 0; transition: opacity 0.3s ease-in-out; } img.loaded { opacity: 1; } img.fade-in { animation: fadeIn 0.5s ease-in-out; } img.error { opacity: 0.5; filter: grayscale(100%); } @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } } /* 플레이스홀더 스타일 */ .lazy-placeholder { background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%); background-size: 200% 100%; animation: loading 1.5s infinite; } @keyframes loading { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }</style><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-center"><div class="profile-wrapper text-center"><div class="site-title"> <a href="/">MXXI.kr</a></div><div class="site-subtitle font-weight-bold">Backend Developer</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/mxxikr" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['mxxikr','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[운영 체제] 10강 - 페이지 교체 알고리즘</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[운영 체제] 10강 - 페이지 교체 알고리즘</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1746111600" data-df="ll" data-toggle="tooltip" data-placement="bottom"> May 2, 2025 </em> </span> <span> Updated <em class="" data-ts="1755589875" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Aug 19, 2025 </em> </span><div class="d-flex justify-content-between"> <span> By <em> mxxikr </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2608 words"> read <em>14 min</em> </span></div></div></div><div class="post-content"><p><strong><center>💡해당 게시글은 방송통신대학교 김진욱 교수님의 '운영 체제' 강의를 개인 공부 목적으로 메모하였습니다. </center></strong></p><p><br /><br /></p><h1 id="학습-개요">학습 개요</h1><hr /><ul><li>새로운 페이지를 메모리에 적재하려는데 빈 페이지 프레임이 없을 경우 페이지 프레임 중 한 칸을 선택하여 거기에 든 페이지 대신 새로운 페이지를 넣어야 함<li>어떤 페이지를 교체 대상으로 선택 하느냐에 따라 컴퓨터 시스템의 성능에 영향을 주게 됨<li>다중 프로그래밍 환경에서는 각 프로세스가 사용할 수 있는 페이지 프레임의 개수를 제한할 필요가 있는데, 이 개수 또한 컴퓨터 시스템의 성능에 영향을 줌<li>여러 가지 페이지 교체 알고리즘에 대해 학습함<li>프로세스 별 페이지 집합을 관리하는 기법도 살펴봄</ul><p><br /><br /></p><h1 id="학습-목표">학습 목표</h1><hr /><ul><li>다양한 페이지 교체 알고리즘을 설명할 수 있음<li>프로세스 별 페이지 집합 관리를 설명할 수 있음</ul><p><br /><br /></p><h1 id="강의록">강의록</h1><hr /><h2 id="페이지-교체-알고리즘"><span class="mr-2"><strong>페이지 교체 알고리즘</strong></span><a href="#페이지-교체-알고리즘" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="페이징-기법"><span class="mr-2"><strong>페이징 기법</strong></span><a href="#페이징-기법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>모든 페이지 프레임이 사용되고 있을 때 새로 적재되어야 할 페이지를 위해 적절한 교체 대상을 결정</p><p><img data-src="/assets/img/knou/os/2025-05-02-knou-os-10/image.png" alt="image.png" data-proofer-ignore></p></ul><h3 id="교체-대상-선택"><span class="mr-2"><strong>교체 대상 선택</strong></span><a href="#교체-대상-선택" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>최적화의 원칙<ul><li>앞으로 가장 오랫동안 사용되지 않을 페이지를 교체 대상으로 선택<li>이론적으로 최적이나 미래를 예측할 수 없어 실현 불가능</ul><li>선택을 위한 기본 정책<ul><li>대체로 좋은 결론은 내리면서 선택을 위한 시간 및 공간 오버 헤드가 적은 방법</ul><li>교체 제외 페이지<ul><li>페이징을 위한 커널 코드 영역<li>보조 기억 장치 드라이버 영역<li>시간을 맞춰 동작해야 하는 코드 영역<li>입출력 장치를 위한 데이터 버퍼 영역 등</ul></ul><h3 id="페이지-교체-알고리즘-1"><span class="mr-2"><strong>페이지 교체 알고리즘</strong></span><a href="#페이지-교체-알고리즘-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>FIFO 페이지 교체<li>LRU 페이지 교체<li>LFU 페이지 교체<li>2차 기회 페이지 교체</ul><h3 id="fifo-페이지-교체"><span class="mr-2"><strong>FIFO 페이지 교체</strong></span><a href="#fifo-페이지-교체" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>FIFO (First-In First-Out)<ul><li>메모리 내에 가장 오래 있었던 페이지를 선택하여 교체</ul><li><strong>구현</strong><ul><li>FIFO 큐 이용</ul><p><img data-src="/assets/img/knou/os/2025-05-02-knou-os-10/b33ce94f-4f73-42fc-8269-474167e8bd87.png" alt="image.png" data-proofer-ignore></p><ol><li>교체 대상 페이지 선택 (FIFO 큐의 선두)<li>가상 메모리에 보관<li>새로운 페이지 적재 (FIFO 큐의 끝에 추가)</ol><li>단점<ul><li>가장 많이 쓰이는 페이지를 교체 시킬 가능성 있음<li>Belady의 이상 현상<ul><li>프로세스에 더 많은 수의 페이지 프레임을 할당하면 오히려 페이지 부재가 더 많이 발생할 수 있는 현상</ul></ul><li><p><strong>Belady의 이상 현상 예</strong></p><p><img data-src="/assets/img/knou/os/2025-05-02-knou-os-10/7a194623-90a5-4732-8141-0d8ef42b7114.png" alt="image.png" data-proofer-ignore></p></ul><h3 id="lru-페이지-교체"><span class="mr-2"><strong>LRU 페이지 교체</strong></span><a href="#lru-페이지-교체" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>LPU(Least Recently Used)<li>메모리 내에서 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체<li>국부성(locality) 휴리스틱에 기반<ul><li>최근의 상황이 가까운 미래에 대한 좋은 척도<li>시간 국부성, 공간 국부성</ul><li>구현<ul><li>참조 시각 또는 리스트 이용</ul><li>참조 시각을 이용한 구현<ul><li>각 페이지가 참조될 때마다 그때의 시각을 테이블에 기록<li>교체가 필요한 경우 참조 시각이 가장 오래된 페이지를 선택하여 교체</ul><p><img data-src="/assets/img/knou/os/2025-05-02-knou-os-10/image1.png" alt="image.png" data-proofer-ignore></p><ul><li>교체가 필요할 때 참조 시각이 가장 오래된 C를 B와 교체</ul><li>리스트를 이용한 구현<ul><li>각 페이지가 참조될 때마다 리스트의 선두로 옮김<li>교체가 필요한 경우 리스트의 끝에 있는 페이지를 선택하여 교체</ul><p><img data-src="/assets/img/knou/os/2025-05-02-knou-os-10/6911c5ad-a416-4ee6-bf23-4dd8a26554a3.png" alt="image.png" data-proofer-ignore></p><li>장점<ul><li>Belady의 이상 현상 발생하지 않음<li>많은 경우 최적화 원칙에 근사한 선택 가능</ul><li>단점<ul><li>국부성이 맞지 않는 상황도 존재<li>막대한 오버 헤드</ul></ul><h3 id="lfu-페이지-교체"><span class="mr-2"><strong>LFU 페이지 교체</strong></span><a href="#lfu-페이지-교체" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>LFU(Least Frequently Used)<li>메모리 내에서 참조 된 횟수가 가장 적은 페이지를 선택하여 교체<li>구현<ul><li>참조 횟수 이용<ul><li>각 페이지가 참조될 때마다 참조 횟수를 기록<li>교체가 필요한 경우 참조 횟수가 가장 적은 페이지를 선택하여 교체</ul></ul><p><img data-src="/assets/img/knou/os/2025-05-02-knou-os-10/image2.png" alt="image.png" data-proofer-ignore></p><li>단점<ul><li>가장 최근에 메모리로 옮겨진 페이지가 교체될 가능성 높음<li>초기에 매우 많이 사용된 후 더 이상 사용되지 않는 페이지는 교체 가능성 낮음<li>막대한 오버 헤드</ul></ul><h3 id="2차-기회-페이지-교체"><span class="mr-2"><strong>2차 기회 페이지 교체</strong></span><a href="#2차-기회-페이지-교체" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>참조 비트가 0이면서 메모리 내에 가장 오래 있었던 페이지를 선택하여 교체<li>구현<ul><li>FIFO 큐와 참조 비트 이용<ul><li>각 페이지가 메모리에 적재될 때는 참조 비트 0<li>적재된 상태에서 추가로 참조되면 참조 비트 1</ul></ul><p><img data-src="/assets/img/knou/os/2025-05-02-knou-os-10/image3.png" alt="image.png" data-proofer-ignore></p><li>참조할 페이지가 메모리에 없는 경우<ul><li>빈 페이지 프레임이 있으면<ul><li>페이지 적재, 큐에 추가, 참조 비트는 0으로 설정</ul><li>빈 페이지 프레임이 없으면<ol><li>큐의 선두 항목을 꺼내 참조 비트 조사<li>참조 비트가 1이면 0으로 바꿔 큐의 뒤에 추가 후 1) 단계로 이동<li>참조 비트가 0이면 교체 대상으로 선택하여 교체</ol></ul><li>참조할 페이지가 메모리에 있는 경우<ul><li>큐 위치 변화 없이 참조 비트만 1로 설정</ul><li><p>큐를 이용한 구현</p><p><img data-src="/assets/img/knou/os/2025-05-02-knou-os-10/image4.png" alt="image.png" data-proofer-ignore></p><p><img data-src="/assets/img/knou/os/2025-05-02-knou-os-10/image5.png" alt="image.png" data-proofer-ignore></p><ul><li>B 페이지 참조<ul><li>큐에서 A의 참조 값 1 확인 후 참조 값 0으로 바꿔 큐의 맨 뒤로 이동<li>큐에서 C의 참조 값 1 확인 후 참조 값 0으로 바꿔 큐의 맨 뒤로 이동<li>큐에서 D의 참조 값 0 확인 후 참조 값 0이므로 B로 교체</ul></ul><li>변형 된 원형 큐를 이용한 구현(클럭 페이지 교체 알고리즘)<ul><li>포인터는 마지막에 추가된 페이지의 다음 위치를 가리킴<ul><li>빈 페이지 프레임이 있는 경우: 빈칸<li>페이지 프레임이 꽉 찬 경우: 큐의 선두</ul><p><img data-src="/assets/img/knou/os/2025-05-02-knou-os-10/image6.png" alt="image.png" data-proofer-ignore></p><p><img data-src="/assets/img/knou/os/2025-05-02-knou-os-10/image7.png" alt="image.png" data-proofer-ignore></p></ul></ul><h2 id="프로세스-별-페이지-집합-관리"><span class="mr-2"><strong>프로세스 별 페이지 집합 관리</strong></span><a href="#프로세스-별-페이지-집합-관리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>프로세스마다 사용할 수 있는 페이지 프레임의 개수만큼 메모리에 유지 되는 페이지 집합<li>집합의 크기가 작을수록 시스템 처리량 증대<ul><li>각 프로세스 별 페이지 부재는 자주 발생하여 성능 저하</ul><li>집합의 크기가 클수록 프로세스 별 페이지 부재는 감소<ul><li>메모리에 적재될 수 있는 프로세스 수는 줄어듦</ul><li>각 프로세스가 사용할 수 있는 페이지 프레임 개수 관리<ul><li>워킹 세트 알고리즘, PFF 알고리즘</ul></ul><h3 id="워킹-세트-알고리즘"><span class="mr-2"><strong>워킹 세트 알고리즘</strong></span><a href="#워킹-세트-알고리즘" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>워킹 세트(working set) 모델<ul><li>페이지 부재 비율을 감소 시키기 위해 Denning이 제안한 모델</ul><li>프로세스의 워킹 세트 W(t, ∂)<ul><li>시각 t에 t를 포함한 직전 ∂시간 동안 참조한 페이지의 집합</ul><p><img data-src="/assets/img/knou/os/2025-05-02-knou-os-10/image8.png" alt="image.png" data-proofer-ignore></p></ul><h3 id="워킹-세트-알고리즘-1"><span class="mr-2">워킹 세트 알고리즘</span><a href="#워킹-세트-알고리즘-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>프로세스가 수행 됨에 따라 그 프로세스의 워킹 세트는 변할 수 있으며 워킹 세트의 크기도 달라질 수 있음<li>워킹 세트 알고리즘의 원칙<ul><li>프로세스의 워킹 세트를 메모리에 유지 시키는 것</ul><li>워킹 세트를 메모리에 유지하지 않으면 쓰래싱 유발 가능<ul><li><strong>쓰래싱 (thrashing)</strong><ul><li>페이지 부재가 비정상적으로 많이 발생하여 프로세스 처리보다 페이지 교체 처리에 너무 많은 시간을 소비하여 시스템의 처리량이 급감하는 현상</ul></ul><li>프로세스마다 워킹 세트 크기에 맞게 페이지 프레임 개수 조절<li>충분한 여분의 페이지 프레임이 존재<ul><li>실행 프로세스 수 늘림</ul><li>실행 중인 프로세스들의 워킹 세트 크기의 합이 총 페이지 프레임 수를 넘어섬<ul><li>우선 순위가 낮은 프로세스를 일시 중지</ul><li>문제점<ul><li>과거를 통해 미래를 예측하는 것이 정확하지 않음<li>워킹 세트를 정확히 알아내고 계속 업데이트하는 것이 현실적으로 어려움<li>워킹 세트 윈도 크기 ∂의 최적 값을 알기 어려우며 이 역시 변화할 수 있음</ul></ul><h3 id="pff-알고리즘"><span class="mr-2"><strong>PFF 알고리즘</strong></span><a href="#pff-알고리즘" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>페이지 부재 빈도(PFF)를 이용하여 프로세스 별 페이지 집합의 크기를 변화 시키는 기법<li>PFF(Page Fault Frequency)<ul><li>얼마나 자주 페이지 교체가 발생하는 지를 나타내는 척도<li>페이지 부재가 발생하면 직전 페이지 부재 이후로 경과 된 시간의 역수</ul><li>PFF의 상한과 하한을 정해 둠<li>PFF가 상한보다 높으면<ul><li>페이지 프레임 개수를 1 증가</ul><li>PFF가 하한보다 낮으면<ul><li>그 사이에 참조되지 않았던 페이지를 모두 제거</ul><li>장점<ul><li>프로세스 별 페이지 집합이 워킹 세트 알고리즘처럼 자주 바뀌지 않음</ul></ul><p><br /><br /></p><h1 id="정리-하기">정리 하기</h1><hr /><ul><li>페이지 교체는 메모리가 완전히 사용되고 있을 때, 새로 적재되어야 할 페이지를 위해 어느 페이지가 교체되어야 하는 지를 다룸<li>페이지 교체 알고리즘에는 FIFO, LRU, LFU, 2차 기회 페이지 교체 등이 있음<li>최적의 페이지 교체 방법은 앞으로 가장 오랫동안 사용되지 않을 페이지를 선택하는 방법이지만 현실적으로 불가능함<li>프로세스는 기억 장치 내의 정보를 균일하게 액세스하는 것이 아니라 어느 한순간에는 특정 부분을 집중적으로 참조하는 국부성을 보임<li>워킹 세트는 한 프로세스가 최근에 참조한 페이지의 집합임<li>프로세스가 효율적으로 수행되기 위해서는 워킹 세트가 메모리 내에 유지되어야 함<li>PFF 알고리즘의 기본 아이디어는 페이지 부재 빈도가 높으면 페이지 프레임을 해당 프로세스에 더 배정하고 낮으면 회수하는 것임</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/os/'>OS</a>, <a href='/categories/operating-system/'>Operating System</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/knou/" class="post-tag no-text-decoration" >knou</a> <a href="/tags/os/" class="post-tag no-text-decoration" >os</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"></div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[운영 체제] 10강 - 페이지 교체 알고리즘 - MXXI.kr&amp;url=https://mxxikr.github.io/posts/knou-os-10/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[운영 체제] 10강 - 페이지 교체 알고리즘 - MXXI.kr&amp;u=https://mxxikr.github.io/posts/knou-os-10/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://mxxikr.github.io/posts/knou-os-10/&amp;text=[운영 체제] 10강 - 페이지 교체 알고리즘 - MXXI.kr" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div><script src="https://utteranc.es/client.js" repo="mxxikr/mxxikr.github.io" issue-term="pathname" label="comments" theme="github-dark" crossorigin="anonymous" async> </script></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/google-colab-font-error/">Google Colab 환경의 Matplotlib 한글 폰트 깨짐 현상</a><li><a href="/posts/apache-kafka-quick-start/">Apache Kafka와 Spring Boot로 구축하는 실시간 데이터 처리 시스템</a><li><a href="/posts/apache-kafka-concepts/">Apache Kafka 개념과 아키텍처</a><li><a href="/posts/image-auto-optimization/">Jekyll 블로그 이미지 자동 최적화</a><li><a href="/posts/jekyll-blog-installation-guide/">Jekyll 블로그 설치 및 로컬 실행 가이드</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/knou/">knou</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/data-information-processing/">data information processing</a> <a class="post-tag" href="/tags/database/">database</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/ubiquitous-computing/">ubiquitous computing</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/network/">network</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div><script> $(document).ready(function() { // Bootstrap TOC 초기화 if ($('#toc').length) { $('#toc').toc({ 'selectors': 'h1,h2', 'container': '.post-content', 'smoothScrolling': true, 'highlightOffset': 50, 'scrollSpy': true, 'scrollSpyOffset': 50 }); // TOC 스타일 적용 함수 function applyTOCStyles() { $('#toc .nav-link').each(function() { var $link = $(this); var href = $link.attr('href'); // H1, H2 구분 if (href) { var targetElement = $(href); if (targetElement.length > 0) { var tagName = targetElement.prop('tagName'); if (tagName === 'H1') { $link.addClass('toc-h1'); } else if (tagName === 'H2') { $link.addClass('toc-h2'); } } } }); } // TOC 높이 동적 조정 함수 function adjustTOCHeight() { var toc = $('#toc'); if (toc.length === 0) return; // 먼저 모든 제한을 제거하고 자연스러운 높이로 설정 toc.css({ 'max-height': 'none', 'overflow-y': 'visible', 'overflow-x': 'visible' }); // 잠시 기다린 후 실제 내용 높이 측정 setTimeout(function() { var contentHeight = toc[0].scrollHeight; var screenHeight = $(window).height(); var maxHeight = screenHeight * 0.8; // 화면의 80%로 증가 console.log('TOC content height:', contentHeight, 'Screen height:', screenHeight, 'Max height:', maxHeight); if (contentHeight > maxHeight) { // 내용이 화면보다 크면 제한하고 스크롤 추가 toc.css({ 'max-height': maxHeight + 'px', 'overflow-y': 'auto', 'overflow-x': 'hidden' }); console.log('TOC height limited to', maxHeight + 'px with scroll'); } else { console.log('TOC using natural height:', contentHeight + 'px'); } }, 50); } // 스타일 적용 setTimeout(applyTOCStyles, 100); setTimeout(applyTOCStyles, 500); // TOC 높이 조정 - 여러 시점에서 실행 setTimeout(adjustTOCHeight, 200); setTimeout(adjustTOCHeight, 500); setTimeout(adjustTOCHeight, 1000); setTimeout(adjustTOCHeight, 2000); // 창 크기 변경 시 높이 재조정 $(window).on('resize', function() { setTimeout(adjustTOCHeight, 100); }); // 페이지 로드 완료 후에도 실행 $(window).on('load', function() { setTimeout(adjustTOCHeight, 500); }); // TOC 자동 스크롤 기능 (스크롤 박스가 있을 때만) var lastActiveItem = ''; function scrollToActiveTOCItem() { var activeItem = $('#toc .nav-link.active'); if (activeItem.length > 0) { var activeText = activeItem.text().trim(); // 같은 항목이면 스크롤하지 않음 if (lastActiveItem === activeText) { return; } lastActiveItem = activeText; var tocContainer = $('#toc'); if (tocContainer.length > 0) { var containerHeight = tocContainer.height(); var contentHeight = tocContainer[0].scrollHeight; // 스크롤이 필요한 경우에만 자동 스크롤 if (contentHeight > containerHeight) { var activeItemTop = activeItem.position().top; var activeItemHeight = activeItem.outerHeight(); var currentScrollTop = tocContainer.scrollTop(); // 활성 아이템이 보이는 영역에 있는지 확인 var itemTop = activeItemTop + currentScrollTop; var itemBottom = itemTop + activeItemHeight; var visibleTop = currentScrollTop; var visibleBottom = currentScrollTop + containerHeight; // 아이템이 보이지 않으면 스크롤 if (itemTop < visibleTop || itemBottom > visibleBottom) { var targetScrollTop = activeItemTop - (containerHeight / 2) + (activeItemHeight / 2); var maxScrollTop = contentHeight - containerHeight; targetScrollTop = Math.max(0, Math.min(targetScrollTop, maxScrollTop)); tocContainer.animate({ scrollTop: targetScrollTop }, 200); console.log('TOC auto-scrolled to:', activeText); } } } } } // 스크롤 스파이 개선 function initScrollSpy() { var $toc = $('#toc'); var $links = $toc.find('.nav-link'); var $sections = $('.post-content h1, .post-content h2'); // 스크롤 이벤트 최적화를 위한 throttle var scrollTimeout; $(window).on('scroll', function() { if (scrollTimeout) { clearTimeout(scrollTimeout); } scrollTimeout = setTimeout(function() { var scrollTop = $(window).scrollTop(); var windowHeight = $(window).height(); var current = ''; var currentOffset = 0; $sections.each(function() { var $section = $(this); var sectionTop = $section.offset().top; var sectionHeight = $section.outerHeight(); // 섹션의 상단이 화면 상단에서 150px 이내에 있으면 활성화 if (scrollTop + 150 >= sectionTop && scrollTop + 150 < sectionTop + sectionHeight + 200) { current = $section.attr('id'); currentOffset = sectionTop; } }); // 활성 링크 업데이트 $links.removeClass('active'); if (current) { var $activeLink = $links.filter('[href="#' + current + '"]'); $activeLink.addClass('active'); // TOC 자동 스크롤 scrollToActiveTOCItem(); } }, 10); }); // 초기 활성화 $(window).trigger('scroll'); } // 스크롤 스파이 초기화 setTimeout(initScrollSpy, 200); // 초기 실행 setTimeout(scrollToActiveTOCItem, 1500); } }); </script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/knou-os-4/"><div class="card-body"> <em class="timeago small" data-ts="1743433200" > 2025-04-01 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[운영 체제] 4강 - 병행 프로세스</h3><div class="text-muted small"><p> 💡해당 게시글은 방송통신대학교 김진욱 교수님의 &#39;운영 체제&#39; 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 최근에는 여러 프로세스가 단순히 순차 처리가 아닌 병행 처리될 필요가 많음 음악 파일을 배경 음악으로 재생하며 동영상도 틀어 놓고 문서 작업을 하는 경우, 운영 체제는 이들을 병행으로 처리해야 함 특히 이렇게 병행...</p></div></div></a></div><div class="card"> <a href="/posts/knou-os-5/"><div class="card-body"> <em class="timeago small" data-ts="1743865200" > 2025-04-06 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[운영 체제] 5강 - 병행 프로세스</h3><div class="text-muted small"><p> 💡해당 게시글은 방송통신대학교 김진욱 교수님의 &#39;운영 체제&#39; 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 병행 프로세스 중 협력 프로세스에서 발생할 수 있는 구체적인 문제로 생산자-소비자 문제와 판독기-기록기 문제가 있음 협력 프로세스 사이에는 데이터를 공유하기 위해 통신이 필수인데, 이 과정에서도 다양한 문제가 발생할 ...</p></div></div></a></div><div class="card"> <a href="/posts/knou-os-6/"><div class="card-body"> <em class="timeago small" data-ts="1744383600" > 2025-04-12 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[운영 체제] 6강 - 교착 상태</h3><div class="text-muted small"><p> 💡해당 게시글은 방송통신대학교 김진욱 교수님의 &#39;운영 체제&#39; 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 병행 프로세스들은 컴퓨터 시스템의 제한된 자원을 사용하기 위해 서로 경쟁할 수 있음 만일 어떤 프로세스가 사용하고자 하는 자원을 다른 프로세스가 온전히 점유하고 있다면 그 프로세스는 대기해야 함 이렇게 요구와 점유...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/knou-dbs-10/" class="btn btn-outline-primary" prompt="Older"><p>[데이터베이스 시스템] 10강 - 데이터 저장과 파일</p></a> <a href="/posts/knou-uqc-10/" class="btn btn-outline-primary" prompt="Newer"><p>[유비쿼터스 컴퓨팅 개론] 10강 - 상황 인식 처리 기술</p></a></div></div></div><footer class="card-footer"><div class="align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/mxxikr">mxxikr</a>.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/knou/">knou</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/data-information-processing/">data information processing</a> <a class="post-tag" href="/tags/database/">database</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/ubiquitous-computing/">ubiquitous computing</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/network/">network</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> <script> document.addEventListener('DOMContentLoaded', function() { mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'loose', maxTextSize: 90000, flowchart: { htmlLabels: true, useMaxWidth: true, diagramPadding: 8, padding: 15, curve: 'basis', nodeSpacing: 80, rankSpacing: 100, ranker: 'tight-tree', align: 'UD', wrap: true, defaultRenderer: 'dagre-wrapper' } }); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/assets/js/apple-liquid-glass.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-G1QMP111QH"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-G1QMP111QH'); }); </script>
