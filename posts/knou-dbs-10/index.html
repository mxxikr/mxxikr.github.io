<!DOCTYPE html><html lang="en" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="ko"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="[데이터베이스 시스템] 10강 - 데이터 저장과 파일" /><meta name="author" content="mxxikr" /><meta property="og:locale" content="en" /><meta name="description" content="💡해당 게시글은 방송통신대학교 정재화 교수님의 &#39;데이터베이스 시스템&#39; 강의를 개인 공부 목적으로 메모하였습니다." /><meta property="og:description" content="💡해당 게시글은 방송통신대학교 정재화 교수님의 &#39;데이터베이스 시스템&#39; 강의를 개인 공부 목적으로 메모하였습니다." /><link rel="canonical" href="https://mxxikr.github.io/posts/knou-dbs-10/" /><meta property="og:url" content="https://mxxikr.github.io/posts/knou-dbs-10/" /><meta property="og:site_name" content="MXXI.kr" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-04-30T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[데이터베이스 시스템] 10강 - 데이터 저장과 파일" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@mxxikr" /><meta name="google-site-verification" content="jrB0ZGRmhAQ9sqzUNV-C9QdF0brDTEBfkBb9o7loUxc" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"mxxikr"},"dateModified":"2025-08-19T16:51:15+09:00","datePublished":"2025-04-30T00:00:00+09:00","description":"💡해당 게시글은 방송통신대학교 정재화 교수님의 &#39;데이터베이스 시스템&#39; 강의를 개인 공부 목적으로 메모하였습니다.","headline":"[데이터베이스 시스템] 10강 - 데이터 저장과 파일","mainEntityOfPage":{"@type":"WebPage","@id":"https://mxxikr.github.io/posts/knou-dbs-10/"},"url":"https://mxxikr.github.io/posts/knou-dbs-10/"}</script><title>[데이터베이스 시스템] 10강 - 데이터 저장과 파일 | MXXI.kr</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png?v=3"><link rel="icon" type="image/png" sizes="512x512" href="/assets/img/favicons/android-chrome-512x512.png?v=3"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-chrome-192x192.png?v=3"><link rel="icon" type="image/png" sizes="64x64" href="/assets/img/favicons/favicon-64x64.png?v=3"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png?v=3"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png?v=3"><link rel="manifest" href="/assets/img/favicons/site.webmanifest?v=3"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico?v=3"><meta name="apple-mobile-web-app-title" content="MXXI.kr"><meta name="application-name" content="MXXI.kr"><meta name="msapplication-TileColor" content="#c4beed"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml?v=2"><meta name="theme-color" content="#c4beed"> <script src="https://cdn.jsdelivr.net/npm/mermaid@9.3.0/dist/mermaid.min.js"></script> <script> document.addEventListener('DOMContentLoaded', function() { mermaid.initialize({ startOnLoad: true, theme: 'neutral', securityLevel: 'loose', flowchart: { curve: 'basis', padding: 15, nodeSpacing: 30, rankSpacing: 50, htmlLabels: true } }); // Mermaid 다이어그램 렌더링 후 스타일 적용 setTimeout(function() { document.querySelectorAll('.mermaid').forEach(function(element) { element.style.background = '#f8f9fa'; element.style.padding = '15px'; element.style.borderRadius = '8px'; element.style.marginTop = '10px'; element.style.marginBottom = '20px'; }); }, 1000); }); </script><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><link rel="dns-prefetch" href="//fonts.googleapis.com"><link rel="dns-prefetch" href="//fonts.gstatic.com"><link rel="dns-prefetch" href="//cdn.jsdelivr.net"><link rel="preload" href="/assets/css/style.css" as="style"><link rel="preload" href="/assets/js/apple-liquid-glass.js" as="script"> <script> // 개발 환경에서만 로딩 시간 체크 if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') { window.addEventListener('load', () => { if ('performance' in window) { const perfData = performance.getEntriesByType('navigation')[0]; const loadTime = perfData.loadEventEnd - perfData.loadEventStart; console.log('📊 Page loaded in:', loadTime + 'ms'); } }); } </script> <script> if ('serviceWorker' in navigator) { window.addEventListener('load', () => { navigator.serviceWorker.register('/sw.js') .then(registration => console.log('SW registered')) .catch(error => console.log('SW registration failed')); }); } </script> <script> (function() { 'use strict'; // Intersection Observer 지원 확인 if (!('IntersectionObserver' in window)) { // 폴백: 모든 이미지를 즉시 로드 const images = document.querySelectorAll('img[data-src]'); images.forEach(img => { img.src = img.dataset.src; img.removeAttribute('data-src'); }); return; } // 이미지 지연 로딩 설정 const imageObserver = new IntersectionObserver((entries, observer) => { entries.forEach(entry => { if (entry.isIntersecting) { const img = entry.target; // 이미지 로드 const loadImage = () => { const src = img.dataset.src; if (src) { img.src = src; img.classList.add('loaded'); img.removeAttribute('data-src'); } }; // 이미지 로드 완료 시 처리 img.onload = () => { img.classList.add('fade-in'); }; // 이미지 로드 에러 시 처리 img.onerror = () => { img.classList.add('error'); console.warn('Failed to load image:', img.dataset.src); }; loadImage(); observer.unobserve(img); } }); }, { rootMargin: '50px 0px', // 50px 전에 미리 로드 threshold: 0.01 }); // 모든 지연 로딩 이미지에 Observer 적용 const lazyImages = document.querySelectorAll('img[data-src]'); lazyImages.forEach(img => { imageObserver.observe(img); }); // 페이지 로드 완료 후 남은 이미지들 처리 window.addEventListener('load', () => { const remainingImages = document.querySelectorAll('img[data-src]'); remainingImages.forEach(img => { img.src = img.dataset.src; img.removeAttribute('data-src'); }); }); })(); </script><style> img[data-src] { opacity: 0; transition: opacity 0.3s ease-in-out; } img.loaded { opacity: 1; } img.fade-in { animation: fadeIn 0.5s ease-in-out; } img.error { opacity: 0.5; filter: grayscale(100%); } @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } } /* 플레이스홀더 스타일 */ .lazy-placeholder { background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%); background-size: 200% 100%; animation: loading 1.5s infinite; } @keyframes loading { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }</style><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-center"><div class="profile-wrapper text-center"><div class="site-title"> <a href="/">MXXI.kr</a></div><div class="site-subtitle font-weight-bold">Backend Developer</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/mxxikr" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['mxxikr','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[데이터베이스 시스템] 10강 - 데이터 저장과 파일</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[데이터베이스 시스템] 10강 - 데이터 저장과 파일</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1745938800" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Apr 30, 2025 </em> </span> <span> Updated <em class="" data-ts="1755589875" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Aug 19, 2025 </em> </span><div class="d-flex justify-content-between"> <span> By <em> mxxikr </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4851 words"> read <em>26 min</em> </span></div></div></div><div class="post-content"><p><strong><center>💡해당 게시글은 방송통신대학교 정재화 교수님의 '데이터베이스 시스템' 강의를 개인 공부 목적으로 메모하였습니다. </center></strong></p><p><br /><br /></p><h1 id="학습-개요">학습 개요</h1><hr /><ul><li>현대의 DBMS는 사용자에게 물리적 저장 세부 사항을 숨기고, 논리적 관점에서 데이터를 정의하고 조작할 수 있도록 다양한 추상화 계층을 제공함<li>이러한 추상화 덕분에 응용 개발자나 일반 사용자는 저장 장치의 구조나 접근 방식에 대해 직접 고려하지 않아도 되며, 데이터 모델과 질의 언어 수준에서 시스템을 이용할 수 있음<li>그러나 데이터의 실제 저장 방식, 파일 구조, 접근 방식 등은 데이터베이스 성능에 직접적인 영향을 미치기 때문에, 데이터베이스 관리자(DBA)는 이러한 물리적 저장 계층에 대한 깊은 이해를 바탕으로 적절한 설계를 수행하고 운영 전략을 결정해야 함<li>DBMS가 파일 시스템을 기반으로 데이터를 어떻게 저장하고 관리하는 지를 이해하기 위해, 저장 장치의 계층 적 구조, 데이터 파일의 구성 방식, 레코드의 조직 방법, 저장 장치 접근 기법 등 물리적 저장 관련 핵심 개념들을 살펴봄<li>이를 통해 논리적 수준에서 설계된 데이터베이스가 실제 저장 장치 상에서 어떻게 표현되고 동작하는 지를 파악할 수 있음</ul><p><br /><br /></p><h1 id="주요-용어">주요 용어</h1><hr /><ul><li><strong>파일</strong><ul><li>디스크에 데이터를 저장하고 사용하기 위해 접근 되는 가장 기초적인 논리적 저장 단위</ul><li><strong>블록</strong><ul><li>디스크에 데이터를 저장하는 고정적 크기의 물리적 저장 단위</ul><li><strong>레코드</strong><ul><li>블록을 구성하는 요소로 더 이상 분리될 수 없는 최소 데이터 저장 단위</ul><li><strong>멀티 셋</strong><ul><li>한 레코드의 컬럼 값이 여러 개인 컬럼</ul></ul><p><br /><br /></p><h1 id="강의록">강의록</h1><hr /><h2 id="물리적-저장-장치와-파일"><span class="mr-2">물리적 저장 장치와 파일</span><a href="#물리적-저장-장치와-파일" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="물리적-저장-장치의-구성"><span class="mr-2">물리적 저장 장치의 구성</span><a href="#물리적-저장-장치의-구성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>물리적 저장장치는 데이터 접근 속도, 용량을 기준으로 다양한 장치로 <strong>계층 적(hierarchical) 구성</strong></p><p><img data-src="/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image.png" alt="image.png" data-proofer-ignore></p></ul><h3 id="물리적-저장-장치-별-특징"><span class="mr-2">물리적 저장 장치 별 특징</span><a href="#물리적-저장-장치-별-특징" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>기억 지속성 관점으로 <strong>휘발성</strong>과 <strong>비 휘발성</strong>으로 구분<li><strong>휘발성 저장 장치</strong><ul><li><strong>캐시</strong><ul><li>CPU 내부에 위치하여 자주 사용될 것으로 예상되는 데이터를 저장</ul><li><strong>메인 메모리</strong><ul><li>임의 접근이 가능한 고속의 저장 공간</ul></ul><li><strong>비 휘발성 저장 장치</strong><ul><li><strong>플래시 메모리</strong><ul><li>메인 메모리와 유사하나 비 휘발성</ul><li><strong>자기 디스크</strong><ul><li>자성체를 통해 영구적으로 데이터를 저장</ul><li><strong>광학 디스크 드라이브</strong><ul><li>CD, DVD, Blu-ray 등</ul><li><strong>테이프</strong><ul><li>용량이 크고 저렴하나 순차 접근 방식으로 접근 속도가 매우 느림</ul></ul></ul><h3 id="데이터베이스-저장-구조"><span class="mr-2">데이터베이스 저장 구조</span><a href="#데이터베이스-저장-구조" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/knou/dbs/2025-04-30-knou-dbs-10/ee38fc91-c9b1-4004-98e2-6721d70d7b2c.png" alt="image.png" data-proofer-ignore></p><ul><li>데이터베이스는 하나 이상의 파일로 구성될 수 있음<li>각 파일은 여러 블럭으로 나뉨<li>블럭 내에는 레코드들이 저장됨<ol><li>사용자가 원하는 부분을 DBMS에 요청<li>DBMS가 내부 관리하고 있는 파일의 데이터에 접근 · 전달</ol></ul><h3 id="데이터베이스-구성-요소"><span class="mr-2">데이터베이스 구성 요소</span><a href="#데이터베이스-구성-요소" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><strong>파일</strong><ul><li>데이터를 영구적으로 저장하기 위해 사용되는 가장 기초적인 논리적 구조</ul><li><strong>블럭</strong><ul><li>파일을 고정적인 길이로 분할하여 생기는 균등한 크기의 데이터 묶음<li>일반적으로 메모리와 디스크 간 데이터 전송 단위로 결정<ul><li>데이터 전송 단위(page size)</ul></ul><li><strong>레코드</strong><ul><li>블럭에 저장되는 요소<li>관계형 모델에서 분리될 수 없는 최소 데이터 저장 단위<ul><li>입출력은 최소 단위인 레코드 단위로만</ul><li>상황에 따라 <strong>두 가지 타입</strong>으로 구분<ul><li>테이블에 존재하는 <strong>모든 레코드가 항상 길이가 같을 때 → 고정 길이 레코드</strong><li>테이블에 존재하는 <strong>레코드마다 길이가 모두 다를 때 → 가변 길이 레코드</strong></ul></ul></ul><h3 id="고정-길이-레코드"><span class="mr-2">고정 길이 레코드</span><a href="#고정-길이-레코드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p><strong>고정적인 바이트 수를 갖는 레코드</strong> 저장 시 고려되는 기법</p><ul><li><p>사원 릴레이션</p><div class="table-wrapper"><table><thead><tr><th>사번 (CHAR(8))<th>이름 (VARCHAR(20))<th>부서명 (CHAR(10))<th>연봉 (INT)<tbody><tr><td>12012<td>홍길동<td>인사부<td>90,000,000<tr><td>12034<td>임꺽정<td>재무부<td>80,000,000<tr><td>13019<td>이순신<td>법무지원부<td>90,000,000<tr><td>13030<td>장보고<td>인사부<td>75,000,000<tr><td>13044<td>나철수<td>시설관리부<td>80,000,000<tr><td>14001<td>김영희<td>마케팅부<td>90,000,000<tr><td>14004<td>유관순<td>총무부<td>92,000,000<tr><td>14017<td>안창호<td>생산부<td>98,000,000</table></div></ul><p><img data-src="/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image2.png" alt="image.png" data-proofer-ignore></p><li><p><strong>데이터 접근</strong></p><ul><li>모든 레코드는 42 바이트 크기로 구성<li>i번째 레코드 접근<ul><li>(i - 1) * 42 + 1 번째 바이트부터 42개의 바이트를 읽어 접근</ul></ul></ul><h3 id="고정-길이-레코드-할당"><span class="mr-2">고정 길이 레코드 할당</span><a href="#고정-길이-레코드-할당" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>블럭의 길이가 레코드 길이로 정확히 나눠지지 않아 잔여 공간을 비워두는 방법<ul><li>블럭 내의 남은 공간 낭비</ul><p><img data-src="/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image3.png" alt="image.png" data-proofer-ignore></p><ul><li>레코드 k + 1을 저장하고자 함 → 블럭 1에 충분한 공간이 없음 → 남겨놓고 다음 블럭에 저장</ul><li>블럭의 길이가 레코드 길이로 정확히 나눠지지 않아 한 레코드를 두 블럭에 나누어 저장하는 방법<ul><li>레코드 접근 시 <strong>두 개의 블럭</strong>에 접근 필요</ul><p><img data-src="/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image4.png" alt="image.png" data-proofer-ignore></p></ul><h3 id="고정-길이-레코드-할당-시-고려-사항"><span class="mr-2">고정 길이 레코드 할당 시 고려 사항</span><a href="#고정-길이-레코드-할당-시-고려-사항" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>레코드 삭제 시<ul><li>해당 레코드가 저장 된 위치에 빈 공간이 생성<li>장시간 레코드의 삽입 및 삭제 발생 시, 저장 공간에 많은 낭비가 발생</ul><li>레코드 삭제 시 대체 방안<ul><li>마지막 레코드로 공백 대체<li>삭제 레코드 이후의 레코드를 이동<li>가용 리스트 관리</ul></ul><h3 id="레코드-삭제-대처"><span class="mr-2">레코드 삭제 대처</span><a href="#레코드-삭제-대처" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ol><li><p>마지막 레코드로 공백 대체</p><div class="table-wrapper"><table><thead><tr><th><u>사번</u><th><u>이름</u><th>부서명<th>연봉<tbody><tr><td>12012<td>정용호<td>인사부<td>90,000,000<tr><td>12034<td>임꺽정<td>재무부<td>80,000,000<tr><td>13019<td>이순신<td>법무지원부<td>90,000,000<tr><td>13030<td>장보고<td>인사부<td>75,000,000<tr><td>13044<td>나철수<td>시설관리부<td>80,000,000<tr><td>14001<td>김영희<td>마케팅부<td>90,000,000<tr><td>14004<td>유관순<td>총무부<td>92,000,000<tr><td>14017<td>안창호<td>생산부<td>98,000,000</table></div><ul><li>속도 저하는 없으나 <strong>삽입과 접근의 순서</strong>가 달라질 수도 있음</ul><li><p>삭제 레코드 이후의 레코드를 이동</p><div class="table-wrapper"><table><thead><tr><th><u>사번</u><th><u>이름</u><th>부서명<th>연봉<tbody><tr><td>12012<td>정용호<td>인사부<td>90,000,000<tr><td>12034<td>임꺽정<td>재무부<td>80,000,000<tr><td>13019<td>이순신<td>법무지원부<td>90,000,000<tr><td>13044<td>나철수<td>시설관리부<td>80,000,000<tr><td>14001<td>김영희<td>마케팅부<td>90,000,000<tr><td>14004<td>유관순<td>총무부<td>92,000,000<tr><td>14017<td>안창호<td>생산부<td>98,000,000</table></div><ul><li><p>레코드 4번 삭제 후 이동</p><div class="table-wrapper"><table><thead><tr><th><u>사번</u><th><u>이름</u><th>부서명<th>연봉<tbody><tr><td>13030<td>장보고<td>인사부<td>75,000,000</table></div><li>저장의 순서와 접근의 순서가 크게 달라지지 않음<li>순서는 유지되나 <strong>성능 저하</strong>가 크게 일어날 수도 있음</ul><li><p>가용 리스트 관리</p><p><img data-src="/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image7.png" alt="image.png" data-proofer-ignore></p><ul><li>새로운 레코드가 들어오려 할 때 가용 리스트의 첫 번째 헤더에 할당해 저장 시킴<li><strong>포인터의 정보</strong>를 연속적으로 유지, 보유해야 함</ul></ol><h3 id="가변-길이-레코드"><span class="mr-2">가변 길이 레코드</span><a href="#가변-길이-레코드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>블럭에 저장 되는 레코드의 길이가 <strong>서로 다른(가변적)레코드를 할당</strong>하는 방법<ul><li>가변 길이 레코드는 길이를 예상할 수가 없음 → 수식을 통해 데이터에 접근할 수 없음</ul><li>가변 길이 레코드가 고려되어야 하는 상황<ul><li>한 블럭 내에 저장 되는 레코드 유형이 둘 이상<li>길이가 고정되지 않은 컬럼의 개수가 하나 이상<li>레코드가 멀티 셋을 허용하는 컬럼을 가질 때<ul><li>멀티셋<ul><li>레코드의 컬럼 값이 여러 개인 컬럼</ul></ul></ul><p><img data-src="/assets/img/knou/dbs/2025-04-30-knou-dbs-10/71c5fcb1-e3e9-4ece-b4e5-d46bfcd9b267.png" alt="image.png" data-proofer-ignore></p><ul><li>가변 길이에 해당하는 컬럼은 맨 뒤에 배치시킴<li>가변 길이 컬럼이 시작하는 시작 포인터와 길이를 레코드 맨 앞에 위치 시킴<li>NULL<ul><li>가변 길이와 고정 길이를 구분하기 위해 추가<li>1byte</ul></ul></ul><h3 id="슬롯-페이지-구조"><span class="mr-2">슬롯 페이지 구조</span><a href="#슬롯-페이지-구조" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>가변길이 레코드를 관리하기에 최적의 방법</ul><p><img data-src="/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image8.png" alt="image.png" data-proofer-ignore></p><ul><li>블럭 헤더<ul><li>몇 번째 레코드를 읽어와야 하는 지를 파악</ul></ul><h3 id="파일-구조화-방법"><span class="mr-2">파일 구조화 방법</span><a href="#파일-구조화-방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>파일 구조화<ul><li>파일 수준에서 레코드를 관리(순서 등)하는 기법</ul><p><img data-src="/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image9.png" alt="image.png" data-proofer-ignore></p><ul><li>테이블에 존재하는 블록 중 어느 순서에 저장해야 할까?(어디에)</ul></ul><h3 id="파일-구조화-방법의-종류"><span class="mr-2">파일 구조화 방법의 종류</span><a href="#파일-구조화-방법의-종류" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>힙 파일 구조<ul><li>저장 순서 고려 없이 파일 내 임의 블럭에 배치<li>장점<ul><li>저장 순서가 빠름</ul><li>단점<ul><li>검색의 속도가 떨어짐<li>어느 블록에 있는지 일일이 확인해야 함</ul></ul><li>순차 파일 구조<ul><li>레코드가 탐색 키 기준으로 정렬되어 저장<li>장점<ul><li>검색 순서가 빠름</ul><li>단점<ul><li>힙 파일 구조보다는 저장 속도가 떨어짐</ul></ul><li>해시 파일 구조<ul><li>해시 함수를 사용하여 블럭 주소를 계산<li>힙 파일 구조와 순차 파일 구조의 중간 지점에 해당</ul></ul><p><img data-src="/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image10.png" alt="image.png" data-proofer-ignore></p><h3 id="순차-파일-구조의-예"><span class="mr-2">순차 파일 구조의 예</span><a href="#순차-파일-구조의-예" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image11.png" alt="image.png" data-proofer-ignore></p><h3 id="순차-파일-구조"><span class="mr-2">순차 파일 구조</span><a href="#순차-파일-구조" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>레코드가 <strong>탐색 키 순서대로</strong> 정렬<li>레코드가 파일에 삽입 되는 시점에서 키 값이 부여<li>장점<ul><li>검색 키에 대한 정렬 연산이 불 필요, 키 값들의 순서로 레코드를 판독하는 연산에 효율적<li>현재 레코드에서 정렬 된 키 순서로 다음 레코드를 찾을 때 부가적인 블럭 접근이 불필요<li>이진 탐색을 사용하면 더 빠르게 레코드를 검색</ul><li>단점<ul><li>레코드 삽입, 삭제에 많은 비용 소요</ul></ul><h3 id="오버-플로우-블럭"><span class="mr-2">오버 플로우 블럭</span><a href="#오버-플로우-블럭" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>순차 파일 구조에서 <strong>레코드의 정렬 된 상태 유지</strong>를 위해 삽입 된 신규 블럭</p><p><img data-src="/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image12.png" alt="image.png" data-proofer-ignore></p><ul><li>신규 데이터를 삽입할 때 기존 저장 공간에 여유가 없거나 데이터의 순서를 유지하기 위해 데이터가 원래의 블럭에 적합하지 않을 경우, 이를 저장하기 위해 새롭게 생성되는 추가 블럭<ol><li>새로운 래코드가 삽입 되어야 할 위치가 정해져 있지만 해당 블럭에 여유 공간이 없는 경우 새로운 블럭을 생성하여 데이터를 생성함<li>기존 블럭과 오버 플로우 블럭을 포인터로 연결해 기존의 순차성을 유지하면서 추가 데이터 검색할 수 있음</ol><li>단점<ul><li>데이터 접근 속도와 검색 효율성 저하</ul></ul></ul><h2 id="저장-장치-관리"><span class="mr-2">저장 장치 관리</span><a href="#저장-장치-관리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="저장-장치-접근"><span class="mr-2">저장 장치 접근</span><a href="#저장-장치-접근" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>파일은 논리적 관점에서의 저장 객체<li>실제 저장 될 때에는 여러 개의 물리적 단위인 <strong>블럭</strong>으로 저장<ul><li>블럭은 메모리와 디스크 간 데이터의 전송 단위<li>일반적으로 2KB ~ 32KB 사용<li>블럭 전송을 최소화할 수록 입출력 소요 시간이 단축<ul><li>사용 중인 블럭을 지속적으로 메모리에 적재<li>한정적 공간으로 인하여 필요에 따라 특정 블럭 할당을 해지<li>메모리 내부에 버퍼라는 공간에 블럭을 저장하고, 이를 관리하기 위한 버퍼 관리자를 사용</ul></ul><p><img data-src="/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image13.png" alt="image.png" data-proofer-ignore></p></ul><h3 id="버퍼-관리자"><span class="mr-2">버퍼 관리자</span><a href="#버퍼-관리자" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>DBMS가 메모리 내부의 공간인 버퍼(buffer)를 효율적으로 관리하기 위한 하위 시스템<ul><li>계속 사용하고 잇는 <strong>블럭을 고정</strong>시켜 <strong>효율적으로 메모리를 사용</strong></ul><li>DBMS 상의 소프트웨어는 필요한 블럭이 있을 때 버퍼 관리자에게 해당 블럭을 요청<ul><li>요청 된 블럭이 버퍼에 있다면, 버퍼 관리자는 블럭이 위치한 메모리 주소를 프로그램에게 전달<li>요청 된 블럭이 없는 경우, 버퍼 관리자는 버퍼 내의 새로운 공간을 할당하고 해당 블럭을 적재<li>더 이상 적재할 공간이 없다면, 버퍼에 있는 기존 블럭을 선택하여 할당을 해지하고 해당 블럭을 적재</ul></ul><h3 id="버퍼-교체-전략"><span class="mr-2">버퍼 교체 전략</span><a href="#버퍼-교체-전략" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image14.png" alt="image.png" data-proofer-ignore></p><ul><li><strong>교체의 우선순위</strong>를 조작</ul><h3 id="버퍼-관리자의-기능"><span class="mr-2">버퍼 관리자의 기능</span><a href="#버퍼-관리자의-기능" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>버퍼 교체<ul><li>가용 공간을 확보 하기 위해 기존에 적재 된 블록을 특정 기준에 의하여 해지<li>미래에 가장 적게 사용 될 블록을 선택하여 디스크로 내보내는 것이 이상적인 버퍼 교체 전략<li>버퍼 교체 전략<ul><li>LRU(Least Recently Used)<ul><li>최근에 가장 적게 참조 된 블럭을 교체</ul><li>MFU(Most Frequently Used)<ul><li>특정 기간 동안 가장 여러 번 사용 된 블럭을 선택하여 블럭을 교체</ul></ul></ul><li>블럭 고정<ul><li>장애로 메모리의 데이터가 손실 되어 작업이 중단될 경우, 중단 된 작업의 결과물이 디스크에 기록되는 것을 방지<li>디스크 블럭이 교체되는 것을 제한</ul><li>블럭 강제 출력<ul><li>시스템 로그와 같이 중요한 데이터는 디스크에 영구적으로 기록되어야 할 필요<li>버퍼 공간이 필요 없어도 강제로 디스크에 기록</ul></ul><h3 id="고정-블럭과-블럭-강제-출력"><span class="mr-2">고정 블럭과 블럭 강제 출력</span><a href="#고정-블럭과-블럭-강제-출력" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image15.png" alt="image.png" data-proofer-ignore></p><p><br /><br /></p><h1 id="연습-문제">연습 문제</h1><hr /><ol><li><p>다음 물리적 저장 장치들 중 휘발성과 비휘발성 장치를 올바르게 짝지은 것은?</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre> 디스크, 메인 메모리, 자기 테이프, 캐시
</pre></table></code></div></div><p>a. 휘발성-&lt;캐시, 메인 메모리&gt;,  비휘발성-&lt;디스크, 자기 테이프&gt;</p><ul><li>전원 공급이 없을 때 데이터가 사라지는 휘발성 저장장치로는 주로 CPU가 이용하는 주 기억 장치인 레지스터, 캐시, 메인 메모리가 있음<li>전원 공급이 없어도 데이터가 보존되는 비 휘발성 저장장치는 디스크와 같이 주 기억 장치보다 하위에 위치하는 보조 기억 장치와 3차 기억 장치인 광학 디스크 드라이브와 자기 테이프가 있음</ul><li><p>다음은 어떤 파일 구조에 대한 설명인가?</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre> 모든 레코드를 파일 내 임의의 위치에 저장하며, 저장하는 순서를 고려하지 않는 파일 구조
</pre></table></code></div></div><p>a. 힙 파일 구조</p><ul><li>순차 파일 구조에서는 레코드들이 특정 컬럼에 대한 값을 기준으로 정렬되어 저장이 됨<li>해시 파일 구조에서는 레코드가 입력 되면 레코드가 저장 될 블록 주소를 반환해주는 해시 함수를 사용함<li>다중 테이블 클러스터링 파일 구조는 빈번히 조인 되는 테이블을 하나의 파일에 저장하기 위해 미리 테이블이 조인 되어 저장 되어있는 구조임</ul><li><p>다음은 어떤 버퍼 교체 전략에 관한 설명인가?</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre> 미래에 가장 적게 사용될 블록을 선택하여 버퍼에 적재하기 위해 특정 기간동안 가장 여러 번 사용된 블럭을 선택하여 블럭을 교체
</pre></table></code></div></div><p>a. MFU</p><ul><li>LRU의 경우 최근에 참조된 블록은 다시 참조 될 가능성이 높다고 판단하여 가장 최근에 적게 참조 된 블록을 교체하는 전략임<li>SJF(최단 작업 우선 스케줄링)와 FCFS(선입 선처리 스케줄링)는 CPU에 프로세스를 할당하기 위한 전략임</ul></ol><p><br /><br /></p><h1 id="정리-하기">정리 하기</h1><hr /><ul><li>물리적 저장 장치들은 데이터 접근 속도 관점에서 계층 적으로 분류됨<ul><li>상위 계층은 접근 속도가 빠르지만 고가의 장비이며, 하위 계층은 접근 속도가 느리지만 저가의 장비임</ul><li>일반적으로 상위의 저장 장치들은 전원 공급이 차단되면 데이터가 소멸되는 휘발성이며, 하위의 저장장치들은 전원 공급이 차단되어도 데이터가 소멸되지 않는 비 휘발성임<li>데이터베이스는 여러 파일로 구현됨<ul><li>파일이란 데이터를 영구적으로 저장하기 위해 사용하는 구조임<li>파일은 물리적으로 여러 블럭으로 나뉘어 저장되기도 함<li>하나의 파일은 다수의 레코드를 저장하고 있음</ul><li>레코드의 형식은 고정 길이 레코드와 가변 길이 레코드가 있음<ul><li>레코드의 형식에 따라 파일 및 블럭에서 레코드를 관리하는 방식이 달라짐<li>특히 슬롯 페이지 구조는 가변 길이 레코드를 관리할 때 이용되는 블럭 구조임</ul><li>특정 필드에 대한 빠른 접근이 요구되는 경우, 파일에 저장되는 레코드를 구조화하는 것이 좋음<ul><li>파일 구조화 방법으로는 힙 파일 구조화, 순차 파일 구조화, 해시 파일 구조화가 있음<li>파일 구조 중 다중 테이블 군집 파일 구조는 여러 개의 테이블을 하나의 파일에서 관리하는 특수한 파일 구조임</ul><li>메모리와 디스크는 블럭 단위로 데이터를 주고받음<ul><li>이때 데이터베이스 시스템에서는 블럭의 입출력을 최소화하기 위해 메모리 내에 버퍼라는 공간을 만들며, 버퍼를 효율적으로 관리하기 위해 버퍼 관리자를 사용함</ul><li>버퍼 관리자는 버퍼 공간에 대한 추가적인 공간 요청 시 버퍼 교체 전략을 사용하여 사용 된 블록을 디스크로 내보내어 공간을 확보함</ul><p><br /><br /></p><h1 id="체크-포인트">체크 포인트</h1><hr /><ol><li><p>데이터베이스 저장 구조에 대한 설명으로 옳지 않은 것은?</p><p>a. 해싱 파일은 각 레코드의 속성에 해싱 함수를 적용한 후 레코드들을 정렬하여 저장</p><ul><li>레코드를 정렬하지는 않음<li>데이터베이스 저장 구조에 대한 설명으로 옳은 것은?<ul><li>힙 파일은 파일에서 빈 공간이 있다면 레코드를 어느 위치에나 저장<li>순차 파일은 검색키 값의 순서에 따라 정렬된 형태로 레코드들을 저장<li>다중테이블 클러스터링 파일은 서로 다른 릴레이션들의 관련 레코드들을 같은 블록에 저장</ul></ul><li><p>다음 중 가변 길이 레코드 방식이 필요한 이유가 아닌 것은?</p><p>a. 레코드의 수정이 매우 자주 발생할 때</p><ul><li>가변 길이 레코드 방식이 필요한 이유<ul><li>레코드가 멀티셋(multiset)을 이용하는 컬럼을 가질 때<li>한 블록 내에 저장되는 레코드 유형이 둘 이상일 때<li>길이가 고정되지 않은 컬럼이 한 개 이상일 때</ul></ul></ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/database/'>Database</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/knou/" class="post-tag no-text-decoration" >knou</a> <a href="/tags/database/" class="post-tag no-text-decoration" >database</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"></div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[데이터베이스 시스템] 10강 - 데이터 저장과 파일 - MXXI.kr&amp;url=https://mxxikr.github.io/posts/knou-dbs-10/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[데이터베이스 시스템] 10강 - 데이터 저장과 파일 - MXXI.kr&amp;u=https://mxxikr.github.io/posts/knou-dbs-10/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://mxxikr.github.io/posts/knou-dbs-10/&amp;text=[데이터베이스 시스템] 10강 - 데이터 저장과 파일 - MXXI.kr" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div><script src="https://utteranc.es/client.js" repo="mxxikr/mxxikr.github.io" issue-term="pathname" label="comments" theme="github-dark" crossorigin="anonymous" async> </script></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/google-colab-font-error/">Google Colab 환경의 Matplotlib 한글 폰트 깨짐 현상</a><li><a href="/posts/apache-kafka-quick-start/">Apache Kafka와 Spring Boot로 구축하는 실시간 데이터 처리 시스템</a><li><a href="/posts/apache-kafka-concepts/">Apache Kafka 개념과 아키텍처</a><li><a href="/posts/image-auto-optimization/">Jekyll 블로그 이미지 자동 최적화</a><li><a href="/posts/jekyll-blog-installation-guide/">Jekyll 블로그 설치 및 로컬 실행 가이드</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/knou/">knou</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/data-information-processing/">data information processing</a> <a class="post-tag" href="/tags/database/">database</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/ubiquitous-computing/">ubiquitous computing</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/network/">network</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div><script> $(document).ready(function() { // Bootstrap TOC 초기화 if ($('#toc').length) { $('#toc').toc({ 'selectors': 'h1,h2', 'container': '.post-content', 'smoothScrolling': true, 'highlightOffset': 50, 'scrollSpy': true, 'scrollSpyOffset': 50 }); // TOC 스타일 적용 함수 function applyTOCStyles() { $('#toc .nav-link').each(function() { var $link = $(this); var href = $link.attr('href'); // H1, H2 구분 if (href) { var targetElement = $(href); if (targetElement.length > 0) { var tagName = targetElement.prop('tagName'); if (tagName === 'H1') { $link.addClass('toc-h1'); } else if (tagName === 'H2') { $link.addClass('toc-h2'); } } } }); } // TOC 높이 동적 조정 함수 function adjustTOCHeight() { var toc = $('#toc'); if (toc.length === 0) return; // 먼저 모든 제한을 제거하고 자연스러운 높이로 설정 toc.css({ 'max-height': 'none', 'overflow-y': 'visible', 'overflow-x': 'visible' }); // 잠시 기다린 후 실제 내용 높이 측정 setTimeout(function() { var contentHeight = toc[0].scrollHeight; var screenHeight = $(window).height(); var maxHeight = screenHeight * 0.8; // 화면의 80%로 증가 console.log('TOC content height:', contentHeight, 'Screen height:', screenHeight, 'Max height:', maxHeight); if (contentHeight > maxHeight) { // 내용이 화면보다 크면 제한하고 스크롤 추가 toc.css({ 'max-height': maxHeight + 'px', 'overflow-y': 'auto', 'overflow-x': 'hidden' }); console.log('TOC height limited to', maxHeight + 'px with scroll'); } else { console.log('TOC using natural height:', contentHeight + 'px'); } }, 50); } // 스타일 적용 setTimeout(applyTOCStyles, 100); setTimeout(applyTOCStyles, 500); // TOC 높이 조정 - 여러 시점에서 실행 setTimeout(adjustTOCHeight, 200); setTimeout(adjustTOCHeight, 500); setTimeout(adjustTOCHeight, 1000); setTimeout(adjustTOCHeight, 2000); // 창 크기 변경 시 높이 재조정 $(window).on('resize', function() { setTimeout(adjustTOCHeight, 100); }); // 페이지 로드 완료 후에도 실행 $(window).on('load', function() { setTimeout(adjustTOCHeight, 500); }); // TOC 자동 스크롤 기능 (스크롤 박스가 있을 때만) var lastActiveItem = ''; function scrollToActiveTOCItem() { var activeItem = $('#toc .nav-link.active'); if (activeItem.length > 0) { var activeText = activeItem.text().trim(); // 같은 항목이면 스크롤하지 않음 if (lastActiveItem === activeText) { return; } lastActiveItem = activeText; var tocContainer = $('#toc'); if (tocContainer.length > 0) { var containerHeight = tocContainer.height(); var contentHeight = tocContainer[0].scrollHeight; // 스크롤이 필요한 경우에만 자동 스크롤 if (contentHeight > containerHeight) { var activeItemTop = activeItem.position().top; var activeItemHeight = activeItem.outerHeight(); var currentScrollTop = tocContainer.scrollTop(); // 활성 아이템이 보이는 영역에 있는지 확인 var itemTop = activeItemTop + currentScrollTop; var itemBottom = itemTop + activeItemHeight; var visibleTop = currentScrollTop; var visibleBottom = currentScrollTop + containerHeight; // 아이템이 보이지 않으면 스크롤 if (itemTop < visibleTop || itemBottom > visibleBottom) { var targetScrollTop = activeItemTop - (containerHeight / 2) + (activeItemHeight / 2); var maxScrollTop = contentHeight - containerHeight; targetScrollTop = Math.max(0, Math.min(targetScrollTop, maxScrollTop)); tocContainer.animate({ scrollTop: targetScrollTop }, 200); console.log('TOC auto-scrolled to:', activeText); } } } } } // 스크롤 스파이 개선 function initScrollSpy() { var $toc = $('#toc'); var $links = $toc.find('.nav-link'); var $sections = $('.post-content h1, .post-content h2'); // 스크롤 이벤트 최적화를 위한 throttle var scrollTimeout; $(window).on('scroll', function() { if (scrollTimeout) { clearTimeout(scrollTimeout); } scrollTimeout = setTimeout(function() { var scrollTop = $(window).scrollTop(); var windowHeight = $(window).height(); var current = ''; var currentOffset = 0; $sections.each(function() { var $section = $(this); var sectionTop = $section.offset().top; var sectionHeight = $section.outerHeight(); // 섹션의 상단이 화면 상단에서 150px 이내에 있으면 활성화 if (scrollTop + 150 >= sectionTop && scrollTop + 150 < sectionTop + sectionHeight + 200) { current = $section.attr('id'); currentOffset = sectionTop; } }); // 활성 링크 업데이트 $links.removeClass('active'); if (current) { var $activeLink = $links.filter('[href="#' + current + '"]'); $activeLink.addClass('active'); // TOC 자동 스크롤 scrollToActiveTOCItem(); } }, 10); }); // 초기 활성화 $(window).trigger('scroll'); } // 스크롤 스파이 초기화 setTimeout(initScrollSpy, 200); // 초기 실행 setTimeout(scrollToActiveTOCItem, 1500); } }); </script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/knou-dbs-3/"><div class="card-body"> <em class="timeago small" data-ts="1743001200" > 2025-03-27 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[데이터베이스 시스템] 3강 - 관계형 모델</h3><div class="text-muted small"><p> 💡해당 게시글은 방송통신대학교 정재화 교수님의 &#39;데이터베이스 시스템&#39; 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 우리 주변에서 사용되는 상용 DBMS의 대다수가 관계형 모델을 사용할 정도로 관계형 모델은 DBMS를 학습함에 있어 매우 중요한 데이터 모델이라고 할 수 있음 관계형 모델은 일련의 정형화된 릴레이션과 수학적 ...</p></div></div></a></div><div class="card"> <a href="/posts/knou-dbs-4/"><div class="card-body"> <em class="timeago small" data-ts="1743778800" > 2025-04-05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[데이터베이스 시스템] 4강 - SQL</h3><div class="text-muted small"><p> 💡해당 게시글은 방송통신대학교 정재화 교수님의 &#39;데이터베이스 시스템&#39; 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 DBMS의 데이터 관리 기능이 우수하다 하더라도 DBMS에 데이터 요청을 명확한 전달하고 결과를 받을 수 있는 방법이 없다면 DBMS의 높은 활용도를 기대할 수 없음 사용자와 DBMS 간 의사...</p></div></div></a></div><div class="card"> <a href="/posts/knou-dbs-5/"><div class="card-body"> <em class="timeago small" data-ts="1743865200" > 2025-04-06 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[데이터베이스 시스템] 5강 - SQL</h3><div class="text-muted small"><p> 💡해당 게시글은 방송통신대학교 정재화 교수님의 &#39;데이터베이스 시스템&#39; 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 DBMS의 기능은 데이터의 저장 및 관리에 그치지 않고 사용자의 요청에 따라 데이터의 입력, 수정, 삭제 및 필요 데이터를 신속히 제공하는 것까지 포함함 SQL은 데이터 정의 언어를 통해 데이터를 저장하고 유...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/knou-python-10/" class="btn btn-outline-primary" prompt="Older"><p>[파이썬 프로그래밍 기초] 10강 - 객체 지향</p></a> <a href="/posts/knou-os-10/" class="btn btn-outline-primary" prompt="Newer"><p>[운영 체제] 10강 - 페이지 교체 알고리즘</p></a></div></div></div><footer class="card-footer"><div class="align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/mxxikr">mxxikr</a>.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/knou/">knou</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/data-information-processing/">data information processing</a> <a class="post-tag" href="/tags/database/">database</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/ubiquitous-computing/">ubiquitous computing</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/network/">network</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> <script> document.addEventListener('DOMContentLoaded', function() { mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'loose', maxTextSize: 90000, flowchart: { htmlLabels: true, useMaxWidth: true, diagramPadding: 8, padding: 15, curve: 'basis', nodeSpacing: 80, rankSpacing: 100, ranker: 'tight-tree', align: 'UD', wrap: true, defaultRenderer: 'dagre-wrapper' } }); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/assets/js/apple-liquid-glass.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-G1QMP111QH"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-G1QMP111QH'); }); </script>
