<!DOCTYPE html><html lang="en" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="ko"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Apache Kafka 개념과 아키텍처" /><meta name="author" content="mxxikr" /><meta property="og:locale" content="en" /><meta name="description" content="개요" /><meta property="og:description" content="개요" /><link rel="canonical" href="https://mxxikr.github.io/posts/apache-kafka-concepts/" /><meta property="og:url" content="https://mxxikr.github.io/posts/apache-kafka-concepts/" /><meta property="og:site_name" content="MXXI.kr" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-10-12T01:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Apache Kafka 개념과 아키텍처" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@mxxikr" /><meta name="google-site-verification" content="jrB0ZGRmhAQ9sqzUNV-C9QdF0brDTEBfkBb9o7loUxc" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"mxxikr"},"dateModified":"2025-10-20T03:15:36+09:00","datePublished":"2025-10-12T01:00:00+09:00","description":"개요","headline":"Apache Kafka 개념과 아키텍처","mainEntityOfPage":{"@type":"WebPage","@id":"https://mxxikr.github.io/posts/apache-kafka-concepts/"},"url":"https://mxxikr.github.io/posts/apache-kafka-concepts/"}</script><title>Apache Kafka 개념과 아키텍처 | MXXI.kr</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png?v=3"><link rel="icon" type="image/png" sizes="512x512" href="/assets/img/favicons/android-chrome-512x512.png?v=3"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-chrome-192x192.png?v=3"><link rel="icon" type="image/png" sizes="64x64" href="/assets/img/favicons/favicon-64x64.png?v=3"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png?v=3"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png?v=3"><link rel="manifest" href="/assets/img/favicons/site.webmanifest?v=3"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico?v=3"><meta name="apple-mobile-web-app-title" content="MXXI.kr"><meta name="application-name" content="MXXI.kr"><meta name="msapplication-TileColor" content="#c4beed"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml?v=2"><meta name="theme-color" content="#c4beed"> <script src="https://cdn.jsdelivr.net/npm/mermaid@9.3.0/dist/mermaid.min.js"></script> <script> document.addEventListener('DOMContentLoaded', function() { mermaid.initialize({ startOnLoad: true, theme: 'neutral', securityLevel: 'loose', flowchart: { curve: 'basis', padding: 15, nodeSpacing: 30, rankSpacing: 50, htmlLabels: true } }); // Mermaid 다이어그램 렌더링 후 스타일 적용 setTimeout(function() { document.querySelectorAll('.mermaid').forEach(function(element) { element.style.background = '#f8f9fa'; element.style.padding = '15px'; element.style.borderRadius = '8px'; element.style.marginTop = '10px'; element.style.marginBottom = '20px'; }); }, 1000); }); </script><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><link rel="dns-prefetch" href="//fonts.googleapis.com"><link rel="dns-prefetch" href="//fonts.gstatic.com"><link rel="dns-prefetch" href="//cdn.jsdelivr.net"><link rel="preload" href="/assets/css/style.css" as="style"><link rel="preload" href="/assets/js/apple-liquid-glass.js" as="script"> <script> // 개발 환경에서만 로딩 시간 체크 if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') { window.addEventListener('load', () => { if ('performance' in window) { const perfData = performance.getEntriesByType('navigation')[0]; const loadTime = perfData.loadEventEnd - perfData.loadEventStart; console.log('📊 Page loaded in:', loadTime + 'ms'); } }); } </script> <script> if ('serviceWorker' in navigator) { window.addEventListener('load', () => { navigator.serviceWorker.register('/sw.js') .then(registration => console.log('SW registered')) .catch(error => console.log('SW registration failed')); }); } </script> <script> (function() { 'use strict'; // Intersection Observer 지원 확인 if (!('IntersectionObserver' in window)) { // 폴백: 모든 이미지를 즉시 로드 const images = document.querySelectorAll('img[data-src]'); images.forEach(img => { img.src = img.dataset.src; img.removeAttribute('data-src'); }); return; } // 이미지 지연 로딩 설정 const imageObserver = new IntersectionObserver((entries, observer) => { entries.forEach(entry => { if (entry.isIntersecting) { const img = entry.target; // 이미지 로드 const loadImage = () => { const src = img.dataset.src; if (src) { img.src = src; img.classList.add('loaded'); img.removeAttribute('data-src'); } }; // 이미지 로드 완료 시 처리 img.onload = () => { img.classList.add('fade-in'); }; // 이미지 로드 에러 시 처리 img.onerror = () => { img.classList.add('error'); console.warn('Failed to load image:', img.dataset.src); }; loadImage(); observer.unobserve(img); } }); }, { rootMargin: '50px 0px', // 50px 전에 미리 로드 threshold: 0.01 }); // 모든 지연 로딩 이미지에 Observer 적용 const lazyImages = document.querySelectorAll('img[data-src]'); lazyImages.forEach(img => { imageObserver.observe(img); }); // 페이지 로드 완료 후 남은 이미지들 처리 window.addEventListener('load', () => { const remainingImages = document.querySelectorAll('img[data-src]'); remainingImages.forEach(img => { img.src = img.dataset.src; img.removeAttribute('data-src'); }); }); })(); </script><style> img[data-src] { opacity: 0; transition: opacity 0.3s ease-in-out; } img.loaded { opacity: 1; } img.fade-in { animation: fadeIn 0.5s ease-in-out; } img.error { opacity: 0.5; filter: grayscale(100%); } @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } } /* 플레이스홀더 스타일 */ .lazy-placeholder { background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%); background-size: 200% 100%; animation: loading 1.5s infinite; } @keyframes loading { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }</style><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-center"><div class="profile-wrapper text-center"><div class="site-title"> <a href="/">MXXI.kr</a></div><div class="site-subtitle font-weight-bold">Backend Developer</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/mxxikr" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['mxxikr','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Apache Kafka 개념과 아키텍처</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Apache Kafka 개념과 아키텍처</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1760198400" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Oct 12, 2025 </em> </span> <span> Updated <em class="" data-ts="1760897736" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Oct 20, 2025 </em> </span><div class="d-flex justify-content-between"> <span> By <em> mxxikr </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7842 words"> read <em>43 min</em> </span></div></div></div><div class="post-content"><h2 id="개요"><span class="mr-2">개요</span><a href="#개요" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>Apache Kafka는 실시간으로 대량의 데이터를 안전하게 전달하고 처리하기 위한 플랫폼임</ul><h3 id="kafka가-필요한-이유"><span class="mr-2">Kafka가 필요한 이유</span><a href="#kafka가-필요한-이유" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>우리가 사용하는 현대의 서비스들(넷플릭스, 쇼핑몰, SNS 등)은 수많은 데이터를 실시간으로 처리해야 함<ul><li>사용자의 클릭, 검색, 결제 데이터<li>서비스 로그, 에러 메시지<li>IoT 센서 데이터<li>실시간 알림</ul><li>이러한 데이터를 안전하고 빠르게 처리하기 위해 Kafka를 사용함</ul><h2 id="기본-개념"><span class="mr-2">기본 개념</span><a href="#기본-개념" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="메시지-전달-구성-요소"><span class="mr-2">메시지 전달 구성 요소</span><a href="#메시지-전달-구성-요소" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>카프카를 우체국에 비유하면 다음과 같음</p><div class="mermaid"> graph TD A[편지 작성자<br />Producer] --&gt;|편지 전송| B[우체국<br />Kafka Broker] B --&gt;|편지 분류| C[우편함<br />Topic] C --&gt;|편지 수령| D[수령인<br />Consumer]</div><li><strong>Producer(생산자)</strong><ul><li>편지를 쓰는 사람</ul><li><strong>Kafka Broker(우체국)</strong><ul><li>메시지를 저장하고 전달하는 서버</ul><li><strong>Topic(우편함)</strong><ul><li>메시지를 종류별로 구분하는 공간</ul><li><strong>Consumer(소비자)</strong><ul><li>메시지를 받아서 처리하는 프로그램</ul></ul><h3 id="메시지-추적과-관리"><span class="mr-2">메시지 추적과 관리</span><a href="#메시지-추적과-관리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><strong>커밋</strong>(<strong>Commit</strong>)이란?<ul><li>컨슈머가 어디까지 메시지를 처리했는지 표시하는 것<li>마치 책갈피처럼 다음에 어디서부터 읽어야 할지 기억<li>메시지 처리 진행 상황을 추적하고 관리</ul><li><strong>오프셋</strong>(<strong>Offset</strong>)이란?<ul><li>각 파티션 내의 메시지 위치를 가리키는 번호<li>첫 메시지는 0번부터 시작해서 순차적으로 증가<li>메시지의 고유한 ‘주소’나 ‘페이지 번호’ 같은 역할<div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>파티션
[메시지0] [메시지1] [메시지2] [메시지3] ...
  ↑         ↑         ↑         ↑
오프셋=0  오프셋=1  오프셋=2  오프셋=3
</pre></table></code></div></div></ul><li><strong>커밋과 오프셋의 관계</strong><ul><li>컨슈머는 처리한 메시지의 오프셋을 커밋<li>커밋된 오프셋을 통해 처리 진행상황 파악<li>장애 발생 시 마지막 커밋 오프셋부터 재시작</ul></ul><div class="mermaid"> sequenceDiagram participant C as Consumer participant K as Kafka participant O as __consumer_offsets Note over C,K: 메시지 소비 및 처리 K-&gt;&gt;C: 오프셋 5까지 메시지 전달 C-&gt;&gt;C: 메시지 처리 C-&gt;&gt;O: 오프셋 5 커밋 Note over C,O: 처리 완료 지점 기록 Note over C,K: 장애 발생 및 복구 C-&gt;&gt;C: 장애 발생! C-&gt;&gt;O: 마지막 커밋 오프셋 조회 O-&gt;&gt;C: 오프셋 5 반환 C-&gt;&gt;K: 오프셋 5부터 메시지 요청 K-&gt;&gt;C: 오프셋 5 이후 메시지 전달 Note over C,K: 장애 지점부터 재시작</div><h3 id="전체-아키텍처"><span class="mr-2">전체 아키텍처</span><a href="#전체-아키텍처" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>Kafka의 전체 구조를 이해하면 데이터가 어떻게 흐르는지 파악할 수 있음</p><div class="mermaid"> graph TB subgraph Producers[데이터 생산자들] P1[웹서버] P2[모바일앱] P3[IoT센서] end subgraph Kafka_Cluster[카프카 클러스터] subgraph Brokers[브로커들] B1[브로커1] B2[브로커2] B3[브로커3] end subgraph Topics[토픽들] T1[로그 토픽] T2[주문 토픽] T3[알림 토픽] end end subgraph Consumers[데이터 소비자들] C1[분석 시스템] C2[모니터링] C3[백업 시스템] end P1 &amp; P2 &amp; P3 --&gt; Brokers Brokers &lt;--&gt; Topics Topics --&gt; C1 &amp; C2 &amp; C3</div></ul><h3 id="주요-특징"><span class="mr-2">주요 특징</span><a href="#주요-특징" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><strong>안정성</strong><ul><li>데이터를 안전하게 보관 (마치 은행 금고처럼)<li>여러 서버에 복사본 저장으로 데이터 유실 방지<li>서버 장애가 발생해도 서비스 계속 운영</ul><li><strong>확장성</strong><ul><li>처리할 데이터가 늘어나면 서버 추가로 확장<li>카카오톡 단체방처럼 많은 사용자 동시 처리 가능<li>필요할 때마다 쉽게 용량 증설</ul><li><strong>고성능</strong><ul><li>대량의 데이터를 빠르게 처리<li>효율적인 데이터 저장 방식 사용<li>여러 소비자가 동시에 데이터 읽기 가능</ul></ul><h3 id="메시지-생산자-producer"><span class="mr-2">메시지 생산자 (Producer)</span><a href="#메시지-생산자-producer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>데이터를 만들어서 Kafka로 보내는 프로그램</p><div class="mermaid"> graph LR A[웹서버] --&gt;|주문 데이터| B[카프카] C[모바일앱] --&gt;|로그 데이터| B D[센서] --&gt;|측정 데이터| B</div><li><p>ex)</p><ul><li>쇼핑몰의 주문 처리 시스템<li>핸드폰 앱의 사용자 활동 로그<li>기상 관측소의 온도 센서</ul></ul><h3 id="메시지-소비자-consumer"><span class="mr-2">메시지 소비자 (Consumer)</span><a href="#메시지-소비자-consumer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>Kafka에서 데이터를 가져와서 처리하는 프로그램</p><div class="mermaid"> graph LR A[카프카] --&gt;|주문 데이터| B[결제 시스템] A --&gt;|로그 데이터| C[분석 시스템] A --&gt;|측정 데이터| D[모니터링]</div><li><p>ex)</p><ul><li>주문 데이터를 받아서 배송 처리하는 시스템<li>사용자 행동 데이터를 분석하는 시스템<li>실시간 알림을 보내는 서비스</ul></ul><h3 id="메시지-저장소-broker"><span class="mr-2">메시지 저장소 (Broker)</span><a href="#메시지-저장소-broker" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>Kafka 서버를 브로커라고 부름<li><p>데이터를 저장하고 관리하는 창고와 같음</p><div class="mermaid"> graph TB subgraph 카프카_클러스터 B1[브로커1<br />주 서버] B2[브로커2<br />백업 서버1] B3[브로커3<br />백업 서버2] B1 &lt;--&gt; B2 B2 &lt;--&gt; B3 B3 &lt;--&gt; B1 end</div><li>특징<ul><li>여러 서버가 협력하여 작동 (마치 여러 지점을 가진 은행처럼)<li>한 서버가 고장나도 다른 서버가 대신 처리<li>데이터를 안전하게 보관하고 전달</ul></ul><h3 id="메시지-분류-topic"><span class="mr-2">메시지 분류 (Topic)</span><a href="#메시지-분류-topic" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>토픽은 같은 종류의 메시지를 모아두는 공간임<li>도서관의 서가나 우체국의 우편함과 비슷함</ul><div class="mermaid"> graph TB subgraph 토픽들 T1[주문 토픽] T2[로그 토픽] T3[알림 토픽] end P1[주문 시스템] --&gt; T1 P2[앱/웹서버] --&gt; T2 P3[알림 서버] --&gt; T3 T1 --&gt; C1[결제 처리] T2 --&gt; C2[로그 분석] T3 --&gt; C3[푸시 발송]</div><ul><li>ex)<ul><li>주문 토픽: 모든 주문 관련 데이터 저장<li>로그 토픽: 시스템 로그 메시지 저장<li>알림 토픽: 사용자 알림 메시지 저장</ul></ul><h3 id="데이터-분산-저장-partition"><span class="mr-2">데이터 분산 저장 (Partition)</span><a href="#데이터-분산-저장-partition" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>각 토픽은 여러 개의 파티션으로 나뉘어 저장됨<li><p>하나의 큰 책을 여러 장으로 나누어 보관하는 것과 같음</p><div class="mermaid"> graph LR subgraph 주문_토픽 P1[파티션1<br />주문 1-1000] P2[파티션2<br />주문 1001-2000] P3[파티션3<br />주문 2001-3000] end</div><li>장점<ul><li>대량의 데이터를 나눠서 처리 가능<li>여러 소비자가 동시에 데이터 처리 가능<li>데이터 처리 속도 향상</ul></ul><h2 id="데이터-흐름"><span class="mr-2">데이터 흐름</span><a href="#데이터-흐름" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="메시지가-전달되는-과정"><span class="mr-2">메시지가 전달되는 과정</span><a href="#메시지가-전달되는-과정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><div class="mermaid"> sequenceDiagram participant P as 생산자(Producer) participant B as 브로커(Broker) participant C as 소비자(Consumer) P-&gt;&gt;+B: 1. 메시지 전송 Note over B: 2. 메시지 저장 B-&gt;&gt;-B: 3. 복제본 생성 C-&gt;&gt;+B: 4. 메시지 요청 B-&gt;&gt;-C: 5. 메시지 전달 Note over C: 6. 메시지 처리</div><ul><li>ex)<ol><li>사용자가 온라인 쇼핑몰에서 주문 버튼 클릭<li>주문 시스템(Producer)이 주문 데이터를 Kafka로 전송<li>Kafka가 주문 데이터를 ‘주문’ 토픽에 안전하게 저장<li>결제 시스템(Consumer)이 새로운 주문 데이터를 가져감<li>배송 시스템(Consumer)이 동일한 주문 데이터로 배송 처리</ol></ul><h3 id="데이터-처리-방식"><span class="mr-2">데이터 처리 방식</span><a href="#데이터-처리-방식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><div class="mermaid"> graph TB subgraph 데이터_저장소 T1[토픽 1] T2[토픽 2] T3[토픽 3] end subgraph 소비자_그룹_1 C1[소비자 1] C2[소비자 2] end subgraph 소비자_그룹_2 C3[소비자 3] C4[소비자 4] end T1 &amp; T2 &amp; T3 --&gt; C1 &amp; C2 T1 &amp; T2 &amp; T3 --&gt; C3 &amp; C4</div><ul><li><strong>병렬 처리</strong><ul><li>여러 소비자가 동시에 데이터 처리<li>처리 속도 향상<li>부하 분산</ul><li><strong>독립적 처리</strong><ul><li>각 소비자 그룹은 독립적으로 데이터 처리<li>한 그룹의 문제가 다른 그룹에 영향을 주지 않음<li>다양한 용도로 같은 데이터 사용 가능</ul><li><strong>순서 보장</strong><ul><li>같은 키를 가진 메시지는 순서대로 처리<li>ex)<ul><li>같은 사용자의 주문은 순서대로 처리</ul><li>다른 사용자의 주문은 병렬로 처리</ul></ul><h2 id="활용-사례"><span class="mr-2">활용 사례</span><a href="#활용-사례" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="로그-수집"><span class="mr-2">로그 수집</span><a href="#로그-수집" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>실시간 로그 처리<ul><li>시스템/애플리케이션 로그 수집<ul><li>서버, 애플리케이션의 모든 로그를 중앙 집중화</ul><li>실시간 모니터링 데이터 처리<ul><li>시스템 성능, 사용자 행동 패턴 실시간 추적</ul><li>보안 이벤트 로그 분석<ul><li>보안 위협 실시간 탐지 및 대응</ul></ul><li>구현 고려사항<ul><li>로그 포맷 표준화<ul><li>JSON 형식 등 일관된 로그 형식 정의</ul><li>보관 기간 설정<ul><li>법적 요구 사항, 디스크 용량을 고려한 보관 기간 설정</ul><li>처리 파이프라인 구성<ul><li>수집 → 필터링 → 저장 → 분석 단계별 처리</ul></ul></ul><h3 id="이벤트-스트리밍"><span class="mr-2">이벤트 스트리밍</span><a href="#이벤트-스트리밍" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>실시간 데이터 처리<ul><li>실시간 분석<ul><li>사용자 행동, 시장 동향 등 실시간 분석</ul><li>IoT 데이터 수집<ul><li>센서 데이터 실시간 수집 및 모니터링</ul><li>실시간 처리 파이프라인<ul><li>들어오는 데이터를 지연 없이 처리</ul></ul><li>주요 패턴<ul><li>Event Sourcing<ul><li>상태 변경을 이벤트로 저장하여 이력 관리</ul><li>CQRS<ul><li>읽기와 쓰기 작업을 분리하여 성능 최적화</ul><li>Stream Processing<ul><li>데이터 흐름을 실시간으로 처리</ul></ul></ul><h3 id="데이터-동기화"><span class="mr-2">데이터 동기화</span><a href="#데이터-동기화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>시스템 간 데이터 연동<ul><li>DB 변경 데이터 캡처(CDC)<ul><li>데이터베이스 변경사항 실시간 추적</ul><li>시스템 간 데이터 동기화<ul><li>여러 시스템의 데이터 일관성 유지</ul><li>캐시 업데이트<ul><li>캐시 데이터의 실시간 갱신으로 성능 향상</ul></ul><li>구현 패턴<ul><li>Outbox Pattern<ul><li>분산 트랜잭션 문제 해결을 위한 이벤트 발행</ul><li>Event-Driven Architecture<ul><li>이벤트 기반의 느슨한 결합 구조</ul><li>Master-Slave Replication<ul><li>데이터베이스 복제 및 동기화</ul></ul></ul><h3 id="메시징-시스템"><span class="mr-2">메시징 시스템</span><a href="#메시징-시스템" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>시스템 통합<ul><li>시스템 간 느슨한 결합<ul><li>서비스 간 직접 의존성 제거</ul><li>마이크로서비스 통신<ul><li>서비스 간 비동기 메시지 교환</ul><li>비동기 작업 처리<ul><li>시간이 오래 걸리는 작업의 비동기 처리</ul></ul><li>아키텍처 패턴<ul><li>Pub/Sub Pattern<ul><li>발행자와 구독자 간의 메시지 전달</ul><li>Point-to-Point<ul><li>1:1 메시지 전달 방식</ul><li>Request-Reply<ul><li>요청-응답 기반의 메시지 교환</ul></ul></ul><h2 id="고급-기능"><span class="mr-2">고급 기능</span><a href="#고급-기능" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="데이터-일관성과-안정성"><span class="mr-2">데이터 일관성과 안정성</span><a href="#데이터-일관성과-안정성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><strong>메시지 전송 보장 수준 (acks)</strong><ul><li><code class="language-plaintext highlighter-rouge">acks=0</code><ul><li>전송 즉시 성공으로 간주<li>속도는 가장 빠르지만 데이터 유실 위험 높음</ul><li><code class="language-plaintext highlighter-rouge">acks=1</code><ul><li>리더가 메시지 수신 확인 시 성공<li>적절한 속도와 안정성의 균형</ul><li><code class="language-plaintext highlighter-rouge">acks=all</code><ul><li>모든 복제본이 메시지 수신 확인 시 성공<li>가장 안전하지만 속도는 느림</ul></ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>  <span class="c1">// 프로듀서 설정</span>
  <span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>

  <span class="c1">// 빠른 처리 속도 우선</span>
  <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"acks"</span><span class="o">,</span> <span class="s">"0"</span><span class="o">);</span>

  <span class="c1">// 안정성과 속도의 균형</span>
  <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"acks"</span><span class="o">,</span> <span class="s">"1"</span><span class="o">);</span>

  <span class="c1">// 데이터 안정성 우선</span>
  <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"acks"</span><span class="o">,</span> <span class="s">"all"</span><span class="o">);</span>

  <span class="nc">KafkaProducer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">producer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">KafkaProducer</span><span class="o">&lt;&gt;(</span><span class="n">props</span><span class="o">);</span>
</pre></table></code></div></div><li><strong>복제 설정</strong><ul><li><code class="language-plaintext highlighter-rouge">replication.factor</code><ul><li>각 파티션의 복제본 수 지정<li>높을수록 안전하지만 리소스 사용량 증가<li>일반적으로 3 설정 (1 리더 + 2 팔로워)</ul><li><code class="language-plaintext highlighter-rouge">min.insync.replicas</code><ul><li>최소 동기화 복제본 수<li>이 수보다 적으면 쓰기 거부<li>데이터 안정성 보장을 위한 중요 설정</ul></ul><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>  <span class="c"># 토픽 생성 시 복제 설정</span>
  kafka-topics.sh <span class="nt">--create</span> <span class="se">\ </span>              <span class="c"># 토픽 생성 명령</span>
      <span class="nt">--bootstrap-server</span> localhost:9092 <span class="se">\ </span>   <span class="c"># Kafka 브로커 주소</span>
      <span class="nt">--topic</span> my-topic <span class="se">\ </span>                    <span class="c"># 생성할 토픽 이름</span>
      <span class="nt">--partitions</span> 3 <span class="se">\ </span>                      <span class="c"># 파티션 수 (병렬 처리 단위)</span>
      <span class="nt">--replication-factor</span> 3                 <span class="c"># 복제본 수 (데이터 안정성)</span>

  <span class="c"># 브로커 설정 파일에서 최소 동기화 복제본 설정</span>
  min.insync.replicas<span class="o">=</span>2
</pre></table></code></div></div><li><strong>데이터 정합성 보장</strong><ul><li>ISR(In-Sync Replicas)<ul><li>리더와 제대로 동기화된 복제본들의 집합<li><code class="language-plaintext highlighter-rouge">replica.lag.time.max.ms</code> 설정 시간 내에 리더와 동기화된 복제본만 포함<li>ISR이 아닌 복제본은 장애 복구 시 리더가 될 수 없음</ul><li>파티션 리더 선출<ul><li>리더 장애 시 ISR 중에서만 새 리더 선출<li>가장 최신 데이터(높은 LEO)를 가진 복제본이 우선 선출<li>ISR 아닌 복제본은 데이터 유실 위험으로 리더가 될 수 없음</ul><li>커밋된 메시지 처리<ul><li>High Watermark(HW)<ul><li>모든 ISR이 복제 완료한 최신 오프셋</ul><li>소비자는 HW까지의 메시지만 읽을 수 있음<li>리더 변경 시에도 HW 이후 메시지는 롤백되어 데이터 일관성 유지</ul></ul><div class="mermaid"> graph LR A[리더] --&gt;|복제| B[ISR 팔로워1] A --&gt;|복제| C[ISR 팔로워2] A --&gt;|복제 지연| D[비ISR 팔로워] subgraph 메시지_상태 E[커밋된 메시지<br />HW까지] F[언커밋 메시지<br />HW 이후] end</div></ul><h2 id="운영-관리"><span class="mr-2">운영 관리</span><a href="#운영-관리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="성능-튜닝-설정"><span class="mr-2">성능 튜닝 설정</span><a href="#성능-튜닝-설정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><strong>프로듀서 성능 설정</strong><ul><li><code class="language-plaintext highlighter-rouge">batch.size</code><ul><li>한 번에 전송할 최대 메시지 크기<li>default value: 16384 바이트<li>권장값: 64KB ~ 128KB (처리량 우선 시)<li>영향도: 메모리 사용량 ↑, 처리량 ↑<li>실제 사례: 로그 수집 시스템에서 128KB 사용 시 30% 처리량 향상</ul><li><code class="language-plaintext highlighter-rouge">linger.ms</code><ul><li>배치를 전송하기 전 대기 시간<li>default value: 0ms (즉시 전송)<li>권장값: 50ms ~ 100ms (처리량 우선 시)<li>영향도: 지연시간 ↑, 처리량 ↑<li>실제 사례: IoT 데이터 수집 시 100ms 설정으로 40% 네트워크 사용량 감소</ul><li><code class="language-plaintext highlighter-rouge">max.in.flight.requests.per.connection</code><ul><li>응답을 기다리는 최대 요청 수<li>default value: 5<li>권장값: 3 ~ 5 (메모리 제약 환경)<li>영향도: 메모리 사용량 ↑, 동시성 ↑<li>실제 사례: 고성능 환경에서 5로 설정 시 최적의 처리량 달성</ul></ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>  <span class="c1">// 프로듀서 성능 최적화 설정</span>
  <span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>

  <span class="c1">// 처리량 우선 설정</span>
  <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"batch.size"</span><span class="o">,</span> <span class="mi">262144</span><span class="o">);</span>         <span class="c1">// 256KB</span>
  <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"linger.ms"</span><span class="o">,</span> <span class="mi">100</span><span class="o">);</span>             <span class="c1">// 100ms</span>
  <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"compression.type"</span><span class="o">,</span> <span class="s">"snappy"</span><span class="o">);</span>  <span class="c1">// 압축 활성화</span>

  <span class="c1">// 안정성 우선 설정</span>
  <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"max.in.flight.requests.per.connection"</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
  <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"retries"</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
  <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"acks"</span><span class="o">,</span> <span class="s">"all"</span><span class="o">);</span>

  <span class="nc">KafkaProducer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">producer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">KafkaProducer</span><span class="o">&lt;&gt;(</span><span class="n">props</span><span class="o">);</span>
</pre></table></code></div></div><li><strong>컨슈머 성능 설정</strong><ul><li><code class="language-plaintext highlighter-rouge">fetch.min.bytes</code><ul><li>한 번에 가져올 최소 데이터 크기<li>default value: 1 바이트<li>권장값: 1KB ~ 64KB (네트워크 효율성 우선 시)<li>영향도: 지연시간 ↑, 네트워크 효율성 ↑</ul><li><code class="language-plaintext highlighter-rouge">max.poll.records</code><ul><li>한 번에 가져올 최대 레코드 수<li>default value: 500<li>권장값: 300 ~ 1000 (메모리 크기에 따라 조정)<li>영향도: 메모리 사용량 ↑, 처리 지연 가능성 ↑</ul><li><code class="language-plaintext highlighter-rouge">heartbeat.interval.ms</code><ul><li>그룹 코디네이터에 하트비트 전송 주기<li>default value: 3000ms<li>권장값: session.timeout.ms의 1/3<li>영향도: 네트워크 트래픽 ↑, 리밸런싱 감지 속도 ↑</ul></ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>  <span class="c1">// 컨슈머 성능 최적화 설정</span>
  <span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>

  <span class="c1">// 대용량 처리 설정</span>
  <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"fetch.min.bytes"</span><span class="o">,</span> <span class="mi">65536</span><span class="o">);</span>      <span class="c1">// 64KB</span>
  <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"max.poll.records"</span><span class="o">,</span> <span class="mi">500</span><span class="o">);</span>
  <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"fetch.max.bytes"</span><span class="o">,</span> <span class="mi">52428800</span><span class="o">);</span>   <span class="c1">// 50MB</span>

  <span class="c1">// 안정성 설정</span>
  <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"session.timeout.ms"</span><span class="o">,</span> <span class="mi">45000</span><span class="o">);</span>   <span class="c1">// 45초</span>
  <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"heartbeat.interval.ms"</span><span class="o">,</span> <span class="mi">15000</span><span class="o">);</span> <span class="c1">// 15초</span>
  <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"enable.auto.commit"</span><span class="o">,</span> <span class="s">"false"</span><span class="o">);</span>  <span class="c1">// 수동 커밋</span>

  <span class="nc">KafkaConsumer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">consumer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">KafkaConsumer</span><span class="o">&lt;&gt;(</span><span class="n">props</span><span class="o">);</span>
</pre></table></code></div></div><li><strong>브로커 성능 설정</strong><ul><li><code class="language-plaintext highlighter-rouge">num.io.threads</code><ul><li>디스크 I/O 처리 스레드 수<li>default value: 8<li>권장값: CPU 코어 수의 2배<li>영향도: CPU 사용량 ↑, I/O 처리량 ↑</ul><li><code class="language-plaintext highlighter-rouge">num.network.threads</code><ul><li>네트워크 요청 처리 스레드 수<li>default value: 3<li>권장값: CPU 코어 수 * 2 (최소 8)<li>영향도: CPU 사용량 ↑, 네트워크 처리량 ↑</ul><li><code class="language-plaintext highlighter-rouge">log.flush.interval.messages</code><ul><li>디스크에 강제로 기록할 메시지 수<li>default value: 9223372036854775807<li>권장값: 처리량에 따라 1000~50000<li>영향도: 디스크 I/O ↑, 데이터 내구성 ↑</ul></ul><div class="language-properties highlighter-rouge"><div class="code-header"> <span data-label-text="Properties"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre>  <span class="c"># 브로커 서버 설정 파일 (server.properties)
</span>    
  <span class="c"># 고성능 처리 설정
</span>  <span class="py">num.io.threads</span><span class="p">=</span><span class="s">16                        # CPU 코어 수 * 2</span>
  <span class="py">num.network.threads</span><span class="p">=</span><span class="s">16                   # network.threads와 동일 구성</span>
  <span class="py">num.replica.fetchers</span><span class="p">=</span><span class="s">8                   # 복제 성능 향상</span>
    
  <span class="c"># 메모리 최적화
</span>  <span class="py">socket.receive.buffer.bytes</span><span class="p">=</span><span class="s">1048576      # 1MB</span>
  <span class="py">socket.send.buffer.bytes</span><span class="p">=</span><span class="s">1048576         # 1MB</span>
  <span class="py">replica.fetch.max.bytes</span><span class="p">=</span><span class="s">104857600        # 100MB</span>
    
  <span class="c"># 디스크 I/O 최적화
</span>  <span class="py">log.flush.interval.messages</span><span class="p">=</span><span class="s">10000</span>
  <span class="py">log.flush.interval.ms</span><span class="p">=</span><span class="s">1000</span>
  <span class="py">log.flush.scheduler.interval.ms</span><span class="p">=</span><span class="s">1000</span>
    
  <span class="c"># 네트워크 최적화
</span>  <span class="py">num.partitions</span><span class="p">=</span><span class="s">8                         # 브로커당 기본 파티션 수</span>
  <span class="py">socket.request.max.bytes</span><span class="p">=</span><span class="s">104857600       # 100MB</span>
  <span class="py">replica.fetch.response.max.bytes</span><span class="p">=</span><span class="s">10485760 # 10MB</span>
</pre></table></code></div></div></ul><h3 id="확장성-관리"><span class="mr-2">확장성 관리</span><a href="#확장성-관리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><strong>파티션 할당과 재조정</strong><ul><li>파티션 개수 결정 요소<ul><li>처리량 요구사항<ul><li>단일 파티션 처리량 = 100MB/s인 경우, 1GB/s 처리량 필요시 최소 10개 파티션 필요</ul><li>동시성 레벨<ul><li>컨슈머 그룹 내 병렬 처리를 위한 최대 컨슈머 수 결정</ul><li>메시지 순서<ul><li>동일 키의 메시지는 같은 파티션에 할당되어 순서 보장</ul></ul><li>파티션 수 산정 공식<div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>  필요 파티션 수 = MAX(
   처리량 기준: (예상 최대 처리량 * (1 + 성장률)) / (단일 파티션 처리량 * 0.7),
   컨슈머 기준: 목표 최대 컨슈머 수 * 2,
   보관 기준: (일일 데이터량 * 보관일수 * (1 + 성장률)) / (단일 파티션 최대 크기 * 0.7)
  )
</pre></table></code></div></div><li>성장률<li>예상 연간 데이터 증가율 (예: 0.3 = 30%)<li>단일 파티션 처리량<li>보통 10MB/s<li>단일 파티션 최대 크기<li>권장 25GB<li>0.7<li>안전율 (70% 활용도 기준)<li>파티션 수 조정 시 고려사항<li>파티션 수는 감소시킬 수 없음<li>파티션당 최소 50MB/일 데이터량 권장<li>브로커당 4000-6000개 파티션 제한<li>파티션 수와 메모리 사용량은 비례<li><p>단일 파티션 최대 크기는 리더 선출 시간에 영향을 미침</p><li>파티션 확장 전략 ```bash # 토픽의 파티션 수 증가 kafka-topics.sh –bootstrap-server localhost:9092 <br /> –alter <br /> –topic my-topic <br /> –partitions 6</ul><p># 파티션 재할당 계획 생성 cat &gt; reassign.json « EOF { “version”: 1, “partitions”: [ {“topic”: “my-topic”, “partition”: 0, “replicas”: [0,1,2]}, {“topic”: “my-topic”, “partition”: 1, “replicas”: [1,2,3]} ] } EOF</p><p># 파티션 재할당 실행 kafka-reassign-partitions.sh –bootstrap-server localhost:9092 <br /> –reassignment-json-file reassign.json <br /> –execute ```</p><ul><li>리밸런싱 전략<ul><li><p>RoundRobinAssignor (권장 기본 전략)</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre> <span class="c1">// 컨슈머 설정</span>
 <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"partition.assignment.strategy"</span><span class="o">,</span> 
             <span class="s">"org.apache.kafka.clients.consumer.RoundRobinAssignor"</span><span class="o">);</span>
</pre></table></code></div></div><ul><li>파티션을 컨슈머에 균등하게 분배<li>더 나은 부하 분산 효과<li>확장성이 우수함</ul><li><p>Cooperative Rebalancing (점진적 리밸런싱)</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre> <span class="c1">// 컨슈머 설정</span>
 <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"partition.assignment.strategy"</span><span class="o">,</span> 
             <span class="s">"org.apache.kafka.clients.consumer.CooperativeStickyAssignor"</span><span class="o">);</span>
</pre></table></code></div></div><ul><li>리밸런싱 중에도 파티션 소비 가능<li>서비스 중단 최소화<li>대규모 클러스터에 적합</ul><li>StickyAssignor (특수 케이스)<br /> ㄴ<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre> <span class="c1">// 컨슈머 설정</span>
 <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"partition.assignment.strategy"</span><span class="o">,</span> 
             <span class="s">"org.apache.kafka.clients.consumer.StickyAssignor"</span><span class="o">);</span>
</pre></table></code></div></div><ul><li>리밸런싱 시 기존 할당 유지 최대화<li>불필요한 파티션 재할당 최소화<li>캐시 효율성 향상</ul><li><p>커스텀 할당 전략</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre> <span class="c1">// 사용자 정의 파티션 할당 전략</span>
 <span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomAssignor</span> <span class="kd">implements</span> <span class="nc">ConsumerPartitionAssignor</span> <span class="o">{</span>
     <span class="nd">@Override</span>
     <span class="kd">public</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">TopicPartition</span><span class="o">&gt;&gt;</span> <span class="nf">assign</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">partitionsPerTopic</span><span class="o">,</span> 
                                                     <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Subscription</span><span class="o">&gt;</span> <span class="n">subscriptions</span><span class="o">)</span> <span class="o">{</span>
         <span class="c1">// 커스텀 로직 구현</span>
     <span class="o">}</span>

     <span class="nd">@Override</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onAssignment</span><span class="o">(</span><span class="nc">Assignment</span> <span class="n">assignment</span><span class="o">,</span> <span class="nc">ConsumerGroupMetadata</span> <span class="n">metadata</span><span class="o">)</span> <span class="o">{</span>
         <span class="c1">// 할당 후 처리 로직</span>
     <span class="o">}</span>
 <span class="o">}</span>
</pre></table></code></div></div></ul></ul></ul><div class="mermaid"> sequenceDiagram participant C1 as Consumer1 participant C2 as Consumer2 participant C3 as Consumer3 participant GC as GroupCoordinator Note over C1,GC: 초기 상태: Consumer1,2가 파티션 분배 C3-&gt;&gt;GC: 그룹 참가 요청 GC-&gt;&gt;C1: 리밸런싱 트리거 GC-&gt;&gt;C2: 리밸런싱 트리거 GC-&gt;&gt;C3: 리밸런싱 트리거 Note over C1,GC: 리밸런싱 시작 GC-&gt;&gt;C1: 새로운 파티션 할당 GC-&gt;&gt;C2: 새로운 파티션 할당 GC-&gt;&gt;C3: 새로운 파티션 할당 Note over C1,C3: 파티션 재분배 완료</div><ul><li><strong>파티션 배치 전략</strong><ul><li>리더 파티션 분산</ul><div class="language-properties highlighter-rouge"><div class="code-header"> <span data-label-text="Properties"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>  <span class="c"># 브로커 설정 (server.properties)
</span>    
  <span class="c"># 데이터 무손실을 위한 필수 설정
</span>  <span class="py">min.insync.replicas</span><span class="p">=</span><span class="s">2                    # 최소 동기화 복제본 수</span>
  <span class="py">unclean.leader.election.enable</span><span class="p">=</span><span class="s">false     # 데이터 일관성 우선</span>
    
  <span class="c"># 자동 리더 재균형 설정
</span>  <span class="py">auto.leader.rebalance.enable</span><span class="p">=</span><span class="s">true</span>
  <span class="py">leader.imbalance.per.broker.percentage</span><span class="p">=</span><span class="s">20</span>
  <span class="py">leader.imbalance.check.interval.seconds</span><span class="p">=</span><span class="s">300</span>
</pre></table></code></div></div><ul><li>리플리케이션 배치</ul><div class="language-properties highlighter-rouge"><div class="code-header"> <span data-label-text="Properties"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>  <span class="c"># 랙 인식 배치 설정
</span>  <span class="py">broker.rack</span><span class="p">=</span><span class="s">rack1  # 브로커1의 랙 정보</span>
    
  <span class="c"># 복제본 배치 제한
</span>  <span class="py">replica.selector.class</span><span class="p">=</span><span class="s">org.apache.kafka.common.replica.RackAwareReplicaSelector</span>
</pre></table></code></div></div><ul><li>파티션 리더십 관리</ul><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>  <span class="c"># 선호 리더 선출 실행</span>
  kafka-leader-election.sh <span class="nt">--bootstrap-server</span> localhost:9092 <span class="se">\</span>
                      <span class="nt">--topic</span> my-topic <span class="se">\</span>
                      <span class="nt">--partition</span> 1 <span class="se">\</span>
                      <span class="nt">--election-type</span> PREFERRED
    
  <span class="c"># 리더십 상태 확인</span>
  kafka-topics.sh <span class="nt">--bootstrap-server</span> localhost:9092 <span class="se">\</span>
              <span class="nt">--describe</span> <span class="nt">--topic</span> my-topic
</pre></table></code></div></div><ul><li>고가용성을 위한 배치 규칙<ul><li>브로커 간 균등 분배<li>랙 간 분산 배치 (단일 랙 장애 대비)<li>리더/팔로워 역할 분산</ul></ul><li><strong>스케일링 방안</strong><ul><li>수직적 확장 (Scale Up)<ul><li><p>하드웨어 리소스 증설</p><div class="language-properties highlighter-rouge"><div class="code-header"> <span data-label-text="Properties"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre> <span class="c"># 메모리 설정
</span> <span class="c"># 브로커당 4GB가 표준적인 설정
</span> <span class="py">heap.opts</span><span class="p">=</span><span class="s">-Xms4g -Xmx4g  # JVM 힙 크기</span>
        
 <span class="c"># GC 설정
</span> <span class="py">KAFKA_JVM_PERFORMANCE_OPTS</span><span class="p">=</span><span class="s">"-server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+ExplicitGCInvokesConcurrent -XX:G1HeapRegionSize=16M"</span>
        
 <span class="c"># 디스크 설정
</span> <span class="py">log.dirs</span><span class="p">=</span><span class="s">/data/kafka-logs-1,/data/kafka-logs-2  # 다중 디스크 사용</span>
        
 <span class="c"># 네트워크 설정
</span> <span class="py">socket.send.buffer.bytes</span><span class="p">=</span><span class="s">10485760    # 소켓 버퍼 크기 증가</span>
 <span class="py">socket.receive.buffer.bytes</span><span class="p">=</span><span class="s">10485760</span>
</pre></table></code></div></div></ul><li>수평적 확장 (Scale Out)</ul><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre>  <span class="c"># 새 브로커 추가를 위한 단계별 프로세스</span>
    
  <span class="c"># 1. 새 브로커 설정</span>
  broker.id<span class="o">=</span>4
  zookeeper.connect<span class="o">=</span>zk1:2181,zk2:2181,zk3:2181
    
  <span class="c"># 2. 파티션 재분배 계획 생성</span>
  <span class="nb">cat</span> <span class="o">&gt;</span> expand-cluster-reassignment.json <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
  {
  "version": 1,
  "partitions": [
      {"topic": "my-topic", "partition": 0, "replicas": [1,2,4]},
      {"topic": "my-topic", "partition": 1, "replicas": [2,3,4]},
      {"topic": "my-topic", "partition": 2, "replicas": [3,4,1]}
  ]
  }
</span><span class="no">  EOF
    
</span>  <span class="c"># 3. 재분배 실행 및 모니터링</span>
  kafka-reassign-partitions.sh <span class="nt">--bootstrap-server</span> localhost:9092 <span class="se">\</span>
                              <span class="nt">--reassignment-json-file</span> expand-cluster-reassignment.json <span class="se">\</span>
                              <span class="nt">--execute</span>
</pre></table></code></div></div><ul><li>클러스터 조정 전략<ul><li>단계적 확장 프로세스<ol><li>용량 계획 수립<ul><li>현재 사용량 분석 (CPU, 메모리, 디스크, 네트워크)<li>예상 성장률 계산 (6-12개월)<li>필요 리소스 산정 (N+2 여유도 확보)</ul><li>브로커 확장 준비</ol><div class="language-properties highlighter-rouge"><div class="code-header"> <span data-label-text="Properties"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre> <span class="c"># 신규 브로커 설정 (server.properties)
</span> <span class="py">broker.id</span><span class="p">=</span><span class="s">4</span>
 <span class="py">zookeeper.connect</span><span class="p">=</span><span class="s">zk1:2181,zk2:2181,zk3:2181</span>
 <span class="py">log.dirs</span><span class="p">=</span><span class="s">/kafka/broker-4/logs</span>
 <span class="py">listeners</span><span class="p">=</span><span class="s">PLAINTEXT://broker4:9092</span>
 <span class="c"># 랙 인식 설정
</span> <span class="py">broker.rack</span><span class="p">=</span><span class="s">rack2</span>
</pre></table></code></div></div><ol><li>데이터 재분배 수행</ol><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre> <span class="c"># 재분배 계획 생성</span>
 <span class="nb">cat</span> <span class="o">&gt;</span> reassign.json <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
 {
 "version": 1,
 "partitions": [
     {"topic": "my-topic", "partition": 0, "replicas": [1,2,4]},
     {"topic": "my-topic", "partition": 1, "replicas": [2,3,4]},
     {"topic": "my-topic", "partition": 2, "replicas": [3,4,1]}
 ]
 }
</span><span class="no"> EOF
        
</span> <span class="c"># 재분배 실행 및 모니터링</span>
 kafka-reassign-partitions.sh <span class="nt">--bootstrap-server</span> localhost:9092 <span class="se">\</span>
                             <span class="nt">--reassignment-json-file</span> reassign.json <span class="se">\</span>
                             <span class="nt">--execute</span> <span class="nt">--throttle</span> 50000000  <span class="c"># 50MB/s 제한</span>

 <span class="c"># 재분배 진행 상태 확인</span>
 kafka-reassign-partitions.sh <span class="nt">--bootstrap-server</span> localhost:9092 <span class="se">\</span>
                             <span class="nt">--reassignment-json-file</span> reassign.json <span class="se">\</span>
                             <span class="nt">--verify</span>
</pre></table></code></div></div><ol><li>성능 모니터링<ul><li>브로커 레벨 메트릭<ul><li>CPU 사용률 (임계치: 85%)<li>메모리 사용률 (임계치: 80%)<li>디스크 I/O (임계치: 80MB/s)<li>네트워크 처리량 (임계치: 70%)</ul><li>토픽 레벨 메트릭<ul><li>메시지 처리량 (초당)<li>복제 지연(Replica Lag)<li>ISR 크기 변화<li>리더/팔로워 비율</ul></ul></ol><li>브로커 제거 절차<ol><li>사전 준비<ul><li>제거할 브로커의 파티션 목록 확인<li>데이터 마이그레이션 계획 수립<li>리소스 여유도 검증</ul><li>데이터 마이그레이션</ol><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre> <span class="c"># 제거할 브로커의 파티션 이동 계획</span>
 <span class="nb">cat</span> <span class="o">&gt;</span> remove-broker.json <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
 {
 "topics": [
     {"topic": "my-topic"}
 ],
 "version": 1
 }
</span><span class="no"> EOF
        
</span> <span class="c"># 파티션 재할당 계획 생성</span>
 kafka-reassign-partitions.sh <span class="nt">--bootstrap-server</span> localhost:9092 <span class="se">\</span>
                             <span class="nt">--generate</span> <span class="se">\</span>
                             <span class="nt">--topics-to-move-json-file</span> remove-broker.json <span class="se">\</span>
                             <span class="nt">--broker-list</span> <span class="s2">"1,2,3"</span>
</pre></table></code></div></div><ol><li>단계적 종료</ol><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre> <span class="c"># 리더십 이전 (Preferred Replica Election)</span>
 kafka-preferred-replica-election.sh <span class="nt">--bootstrap-server</span> localhost:9092
        
 <span class="c"># 브로커 상태 확인</span>
 kafka-broker-api-versions.sh <span class="nt">--bootstrap-server</span> localhost:9092
        
 <span class="c"># 브로커 종료 전 마지막 점검</span>
 kafka-topics.sh <span class="nt">--bootstrap-server</span> localhost:9092 <span class="nt">--describe</span>
</pre></table></code></div></div><li>모니터링 및 경보 설정<ol><li>핵심 메트릭<ul><li>브로커별 파티션 분포 (불균형 20% 이상 시 경보)<li>리더/팔로워 비율 (리더 편중 30% 이상 시 경보)<li>디스크 사용률 (임계치 85% 이상 시 경보)<li>네트워크 처리량 (포화도 80% 이상 시 경보)</ul><li>성능 메트릭<ul><li>메시지 처리 지연시간 (p99 &gt; 100ms 시 경보)<li>복제 지연 (Lag &gt; 1000 시 경보)<li>Under-replicated 파티션 수 (0 초과 시 경보)<li>Active Controller 수 (1 아닐 시 경보)</ul></ol></ul></ul></ul><h3 id="메시지-압축"><span class="mr-2">메시지 압축</span><a href="#메시지-압축" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><strong>지원 알고리즘 비교</strong><ul><li>gzip<ul><li>압축률: 매우 높음 (원본 대비 약 40% 크기)<li>CPU 사용량: 매우 높음 (4-5배)<li>처리 속도: 가장 느림<li>메모리 사용량: 높음<li>장기 보관 데이터, 네트워크 대역폭 제약이 심한 환경</ul><li>snappy<ul><li>압축률: 중간 (원본 대비 약 60% 크기)<li>CPU 사용량: 낮음 (1.5-2배)<li>처리 속도: 빠름<li>메모리 사용량: 낮음<li>일반적인 메시징, 실시간 로그 수집</ul><li>lz4<ul><li>압축률: 낮음 (원본 대비 약 70% 크기)<li>CPU 사용량: 매우 낮음 (1.2-1.5배)<li>처리 속도: 매우 빠름<li>메모리 사용량: 매우 낮음<li>고성능 실시간 처리 필요한 경우</ul><li>zstd<ul><li>압축률: 높음 (원본 대비 약 45% 크기)<li>CPU 사용량: 중간 (2-3배)<li>처리 속도: 중간<li>메모리 사용량: 중간<li>압축률과 성능 균형이 필요한 경우</ul></ul><li><p><strong>압축 설정</strong></p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre>  <span class="c1">// 프로듀서 압축 설정 예시</span>
  <span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>

  <span class="c1">// 메시지 압축 알고리즘 선택</span>
  <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"compression.type"</span><span class="o">,</span> <span class="s">"snappy"</span><span class="o">);</span>  <span class="c1">// gzip, snappy, lz4, zstd</span>

  <span class="c1">// 압축 전 최소 메시지 크기 (바이트)</span>
  <span class="c1">// 이 크기보다 작은 메시지는 압축하지 않음</span>
  <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"compression.min.bytes"</span><span class="o">,</span> <span class="s">"1024"</span><span class="o">);</span>

  <span class="c1">// zstd 압축 레벨 설정 (1-22, 기본값: 3)</span>
  <span class="c1">// 높을수록 압축률은 높아지지만 CPU 사용량 증가</span>
  <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"compression.level"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">);</span>

  <span class="c1">// 배치 크기를 증가시켜 압축 효율 향상</span>
  <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"batch.size"</span><span class="o">,</span> <span class="s">"131072"</span><span class="o">);</span>  <span class="c1">// 128KB</span>

  <span class="nc">KafkaProducer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">producer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">KafkaProducer</span><span class="o">&lt;&gt;(</span><span class="n">props</span><span class="o">);</span>
</pre></table></code></div></div><li><p><strong>브로커 압축 설정</strong></p><div class="language-properties highlighter-rouge"><div class="code-header"> <span data-label-text="Properties"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>  <span class="c"># 브로커 압축 설정 (server.properties)
</span>
  <span class="c"># 로그 세그먼트 압축 정책
</span>  <span class="py">log.compression.type</span><span class="p">=</span><span class="s">producer  # producer(기본값), uncompressed, lz4, snappy, gzip, zstd</span>

  <span class="c"># 압축 관련 스레드 풀 크기
</span>  <span class="py">compression.threads</span><span class="p">=</span><span class="s">4</span>

  <span class="c"># 압축된 로그 세그먼트 최대 크기
</span>  <span class="py">max.compressed.log.segment.bytes</span><span class="p">=</span><span class="s">536870912  # 512MB</span>
</pre></table></code></div></div><li><strong>성능 고려사항</strong><ul><li>네트워크 대역폭 영향<ul><li>압축으로 인한 전송 데이터 감소: 30-60%<li>네트워크 비용 절감 효과<li>대역폭 제한 환경에서 효과적</ul><li>CPU 리소스 영향<ul><li>알고리즘별 CPU 사용량 차이<ul><li>gzip: 높은 CPU 사용 (전체 CPU의 15-20%)<li>snappy: 중간 CPU 사용 (전체 CPU의 5-10%)<li>lz4: 낮은 CPU 사용 (전체 CPU의 3-7%)</ul><li>압축/해제 시 추가 CPU 사이클 필요<li>서버 사양에 따른 알고리즘 선택 중요</ul><li>지연시간 영향<ul><li>압축 시 추가되는 지연시간<ul><li>gzip: 1.5-2ms<li>snappy: 0.5-1ms<li>lz4: 0.3-0.5ms</ul><li>해제 시 추가되는 지연시간<ul><li>gzip: 0.8-1ms<li>snappy: 0.2-0.4ms<li>lz4: 0.1-0.2ms</ul></ul><li>메모리 사용량<ul><li>압축 버퍼로 인한 추가 메모리 사용<li>알고리즘별 메모리 사용량 차이<li>배치 크기에 따른 메모리 사용량 변화</ul></ul></ul><h3 id="메시지-보관"><span class="mr-2">메시지 보관</span><a href="#메시지-보관" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><strong>보관 정책 상세</strong><ul><li>시간 기반 정책</ul><div class="language-properties highlighter-rouge"><div class="code-header"> <span data-label-text="Properties"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>  <span class="c"># 토픽별 보관 기간 설정
</span>  <span class="py">retention.ms</span><span class="p">=</span><span class="s">604800000        # 7일</span>
  <span class="py">retention.ms</span><span class="p">=</span><span class="s">86400000         # 1일</span>
  <span class="py">retention.ms</span><span class="p">=</span><span class="s">3600000          # 1시간</span>
</pre></table></code></div></div><ul><li>크기 기반 정책</ul><div class="language-properties highlighter-rouge"><div class="code-header"> <span data-label-text="Properties"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>  <span class="c"># 토픽별 최대 크기 설정
</span>  <span class="py">retention.bytes</span><span class="p">=</span><span class="s">1073741824    # 1GB</span>
  <span class="py">retention.bytes</span><span class="p">=</span><span class="s">5368709120    # 5GB</span>
</pre></table></code></div></div><ul><li>혼합 정책 예시</ul><div class="language-properties highlighter-rouge"><div class="code-header"> <span data-label-text="Properties"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>  <span class="c"># 두 조건 중 하나라도 충족 시 삭제
</span>  <span class="py">retention.ms</span><span class="p">=</span><span class="s">604800000        # 7일</span>
  <span class="py">retention.bytes</span><span class="p">=</span><span class="s">1073741824    # 1GB</span>
</pre></table></code></div></div><li><strong>정책 유형별 특징</strong><ul><li><code class="language-plaintext highlighter-rouge">Delete</code><ul><li>오래된 메시지 완전 삭제<li>디스크 공간 즉시 회수<li>단순하고 예측 가능</ul><li><code class="language-plaintext highlighter-rouge">Compact</code><ul><li>키별로 최신 메시지만 유지<li>상태 기반 처리에 적합<li>디스크 사용량 최적화</ul></ul><div class="language-properties highlighter-rouge"><div class="code-header"> <span data-label-text="Properties"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>  <span class="c"># 압축 정책 설정
</span>  <span class="py">cleanup.policy</span><span class="p">=</span><span class="s">compact</span>
    
  <span class="c"># 압축 주기 설정 (밀리초)
</span>  <span class="py">min.cleanable.dirty.ratio</span><span class="p">=</span><span class="s">0.5</span>
  <span class="py">delete.retention.ms</span><span class="p">=</span><span class="s">86400000</span>
</pre></table></code></div></div><li><p><strong>고급 보관 설정</strong></p><div class="language-properties highlighter-rouge"><div class="code-header"> <span data-label-text="Properties"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>  <span class="c"># 세그먼트 관리
</span>  <span class="py">segment.bytes</span><span class="p">=</span><span class="s">1073741824        # 세그먼트 크기</span>
  <span class="py">segment.ms</span><span class="p">=</span><span class="s">604800000           # 세그먼트 롤링 주기</span>

  <span class="c"># 인덱스 관리
</span>  <span class="py">segment.index.bytes</span><span class="p">=</span><span class="s">10485760   # 인덱스 크기</span>

  <span class="c"># 정리 스케줄링
</span>  <span class="py">log.cleanup.interval.ms</span><span class="p">=</span><span class="s">300000  # 정리 검사 주기</span>
</pre></table></code></div></div></ul><h3 id="모니터링-지표"><span class="mr-2">모니터링 지표</span><a href="#모니터링-지표" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><strong>브로커 핵심 메트릭</strong><ul><li>복제 관련<ul><li><code class="language-plaintext highlighter-rouge">UnderReplicatedPartitions</code>: 복제 지연 파티션 수<li><code class="language-plaintext highlighter-rouge">IsrShrinksPerSec</code>: ISR 축소 빈도<li><code class="language-plaintext highlighter-rouge">IsrExpandsPerSec</code>: ISR 확장 빈도<li><code class="language-plaintext highlighter-rouge">ReplicationBytesInPerSec</code>: 복제 수신 바이트</ul><li>요청 처리<ul><li><code class="language-plaintext highlighter-rouge">RequestQueueSize</code>: 요청 대기열 크기<li><code class="language-plaintext highlighter-rouge">RequestHandlerAvgIdlePercent</code>: 핸들러 유휴율<li><code class="language-plaintext highlighter-rouge">NetworkProcessorAvgIdlePercent</code>: 네트워크 처리 유휴율</ul><li>디스크 성능<ul><li><code class="language-plaintext highlighter-rouge">LogFlushRateAndTimeMs</code>: 로그 플러시 지연시간<li><code class="language-plaintext highlighter-rouge">LogFlushPerSec</code>: 초당 로그 플러시 횟수<li><code class="language-plaintext highlighter-rouge">PageCacheHitRatio</code>: 페이지 캐시 적중률<li>LogDirsDiskUsagePercent: 로그 디렉토리 디스크 사용률</ul></ul><li><strong>프로듀서 성능 메트릭</strong><ul><li>처리량<ul><li><code class="language-plaintext highlighter-rouge">RecordSendRate</code>: 초당 전송 레코드 수<li><code class="language-plaintext highlighter-rouge">BytesSentPerSec</code>: 초당 전송 바이트<li><code class="language-plaintext highlighter-rouge">CompressionRateAvg</code>: 평균 압축률</ul><li>지연시간<ul><li><code class="language-plaintext highlighter-rouge">RequestLatencyAvg</code>: 평균 요청 지연시간<li><code class="language-plaintext highlighter-rouge">RequestLatencyMax</code>: 최대 요청 지연시간<li><code class="language-plaintext highlighter-rouge">RecordQueueTimeAvg</code>: 평균 대기열 시간</ul><li>배치 처리<ul><li><code class="language-plaintext highlighter-rouge">BatchSizeAvg</code>: 평균 배치 크기<li><code class="language-plaintext highlighter-rouge">RecordPerRequestAvg</code>: 요청당 평균 레코드 수<li><code class="language-plaintext highlighter-rouge">RecordRetries</code>: 재시도 횟수</ul></ul><li><strong>컨슈머 성능 메트릭</strong><ul><li>처리량<ul><li><code class="language-plaintext highlighter-rouge">RecordsConsumedRate</code>: 초당 소비 레코드 수<li><code class="language-plaintext highlighter-rouge">BytesConsumedRate</code>: 초당 소비 바이트<li><code class="language-plaintext highlighter-rouge">FetchRequestRate</code>: 초당 fetch 요청 수</ul><li>지연<ul><li>ConsumerLag: 컨슈머 지연(파티션별)<li>ConsumerLagByGroup: 그룹별 컨슈머 지연<li>FetchLatencyAvg: 평균 fetch 지연시간</ul><li>처리 성능<ul><li>RecordsProcessedPerSec: 초당 처리 레코드 수<li>ProcessingTimeAvg: 평균 처리 시간<li>CommitLatencyAvg: 평균 커밋 지연시간</ul></ul><li><strong>JVM 및 시스템 메트릭</strong><ul><li>JVM 상태<ul><li><code class="language-plaintext highlighter-rouge">G1YoungGenerationTime</code>: G1 Young GC 시간<li><code class="language-plaintext highlighter-rouge">G1OldGenerationTime</code>: G1 Old GC 시간<li><code class="language-plaintext highlighter-rouge">HeapMemoryUsage</code>: 힙 메모리 사용량<li><code class="language-plaintext highlighter-rouge">NonHeapMemoryUsage</code>: 비힙 메모리 사용량</ul><li>시스템 자원<ul><li><code class="language-plaintext highlighter-rouge">CPUUtilization</code>: CPU 사용률<li><code class="language-plaintext highlighter-rouge">NetworkInboundRate</code>: 네트워크 수신률<li><code class="language-plaintext highlighter-rouge">NetworkOutboundRate</code>: 네트워크 송신률<li><code class="language-plaintext highlighter-rouge">DiskUtilization</code>: 디스크 사용률</ul></ul><li><p><strong>알림 설정 권장값</strong></p><div class="language-properties highlighter-rouge"><div class="code-header"> <span data-label-text="Properties"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>  <span class="c"># 브로커 알림 임계값
</span>  <span class="py">under_replicated_partitions.threshold</span><span class="p">=</span><span class="s">0</span>
  <span class="py">request_queue_size.threshold</span><span class="p">=</span><span class="s">100</span>
  <span class="py">page_cache_hit_ratio.min</span><span class="p">=</span><span class="s">0.8</span>
  <span class="py">log_flush_latency.max</span><span class="p">=</span><span class="s">500</span>

  <span class="c"># 컨슈머 알림 임계값
</span>  <span class="py">consumer_lag.max</span><span class="p">=</span><span class="s">10000</span>
  <span class="py">consumer_lag_minutes.max</span><span class="p">=</span><span class="s">30</span>
  <span class="py">fetch_latency.max</span><span class="p">=</span><span class="s">1000</span>

  <span class="c"># 시스템 알림 임계값
</span>  <span class="py">cpu_utilization.max</span><span class="p">=</span><span class="s">0.85</span>
  <span class="py">heap_memory_usage.max</span><span class="p">=</span><span class="s">0.8</span>
  <span class="py">disk_usage.max</span><span class="p">=</span><span class="s">0.85</span>
  <span class="py">gc_time.max</span><span class="p">=</span><span class="s">100</span>
</pre></table></code></div></div></ul><h3 id="커밋과-오프셋-관리"><span class="mr-2">커밋과 오프셋 관리</span><a href="#커밋과-오프셋-관리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><strong>커밋 로그</strong><ul><li>커밋의 의미<ul><li>컨슈머가 메시지를 성공적으로 처리했음을 기록<li>장애 발생 시 재시작 지점으로 사용<li>컨슈머 그룹의 진행 상황 추적</ul><li>커밋 로그 저장<ul><li><code class="language-plaintext highlighter-rouge">__consumer_offsets</code> 토픽에 저장<li>컨슈머 그룹별로 관리<li>주기적으로 압축되어 용량 관리</ul></ul><li><strong>오프셋 관리 전략</strong><ul><li>자동 커밋<ul><li><code class="language-plaintext highlighter-rouge">enable.auto.commit=true</code>로 설정<li><code class="language-plaintext highlighter-rouge">auto.commit.interval.ms</code> 간격으로 자동 커밋<li>간단하지만 중복/유실 가능성 있음</ul><li>수동 커밋<ul><li><code class="language-plaintext highlighter-rouge">commitSync()</code>: 동기식 커밋<ul><li>안전하지만 성능 저하 가능성</ul><li><code class="language-plaintext highlighter-rouge">commitAsync()</code>: 비동기식 커밋<ul><li>성능은 좋지만 실패 시 재시도 없음</ul></ul></ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre>  <span class="c1">// 자동 커밋 설정</span>
  <span class="nc">Properties</span> <span class="n">autoCommitProps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
  <span class="n">autoCommitProps</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"enable.auto.commit"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span>
  <span class="n">autoCommitProps</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"auto.commit.interval.ms"</span><span class="o">,</span> <span class="s">"5000"</span><span class="o">);</span>

  <span class="c1">// 수동 커밋 예시</span>
  <span class="nc">Properties</span> <span class="n">manualCommitProps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
  <span class="n">manualCommitProps</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"enable.auto.commit"</span><span class="o">,</span> <span class="s">"false"</span><span class="o">);</span>
  <span class="nc">KafkaConsumer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">consumer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">KafkaConsumer</span><span class="o">&lt;&gt;(</span><span class="n">manualCommitProps</span><span class="o">);</span>

  <span class="c1">// 동기식 커밋</span>
  <span class="k">try</span> <span class="o">{</span>
      <span class="nc">ConsumerRecords</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">records</span> <span class="o">=</span> <span class="n">consumer</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="na">ofMillis</span><span class="o">(</span><span class="mi">100</span><span class="o">));</span>
      <span class="n">processRecords</span><span class="o">(</span><span class="n">records</span><span class="o">);</span> <span class="c1">// 레코드 처리</span>
      <span class="n">consumer</span><span class="o">.</span><span class="na">commitSync</span><span class="o">();</span> <span class="c1">// 동기식 커밋</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 에러 처리</span>
  <span class="o">}</span>

  <span class="c1">// 비동기식 커밋</span>
  <span class="n">consumer</span><span class="o">.</span><span class="na">commitAsync</span><span class="o">((</span><span class="n">offsets</span><span class="o">,</span> <span class="n">exception</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">exception</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
          <span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Commit failed for offsets: "</span> <span class="o">+</span> <span class="n">offsets</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">});</span>
</pre></table></code></div></div><ul><li>처리 시맨틱<ul><li><code class="language-plaintext highlighter-rouge">at-most-once</code>: 메시지 유실 가능성, 자동 커밋 사용 시 해당<li><code class="language-plaintext highlighter-rouge">at-least-once</code>: 중복 처리 가능성, 수동 커밋 사용 시 일반적인 방식<li><code class="language-plaintext highlighter-rouge">exactly-once</code>: 정확히 한 번 처리 보장<ul><li>트랜잭션과 멱등성 프로듀를 함께 사용하여 달성하는 엔드투엔드 처리 보장 방식</ul></ul></ul><li><strong>오프셋 리셋</strong><ul><li><code class="language-plaintext highlighter-rouge">auto.offset.reset</code> 설정<ul><li><code class="language-plaintext highlighter-rouge">earliest</code>: 가장 오래된 오프셋부터 시작<li><code class="language-plaintext highlighter-rouge">latest</code>: 최신 오프셋부터 시작<li><code class="language-plaintext highlighter-rouge">none</code>: 저장된 오프셋이 없으면 에러</ul><li>수동 리셋<ul><li>특정 시점으로 오프셋 이동<li>데이터 재처리 필요 시 사용<li>신중한 사용 필요</ul></ul></ul><h2 id="reference"><span class="mr-2">Reference</span><a href="#reference" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><a href="https://kafka.apache.org/documentation/">Apache Kafka 공식 문서</a><li><a href="https://kafka.apache.org/documentation/#design">Kafka 디자인 문서</a><li><a href="https://kafka.apache.org/protocol.html">Kafka 프로토콜 가이드</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/messaging/'>Messaging</a>, <a href='/categories/kafka/'>Kafka</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/kafka/" class="post-tag no-text-decoration" >kafka</a> <a href="/tags/apache/" class="post-tag no-text-decoration" >apache</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"></div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Apache Kafka 개념과 아키텍처 - MXXI.kr&amp;url=https://mxxikr.github.io/posts/apache-kafka-concepts/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Apache Kafka 개념과 아키텍처 - MXXI.kr&amp;u=https://mxxikr.github.io/posts/apache-kafka-concepts/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://mxxikr.github.io/posts/apache-kafka-concepts/&amp;text=Apache Kafka 개념과 아키텍처 - MXXI.kr" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div><script src="https://utteranc.es/client.js" repo="mxxikr/mxxikr.github.io" issue-term="pathname" label="comments" theme="github-dark" crossorigin="anonymous" async> </script></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/google-colab-font-error/">Google Colab 환경의 Matplotlib 한글 폰트 깨짐 현상</a><li><a href="/posts/apache-kafka-quick-start/">Apache Kafka와 Spring Boot로 구축하는 실시간 데이터 처리 시스템</a><li><a href="/posts/apache-kafka-concepts/">Apache Kafka 개념과 아키텍처</a><li><a href="/posts/image-auto-optimization/">Jekyll 블로그 이미지 자동 최적화</a><li><a href="/posts/jekyll-blog-installation-guide/">Jekyll 블로그 설치 및 로컬 실행 가이드</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/knou/">knou</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/data-information-processing/">data information processing</a> <a class="post-tag" href="/tags/database/">database</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/ubiquitous-computing/">ubiquitous computing</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/network/">network</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div><script> $(document).ready(function() { // Bootstrap TOC 초기화 if ($('#toc').length) { $('#toc').toc({ 'selectors': 'h1,h2', 'container': '.post-content', 'smoothScrolling': true, 'highlightOffset': 50, 'scrollSpy': true, 'scrollSpyOffset': 50 }); // TOC 스타일 적용 함수 function applyTOCStyles() { $('#toc .nav-link').each(function() { var $link = $(this); var href = $link.attr('href'); // H1, H2 구분 if (href) { var targetElement = $(href); if (targetElement.length > 0) { var tagName = targetElement.prop('tagName'); if (tagName === 'H1') { $link.addClass('toc-h1'); } else if (tagName === 'H2') { $link.addClass('toc-h2'); } } } }); } // TOC 높이 동적 조정 함수 function adjustTOCHeight() { var toc = $('#toc'); if (toc.length === 0) return; // 먼저 모든 제한을 제거하고 자연스러운 높이로 설정 toc.css({ 'max-height': 'none', 'overflow-y': 'visible', 'overflow-x': 'visible' }); // 잠시 기다린 후 실제 내용 높이 측정 setTimeout(function() { var contentHeight = toc[0].scrollHeight; var screenHeight = $(window).height(); var maxHeight = screenHeight * 0.8; // 화면의 80%로 증가 console.log('TOC content height:', contentHeight, 'Screen height:', screenHeight, 'Max height:', maxHeight); if (contentHeight > maxHeight) { // 내용이 화면보다 크면 제한하고 스크롤 추가 toc.css({ 'max-height': maxHeight + 'px', 'overflow-y': 'auto', 'overflow-x': 'hidden' }); console.log('TOC height limited to', maxHeight + 'px with scroll'); } else { console.log('TOC using natural height:', contentHeight + 'px'); } }, 50); } // 스타일 적용 setTimeout(applyTOCStyles, 100); setTimeout(applyTOCStyles, 500); // TOC 높이 조정 - 여러 시점에서 실행 setTimeout(adjustTOCHeight, 200); setTimeout(adjustTOCHeight, 500); setTimeout(adjustTOCHeight, 1000); setTimeout(adjustTOCHeight, 2000); // 창 크기 변경 시 높이 재조정 $(window).on('resize', function() { setTimeout(adjustTOCHeight, 100); }); // 페이지 로드 완료 후에도 실행 $(window).on('load', function() { setTimeout(adjustTOCHeight, 500); }); // TOC 자동 스크롤 기능 (스크롤 박스가 있을 때만) var lastActiveItem = ''; function scrollToActiveTOCItem() { var activeItem = $('#toc .nav-link.active'); if (activeItem.length > 0) { var activeText = activeItem.text().trim(); // 같은 항목이면 스크롤하지 않음 if (lastActiveItem === activeText) { return; } lastActiveItem = activeText; var tocContainer = $('#toc'); if (tocContainer.length > 0) { var containerHeight = tocContainer.height(); var contentHeight = tocContainer[0].scrollHeight; // 스크롤이 필요한 경우에만 자동 스크롤 if (contentHeight > containerHeight) { var activeItemTop = activeItem.position().top; var activeItemHeight = activeItem.outerHeight(); var currentScrollTop = tocContainer.scrollTop(); // 활성 아이템이 보이는 영역에 있는지 확인 var itemTop = activeItemTop + currentScrollTop; var itemBottom = itemTop + activeItemHeight; var visibleTop = currentScrollTop; var visibleBottom = currentScrollTop + containerHeight; // 아이템이 보이지 않으면 스크롤 if (itemTop < visibleTop || itemBottom > visibleBottom) { var targetScrollTop = activeItemTop - (containerHeight / 2) + (activeItemHeight / 2); var maxScrollTop = contentHeight - containerHeight; targetScrollTop = Math.max(0, Math.min(targetScrollTop, maxScrollTop)); tocContainer.animate({ scrollTop: targetScrollTop }, 200); console.log('TOC auto-scrolled to:', activeText); } } } } } // 스크롤 스파이 개선 function initScrollSpy() { var $toc = $('#toc'); var $links = $toc.find('.nav-link'); var $sections = $('.post-content h1, .post-content h2'); // 스크롤 이벤트 최적화를 위한 throttle var scrollTimeout; $(window).on('scroll', function() { if (scrollTimeout) { clearTimeout(scrollTimeout); } scrollTimeout = setTimeout(function() { var scrollTop = $(window).scrollTop(); var windowHeight = $(window).height(); var current = ''; var currentOffset = 0; $sections.each(function() { var $section = $(this); var sectionTop = $section.offset().top; var sectionHeight = $section.outerHeight(); // 섹션의 상단이 화면 상단에서 150px 이내에 있으면 활성화 if (scrollTop + 150 >= sectionTop && scrollTop + 150 < sectionTop + sectionHeight + 200) { current = $section.attr('id'); currentOffset = sectionTop; } }); // 활성 링크 업데이트 $links.removeClass('active'); if (current) { var $activeLink = $links.filter('[href="#' + current + '"]'); $activeLink.addClass('active'); // TOC 자동 스크롤 scrollToActiveTOCItem(); } }, 10); }); // 초기 활성화 $(window).trigger('scroll'); } // 스크롤 스파이 초기화 setTimeout(initScrollSpy, 200); // 초기 실행 setTimeout(scrollToActiveTOCItem, 1500); } }); </script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/apache-kafka-quick-start/"><div class="card-body"> <em class="timeago small" data-ts="1760227200" > 2025-10-12 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Apache Kafka와 Spring Boot로 구축하는 실시간 데이터 처리 시스템</h3><div class="text-muted small"><p> 시스템 개요 단일 서버 환경에서 Docker Compose를 사용하여 고가용성 Kafka 클러스터를 구축하는 전체 과정을 다룸 시나리오 시스템 목적 스마트 팩토리 환경 모니터링 시스템 제조 공정의 온습도를 실시간으로 수집/분석하여 품질 관리 이상 상태 즉시 감지 및 알림으로 불량률 최소화 ...</p></div></div></a></div><div class="card"> <a href="/posts/google-colab-font-error/"><div class="card-body"> <em class="timeago small" data-ts="1760832000" > 2025-10-19 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Google Colab 환경의 Matplotlib 한글 폰트 깨짐 현상</h3><div class="text-muted small"><p> 개요 Google Colab 환경에서 matplotlib 라이브러리 사용 시 한글 폰트가 네모(ㅁㅁㅁ) 형태로 깨지는 현상 해결 방법을 설명함 폰트 설치, matplotlib 폰트 캐시 갱신, 런타임 자동 재시작을 통해 문제를 해결함 문제 현상 matplotlib을 사용한 시각화 시 그래프의 제목, 축 라벨 등 한글 텍스트가 네모...</p></div></div></a></div><div class="card"> <a href="/posts/jekyll-blog-comments-utterances/"><div class="card-body"> <em class="timeago small" data-ts="1760176800" > 2025-10-11 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Jekyll 블로그 Utterances 댓글 시스템 추가</h3><div class="text-muted small"><p> 개요 Jekyll 블로그에 Utterances 댓글 시스템을 추가하는 방법을 설명함 Utterances란 특징 GitHub Issues 기반 댓글 시스템 무료 오픈소스 광고 없음 가벼운 용량 마크다운 지원 GitHub 로그인 필요 장점 설정이 간단함 GitHub Issues로 댓글 관리 용이 개발...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/jekyll-blog-comments-utterances/" class="btn btn-outline-primary" prompt="Older"><p>Jekyll 블로그 Utterances 댓글 시스템 추가</p></a> <a href="/posts/apache-kafka-quick-start/" class="btn btn-outline-primary" prompt="Newer"><p>Apache Kafka와 Spring Boot로 구축하는 실시간 데이터 처리 시스템</p></a></div></div></div><footer class="card-footer"><div class="align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/mxxikr">mxxikr</a>.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/knou/">knou</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/data-information-processing/">data information processing</a> <a class="post-tag" href="/tags/database/">database</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/ubiquitous-computing/">ubiquitous computing</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/network/">network</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> <script> document.addEventListener('DOMContentLoaded', function() { mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'loose', maxTextSize: 90000, flowchart: { htmlLabels: true, useMaxWidth: true, diagramPadding: 8, padding: 15, curve: 'basis', nodeSpacing: 80, rankSpacing: 100, ranker: 'tight-tree', align: 'UD', wrap: true, defaultRenderer: 'dagre-wrapper' } }); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/assets/js/apple-liquid-glass.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-G1QMP111QH"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-G1QMP111QH'); }); </script>
