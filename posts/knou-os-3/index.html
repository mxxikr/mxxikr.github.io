<!DOCTYPE html><html lang="en" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="ko"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="[운영 체제] 3강 - 프로세스 스케줄링" /><meta name="author" content="mxxikr" /><meta property="og:locale" content="en" /><meta name="description" content="💡해당 게시글은 방송통신대학교 김진욱 교수님의 &#39;운영 체제&#39; 강의를 개인 공부 목적으로 메모하였습니다." /><meta property="og:description" content="💡해당 게시글은 방송통신대학교 김진욱 교수님의 &#39;운영 체제&#39; 강의를 개인 공부 목적으로 메모하였습니다." /><link rel="canonical" href="https://mxxikr.github.io/posts/knou-os-3/" /><meta property="og:url" content="https://mxxikr.github.io/posts/knou-os-3/" /><meta property="og:site_name" content="MXXI.kr" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-03-24T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[운영 체제] 3강 - 프로세스 스케줄링" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@mxxikr" /><meta name="google-site-verification" content="jrB0ZGRmhAQ9sqzUNV-C9QdF0brDTEBfkBb9o7loUxc" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"mxxikr"},"dateModified":"2025-08-19T16:51:15+09:00","datePublished":"2025-03-24T00:00:00+09:00","description":"💡해당 게시글은 방송통신대학교 김진욱 교수님의 &#39;운영 체제&#39; 강의를 개인 공부 목적으로 메모하였습니다.","headline":"[운영 체제] 3강 - 프로세스 스케줄링","mainEntityOfPage":{"@type":"WebPage","@id":"https://mxxikr.github.io/posts/knou-os-3/"},"url":"https://mxxikr.github.io/posts/knou-os-3/"}</script><title>[운영 체제] 3강 - 프로세스 스케줄링 | MXXI.kr</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png?v=3"><link rel="icon" type="image/png" sizes="512x512" href="/assets/img/favicons/android-chrome-512x512.png?v=3"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-chrome-192x192.png?v=3"><link rel="icon" type="image/png" sizes="64x64" href="/assets/img/favicons/favicon-64x64.png?v=3"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png?v=3"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png?v=3"><link rel="manifest" href="/assets/img/favicons/site.webmanifest?v=3"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico?v=3"><meta name="apple-mobile-web-app-title" content="MXXI.kr"><meta name="application-name" content="MXXI.kr"><meta name="msapplication-TileColor" content="#c4beed"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml?v=2"><meta name="theme-color" content="#c4beed"> <script src="https://cdn.jsdelivr.net/npm/mermaid@9.3.0/dist/mermaid.min.js"></script> <script> document.addEventListener('DOMContentLoaded', function() { mermaid.initialize({ startOnLoad: true, theme: 'neutral', securityLevel: 'loose', flowchart: { curve: 'basis', padding: 15, nodeSpacing: 30, rankSpacing: 50, htmlLabels: true } }); // Mermaid 다이어그램 렌더링 후 스타일 적용 setTimeout(function() { document.querySelectorAll('.mermaid').forEach(function(element) { element.style.background = '#f8f9fa'; element.style.padding = '15px'; element.style.borderRadius = '8px'; element.style.marginTop = '10px'; element.style.marginBottom = '20px'; }); }, 1000); }); </script><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><link rel="dns-prefetch" href="//fonts.googleapis.com"><link rel="dns-prefetch" href="//fonts.gstatic.com"><link rel="dns-prefetch" href="//cdn.jsdelivr.net"><link rel="preload" href="/assets/css/style.css" as="style"><link rel="preload" href="/assets/js/apple-liquid-glass.js" as="script"> <script> // 개발 환경에서만 로딩 시간 체크 if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') { window.addEventListener('load', () => { if ('performance' in window) { const perfData = performance.getEntriesByType('navigation')[0]; const loadTime = perfData.loadEventEnd - perfData.loadEventStart; console.log('📊 Page loaded in:', loadTime + 'ms'); } }); } </script> <script> if ('serviceWorker' in navigator) { window.addEventListener('load', () => { navigator.serviceWorker.register('/sw.js') .then(registration => console.log('SW registered')) .catch(error => console.log('SW registration failed')); }); } </script> <script> (function() { 'use strict'; // Intersection Observer 지원 확인 if (!('IntersectionObserver' in window)) { // 폴백: 모든 이미지를 즉시 로드 const images = document.querySelectorAll('img[data-src]'); images.forEach(img => { img.src = img.dataset.src; img.removeAttribute('data-src'); }); return; } // 이미지 지연 로딩 설정 const imageObserver = new IntersectionObserver((entries, observer) => { entries.forEach(entry => { if (entry.isIntersecting) { const img = entry.target; // 이미지 로드 const loadImage = () => { const src = img.dataset.src; if (src) { img.src = src; img.classList.add('loaded'); img.removeAttribute('data-src'); } }; // 이미지 로드 완료 시 처리 img.onload = () => { img.classList.add('fade-in'); }; // 이미지 로드 에러 시 처리 img.onerror = () => { img.classList.add('error'); console.warn('Failed to load image:', img.dataset.src); }; loadImage(); observer.unobserve(img); } }); }, { rootMargin: '50px 0px', // 50px 전에 미리 로드 threshold: 0.01 }); // 모든 지연 로딩 이미지에 Observer 적용 const lazyImages = document.querySelectorAll('img[data-src]'); lazyImages.forEach(img => { imageObserver.observe(img); }); // 페이지 로드 완료 후 남은 이미지들 처리 window.addEventListener('load', () => { const remainingImages = document.querySelectorAll('img[data-src]'); remainingImages.forEach(img => { img.src = img.dataset.src; img.removeAttribute('data-src'); }); }); })(); </script><style> img[data-src] { opacity: 0; transition: opacity 0.3s ease-in-out; } img.loaded { opacity: 1; } img.fade-in { animation: fadeIn 0.5s ease-in-out; } img.error { opacity: 0.5; filter: grayscale(100%); } @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } } /* 플레이스홀더 스타일 */ .lazy-placeholder { background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%); background-size: 200% 100%; animation: loading 1.5s infinite; } @keyframes loading { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }</style><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-center"><div class="profile-wrapper text-center"><div class="site-title"> <a href="/">MXXI.kr</a></div><div class="site-subtitle font-weight-bold">Backend Developer</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/mxxikr" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['mxxikr','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[운영 체제] 3강 - 프로세스 스케줄링</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[운영 체제] 3강 - 프로세스 스케줄링</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1742742000" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Mar 24, 2025 </em> </span> <span> Updated <em class="" data-ts="1755589875" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Aug 19, 2025 </em> </span><div class="d-flex justify-content-between"> <span> By <em> mxxikr </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2522 words"> read <em>14 min</em> </span></div></div></div><div class="post-content"><p><strong><center>💡해당 게시글은 방송통신대학교 김진욱 교수님의 '운영 체제' 강의를 개인 공부 목적으로 메모하였습니다. </center></strong></p><p><br /><br /></p><h1 id="학습-개요">학습 개요</h1><hr /><ul><li>운영 체제는 실행할 준비가 된 프로세스들이 CPU를 적절히 배정 받아 작업을 효율적으로 처리할 수 있도록 관리해야 하고, 이를 위해 다양한 스케줄링 알고리즘을 활용함<li>프로세스 스케줄링의 개요와 정책에 대해 살펴보고, 스케줄링 알고리즘의 성능 평가 기준과 함께 여러 가지 스케줄링 기법에 대해 학습함</ul><h1 id="학습-목표">학습 목표</h1><hr /><ul><li>프로세스 스케줄링의 개요와 정책을 설명할 수 있음<li>스케줄링 성능 평가 기준을 설명할 수 있음<li>다양한 스케줄링 기법을 설명할 수 있음</ul><p><br /><br /></p><h1 id="강의록">강의록</h1><hr /><h2 id="프로세스-스케줄링"><span class="mr-2">프로세스 스케줄링</span><a href="#프로세스-스케줄링" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="프로세스-스케줄링-1"><span class="mr-2">프로세스 스케줄링</span><a href="#프로세스-스케줄링-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>스케줄링<ul><li>여러 가지 작업의 처리 순서를 결정하는 것<ul><li>ex) 프로세스 스케줄링, 디스크 스케줄링 등</ul></ul><li>프로세스 스케줄링<ul><li>주어진 프로세스가 여러 개인 경우, 프로세스 처리 순서를 결정하는 것</ul></ul><h3 id="스케줄링-단계"><span class="mr-2">스케줄링 단계</span><a href="#스케줄링-단계" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/knou/os/2025-03-24-knou-os-3/image.png" alt="image.png" data-proofer-ignore></p><ul><li>하위 단계 스케줄링<ul><li>준비 큐에 있는 프로세스를 선택하여 사용 가능한 CPU를 할당(디스패치)하는 역할<li>수행 주체<ul><li><p>디스패처(dispatcher)</p><p><img data-src="/assets/img/knou/os/2025-03-24-knou-os-3/image1.png" alt="image.png" data-proofer-ignore></p></ul></ul></ul><h3 id="스케줄링의-목표"><span class="mr-2">스케줄링의 목표</span><a href="#스케줄링의-목표" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><strong>스케줄링 기본 목표</strong><ul><li><strong>공정성</strong><ul><li>모든 프로세스가 적정 수준에서 CPU 작업을 할 수 있게 함</ul><li><strong>균형</strong><ul><li>시스템 자원이 충분히 활용될 수 있게 함</ul></ul><li><strong>운영 체제의 유형에 따른 스케줄링의 목표</strong><ul><li><strong>일괄 처리 운영 체제</strong><ul><li>처리 량의 극대화<ul><li>주어진 시간에 처리한 프로세스 수</ul><li>반환 시간의 최소화<ul><li>프로세스 생성 시점부터 종료 시점까지의 소요 시간</ul><li>CPU 활용의 극대화</ul><li><strong>시 분할 운영 체제</strong><ul><li>빠른 응답 시간<ul><li>요청한 시점부터 반응이 시작되는 시점까지의 소요 시간</ul><li>과다한 대기 시간 방지<ul><li>프로세스가 종료될 때까지 준비 큐에서 기다린 시간의 합</ul></ul><li><strong>실시간 운영 체제</strong><ul><li>처리 기한 맞춤</ul></ul></ul><h3 id="스케줄링-정책"><span class="mr-2">스케줄링 정책</span><a href="#스케줄링-정책" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>스케줄링의 목표에 따라 우선적으로 고려해야 할 기본적인 정책<ul><li>선점 스케줄링 정책<li>비선점 스케줄링 정책</ul></ul><h3 id="선점preemptive-스케줄링-정책"><span class="mr-2">선점(preemptive) 스케줄링 정책</span><a href="#선점preemptive-스케줄링-정책" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>실행 중인 프로세스에 인터럽트를 걸고 다른 프로세스에 CPU를 할당할 수 있는 스케줄링 방식<li>높은 우선 순위의 프로세스를 우선 처리해야 하는 경우에 유용<ul><li>실시간 시스템, 시분할 시스템</ul><li>문맥 교환에 따른 오버 헤드 발생<ul><li>운영 체제는 문맥 교환이 매우 빠르게 실행되도록 만들어져야 함<li>문맥(context)<ul><li>CPU의 모든 레지스터와 기타 운영 체제에 따라 요구되는 프로세스의 상태</ul><li><p>문맥 교환(context switching)</p><p><img data-src="/assets/img/knou/os/2025-03-24-knou-os-3/image2.png" alt="image.png" data-proofer-ignore></p><ul><li>CPU가 현재 실행하고 있는 프로세스의 문맥을 PCB에 저장하고 다른 프로세스의 PCB로부터 문맥을 복원하는 작업</ul></ul></ul><h3 id="비선점nonpreemptive-스케줄링-정책"><span class="mr-2">비선점(nonpreemptive) 스케줄링 정책</span><a href="#비선점nonpreemptive-스케줄링-정책" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>실행 중인 프로세스를 바로 준비 상태로 전이 시킬 수 없는 스케줄링 방식<li>CPU를 할당 받아 실행이 시작된 프로세스는 대기 상태나 종료 상태로 전이될 때까지 계속 실행 상태에 있게 됨<li>강제적인 문맥 교환이 없어 오버 헤드 발생하지 않음<li>긴 프로세스가 실행 중이라면 짧은 프로세스가 오래 기다리게 되는 경우 발생</ul><h3 id="스케줄링의-평가-기준"><span class="mr-2">스케줄링의 평가 기준</span><a href="#스케줄링의-평가-기준" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/knou/os/2025-03-24-knou-os-3/image3.png" alt="image.png" data-proofer-ignore></p><ul><li>평균 대기 시간<ul><li>각 프로세스가 수행이 완료될 때까지 준비 큐에서 기다리는 시간의 합의 평균 값</ul><li>평균 반환 시간<ul><li>각 프로세스가 생성된 시점부터 수행이 완료된 시점까지의 소요 시간의 평균 값</ul></ul><h2 id="스케줄링-알고리즘"><span class="mr-2">스케줄링 알고리즘</span><a href="#스케줄링-알고리즘" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="fcfs-스케줄링"><span class="mr-2">FCFS 스케줄링</span><a href="#fcfs-스케줄링" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/knou/os/2025-03-24-knou-os-3/image4.png" alt="image.png" data-proofer-ignore></p><p><img data-src="/assets/img/knou/os/2025-03-24-knou-os-3/image5.png" alt="image.png" data-proofer-ignore></p><p><img data-src="/assets/img/knou/os/2025-03-24-knou-os-3/image6.png" alt="image.png" data-proofer-ignore></p><ul><li>FCFS(First-Come First-Served)<li>비선점 방식<li>준비 큐에 도착한 순서에 따라 디스패치<li>장점<ul><li>가장 간단한 스케줄링 기법</ul><li>단점<ul><li>짧은 프로세스가 긴 프로세스를 기다리거나 중요한 프로세스가 나중에 수행될 수도 있음<ul><li>시분할 운영 체제나 실시간 운영 체제에는 부적합</ul><li>프로세스들의 도착 순서에 따라 평균 반환 시간이 크게 변함</ul></ul><h3 id="sjf-스케줄링"><span class="mr-2">SJF 스케줄링</span><a href="#sjf-스케줄링" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/knou/os/2025-03-24-knou-os-3/image7.png" alt="image.png" data-proofer-ignore></p><ul><li>SJF(Shortest Job First)<li>비선점 방식<li>준비 큐에서 기다리는 프로세스 중 실행 시간이 가장 짧다고 예상되는 것을 먼저 디스패치<li>장점<ul><li>일괄 처리 환경에서 구현하기 쉬움</ul><li>단점<ul><li>실제로는 먼저 처리할 프로세스의 CPU 시간을 예상할 수 없음<li>새로 들어온 짧은 프로세스가 긴 프로세스를 기다리거나 중요한 프로세스가 나중에 수행될 수도 있음<ul><li>시 분할 운영 체제나 실시간 운영 체제에는 부적합</ul></ul></ul><h3 id="srt-스케줄링"><span class="mr-2">SRT 스케줄링</span><a href="#srt-스케줄링" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/knou/os/2025-03-24-knou-os-3/image8.png" alt="image.png" data-proofer-ignore></p><ul><li>SRT(Shortest Remaining Time)<li>SJF 알고리즘의 선점 방식<li>준비 큐에서 기다리는 프로세스 중 남은 실행 시간이 가장 짧다고 예상되는 것을 먼저 디스패치<li>장점<ul><li>SJF보다 평균 대기 시간이나 평균 반환 시간에서 효율적임</ul><li>단점<ul><li>실제로는 프로세스의 CPU 시간을 예상할 수 없음<li><p>각 프로세스의 실행 시간 추적, 선점을 위한 문맥 교환 등 SJF보다 오버 헤드가 큼</p><p><img data-src="/assets/img/knou/os/2025-03-24-knou-os-3/792bf994-faa9-466f-a2d1-4b23a0ed4435.png" alt="image.png" data-proofer-ignore></p></ul></ul><h3 id="rr-스케줄링"><span class="mr-2">RR 스케줄링</span><a href="#rr-스케줄링" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/knou/os/2025-03-24-knou-os-3/image9.png" alt="image.png" data-proofer-ignore></p><ul><li>RR(Round Robin)<li>선점 방식<li>준비 큐에 도착한 순서대로 디스패치하지만 정해진 시간 할당 량에 의해 실행 제한<li><p>시간 할당 량 안에 종료하지 못한 프로세스는 준비 큐의 마지막에 배치됨</p><p><img data-src="/assets/img/knou/os/2025-03-24-knou-os-3/image10.png" alt="image.png" data-proofer-ignore></p><li>장점<ul><li>CPU를 독점하지 않고 공평하게 이용<ul><li>시분할 운영 체제에 적합</ul></ul><li>단점<ul><li>시간 할당량이 너무 크면 FCFS 스케줄링과 동일<li>시간 할당량이 너무 작으면 너무 많은 문맥 교환 발생으로 오버헤드가 커짐</ul></ul><h3 id="hrn-스케줄링"><span class="mr-2">HRN 스케줄링</span><a href="#hrn-스케줄링" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/knou/os/2025-03-24-knou-os-3/image11.png" alt="image.png" data-proofer-ignore></p><ul><li>HRN(Highest Response Ratio Next)<li>비선점 방식<li><p>준비 큐에서 기다리는 프로세스 중 응답 비율이 가장 큰 것을 먼저 디스패치</p><p><img data-src="/assets/img/knou/os/2025-03-24-knou-os-3/f3fea2f2-75bd-491a-b0f6-1db5f0d8fb53.png" alt="image.png" data-proofer-ignore></p><ul><li>예상 실행 시간이 짧을수록, 대기 시간이 길수록 응답 비율이 커짐</ul><li>장점<ul><li>SJF 스케줄링의 단점을 보완<ul><li>예상 실행 시간이 긴 프로세스도 오래 대기하면 응답 비율이 커져 나중에 들어오는 짧은 프로세스보다 먼저 디스패치 가능</ul></ul><li>단점<ul><li>실제로는 프로세스의 CPU 시간을 예상할 수 없음</ul></ul><h3 id="다단계-피드백-큐-스케줄링"><span class="mr-2">다단계 피드백 큐 스케줄링</span><a href="#다단계-피드백-큐-스케줄링" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/knou/os/2025-03-24-knou-os-3/image12.png" alt="image.png" data-proofer-ignore></p><ul><li>선점 방식<li>I/O 중심 프로세스와 연산 중심 프로세스의 특성에 따라 서로 다른 시간 할당 량 부여<li>단계 1부터 단계 n까지 하나 씩의 준비 큐 존재<li>단계 k는 단계 k+1에 피드백<li>단계가 커질수록 시간 할당 량도 커짐<li>스케줄링 방법<ul><li>디스패치 후 대기 상태로 갔다가 준비 상태가 될 때에는 현재와 동일한 단계의 준비 큐에 배치<li>시간 할당 량을 다 썼으면 다음 단계의 준비 큐로 이동 배치<li>단계 k의 준비 큐에 있는 프로세스가 디스패치 되려면 단계 1부터 단계 k-1까지 모든 준비 큐가 비어 있어야만 함</ul><li>특징<ul><li>I/O 위주 프로세스는 높은 우선권 유지<li>연산 위주의 프로세스는 낮은 우선권이지만 긴 시간 할당 량</ul></ul><h3 id="스케줄링-알고리즘-1"><span class="mr-2">스케줄링 알고리즘</span><a href="#스케줄링-알고리즘-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="/assets/img/knou/os/2025-03-24-knou-os-3/image13.png" alt="image.png" data-proofer-ignore></p><p><br /><br /></p><h1 id="정리-하기">정리 하기</h1><hr /><ul><li>프로세스의 스케줄링을 위해 상위 단계, 하위 단계 및 중간 단계 스케줄링이 사용됨<li>선점 스케줄링 정책<ul><li>실행 중인 프로세스에 인터럽트를 걸고 다른 프로세스에 CPU를 할당할 수 있는 스케줄링 방식</ul><li>비선점 스케줄링 정책<ul><li>실행 중인 프로세스를 바로 준비 상태로 전이 시킬 수 없는 스케줄링 방식</ul><li>FCFS 스케줄링<ul><li>준비 큐에 도착한 순서에 따라 디스 패치하는 비선점 방식의 스케줄링 알고리즘</ul><li>SJF 스케줄링<ul><li>준비 큐에서 기다리는 프로세스 중 실행 시간이 가장 짧다고 예상되는 것을 먼저 디스패치하는 비선점 방식의 스케줄링 알고리즘</ul><li>SRT 스케줄링<ul><li>준비 큐에서 기다리는 프로세스 중 남은 실행 시간이 가장 짧다고 예상되는 것을 먼저 디스패치하는 선점 방식의 알고리즘</ul><li>RR 스케줄링<ul><li>프로세스가 도착한 순서대로 프로세스를 디스패치하지만 정해진 시간 할당 량에 의해 실행을 제한하는 선점 방식의 스케줄링 알고리즘</ul><li>HRN 스케줄링<ul><li>준비 큐에서 기다리는 프로세스 중 응답 비율이 가장 큰 것을 먼저 디스패치하여 실행하는 비선점 방식의 스케줄링 알고리즘</ul><li>HRN 스케줄링의 응답 비율은 예상 실행 시간이 짧을수록, 그리고 대기 시간이 길수록 커짐<li>다단계 피드백 큐 스케줄링<ul><li>입출력 위주의 프로세스가 연산 위주의 프로세스보다 우선권을 갖도록 하는 선점 방식의 알고리즘</ul></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/os/'>OS</a>, <a href='/categories/operating-system/'>Operating System</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/knou/" class="post-tag no-text-decoration" >knou</a> <a href="/tags/os/" class="post-tag no-text-decoration" >os</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"></div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[운영 체제] 3강 - 프로세스 스케줄링 - MXXI.kr&amp;url=https://mxxikr.github.io/posts/knou-os-3/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[운영 체제] 3강 - 프로세스 스케줄링 - MXXI.kr&amp;u=https://mxxikr.github.io/posts/knou-os-3/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://mxxikr.github.io/posts/knou-os-3/&amp;text=[운영 체제] 3강 - 프로세스 스케줄링 - MXXI.kr" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div><script src="https://utteranc.es/client.js" repo="mxxikr/mxxikr.github.io" issue-term="pathname" label="comments" theme="github-dark" crossorigin="anonymous" async> </script></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/google-colab-font-error/">Google Colab 환경의 Matplotlib 한글 폰트 깨짐 현상</a><li><a href="/posts/apache-kafka-quick-start/">Apache Kafka와 Spring Boot로 구축하는 실시간 데이터 처리 시스템</a><li><a href="/posts/apache-kafka-concepts/">Apache Kafka 개념과 아키텍처</a><li><a href="/posts/image-auto-optimization/">Jekyll 블로그 이미지 자동 최적화</a><li><a href="/posts/jekyll-blog-installation-guide/">Jekyll 블로그 설치 및 로컬 실행 가이드</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/knou/">knou</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/data-information-processing/">data information processing</a> <a class="post-tag" href="/tags/database/">database</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/ubiquitous-computing/">ubiquitous computing</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/network/">network</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div><script> $(document).ready(function() { // Bootstrap TOC 초기화 if ($('#toc').length) { $('#toc').toc({ 'selectors': 'h1,h2', 'container': '.post-content', 'smoothScrolling': true, 'highlightOffset': 50, 'scrollSpy': true, 'scrollSpyOffset': 50 }); // TOC 스타일 적용 함수 function applyTOCStyles() { $('#toc .nav-link').each(function() { var $link = $(this); var href = $link.attr('href'); // H1, H2 구분 if (href) { var targetElement = $(href); if (targetElement.length > 0) { var tagName = targetElement.prop('tagName'); if (tagName === 'H1') { $link.addClass('toc-h1'); } else if (tagName === 'H2') { $link.addClass('toc-h2'); } } } }); } // TOC 높이 동적 조정 함수 function adjustTOCHeight() { var toc = $('#toc'); if (toc.length === 0) return; // 먼저 모든 제한을 제거하고 자연스러운 높이로 설정 toc.css({ 'max-height': 'none', 'overflow-y': 'visible', 'overflow-x': 'visible' }); // 잠시 기다린 후 실제 내용 높이 측정 setTimeout(function() { var contentHeight = toc[0].scrollHeight; var screenHeight = $(window).height(); var maxHeight = screenHeight * 0.8; // 화면의 80%로 증가 console.log('TOC content height:', contentHeight, 'Screen height:', screenHeight, 'Max height:', maxHeight); if (contentHeight > maxHeight) { // 내용이 화면보다 크면 제한하고 스크롤 추가 toc.css({ 'max-height': maxHeight + 'px', 'overflow-y': 'auto', 'overflow-x': 'hidden' }); console.log('TOC height limited to', maxHeight + 'px with scroll'); } else { console.log('TOC using natural height:', contentHeight + 'px'); } }, 50); } // 스타일 적용 setTimeout(applyTOCStyles, 100); setTimeout(applyTOCStyles, 500); // TOC 높이 조정 - 여러 시점에서 실행 setTimeout(adjustTOCHeight, 200); setTimeout(adjustTOCHeight, 500); setTimeout(adjustTOCHeight, 1000); setTimeout(adjustTOCHeight, 2000); // 창 크기 변경 시 높이 재조정 $(window).on('resize', function() { setTimeout(adjustTOCHeight, 100); }); // 페이지 로드 완료 후에도 실행 $(window).on('load', function() { setTimeout(adjustTOCHeight, 500); }); // TOC 자동 스크롤 기능 (스크롤 박스가 있을 때만) var lastActiveItem = ''; function scrollToActiveTOCItem() { var activeItem = $('#toc .nav-link.active'); if (activeItem.length > 0) { var activeText = activeItem.text().trim(); // 같은 항목이면 스크롤하지 않음 if (lastActiveItem === activeText) { return; } lastActiveItem = activeText; var tocContainer = $('#toc'); if (tocContainer.length > 0) { var containerHeight = tocContainer.height(); var contentHeight = tocContainer[0].scrollHeight; // 스크롤이 필요한 경우에만 자동 스크롤 if (contentHeight > containerHeight) { var activeItemTop = activeItem.position().top; var activeItemHeight = activeItem.outerHeight(); var currentScrollTop = tocContainer.scrollTop(); // 활성 아이템이 보이는 영역에 있는지 확인 var itemTop = activeItemTop + currentScrollTop; var itemBottom = itemTop + activeItemHeight; var visibleTop = currentScrollTop; var visibleBottom = currentScrollTop + containerHeight; // 아이템이 보이지 않으면 스크롤 if (itemTop < visibleTop || itemBottom > visibleBottom) { var targetScrollTop = activeItemTop - (containerHeight / 2) + (activeItemHeight / 2); var maxScrollTop = contentHeight - containerHeight; targetScrollTop = Math.max(0, Math.min(targetScrollTop, maxScrollTop)); tocContainer.animate({ scrollTop: targetScrollTop }, 200); console.log('TOC auto-scrolled to:', activeText); } } } } } // 스크롤 스파이 개선 function initScrollSpy() { var $toc = $('#toc'); var $links = $toc.find('.nav-link'); var $sections = $('.post-content h1, .post-content h2'); // 스크롤 이벤트 최적화를 위한 throttle var scrollTimeout; $(window).on('scroll', function() { if (scrollTimeout) { clearTimeout(scrollTimeout); } scrollTimeout = setTimeout(function() { var scrollTop = $(window).scrollTop(); var windowHeight = $(window).height(); var current = ''; var currentOffset = 0; $sections.each(function() { var $section = $(this); var sectionTop = $section.offset().top; var sectionHeight = $section.outerHeight(); // 섹션의 상단이 화면 상단에서 150px 이내에 있으면 활성화 if (scrollTop + 150 >= sectionTop && scrollTop + 150 < sectionTop + sectionHeight + 200) { current = $section.attr('id'); currentOffset = sectionTop; } }); // 활성 링크 업데이트 $links.removeClass('active'); if (current) { var $activeLink = $links.filter('[href="#' + current + '"]'); $activeLink.addClass('active'); // TOC 자동 스크롤 scrollToActiveTOCItem(); } }, 10); }); // 초기 활성화 $(window).trigger('scroll'); } // 스크롤 스파이 초기화 setTimeout(initScrollSpy, 200); // 초기 실행 setTimeout(scrollToActiveTOCItem, 1500); } }); </script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/knou-os-4/"><div class="card-body"> <em class="timeago small" data-ts="1743433200" > 2025-04-01 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[운영 체제] 4강 - 병행 프로세스</h3><div class="text-muted small"><p> 💡해당 게시글은 방송통신대학교 김진욱 교수님의 &#39;운영 체제&#39; 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 최근에는 여러 프로세스가 단순히 순차 처리가 아닌 병행 처리될 필요가 많음 음악 파일을 배경 음악으로 재생하며 동영상도 틀어 놓고 문서 작업을 하는 경우, 운영 체제는 이들을 병행으로 처리해야 함 특히 이렇게 병행...</p></div></div></a></div><div class="card"> <a href="/posts/knou-os-5/"><div class="card-body"> <em class="timeago small" data-ts="1743865200" > 2025-04-06 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[운영 체제] 5강 - 병행 프로세스</h3><div class="text-muted small"><p> 💡해당 게시글은 방송통신대학교 김진욱 교수님의 &#39;운영 체제&#39; 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 병행 프로세스 중 협력 프로세스에서 발생할 수 있는 구체적인 문제로 생산자-소비자 문제와 판독기-기록기 문제가 있음 협력 프로세스 사이에는 데이터를 공유하기 위해 통신이 필수인데, 이 과정에서도 다양한 문제가 발생할 ...</p></div></div></a></div><div class="card"> <a href="/posts/knou-os-6/"><div class="card-body"> <em class="timeago small" data-ts="1744383600" > 2025-04-12 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[운영 체제] 6강 - 교착 상태</h3><div class="text-muted small"><p> 💡해당 게시글은 방송통신대학교 김진욱 교수님의 &#39;운영 체제&#39; 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 병행 프로세스들은 컴퓨터 시스템의 제한된 자원을 사용하기 위해 서로 경쟁할 수 있음 만일 어떤 프로세스가 사용하고자 하는 자원을 다른 프로세스가 온전히 점유하고 있다면 그 프로세스는 대기해야 함 이렇게 요구와 점유...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/knou-python-3/" class="btn btn-outline-primary" prompt="Older"><p>[파이썬 프로그래밍 기초] 3강 - 파이썬의 이해</p></a> <a href="/posts/knou-dip-3/" class="btn btn-outline-primary" prompt="Newer"><p>[데이터 정보 처리 입문] 3강 - 통계 정보의 검색 및 활용</p></a></div></div></div><footer class="card-footer"><div class="align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/mxxikr">mxxikr</a>.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/knou/">knou</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/data-information-processing/">data information processing</a> <a class="post-tag" href="/tags/database/">database</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/ubiquitous-computing/">ubiquitous computing</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/network/">network</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> <script> document.addEventListener('DOMContentLoaded', function() { mermaid.initialize({ startOnLoad: true, theme: 'default', securityLevel: 'loose', maxTextSize: 90000, flowchart: { htmlLabels: true, useMaxWidth: true, diagramPadding: 8, padding: 15, curve: 'basis', nodeSpacing: 80, rankSpacing: 100, ranker: 'tight-tree', align: 'UD', wrap: true, defaultRenderer: 'dagre-wrapper' } }); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/assets/js/apple-liquid-glass.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-G1QMP111QH"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-G1QMP111QH'); }); </script>
