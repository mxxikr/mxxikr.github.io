[ { "title": "Google Colab 환경의 Matplotlib 한글 폰트 깨짐 현상", "url": "/posts/google-colab-font-error/", "categories": "Data Science, Data Analysis", "tags": "data, colab, python, 시각화", "date": "2025-10-19 09:00:00 +0900", "snippet": "개요 Google Colab 환경에서 matplotlib 라이브러리 사용 시 한글 폰트가 네모(ㅁㅁㅁ) 형태로 깨지는 현상 해결 방법을 설명함 폰트 설치, matplotlib 폰트 캐시 갱신, 런타임 자동 재시작을 통해 문제를 해결함문제 현상 matplotlib을 사용한 시각화 시 그래프의 제목, 축 라벨 등 한글 텍스트가 네모(ㅁㅁㅁ)로 표시됨 폰트가 설치되지 않은 상태에서 폰트를 지정하면 다음과 같은 경고가 발생함 # WARNING:matplotlib.font_manager:findfont: Font family 'NanumGothic' not found.# UserWarning: Glyph 54620 (한) missing from font(s) DejaVu Sans. 핵심 원인 문제의 원인은 폰트 부재와 matplotlib의 폰트 캐시 관리 방식에 있음한글 폰트 부재 Google Colab의 기본 리눅스 실행 환경에는 한글 렌더링에 필요한 폰트가 기본적으로 설치되어 있지 않음Matplotlib 폰트 캐시 matplotlib은 라이브러리를 처음 import 하는 시점에 시스템에 설치된 폰트 목록을 스캔하여 캐시(임시 저장) 파일을 생성함 런타임 도중 apt-get 명령어를 사용해 새 폰트를 설치하더라도 matplotlib은 이미 생성된 캐시 파일을 참조하기 때문에 새로 설치된 폰트를 인식하지 못함 이로 인해 사용자가 직접 ‘런타임 다시 시작’을 해야 하는 번거로움이 발생하며 때로는 캐시가 꼬여 재시작만으로 해결되지 않는 경우도 있음해결 방법 가장 안정적인 해결책은 다음 과정을 코드로 한 번에 처리하는 것임 폰트 설치 matplotlib 폰트 캐시 강제 갱신 런타임 자동 재시작 이 과정은 두 개의 개별 코드 셀로 나누어 실행해야 함폰트 설치 및 런타임 재시작 나눔고딕 폰트 설치와 캐시 갱신 후 런타임이 자동으로 종료(재시작)됨 import subprocessimport osimport matplotlib.font_manager as fm# 나눔고딕 폰트 패키지 설치subprocess.run(['apt-get', 'update', '-qq'], check=True) # 조용한 모드로 업데이트subprocess.run(['apt-get', 'install', '-y', 'fonts-nanum*'], check=True) # 자동 설치, 나눔 폰트 관련 모든 패키지 설치print(\"&gt;&gt; matplotlib 폰트 캐시를 갱신합니다.\")fm._load_fontmanager(try_read_cache=False) # 캐시 파일을 읽지 않고 시스템의 폰트 목록을 처음부터 다시 스캔하여 캐시를 재생성함# 런타임 재시작os.kill(os.getpid(), 9) 폰트 적용 및 시각화 런타임이 재시작된 후 새로운 셀에서 다음 코드를 실행함 이 시점에는 폰트가 정상적으로 설치되었고 캐시도 갱신되었으므로, plt.rc를 통해 폰트를 지정하면 즉시 적용됨 import matplotlib.pyplot as pltimport platform# 런타임 재시작 후 폰트 설정 적용if platform.system() == 'Linux': plt.rc('font', family='NanumGothic') # Colab 환경의 경우 NanumGothic 폰트를 기본값으로 설정else: pass # 나눔고딕 폰트에 마이너스(-) 부호가 없어 유니코드 마이너스로 대체되어 깨질 수 있음plt.rcParams['axes.unicode_minus'] = False # 마이너스 부호 깨짐 방지# 시각화 코드 실행plt.figure(figsize=(10, 5))plt.title('한글 제목 테스트')plt.xlabel('X축 라벨 (한글)')plt.ylabel('Y축 라벨 (한글)')plt.plot([-1, 0, 1], [1, 2, 0])plt.grid(True)plt.show() Reference Matplotlib 공식 문서 - 폰트 관리 Colab 공식 GitHub (관련 이슈)" }, { "title": "Apache Kafka와 Spring Boot로 구축하는 실시간 데이터 처리 시스템", "url": "/posts/apache-kafka-quick-start/", "categories": "Messaging, Kafka", "tags": "kafka, apache, monitoring, spring boot", "date": "2025-10-12 09:00:00 +0900", "snippet": "시스템 개요 단일 서버 환경에서 Docker Compose를 사용하여 고가용성 Kafka 클러스터를 구축하는 전체 과정을 다룸시나리오 시스템 목적 스마트 팩토리 환경 모니터링 시스템 제조 공정의 온습도를 실시간으로 수집/분석하여 품질 관리 이상 상태 즉시 감지 및 알림으로 불량률 최소화 시스템 구성 요소 데이터 수집층 공정별 온습도 센서 네트워크 센서당 초당 1회 데이터 수집 총 1000개 센서 (10개 공정 * 100개 측정 포인트) 데이터 처리층 Kafka 기반 실시간 스트리밍 처리 Active-Active 이중화 구성 다중 컨슈머 그룹으로 용도별 처리 데이터 활용층 실시간 모니터링 대시보드 이상 징후 자동 감지 및 알림 품질 분석을 위한 데이터 적재 시스템 요구사항 및 설계 원칙 성능 요구사항 처리 성능 초당 1000개 이상 메시지 처리 10ms 이내 처리 지연 데이터 손실률 0% (min.insync.replicas=2로 보장) 가용성 99.9% 이상 서비스 가용성 Active-Active 이중화로 단일 장애 대응 자동 복구 및 재조정 모니터링 실시간 메트릭 수집 (15초 주기) 텔레그램 즉시 알림 시스템 자원 모니터링 기술 스택 선정 애플리케이션: Spring Boot 3.5.6, Java 17 메시징: Apache Kafka 저장소: PostgreSQL 모니터링: Prometheus, Grafana 시스템 아키텍처graph TB subgraph \"데이터 생산\" P1[Producer 1\\n정상: 1000/s\\n피크: 2000/s] --&gt;|160B 데이터\\n40B 헤더| T1 P2[Producer 2\\n정상: 1000/s\\n피크: 2000/s] --&gt;|160B 데이터\\n40B 헤더| T1 P3[Producer 3\\n정상: 1000/s\\n피크: 2000/s] --&gt;|160B 데이터\\n40B 헤더| T2 subgraph \"Spring Boot 프로듀서\" P1 P2 P3 end end subgraph \"Kafka 클러스터\" subgraph \"토픽 구성\" T1[Topic 1\\n파티션: 6개\\n복제팩터: 2\\nISR: 2] --&gt;|파티션 1-2\\n실시간 처리\\n500msg/sec| CG1 T1 --&gt;|파티션 3-4\\nDB 저장\\n500msg/sec| CG2 T1 --&gt;|파티션 5-6\\n분석 처리\\n500msg/sec| CG3 T2[Topic 2\\n파티션: 6개\\n복제팩터: 2\\nISR: 2] --&gt;|백업 처리\\n500msg/sec| CG4 end subgraph \"브로커 구성\" B1[Broker 1\\n16KB 배치\\nmin.insync.replicas=2] B2[Broker 2\\n16KB 배치\\nmin.insync.replicas=2] ZK[ZooKeeper\\n2181 포트\\n메타데이터 관리] B1 &lt;--&gt;|Active-Active 복제| B2 B1 &lt;--&gt;|리더 선출\\n설정 관리| ZK B2 &lt;--&gt;|리더 선출\\n설정 관리| ZK end end subgraph \"데이터 소비\" subgraph \"컨슈머 그룹\" CG1[Group 1\\n실시간 처리\\n배치: 100건/100ms\\nSLA: 10ms] CG2[Group 2\\nDB 저장\\n배치: 500건/초\\n트랜잭션 처리] CG3[Group 3\\n분석\\n배치: 1000건/5초\\n비동기 처리] CG4[Group 4\\n백업\\n배치: 1000건/5초\\n비동기 처리] end CG1 --&gt;|실시간 처리| MC[메모리 캐시\\n100ms 갱신] CG2 --&gt;|저장| DB[(PostgreSQL\\n배치: 500\\n2차 캐시)] CG3 --&gt;|5초 집계| AN[분석 서버] CG4 --&gt;|백업| BK[백업 스토리지] end subgraph \"모니터링\" B1 &amp; B2 --&gt;|JMX 메트릭| JX[JMX Exporter\\n브로커 상태] P1 &amp; P2 &amp; P3 --&gt;|처리량/지연| AE[Actuator Endpoint] CG1 &amp; CG2 &amp; CG3 &amp; CG4 --&gt;|Lag/처리량| AE JX &amp; AE --&gt;|15초 수집| PR[Prometheus] PR --&gt;|대시보드| GF[Grafana] PR --&gt;|임계치 분석| AM[Alert Manager] AM --&gt;|실시간 알림| TG[Telegram Bot] subgraph \"메트릭 지표\" MT1[브로커: 파티션수/리더수] MT2[성능: 처리량/지연] MT3[자원: CPU/메모리/디스크] MT4[컨슈머: Lag/커밋률] end end상세 아키텍처 설계 처리량 및 가용성 설계 수집 데이터 분석 정상 상태: 초당 1000개 센서 데이터 순간 피크: 초당 2000개로 증가 가능 메시지 크기: 200바이트 온도/습도 데이터: 160바이트 메시지 헤더: 40바이트 브로커 구성 결정 브로커 2대 운영 한 대 장애 시에도 서비스 계속하기 위함 부하 분산으로 안정성 확보 ZooKeeper 연동 필수 브로커 메타데이터 관리 리더 선출, 설정 관리 브로커와 별도 서버로 운영 파티션 및 데이터 관리 설계 1단계: 기본 처리량 분석 단일 파티션 처리량: 500 msg/s 필요 파티션 수: 2000 ÷ 500 = 4개 네트워크 대역폭: 2000 msg/s * 200B = 400KB/s 2단계: Topic 1 컨슈머 그룹 고려 실시간 처리용: 2개 파티션 DB 저장용: 2개 파티션 분석용: 2개 파티션 총 필요: 6개 파티션 3단계: Topic 2 (백업) 파티션 설계 처리량 요구사항: Topic 1과 동일 파티션 수: 6개 (2000 msg/s 처리 위해) 파티션 분배: 단일 컨슈머 그룹에서 전체 파티션 처리 처리 방식: 비동기 배치 처리로 성능 최적화 4단계: 데이터 보존 정책 Topic 1: 7일 보관 (실시간/분석 데이터) Topic 2: 30일 보관 (백업 데이터) 디스크 사용량 경고 임계치: 80% 5단계: 고가용성 및 정합성 전략 복제본 수: 2 (1 리더 + 1 팔로워) ISR 설정: 2 (데이터 유실 방지) Producer acks: all (모든 ISR 확인) 리더 선출: preferred leader auto 활성화 재시도 정책: 최대 3회, 지수 백오프 컨슈머 그룹 설계 실시간 처리 파티션: 1-2번 배치: 100건/100ms SLA: 10ms 이내 데이터베이스 저장 파티션: 3-4번 배치: 500건/1초 트랜잭션 처리 데이터 분석 파티션: 5-6번 배치: 1000건/5초 비동기 처리 환경 구성Ubuntu 서버 준비 시스템 업데이트 # 패키지 매니저 업데이트sudo apt update # 시스템 패키지 업그레이드sudo apt upgrade -y Java 개발 환경 설정 JDK 17 설치 # JDK 17 설치sudo apt install openjdk-17-jdk # JAVA_HOME 환경변수 설정echo \"export JAVA_HOME=/usr/lib/jvm/java-17-openjdk-amd64\" &gt;&gt; ~/.bashrcecho \"export PATH=\\$PATH:\\$JAVA_HOME/bin\" &gt;&gt; ~/.bashrcsource ~/.bashrc Gradle 설치 # SDKMAN 설치curl -s \"https://get.sdkman.io\" | bashsource \"$HOME/.sdkman/bin/sdkman-init.sh\" # Gradle 8.4 설치sdk install gradle 8.4 Docker 설치 Docker &amp; Docker Compose 설치 # Docker GPG 키 추가sudo apt install ca-certificates curl gnupgsudo install -m 0755 -d /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg # Docker 저장소 추가echo \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\$(. /etc/os-release &amp;&amp; echo \"$VERSION_CODENAME\") stable\" | \\sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null # Docker 엔진 설치sudo apt updatesudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin # 사용자를 docker 그룹에 추가sudo usermod -aG docker $USERnewgrp docker Kafka 클러스터 구성토픽 초기화 스크립트 scripts/kafka-init.sh 파일 생성 #!/bin/bash # 토픽 생성 함수create_topic() { kafka-topics.sh --create \\ --if-not-exists \\ --bootstrap-server kafka1:9092,kafka2:9093 \\ --topic $1 \\ --partitions $2 \\ --replication-factor $3 \\ --config cleanup.policy=delete \\ --config retention.ms=$4} # sensor-data 토픽 생성 (7일 보존)create_topic \"sensor-data\" 6 2 604800000 # sensor-data-backup 토픽 생성 (30일 보존)create_topic \"sensor-data-backup\" 6 2 2592000000 echo \"Kafka topics initialized successfully\" Docker Compose 설정 docker-compose.yml 파일 생성 version: '3.8'services: # ZooKeeper - 카프카 브로커 메타데이터 관리 zookeeper: image: confluentinc/cp-zookeeper:7.5.1 container_name: zookeeper ports: - \"2181:2181\" environment: ZOOKEEPER_CLIENT_PORT: 2181 # ZooKeeper 포트 ZOOKEEPER_TICK_TIME: 2000 # 타임아웃 설정(ms) volumes: - ./data/zookeeper/data:/var/lib/zookeeper/data - ./data/zookeeper/log:/var/lib/zookeeper/log # Kafka Broker 1 - 첫 번째 브로커 kafka1: image: confluentinc/cp-kafka:7.5.1 container_name: kafka1 ports: - \"9092:9092\" - \"9991:9991\" depends_on: - zookeeper volumes: - ./data/kafka1/data:/var/lib/kafka/data environment: # 기본 설정 KAFKA_BROKER_ID: 1 KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka1:9092 # 복제 및 고가용성 설정 KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 2 KAFKA_DEFAULT_REPLICATION_FACTOR: 2 KAFKA_MIN_INSYNC_REPLICAS: 2 KAFKA_AUTO_LEADER_REBALANCE_ENABLE: \"true\" KAFKA_LEADER_IMBALANCE_CHECK_INTERVAL_SECONDS: 300 # 데이터 처리 설정 KAFKA_MESSAGE_MAX_BYTES: 1048576 KAFKA_COMPRESSION_TYPE: producer KAFKA_NUM_PARTITIONS: 6 # 데이터 보존 정책 - 전역 설정 KAFKA_LOG_RETENTION_HOURS: 168 # 기본 7일 보존 KAFKA_LOG_SEGMENT_BYTES: 1073741824 # 세그먼트 크기 1GB KAFKA_LOG_RETENTION_CHECK_INTERVAL_MS: 300000 # 체크 주기 5분 KAFKA_LOG_CLEANUP_POLICY: delete # 보존기간 초과시 삭제 # 트랜잭션 관련 설정 KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 2 KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 2 # 모니터링 설정 KAFKA_AUTO_CREATE_TOPICS_ENABLE: \"false\" # 토픽 자동 생성 비활성화 KAFKA_AUTO_LEADER_REBALANCE_ENABLE: \"true\" # 자동 리더 리밸런싱 활성화 KAFKA_LEADER_IMBALANCE_CHECK_INTERVAL_SECONDS: 300 # 리더 밸런싱 체크 주기 KAFKA_JMX_PORT: 9991 # JMX 포트 KAFKA_JMX_OPTS: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=kafka1 # 리소스 제한 deploy: resources: limits: memory: 2G reservations: memory: 1G # 헬스체크 healthcheck: test: [\"CMD-SHELL\", \"kafka-topics.sh --bootstrap-server localhost:9092 --list\"] interval: 30s timeout: 10s retries: 3 # 로그 설정 logging: driver: \"json-file\" options: max-size: \"100m\" max-file: \"3\" # Kafka Broker 2 - 두 번째 브로커 kafka2: image: confluentinc/cp-kafka:7.5.1 container_name: kafka2 ports: - \"9093:9093\" - \"9992:9992\" depends_on: - zookeeper volumes: - ./data/kafka2/data:/var/lib/kafka/data environment: # 기본 설정 KAFKA_BROKER_ID: 2 KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181 KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka2:9093 # 복제 및 고가용성 설정 KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 2 KAFKA_DEFAULT_REPLICATION_FACTOR: 2 KAFKA_MIN_INSYNC_REPLICAS: 2 KAFKA_AUTO_LEADER_REBALANCE_ENABLE: \"true\" KAFKA_LEADER_IMBALANCE_CHECK_INTERVAL_SECONDS: 300 # 데이터 처리 설정 KAFKA_MESSAGE_MAX_BYTES: 1048576 KAFKA_COMPRESSION_TYPE: producer KAFKA_NUM_PARTITIONS: 6 # 데이터 보존 정책 - 전역 설정 KAFKA_LOG_RETENTION_HOURS: 168 # 기본 7일 보존 KAFKA_LOG_SEGMENT_BYTES: 1073741824 # 세그먼트 크기 1GB KAFKA_LOG_RETENTION_CHECK_INTERVAL_MS: 300000 # 체크 주기 5분 KAFKA_LOG_CLEANUP_POLICY: delete # 보존기간 초과시 삭제 # 트랜잭션 관련 설정 KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 2 KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 2 # 모니터링 설정 KAFKA_AUTO_CREATE_TOPICS_ENABLE: \"false\" # 토픽 자동 생성 비활성화 KAFKA_AUTO_LEADER_REBALANCE_ENABLE: \"true\" # 자동 리더 리밸런싱 활성화 KAFKA_LEADER_IMBALANCE_CHECK_INTERVAL_SECONDS: 300 # 리더 밸런싱 체크 주기 KAFKA_JMX_PORT: 9992 # JMX 포트 KAFKA_JMX_OPTS: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=kafka2 # 리소스 제한 deploy: resources: limits: memory: 2G reservations: memory: 1G # 헬스체크 healthcheck: test: [\"CMD-SHELL\", \"kafka-topics.sh --bootstrap-server localhost:9093 --list\"] interval: 30s timeout: 10s retries: 3 # 로그 설정 logging: driver: \"json-file\" options: max-size: \"100m\" max-file: \"3\" # Prometheus - 메트릭 수집 prometheus: image: prom/prometheus:v2.48.0 container_name: prometheus ports: - \"9090:9090\" volumes: - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml - ./data/prometheus:/prometheus command: - '--config.file=/etc/prometheus/prometheus.yml' - '--storage.tsdb.path=/prometheus' - '--storage.tsdb.retention.time=30d' # Grafana - 대시보드 시각화 grafana: image: grafana/grafana:10.2.0 container_name: grafana ports: - \"3000:3000\" environment: - GF_SECURITY_ADMIN_USER=admin - GF_SECURITY_ADMIN_PASSWORD=admin volumes: - ./data/grafana:/var/lib/grafana depends_on: - prometheus # Alert Manager - 알림 발송 alertmanager: image: prom/alertmanager:v0.26.0 container_name: alertmanager ports: - \"9094:9093\" # 호스트의 9094 포트를 컨테이너의 9093 포트에 매핑 volumes: - ./alertmanager/alertmanager.yml:/etc/alertmanager/alertmanager.yml command: - '--config.file=/etc/alertmanager/alertmanager.yml' # Kafka 토픽 초기화 kafka-init: image: confluentinc/cp-kafka:7.5.1 depends_on: kafka1: condition: service_healthy # 실제로 서비스가 동작하는 상태 kafka2: condition: service_healthy volumes: - ./scripts/kafka-init.sh:/scripts/kafka-init.sh command: &gt; bash -c \" echo 'Waiting for Kafka to be ready...' &amp;&amp; cub kafka-ready -b kafka1:9092,kafka2:9093 2 60 &amp;&amp; echo 'Initializing Kafka topics...' &amp;&amp; /scripts/kafka-init.sh\" 모니터링 설정 Prometheus 설정 (prometheus/prometheus.yml) global: scrape_interval: 15s # 메트릭 수집 주기 evaluation_interval: 15s # 규칙 평가 주기 rule_files: - 'rules/*.yml' # 알림 규칙 파일 alerting: alertmanagers: - static_configs: - targets: ['alertmanager:9093'] scrape_configs: - job_name: 'kafka' static_configs: - targets: - 'kafka1:9991' # Kafka 브로커 1 JMX - 'kafka2:9992' # Kafka 브로커 2 JMX - job_name: 'spring-actuator' metrics_path: '/actuator/prometheus' scrape_interval: 5s static_configs: - targets: - 'host.docker.internal:8080' # Spring Boot 애플리케이션 - job_name: 'node-exporter' static_configs: - targets: - 'node-exporter:9100' # 시스템 메트릭 Alert Manager 설정 (alertmanager/alertmanager.yml) global: resolve_timeout: 5mroute: receiver: 'telegram' group_by: ['alertname', 'severity', 'consumer_group'] group_wait: 10s group_interval: 10s repeat_interval: 1h routes: - match: severity: critical group_wait: 0s repeat_interval: 5m - match: severity: warning group_wait: 30s repeat_interval: 15m receivers: - name: 'telegram' telegram_configs: - bot_token: 'YOUR_BOT_TOKEN' chat_id: YOUR_CHAT_ID parse_mode: 'HTML' api_url: 'https://api.telegram.org' message: |- 🚨 &lt;b&gt;{{ .GroupLabels.alertname }}&lt;/b&gt; 심각도: {{ .Labels.severity }} 컨슈머 그룹: {{ .Labels.consumer_group }} {{ .Annotations.description }} 클러스터 실행 도커 컴포즈로 시작 # 컨테이너 실행docker-compose up -d # 컨테이너 상태 확인docker-compose ps # 로그 확인docker-compose logs -f Spring Boot 애플리케이션 개발Gradle 의존성 build.gradle 설정 plugins { id 'java' id 'org.springframework.boot' version '3.5.6' id 'io.spring.dependency-management' version '1.1.4'}group = 'com.example'version = '1.0.0'sourceCompatibility = '17'repositories { mavenCentral()}dependencies { // Spring Boot implementation 'org.springframework.boot:spring-boot-starter' implementation 'org.springframework.boot:spring-boot-starter-web' implementation 'org.springframework.kafka:spring-kafka' // Database &amp; Caching implementation 'org.springframework.boot:spring-boot-starter-data-jpa' implementation 'org.postgresql:postgresql' implementation 'org.hibernate.orm:hibernate-jcache' implementation 'org.ehcache:ehcache:3.10.8' // Observability implementation 'org.springframework.boot:spring-boot-starter-actuator' implementation 'io.micrometer:micrometer-registry-prometheus' // lombok compileOnly 'org.projectlombok:lombok' annotationProcessor 'org.projectlombok:lombok' // 테스트 testImplementation 'org.springframework.boot:spring-boot-starter-test' testImplementation 'org.springframework.kafka:spring-kafka-test'} 애플리케이션 설정 application.yml 설정 spring: # Kafka 설정 kafka: bootstrap-servers: localhost:9092,localhost:9093 producer: key-serializer: org.apache.kafka.common.serialization.StringSerializer value-serializer: org.springframework.kafka.support.serializer.JsonSerializer acks: all # 모든 ISR 확인 retries: 3 # 재시도 정책: 최대 3회 retry-backoff-ms: 1000 # 지수 백오프 시작값 batch-size: 16384 # 배치 크기 16KB buffer-memory: 33554432 # 버퍼 메모리 compression-type: lz4 # 메시지 압축 max-request-size: 1048576 # 최대 요청 크기 1MB # 공통 컨슈머 설정 consumer: key-deserializer: org.apache.kafka.common.serialization.StringDeserializer value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer enable-auto-commit: false # 수동 커밋 auto-offset-reset: earliest # 오프셋 초기화 heartbeat-interval: 3000 # 하트비트 간격 session-timeout-ms: 45000 # 세션 타임아웃 # 실시간 처리 컨슈머 설정 consumer-realtime: group-id: realtime-processor max-poll-records: 100 # 100건/100ms fetch-max-wait: 100 # 100ms fetch-min-bytes: 1 # 최소 페치 크기 max-partition-fetch-bytes: 1048576 # 데이터베이스 저장 컨슈머 설정 consumer-database: group-id: database-processor max-poll-records: 500 # 500건/1초 fetch-max-wait: 1000 # 1초 isolation-level: read_committed # 트랜잭션 처리 fetch-min-bytes: 1024 max-partition-fetch-bytes: 1048576 # 데이터 분석 컨슈머 설정 consumer-analytics: group-id: analytics-processor max-poll-records: 1000 # 1000건/5초 fetch-max-wait: 5000 # 5초 fetch-min-bytes: 2048 max-partition-fetch-bytes: 1048576 # Database 설정 datasource: url: jdbc:postgresql://localhost:5432/kafka_stream username: postgres password: postgres driver-class-name: org.postgresql.Driver hikari: maximum-pool-size: 10 minimum-idle: 5 # JPA 설정 jpa: hibernate: ddl-auto: update properties: hibernate: dialect: org.hibernate.dialect.PostgreSQLDialect format_sql: true show_sql: true generate_statistics: true cache: use_second_level_cache: true region.factory_class: org.hibernate.cache.jcache.JCacheRegionFactory provider_configuration_file_path: ehcache.xml jdbc: batch_size: 500 batch_versioned_data: true order_inserts: true order_updates: true # 액추에이터 설정 management: endpoints: web: exposure: include: health,metrics,prometheus metrics: tags: application: ${spring.application.name} 데이터 모델 SensorDataRepository.java - 센서 데이터 레포지토리 /** * 센서 데이터 영속성을 관리하는 리포지토리 인터페이스* JpaRepository를 상속하여 기본적인 CRUD 작업과 페이징 기능을 제공*/@Repository public interface SensorDataRepository extends JpaRepository&lt;SensorData, Long&gt; {} SensorData.java - 센서 데이터 모델 @Data@Entity@Table(name = \"sensor_data\")@Cacheable@org.hibernate.annotations.Cache(usage = org.hibernate.annotations.CacheConcurrencyStrategy.READ_WRITE)public class SensorData { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = \"sensor_id\", nullable = false) @Index(name = \"idx_sensor_id\") // 조회 성능 향상을 위한 인덱스 생성 private String sensorId; @Column(nullable = false) private Double temperature; // 온도 데이터 컬럼 @Column(nullable = false) private Double humidity; // 습도 데이터 컬럼 @Column(nullable = false) @Index(name = \"idx_timestamp\") // 시간 기반 조회를 위한 인덱스 private LocalDateTime timestamp; // 측정 시간 컬럼 // 낙관적 락을 위한 버전 관리 // 동시성 제어: 여러 트랜잭션이 동시에 같은 데이터를 수정하는 것을 방지 @Version private Long version;} 메시지 생산자 KafkaProducerConfig.java - 생산자 설정 /** * Kafka 프로듀서 관련 설정을 담당하는 설정 클래스* 메시지 직렬화, 브로커 연결 등 프로듀서의 핵심 설정을 정의*/@Configuration // 스프링 설정 클래스임을 표시public class KafkaProducerConfig { /** * Kafka 프로듀서 팩토리 빈 생성 * 프로듀서의 기본 설정을 구성하고 인스턴스를 생성하는 팩토리 제공 * * @return 설정이 완료된 프로듀서 팩토리 */ @Bean public ProducerFactory&lt;String, SensorData&gt; producerFactory() { Map&lt;String, Object&gt; config = new HashMap&lt;&gt;(); // 브로커 서버 리스트 설정 config.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, \"localhost:9092,localhost:9093\"); // 메시지 키의 직렬화 방식 설정 config.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class); // 메시지 값의 직렬화 방식 설정 (JSON 형식) config.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class); return new DefaultKafkaProducerFactory&lt;&gt;(config); } /** * Kafka 템플릿 빈 생성 * * @return 설정된 Kafka 템플릿 */ @Bean public KafkaTemplate&lt;String, SensorData&gt; kafkaTemplate() { return new KafkaTemplate&lt;&gt;(producerFactory()); }} SensorDataProducer.java - 센서 데이터 생산 /** * 센서 데이터를 생성하고 Kafka로 전송하는 서비스 클래스* 실시간으로 센서 데이터를 시뮬레이션하고 Kafka 토픽으로 전송*/@Service @Slf4j @RequiredArgsConstructorpublic class SensorDataProducer { // Kafka로 메시지를 전송하기 위한 템플릿 private final KafkaTemplate&lt;String, SensorData&gt; kafkaTemplate; // 센서 데이터가 전송될 Kafka 토픽 이름 private static final String TOPIC = \"sensor-data\"; /** * 센서 데이터 생성 및 전송 메서드 * 매 밀리초마다 실행되어 임의의 센서 데이터를 생성하고 Kafka로 전송 */ @Scheduled(fixedRate = 1) // 1ms 간격으로 실행 public void generateData() { SensorData data = new SensorData(); data.setSensorId(\"SENSOR-\" + ThreadLocalRandom.current().nextInt(1, 1001)); // 1부터 1000까지의 센서 ID 임의 생성 data.setTemperature(20.0 + ThreadLocalRandom.current().nextDouble() * 10); // 20-30도 사이의 임의 온도 생성 data.setHumidity(40.0 + ThreadLocalRandom.current().nextDouble() * 20); // 40-60% 사이의 임의 습도 생성 data.setTimestamp(LocalDateTime.now()); // 현재 시간 기록 // CompletableFuture를 사용한 비동기 전송 kafkaTemplate.send(TOPIC, data.getSensorId(), data) .whenComplete((result, ex) -&gt; { if (ex == null) { log.info(\"Sent data: {} with offset: {}\", data, result.getRecordMetadata().offset()); } else { log.error(\"Unable to send data: {} due to: {}\", data, ex.getMessage()); } }); }} 메시지 소비자 KafkaConsumerConfig.java - 소비자 설정 /** * Kafka 컨슈머 관련 설정을 담당하는 설정 클래스* 메시지 역직렬화, 컨슈머 그룹, 배치 처리 등 컨슈머의 핵심 설정을 정의*/@Configuration public class KafkaConsumerConfig { /** * Kafka 컨슈머 팩토리 빈 생성 * 컨슈머의 기본 설정을 구성하고 인스턴스를 생성 * * @return 설정이 완료된 컨슈머 팩토리 */ @Bean public ConsumerFactory&lt;String, SensorData&gt; consumerFactory() { Map&lt;String, Object&gt; config = new HashMap&lt;&gt;(); // 브로커 서버 리스트 설정 config.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, \"localhost:9092,localhost:9093\"); // 컨슈머 그룹 ID 설정 config.put(ConsumerConfig.GROUP_ID_CONFIG, \"sensor-group\"); // 메시지 키의 역직렬화 방식 설정 config.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); // 메시지 값의 역직렬화 방식 설정 (JSON 형식) config.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class); return new DefaultKafkaConsumerFactory&lt;&gt;(config); } /** * Kafka 리스너 컨테이너 팩토리 빈 생성 * * @return 설정된 리스너 컨테이너 팩토리 */ @Bean public ConcurrentKafkaListenerContainerFactory&lt;String, SensorData&gt; kafkaListenerContainerFactory() { ConcurrentKafkaListenerContainerFactory&lt;String, SensorData&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setBatchListener(true); // 배치 처리 모드 활성화 factory.setConcurrency(3); // 병렬 처리를 위한 컨슈머 스레드 수 설정 factory.getContainerProperties().setPollTimeout(3000); // 폴링 대기 시간 설정(ms) return factory; }} SensorDataConsumer.java - 센서 데이터 소비 /** * 센서 데이터를 소비하고 처리하는 서비스 클래스* Kafka에서 메시지를 배치로 수신하여 데이터베이스에 저장하고 이상 징후를 모니터링*/@Service @Slf4j@RequiredArgsConstructor public class SensorDataConsumer { private final SensorDataRepository sensorDataRepository; // 센서 데이터 저장을 위한 리포지토리 /** * Kafka 토픽으로부터 센서 데이터를 배치로 수신하고 처리하는 메서드 * 데이터베이스에 배치 저장하고 온도 이상 징후를 모니터링 * * @param dataList 수신된 센서 데이터 목록 * @param partitions 메시지가 수신된 파티션 번호 목록 * @param offsets 메시지의 오프셋 목록 * @throws RuntimeException 배치 처리 실패 시 발생 */ @KafkaListener( topics = \"sensor-data\", // 구독할 토픽 groupId = \"db-saver-group\", // 컨슈머 그룹 ID containerFactory = \"kafkaListenerContainerFactory\" // 컨테이너 팩토리 ) @Transactional // 트랜잭션 처리를 위한 어노테이션 public void consume(@Payload List&lt;SensorData&gt; dataList) { log.info(\"Received batch of {} records\", dataList.size()); try { // JPA를 사용하여 데이터를 배치로 저장 sensorDataRepository.saveAll(dataList); // 고온 경고를 위한 메트릭 기록 및 모니터링 for (SensorData data : dataList) { if (data.getTemperature() &gt; 25.0) { log.warn(\"High temperature alert: {}\", data); } } } catch (Exception e) { log.error(\"Error processing batch: {}\", e.getMessage()); throw new RuntimeException(\"Failed to process batch\", e); } }} 모니터링 대시보드Grafana 대시보드 핵심 메트릭 브로커 상태: 활성 파티션 수, 리더 수 메시지 처리량: 초당 메시지 수, 바이트 처리량 성능 지표: 요청 처리 시간, 실패율 컨슈머 상태: Lag, 오프셋 커밋 성공률 리소스 사용: CPU/메모리 사용률, 디스크 I/O 알림 규칙 rules/kafka_alerts.yml 설정 groups: - name: kafka_system_alerts # 브로커 및 시스템 상태 모니터링 rules: - alert: KafkaBrokerDown expr: up{job=\"kafka\"} == 0 for: 1m labels: severity: critical annotations: summary: \"Kafka 브로커 다운\" description: \"브로커 {{ $labels.instance }}가 응답하지 않습니다\" - alert: KafkaUnderReplicatedPartitions expr: kafka_server_replicamanager_underreplicated_partitions &gt; 0 for: 5m labels: severity: warning annotations: summary: \"복제 파티션 부족\" description: \"브로커 {{ $labels.instance }}에 복제가 부족한 파티션이 있습니다\" - alert: KafkaHighCPU expr: rate(process_cpu_seconds_total[5m]) &gt; 0.8 for: 5m labels: severity: warning annotations: summary: \"높은 CPU 사용률\" description: \"인스턴스 {{ $labels.instance }}의 CPU 사용률이 80%를 초과했습니다\" - name: kafka_consumer_alerts # 컨슈머 그룹별 처리 지연 모니터링 rules: # 실시간 처리 그룹 - alert: KafkaRealtimeProcessorLag expr: kafka_consumergroup_lag{group=\"realtime-processor\"} &gt; 200 for: 1m labels: severity: critical consumer_group: realtime-processor annotations: summary: \"실시간 처리 지연 발생\" description: | 실시간 처리 그룹에서 처리 지연이 발생했습니다. - 컨슈머 그룹: {{ $labels.group }} - 토픽: {{ $labels.topic }} - 현재 Lag: {{ $value | printf \"%.0f\" }}건 # DB 저장 그룹 (일반 처리) - alert: KafkaDatabaseProcessorLag expr: kafka_consumergroup_lag{group=\"database-processor\"} &gt; 1000 for: 5m labels: severity: warning consumer_group: database-processor annotations: summary: \"DB 저장 처리 지연 발생\" description: | DB 저장 그룹에서 처리 지연이 발생했습니다. - 컨슈머 그룹: {{ $labels.group }} - 토픽: {{ $labels.topic }} - 현재 Lag: {{ $value | printf \"%.0f\" }}건 # 분석 처리 그룹 (배치 처리) - alert: KafkaAnalyticsProcessorLag expr: kafka_consumergroup_lag{group=\"analytics-processor\"} &gt; 5000 for: 10m labels: severity: info consumer_group: analytics-processor annotations: summary: \"분석 처리 지연 발생\" description: | 분석 처리 그룹에서 배치 처리 지연이 발생했습니다. - 컨슈머 그룹: {{ $labels.group }} - 토픽: {{ $labels.topic }} - 현재 Lag: {{ $value | printf \"%.0f\" }}건 테스트 및 운영성능 테스트 KafkaLoadTest.java - 부하 테스트 @SpringBootTestpublic class KafkaLoadTest { @Autowired private KafkaTemplate&lt;String, SensorData&gt; kafkaTemplate; @Test public void loadTest() throws InterruptedException { int messageCount = 100000; CountDownLatch latch = new CountDownLatch(messageCount); List&lt;Long&gt; latencies = new ArrayList&lt;&gt;(); long start = System.currentTimeMillis(); // 병렬 메시지 전송 IntStream.range(0, messageCount) .parallel() .forEach(i -&gt; { SensorData data = new SensorData(); data.setSensorId(\"TEST-\" + i); data.setTemperature(20.0 + Math.random() * 10); data.setHumidity(40.0 + Math.random() * 20); data.setTimestamp(LocalDateTime.now()); long sendTime = System.nanoTime(); kafkaTemplate.send(\"sensor-data\", data.getSensorId(), data) .whenComplete((result, ex) -&gt; { if (ex == null) { // 지연 시간 측정 (마이크로초 단위) long latency = (System.nanoTime() - sendTime) / 1000; synchronized(latencies) { latencies.add(latency); } latch.countDown(); } else { log.error(\"Failed to send message\", ex); } }); }); // 최대 1분간 대기 boolean completed = latch.await(1, TimeUnit.MINUTES); long end = System.currentTimeMillis(); // 성능 지표 계산 double duration = (end - start) / 1000.0; double throughput = messageCount / duration; // 지연 시간 통계 DoubleSummaryStatistics stats = latencies.stream() .mapToDouble(Long::doubleValue) .summaryStatistics(); // 결과 출력 log.info(\"성능 테스트 결과:\"); log.info(\"- 총 메시지: {} (성공: {})\", messageCount, latencies.size()); log.info(\"- 처리 시간: {:.2f}초\", duration); log.info(\"- 처리율: {:.0f} msg/sec\", throughput); log.info(\"- 평균 지연: {:.2f}µs\", stats.getAverage()); log.info(\"- 최대 지연: {:.2f}µs\", stats.getMax()); log.info(\"- 최소 지연: {:.2f}µs\", stats.getMin()); }} Reference Apache Kafka Documentation Spring for Apache Kafka Spring Boot Actuator Kafka Monitoring Spring Data JPA Reference" }, { "title": "Apache Kafka 개념과 아키텍처", "url": "/posts/apache-kafka-concepts/", "categories": "Messaging, Kafka", "tags": "kafka, apache", "date": "2025-10-12 01:00:00 +0900", "snippet": "개요 Apache Kafka는 실시간으로 대량의 데이터를 안전하게 전달하고 처리하기 위한 플랫폼임Kafka가 필요한 이유 우리가 사용하는 현대의 서비스들(넷플릭스, 쇼핑몰, SNS 등)은 수많은 데이터를 실시간으로 처리해야 함 사용자의 클릭, 검색, 결제 데이터 서비스 로그, 에러 메시지 IoT 센서 데이터 실시간 알림 이러한 데이터를 안전하고 빠르게 처리하기 위해 Kafka를 사용함기본 개념메시지 전달 구성 요소 카프카를 우체국에 비유하면 다음과 같음 graph TD A[편지 작성자Producer] --&gt;|편지 전송| B[우체국Kafka Broker] B --&gt;|편지 분류| C[우편함Topic] C --&gt;|편지 수령| D[수령인Consumer] Producer(생산자) 편지를 쓰는 사람 Kafka Broker(우체국) 메시지를 저장하고 전달하는 서버 Topic(우편함) 메시지를 종류별로 구분하는 공간 Consumer(소비자) 메시지를 받아서 처리하는 프로그램 메시지 추적과 관리 커밋(Commit)이란? 컨슈머가 어디까지 메시지를 처리했는지 표시하는 것 마치 책갈피처럼 다음에 어디서부터 읽어야 할지 기억 메시지 처리 진행 상황을 추적하고 관리 오프셋(Offset)이란? 각 파티션 내의 메시지 위치를 가리키는 번호 첫 메시지는 0번부터 시작해서 순차적으로 증가 메시지의 고유한 ‘주소’나 ‘페이지 번호’ 같은 역할 파티션[메시지0] [메시지1] [메시지2] [메시지3] ... ↑ ↑ ↑ ↑오프셋=0 오프셋=1 오프셋=2 오프셋=3 커밋과 오프셋의 관계 컨슈머는 처리한 메시지의 오프셋을 커밋 커밋된 오프셋을 통해 처리 진행상황 파악 장애 발생 시 마지막 커밋 오프셋부터 재시작 sequenceDiagram participant C as Consumer participant K as Kafka participant O as __consumer_offsets Note over C,K: 메시지 소비 및 처리 K-&gt;&gt;C: 오프셋 5까지 메시지 전달 C-&gt;&gt;C: 메시지 처리 C-&gt;&gt;O: 오프셋 5 커밋 Note over C,O: 처리 완료 지점 기록 Note over C,K: 장애 발생 및 복구 C-&gt;&gt;C: 장애 발생! C-&gt;&gt;O: 마지막 커밋 오프셋 조회 O-&gt;&gt;C: 오프셋 5 반환 C-&gt;&gt;K: 오프셋 5부터 메시지 요청 K-&gt;&gt;C: 오프셋 5 이후 메시지 전달 Note over C,K: 장애 지점부터 재시작전체 아키텍처 Kafka의 전체 구조를 이해하면 데이터가 어떻게 흐르는지 파악할 수 있음 graph TB subgraph Producers[데이터 생산자들] P1[웹서버] P2[모바일앱] P3[IoT센서] end subgraph Kafka_Cluster[카프카 클러스터] subgraph Brokers[브로커들] B1[브로커1] B2[브로커2] B3[브로커3] end subgraph Topics[토픽들] T1[로그 토픽] T2[주문 토픽] T3[알림 토픽] end end subgraph Consumers[데이터 소비자들] C1[분석 시스템] C2[모니터링] C3[백업 시스템] end P1 &amp; P2 &amp; P3 --&gt; Brokers Brokers &lt;--&gt; Topics Topics --&gt; C1 &amp; C2 &amp; C3 주요 특징 안정성 데이터를 안전하게 보관 (마치 은행 금고처럼) 여러 서버에 복사본 저장으로 데이터 유실 방지 서버 장애가 발생해도 서비스 계속 운영 확장성 처리할 데이터가 늘어나면 서버 추가로 확장 카카오톡 단체방처럼 많은 사용자 동시 처리 가능 필요할 때마다 쉽게 용량 증설 고성능 대량의 데이터를 빠르게 처리 효율적인 데이터 저장 방식 사용 여러 소비자가 동시에 데이터 읽기 가능 메시지 생산자 (Producer) 데이터를 만들어서 Kafka로 보내는 프로그램 graph LR A[웹서버] --&gt;|주문 데이터| B[카프카] C[모바일앱] --&gt;|로그 데이터| B D[센서] --&gt;|측정 데이터| B ex) 쇼핑몰의 주문 처리 시스템 핸드폰 앱의 사용자 활동 로그 기상 관측소의 온도 센서 메시지 소비자 (Consumer) Kafka에서 데이터를 가져와서 처리하는 프로그램 graph LR A[카프카] --&gt;|주문 데이터| B[결제 시스템] A --&gt;|로그 데이터| C[분석 시스템] A --&gt;|측정 데이터| D[모니터링] ex) 주문 데이터를 받아서 배송 처리하는 시스템 사용자 행동 데이터를 분석하는 시스템 실시간 알림을 보내는 서비스 메시지 저장소 (Broker) Kafka 서버를 브로커라고 부름 데이터를 저장하고 관리하는 창고와 같음 graph TB subgraph 카프카_클러스터 B1[브로커1주 서버] B2[브로커2백업 서버1] B3[브로커3백업 서버2] B1 &lt;--&gt; B2 B2 &lt;--&gt; B3 B3 &lt;--&gt; B1 end 특징 여러 서버가 협력하여 작동 (마치 여러 지점을 가진 은행처럼) 한 서버가 고장나도 다른 서버가 대신 처리 데이터를 안전하게 보관하고 전달 메시지 분류 (Topic) 토픽은 같은 종류의 메시지를 모아두는 공간임 도서관의 서가나 우체국의 우편함과 비슷함 graph TB subgraph 토픽들 T1[주문 토픽] T2[로그 토픽] T3[알림 토픽] end P1[주문 시스템] --&gt; T1 P2[앱/웹서버] --&gt; T2 P3[알림 서버] --&gt; T3 T1 --&gt; C1[결제 처리] T2 --&gt; C2[로그 분석] T3 --&gt; C3[푸시 발송] ex) 주문 토픽: 모든 주문 관련 데이터 저장 로그 토픽: 시스템 로그 메시지 저장 알림 토픽: 사용자 알림 메시지 저장 데이터 분산 저장 (Partition) 각 토픽은 여러 개의 파티션으로 나뉘어 저장됨 하나의 큰 책을 여러 장으로 나누어 보관하는 것과 같음 graph LR subgraph 주문_토픽 P1[파티션1주문 1-1000] P2[파티션2주문 1001-2000] P3[파티션3주문 2001-3000] end 장점 대량의 데이터를 나눠서 처리 가능 여러 소비자가 동시에 데이터 처리 가능 데이터 처리 속도 향상 데이터 흐름메시지가 전달되는 과정sequenceDiagram participant P as 생산자(Producer) participant B as 브로커(Broker) participant C as 소비자(Consumer) P-&gt;&gt;+B: 1. 메시지 전송 Note over B: 2. 메시지 저장 B-&gt;&gt;-B: 3. 복제본 생성 C-&gt;&gt;+B: 4. 메시지 요청 B-&gt;&gt;-C: 5. 메시지 전달 Note over C: 6. 메시지 처리 ex) 사용자가 온라인 쇼핑몰에서 주문 버튼 클릭 주문 시스템(Producer)이 주문 데이터를 Kafka로 전송 Kafka가 주문 데이터를 ‘주문’ 토픽에 안전하게 저장 결제 시스템(Consumer)이 새로운 주문 데이터를 가져감 배송 시스템(Consumer)이 동일한 주문 데이터로 배송 처리 데이터 처리 방식graph TB subgraph 데이터_저장소 T1[토픽 1] T2[토픽 2] T3[토픽 3] end subgraph 소비자_그룹_1 C1[소비자 1] C2[소비자 2] end subgraph 소비자_그룹_2 C3[소비자 3] C4[소비자 4] end T1 &amp; T2 &amp; T3 --&gt; C1 &amp; C2 T1 &amp; T2 &amp; T3 --&gt; C3 &amp; C4 병렬 처리 여러 소비자가 동시에 데이터 처리 처리 속도 향상 부하 분산 독립적 처리 각 소비자 그룹은 독립적으로 데이터 처리 한 그룹의 문제가 다른 그룹에 영향을 주지 않음 다양한 용도로 같은 데이터 사용 가능 순서 보장 같은 키를 가진 메시지는 순서대로 처리 ex) 같은 사용자의 주문은 순서대로 처리 다른 사용자의 주문은 병렬로 처리 활용 사례로그 수집 실시간 로그 처리 시스템/애플리케이션 로그 수집 서버, 애플리케이션의 모든 로그를 중앙 집중화 실시간 모니터링 데이터 처리 시스템 성능, 사용자 행동 패턴 실시간 추적 보안 이벤트 로그 분석 보안 위협 실시간 탐지 및 대응 구현 고려사항 로그 포맷 표준화 JSON 형식 등 일관된 로그 형식 정의 보관 기간 설정 법적 요구 사항, 디스크 용량을 고려한 보관 기간 설정 처리 파이프라인 구성 수집 → 필터링 → 저장 → 분석 단계별 처리 이벤트 스트리밍 실시간 데이터 처리 실시간 분석 사용자 행동, 시장 동향 등 실시간 분석 IoT 데이터 수집 센서 데이터 실시간 수집 및 모니터링 실시간 처리 파이프라인 들어오는 데이터를 지연 없이 처리 주요 패턴 Event Sourcing 상태 변경을 이벤트로 저장하여 이력 관리 CQRS 읽기와 쓰기 작업을 분리하여 성능 최적화 Stream Processing 데이터 흐름을 실시간으로 처리 데이터 동기화 시스템 간 데이터 연동 DB 변경 데이터 캡처(CDC) 데이터베이스 변경사항 실시간 추적 시스템 간 데이터 동기화 여러 시스템의 데이터 일관성 유지 캐시 업데이트 캐시 데이터의 실시간 갱신으로 성능 향상 구현 패턴 Outbox Pattern 분산 트랜잭션 문제 해결을 위한 이벤트 발행 Event-Driven Architecture 이벤트 기반의 느슨한 결합 구조 Master-Slave Replication 데이터베이스 복제 및 동기화 메시징 시스템 시스템 통합 시스템 간 느슨한 결합 서비스 간 직접 의존성 제거 마이크로서비스 통신 서비스 간 비동기 메시지 교환 비동기 작업 처리 시간이 오래 걸리는 작업의 비동기 처리 아키텍처 패턴 Pub/Sub Pattern 발행자와 구독자 간의 메시지 전달 Point-to-Point 1:1 메시지 전달 방식 Request-Reply 요청-응답 기반의 메시지 교환 고급 기능데이터 일관성과 안정성 메시지 전송 보장 수준 (acks) acks=0 전송 즉시 성공으로 간주 속도는 가장 빠르지만 데이터 유실 위험 높음 acks=1 리더가 메시지 수신 확인 시 성공 적절한 속도와 안정성의 균형 acks=all 모든 복제본이 메시지 수신 확인 시 성공 가장 안전하지만 속도는 느림 // 프로듀서 설정 Properties props = new Properties(); // 빠른 처리 속도 우선 props.put(\"acks\", \"0\"); // 안정성과 속도의 균형 props.put(\"acks\", \"1\"); // 데이터 안정성 우선 props.put(\"acks\", \"all\"); KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props); 복제 설정 replication.factor 각 파티션의 복제본 수 지정 높을수록 안전하지만 리소스 사용량 증가 일반적으로 3 설정 (1 리더 + 2 팔로워) min.insync.replicas 최소 동기화 복제본 수 이 수보다 적으면 쓰기 거부 데이터 안정성 보장을 위한 중요 설정 # 토픽 생성 시 복제 설정 kafka-topics.sh --create \\ # 토픽 생성 명령 --bootstrap-server localhost:9092 \\ # Kafka 브로커 주소 --topic my-topic \\ # 생성할 토픽 이름 --partitions 3 \\ # 파티션 수 (병렬 처리 단위) --replication-factor 3 # 복제본 수 (데이터 안정성) # 브로커 설정 파일에서 최소 동기화 복제본 설정 min.insync.replicas=2 데이터 정합성 보장 ISR(In-Sync Replicas) 리더와 제대로 동기화된 복제본들의 집합 replica.lag.time.max.ms 설정 시간 내에 리더와 동기화된 복제본만 포함 ISR이 아닌 복제본은 장애 복구 시 리더가 될 수 없음 파티션 리더 선출 리더 장애 시 ISR 중에서만 새 리더 선출 가장 최신 데이터(높은 LEO)를 가진 복제본이 우선 선출 ISR 아닌 복제본은 데이터 유실 위험으로 리더가 될 수 없음 커밋된 메시지 처리 High Watermark(HW) 모든 ISR이 복제 완료한 최신 오프셋 소비자는 HW까지의 메시지만 읽을 수 있음 리더 변경 시에도 HW 이후 메시지는 롤백되어 데이터 일관성 유지 graph LR A[리더] --&gt;|복제| B[ISR 팔로워1] A --&gt;|복제| C[ISR 팔로워2] A --&gt;|복제 지연| D[비ISR 팔로워] subgraph 메시지_상태 E[커밋된 메시지HW까지] F[언커밋 메시지HW 이후] end 운영 관리성능 튜닝 설정 프로듀서 성능 설정 batch.size 한 번에 전송할 최대 메시지 크기 default value: 16384 바이트 권장값: 64KB ~ 128KB (처리량 우선 시) 영향도: 메모리 사용량 ↑, 처리량 ↑ 실제 사례: 로그 수집 시스템에서 128KB 사용 시 30% 처리량 향상 linger.ms 배치를 전송하기 전 대기 시간 default value: 0ms (즉시 전송) 권장값: 50ms ~ 100ms (처리량 우선 시) 영향도: 지연시간 ↑, 처리량 ↑ 실제 사례: IoT 데이터 수집 시 100ms 설정으로 40% 네트워크 사용량 감소 max.in.flight.requests.per.connection 응답을 기다리는 최대 요청 수 default value: 5 권장값: 3 ~ 5 (메모리 제약 환경) 영향도: 메모리 사용량 ↑, 동시성 ↑ 실제 사례: 고성능 환경에서 5로 설정 시 최적의 처리량 달성 // 프로듀서 성능 최적화 설정 Properties props = new Properties(); // 처리량 우선 설정 props.put(\"batch.size\", 262144); // 256KB props.put(\"linger.ms\", 100); // 100ms props.put(\"compression.type\", \"snappy\"); // 압축 활성화 // 안정성 우선 설정 props.put(\"max.in.flight.requests.per.connection\", 3); props.put(\"retries\", 3); props.put(\"acks\", \"all\"); KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props); 컨슈머 성능 설정 fetch.min.bytes 한 번에 가져올 최소 데이터 크기 default value: 1 바이트 권장값: 1KB ~ 64KB (네트워크 효율성 우선 시) 영향도: 지연시간 ↑, 네트워크 효율성 ↑ max.poll.records 한 번에 가져올 최대 레코드 수 default value: 500 권장값: 300 ~ 1000 (메모리 크기에 따라 조정) 영향도: 메모리 사용량 ↑, 처리 지연 가능성 ↑ heartbeat.interval.ms 그룹 코디네이터에 하트비트 전송 주기 default value: 3000ms 권장값: session.timeout.ms의 1/3 영향도: 네트워크 트래픽 ↑, 리밸런싱 감지 속도 ↑ // 컨슈머 성능 최적화 설정 Properties props = new Properties(); // 대용량 처리 설정 props.put(\"fetch.min.bytes\", 65536); // 64KB props.put(\"max.poll.records\", 500); props.put(\"fetch.max.bytes\", 52428800); // 50MB // 안정성 설정 props.put(\"session.timeout.ms\", 45000); // 45초 props.put(\"heartbeat.interval.ms\", 15000); // 15초 props.put(\"enable.auto.commit\", \"false\"); // 수동 커밋 KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(props); 브로커 성능 설정 num.io.threads 디스크 I/O 처리 스레드 수 default value: 8 권장값: CPU 코어 수의 2배 영향도: CPU 사용량 ↑, I/O 처리량 ↑ num.network.threads 네트워크 요청 처리 스레드 수 default value: 3 권장값: CPU 코어 수 * 2 (최소 8) 영향도: CPU 사용량 ↑, 네트워크 처리량 ↑ log.flush.interval.messages 디스크에 강제로 기록할 메시지 수 default value: 9223372036854775807 권장값: 처리량에 따라 1000~50000 영향도: 디스크 I/O ↑, 데이터 내구성 ↑ # 브로커 서버 설정 파일 (server.properties) # 고성능 처리 설정 num.io.threads=16 # CPU 코어 수 * 2 num.network.threads=16 # network.threads와 동일 구성 num.replica.fetchers=8 # 복제 성능 향상 # 메모리 최적화 socket.receive.buffer.bytes=1048576 # 1MB socket.send.buffer.bytes=1048576 # 1MB replica.fetch.max.bytes=104857600 # 100MB # 디스크 I/O 최적화 log.flush.interval.messages=10000 log.flush.interval.ms=1000 log.flush.scheduler.interval.ms=1000 # 네트워크 최적화 num.partitions=8 # 브로커당 기본 파티션 수 socket.request.max.bytes=104857600 # 100MB replica.fetch.response.max.bytes=10485760 # 10MB 확장성 관리 파티션 할당과 재조정 파티션 개수 결정 요소 처리량 요구사항 단일 파티션 처리량 = 100MB/s인 경우, 1GB/s 처리량 필요시 최소 10개 파티션 필요 동시성 레벨 컨슈머 그룹 내 병렬 처리를 위한 최대 컨슈머 수 결정 메시지 순서 동일 키의 메시지는 같은 파티션에 할당되어 순서 보장 파티션 수 산정 공식 필요 파티션 수 = MAX( 처리량 기준: (예상 최대 처리량 * (1 + 성장률)) / (단일 파티션 처리량 * 0.7), 컨슈머 기준: 목표 최대 컨슈머 수 * 2, 보관 기준: (일일 데이터량 * 보관일수 * (1 + 성장률)) / (단일 파티션 최대 크기 * 0.7) ) 성장률 예상 연간 데이터 증가율 (예: 0.3 = 30%) 단일 파티션 처리량 보통 10MB/s 단일 파티션 최대 크기 권장 25GB 0.7 안전율 (70% 활용도 기준) 파티션 수 조정 시 고려사항 파티션 수는 감소시킬 수 없음 파티션당 최소 50MB/일 데이터량 권장 브로커당 4000-6000개 파티션 제한 파티션 수와 메모리 사용량은 비례 단일 파티션 최대 크기는 리더 선출 시간에 영향을 미침 파티션 확장 전략 ```bash # 토픽의 파티션 수 증가 kafka-topics.sh –bootstrap-server localhost:9092 –alter –topic my-topic –partitions 6 # 파티션 재할당 계획 생성 cat &gt; reassign.json « EOF { “version”: 1, “partitions”: [ {“topic”: “my-topic”, “partition”: 0, “replicas”: [0,1,2]}, {“topic”: “my-topic”, “partition”: 1, “replicas”: [1,2,3]} ] } EOF # 파티션 재할당 실행 kafka-reassign-partitions.sh –bootstrap-server localhost:9092 –reassignment-json-file reassign.json –execute ``` 리밸런싱 전략 RoundRobinAssignor (권장 기본 전략) // 컨슈머 설정 props.put(\"partition.assignment.strategy\", \"org.apache.kafka.clients.consumer.RoundRobinAssignor\"); 파티션을 컨슈머에 균등하게 분배 더 나은 부하 분산 효과 확장성이 우수함 Cooperative Rebalancing (점진적 리밸런싱) // 컨슈머 설정 props.put(\"partition.assignment.strategy\", \"org.apache.kafka.clients.consumer.CooperativeStickyAssignor\"); 리밸런싱 중에도 파티션 소비 가능 서비스 중단 최소화 대규모 클러스터에 적합 StickyAssignor (특수 케이스)ㄴ // 컨슈머 설정 props.put(\"partition.assignment.strategy\", \"org.apache.kafka.clients.consumer.StickyAssignor\"); 리밸런싱 시 기존 할당 유지 최대화 불필요한 파티션 재할당 최소화 캐시 효율성 향상 커스텀 할당 전략 // 사용자 정의 파티션 할당 전략 public class CustomAssignor implements ConsumerPartitionAssignor { @Override public Map&lt;String, List&lt;TopicPartition&gt;&gt; assign(Map&lt;String, Integer&gt; partitionsPerTopic, Map&lt;String, Subscription&gt; subscriptions) { // 커스텀 로직 구현 } @Override public void onAssignment(Assignment assignment, ConsumerGroupMetadata metadata) { // 할당 후 처리 로직 } } sequenceDiagram participant C1 as Consumer1 participant C2 as Consumer2 participant C3 as Consumer3 participant GC as GroupCoordinator Note over C1,GC: 초기 상태: Consumer1,2가 파티션 분배 C3-&gt;&gt;GC: 그룹 참가 요청 GC-&gt;&gt;C1: 리밸런싱 트리거 GC-&gt;&gt;C2: 리밸런싱 트리거 GC-&gt;&gt;C3: 리밸런싱 트리거 Note over C1,GC: 리밸런싱 시작 GC-&gt;&gt;C1: 새로운 파티션 할당 GC-&gt;&gt;C2: 새로운 파티션 할당 GC-&gt;&gt;C3: 새로운 파티션 할당 Note over C1,C3: 파티션 재분배 완료 파티션 배치 전략 리더 파티션 분산 # 브로커 설정 (server.properties) # 데이터 무손실을 위한 필수 설정 min.insync.replicas=2 # 최소 동기화 복제본 수 unclean.leader.election.enable=false # 데이터 일관성 우선 # 자동 리더 재균형 설정 auto.leader.rebalance.enable=true leader.imbalance.per.broker.percentage=20 leader.imbalance.check.interval.seconds=300 리플리케이션 배치 # 랙 인식 배치 설정 broker.rack=rack1 # 브로커1의 랙 정보 # 복제본 배치 제한 replica.selector.class=org.apache.kafka.common.replica.RackAwareReplicaSelector 파티션 리더십 관리 # 선호 리더 선출 실행 kafka-leader-election.sh --bootstrap-server localhost:9092 \\ --topic my-topic \\ --partition 1 \\ --election-type PREFERRED # 리더십 상태 확인 kafka-topics.sh --bootstrap-server localhost:9092 \\ --describe --topic my-topic 고가용성을 위한 배치 규칙 브로커 간 균등 분배 랙 간 분산 배치 (단일 랙 장애 대비) 리더/팔로워 역할 분산 스케일링 방안 수직적 확장 (Scale Up) 하드웨어 리소스 증설 # 메모리 설정 # 브로커당 4GB가 표준적인 설정 heap.opts=-Xms4g -Xmx4g # JVM 힙 크기 # GC 설정 KAFKA_JVM_PERFORMANCE_OPTS=\"-server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+ExplicitGCInvokesConcurrent -XX:G1HeapRegionSize=16M\" # 디스크 설정 log.dirs=/data/kafka-logs-1,/data/kafka-logs-2 # 다중 디스크 사용 # 네트워크 설정 socket.send.buffer.bytes=10485760 # 소켓 버퍼 크기 증가 socket.receive.buffer.bytes=10485760 수평적 확장 (Scale Out) # 새 브로커 추가를 위한 단계별 프로세스 # 1. 새 브로커 설정 broker.id=4 zookeeper.connect=zk1:2181,zk2:2181,zk3:2181 # 2. 파티션 재분배 계획 생성 cat &gt; expand-cluster-reassignment.json &lt;&lt; EOF { \"version\": 1, \"partitions\": [ {\"topic\": \"my-topic\", \"partition\": 0, \"replicas\": [1,2,4]}, {\"topic\": \"my-topic\", \"partition\": 1, \"replicas\": [2,3,4]}, {\"topic\": \"my-topic\", \"partition\": 2, \"replicas\": [3,4,1]} ] } EOF # 3. 재분배 실행 및 모니터링 kafka-reassign-partitions.sh --bootstrap-server localhost:9092 \\ --reassignment-json-file expand-cluster-reassignment.json \\ --execute 클러스터 조정 전략 단계적 확장 프로세스 용량 계획 수립 현재 사용량 분석 (CPU, 메모리, 디스크, 네트워크) 예상 성장률 계산 (6-12개월) 필요 리소스 산정 (N+2 여유도 확보) 브로커 확장 준비 # 신규 브로커 설정 (server.properties) broker.id=4 zookeeper.connect=zk1:2181,zk2:2181,zk3:2181 log.dirs=/kafka/broker-4/logs listeners=PLAINTEXT://broker4:9092 # 랙 인식 설정 broker.rack=rack2 데이터 재분배 수행 # 재분배 계획 생성 cat &gt; reassign.json &lt;&lt; EOF { \"version\": 1, \"partitions\": [ {\"topic\": \"my-topic\", \"partition\": 0, \"replicas\": [1,2,4]}, {\"topic\": \"my-topic\", \"partition\": 1, \"replicas\": [2,3,4]}, {\"topic\": \"my-topic\", \"partition\": 2, \"replicas\": [3,4,1]} ] } EOF # 재분배 실행 및 모니터링 kafka-reassign-partitions.sh --bootstrap-server localhost:9092 \\ --reassignment-json-file reassign.json \\ --execute --throttle 50000000 # 50MB/s 제한 # 재분배 진행 상태 확인 kafka-reassign-partitions.sh --bootstrap-server localhost:9092 \\ --reassignment-json-file reassign.json \\ --verify 성능 모니터링 브로커 레벨 메트릭 CPU 사용률 (임계치: 85%) 메모리 사용률 (임계치: 80%) 디스크 I/O (임계치: 80MB/s) 네트워크 처리량 (임계치: 70%) 토픽 레벨 메트릭 메시지 처리량 (초당) 복제 지연(Replica Lag) ISR 크기 변화 리더/팔로워 비율 브로커 제거 절차 사전 준비 제거할 브로커의 파티션 목록 확인 데이터 마이그레이션 계획 수립 리소스 여유도 검증 데이터 마이그레이션 # 제거할 브로커의 파티션 이동 계획 cat &gt; remove-broker.json &lt;&lt; EOF { \"topics\": [ {\"topic\": \"my-topic\"} ], \"version\": 1 } EOF # 파티션 재할당 계획 생성 kafka-reassign-partitions.sh --bootstrap-server localhost:9092 \\ --generate \\ --topics-to-move-json-file remove-broker.json \\ --broker-list \"1,2,3\" 단계적 종료 # 리더십 이전 (Preferred Replica Election) kafka-preferred-replica-election.sh --bootstrap-server localhost:9092 # 브로커 상태 확인 kafka-broker-api-versions.sh --bootstrap-server localhost:9092 # 브로커 종료 전 마지막 점검 kafka-topics.sh --bootstrap-server localhost:9092 --describe 모니터링 및 경보 설정 핵심 메트릭 브로커별 파티션 분포 (불균형 20% 이상 시 경보) 리더/팔로워 비율 (리더 편중 30% 이상 시 경보) 디스크 사용률 (임계치 85% 이상 시 경보) 네트워크 처리량 (포화도 80% 이상 시 경보) 성능 메트릭 메시지 처리 지연시간 (p99 &gt; 100ms 시 경보) 복제 지연 (Lag &gt; 1000 시 경보) Under-replicated 파티션 수 (0 초과 시 경보) Active Controller 수 (1 아닐 시 경보) 메시지 압축 지원 알고리즘 비교 gzip 압축률: 매우 높음 (원본 대비 약 40% 크기) CPU 사용량: 매우 높음 (4-5배) 처리 속도: 가장 느림 메모리 사용량: 높음 장기 보관 데이터, 네트워크 대역폭 제약이 심한 환경 snappy 압축률: 중간 (원본 대비 약 60% 크기) CPU 사용량: 낮음 (1.5-2배) 처리 속도: 빠름 메모리 사용량: 낮음 일반적인 메시징, 실시간 로그 수집 lz4 압축률: 낮음 (원본 대비 약 70% 크기) CPU 사용량: 매우 낮음 (1.2-1.5배) 처리 속도: 매우 빠름 메모리 사용량: 매우 낮음 고성능 실시간 처리 필요한 경우 zstd 압축률: 높음 (원본 대비 약 45% 크기) CPU 사용량: 중간 (2-3배) 처리 속도: 중간 메모리 사용량: 중간 압축률과 성능 균형이 필요한 경우 압축 설정 // 프로듀서 압축 설정 예시 Properties props = new Properties(); // 메시지 압축 알고리즘 선택 props.put(\"compression.type\", \"snappy\"); // gzip, snappy, lz4, zstd // 압축 전 최소 메시지 크기 (바이트) // 이 크기보다 작은 메시지는 압축하지 않음 props.put(\"compression.min.bytes\", \"1024\"); // zstd 압축 레벨 설정 (1-22, 기본값: 3) // 높을수록 압축률은 높아지지만 CPU 사용량 증가 props.put(\"compression.level\", \"3\"); // 배치 크기를 증가시켜 압축 효율 향상 props.put(\"batch.size\", \"131072\"); // 128KB KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props); 브로커 압축 설정 # 브로커 압축 설정 (server.properties) # 로그 세그먼트 압축 정책 log.compression.type=producer # producer(기본값), uncompressed, lz4, snappy, gzip, zstd # 압축 관련 스레드 풀 크기 compression.threads=4 # 압축된 로그 세그먼트 최대 크기 max.compressed.log.segment.bytes=536870912 # 512MB 성능 고려사항 네트워크 대역폭 영향 압축으로 인한 전송 데이터 감소: 30-60% 네트워크 비용 절감 효과 대역폭 제한 환경에서 효과적 CPU 리소스 영향 알고리즘별 CPU 사용량 차이 gzip: 높은 CPU 사용 (전체 CPU의 15-20%) snappy: 중간 CPU 사용 (전체 CPU의 5-10%) lz4: 낮은 CPU 사용 (전체 CPU의 3-7%) 압축/해제 시 추가 CPU 사이클 필요 서버 사양에 따른 알고리즘 선택 중요 지연시간 영향 압축 시 추가되는 지연시간 gzip: 1.5-2ms snappy: 0.5-1ms lz4: 0.3-0.5ms 해제 시 추가되는 지연시간 gzip: 0.8-1ms snappy: 0.2-0.4ms lz4: 0.1-0.2ms 메모리 사용량 압축 버퍼로 인한 추가 메모리 사용 알고리즘별 메모리 사용량 차이 배치 크기에 따른 메모리 사용량 변화 메시지 보관 보관 정책 상세 시간 기반 정책 # 토픽별 보관 기간 설정 retention.ms=604800000 # 7일 retention.ms=86400000 # 1일 retention.ms=3600000 # 1시간 크기 기반 정책 # 토픽별 최대 크기 설정 retention.bytes=1073741824 # 1GB retention.bytes=5368709120 # 5GB 혼합 정책 예시 # 두 조건 중 하나라도 충족 시 삭제 retention.ms=604800000 # 7일 retention.bytes=1073741824 # 1GB 정책 유형별 특징 Delete 오래된 메시지 완전 삭제 디스크 공간 즉시 회수 단순하고 예측 가능 Compact 키별로 최신 메시지만 유지 상태 기반 처리에 적합 디스크 사용량 최적화 # 압축 정책 설정 cleanup.policy=compact # 압축 주기 설정 (밀리초) min.cleanable.dirty.ratio=0.5 delete.retention.ms=86400000 고급 보관 설정 # 세그먼트 관리 segment.bytes=1073741824 # 세그먼트 크기 segment.ms=604800000 # 세그먼트 롤링 주기 # 인덱스 관리 segment.index.bytes=10485760 # 인덱스 크기 # 정리 스케줄링 log.cleanup.interval.ms=300000 # 정리 검사 주기 모니터링 지표 브로커 핵심 메트릭 복제 관련 UnderReplicatedPartitions: 복제 지연 파티션 수 IsrShrinksPerSec: ISR 축소 빈도 IsrExpandsPerSec: ISR 확장 빈도 ReplicationBytesInPerSec: 복제 수신 바이트 요청 처리 RequestQueueSize: 요청 대기열 크기 RequestHandlerAvgIdlePercent: 핸들러 유휴율 NetworkProcessorAvgIdlePercent: 네트워크 처리 유휴율 디스크 성능 LogFlushRateAndTimeMs: 로그 플러시 지연시간 LogFlushPerSec: 초당 로그 플러시 횟수 PageCacheHitRatio: 페이지 캐시 적중률 LogDirsDiskUsagePercent: 로그 디렉토리 디스크 사용률 프로듀서 성능 메트릭 처리량 RecordSendRate: 초당 전송 레코드 수 BytesSentPerSec: 초당 전송 바이트 CompressionRateAvg: 평균 압축률 지연시간 RequestLatencyAvg: 평균 요청 지연시간 RequestLatencyMax: 최대 요청 지연시간 RecordQueueTimeAvg: 평균 대기열 시간 배치 처리 BatchSizeAvg: 평균 배치 크기 RecordPerRequestAvg: 요청당 평균 레코드 수 RecordRetries: 재시도 횟수 컨슈머 성능 메트릭 처리량 RecordsConsumedRate: 초당 소비 레코드 수 BytesConsumedRate: 초당 소비 바이트 FetchRequestRate: 초당 fetch 요청 수 지연 ConsumerLag: 컨슈머 지연(파티션별) ConsumerLagByGroup: 그룹별 컨슈머 지연 FetchLatencyAvg: 평균 fetch 지연시간 처리 성능 RecordsProcessedPerSec: 초당 처리 레코드 수 ProcessingTimeAvg: 평균 처리 시간 CommitLatencyAvg: 평균 커밋 지연시간 JVM 및 시스템 메트릭 JVM 상태 G1YoungGenerationTime: G1 Young GC 시간 G1OldGenerationTime: G1 Old GC 시간 HeapMemoryUsage: 힙 메모리 사용량 NonHeapMemoryUsage: 비힙 메모리 사용량 시스템 자원 CPUUtilization: CPU 사용률 NetworkInboundRate: 네트워크 수신률 NetworkOutboundRate: 네트워크 송신률 DiskUtilization: 디스크 사용률 알림 설정 권장값 # 브로커 알림 임계값 under_replicated_partitions.threshold=0 request_queue_size.threshold=100 page_cache_hit_ratio.min=0.8 log_flush_latency.max=500 # 컨슈머 알림 임계값 consumer_lag.max=10000 consumer_lag_minutes.max=30 fetch_latency.max=1000 # 시스템 알림 임계값 cpu_utilization.max=0.85 heap_memory_usage.max=0.8 disk_usage.max=0.85 gc_time.max=100 커밋과 오프셋 관리 커밋 로그 커밋의 의미 컨슈머가 메시지를 성공적으로 처리했음을 기록 장애 발생 시 재시작 지점으로 사용 컨슈머 그룹의 진행 상황 추적 커밋 로그 저장 __consumer_offsets 토픽에 저장 컨슈머 그룹별로 관리 주기적으로 압축되어 용량 관리 오프셋 관리 전략 자동 커밋 enable.auto.commit=true로 설정 auto.commit.interval.ms 간격으로 자동 커밋 간단하지만 중복/유실 가능성 있음 수동 커밋 commitSync(): 동기식 커밋 안전하지만 성능 저하 가능성 commitAsync(): 비동기식 커밋 성능은 좋지만 실패 시 재시도 없음 // 자동 커밋 설정 Properties autoCommitProps = new Properties(); autoCommitProps.put(\"enable.auto.commit\", \"true\"); autoCommitProps.put(\"auto.commit.interval.ms\", \"5000\"); // 수동 커밋 예시 Properties manualCommitProps = new Properties(); manualCommitProps.put(\"enable.auto.commit\", \"false\"); KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(manualCommitProps); // 동기식 커밋 try { ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(100)); processRecords(records); // 레코드 처리 consumer.commitSync(); // 동기식 커밋 } catch (Exception e) { // 에러 처리 } // 비동기식 커밋 consumer.commitAsync((offsets, exception) -&gt; { if (exception != null) { System.err.println(\"Commit failed for offsets: \" + offsets); } }); 처리 시맨틱 at-most-once: 메시지 유실 가능성, 자동 커밋 사용 시 해당 at-least-once: 중복 처리 가능성, 수동 커밋 사용 시 일반적인 방식 exactly-once: 정확히 한 번 처리 보장 트랜잭션과 멱등성 프로듀를 함께 사용하여 달성하는 엔드투엔드 처리 보장 방식 오프셋 리셋 auto.offset.reset 설정 earliest: 가장 오래된 오프셋부터 시작 latest: 최신 오프셋부터 시작 none: 저장된 오프셋이 없으면 에러 수동 리셋 특정 시점으로 오프셋 이동 데이터 재처리 필요 시 사용 신중한 사용 필요 Reference Apache Kafka 공식 문서 Kafka 디자인 문서 Kafka 프로토콜 가이드" }, { "title": "Jekyll 블로그 Utterances 댓글 시스템 추가", "url": "/posts/jekyll-blog-comments-utterances/", "categories": "Blog", "tags": "jekyll, utterances", "date": "2025-10-11 19:00:00 +0900", "snippet": "개요 Jekyll 블로그에 Utterances 댓글 시스템을 추가하는 방법을 설명함Utterances란특징 GitHub Issues 기반 댓글 시스템 무료 오픈소스 광고 없음 가벼운 용량 마크다운 지원 GitHub 로그인 필요장점 설정이 간단함 GitHub Issues로 댓글 관리 용이 개발자 친화적 스팸 방지 다크 모드 지원단점 GitHub 계정이 필요함 일반 사용자에게는 진입장벽 존재 GitHub Issues를 댓글용으로 사용사전 준비사항필수 요소 GitHub 계정 Jekyll 블로그 GitHub Pages 배포 완료 Public Repository Repository 설정 확인 Repository가 Public인지 확인 Private Repository는 Utterances 사용 불가 GitHub Issues 활성화 확인 Repository &gt; Settings &gt; Features Issues 체크박스 확인 설정 방법1단계: _config.yml 파일 수정 블로그 루트 디렉토리에서 _config.yml 파일 열기 comments 섹션 찾기 90번째 줄 근처에 위치 Utterances 설정 입력 comments: active: utterances utterances: repo: username/repository-name issue_term: pathname username/repository-name을 본인의 Repository 정보로 변경 예시: mxxikr/mxxikr.github.io 파일 저장2단계: Utterances App 설치 Utterances GitHub App 접속 Install 또는 Configure 버튼 클릭 Repository 선택 Only select repositories 선택 본인의 블로그 Repository 선택 Install 또는 Save 버튼 클릭 설치 완료 Utterances가 Repository에 접근 권한 획득 Issues 읽기/쓰기 권한 부여됨 3단계: 변경사항 배포 변경사항 추가 git add _config.yml 커밋 git commit -m \"Add Utterances comments\" GitHub에 푸시 git push origin master GitHub Actions에서 빌드 확인 Repository &gt; Actions 탭에서 빌드 진행 상태 확인 빌드 완료 대기 4단계: 댓글 기능 확인 블로그에 접속하여 아무 포스트 열기 포스트 하단에 댓글 영역 확인 “Sign in with GitHub” 버튼이 보이면 성공 테스트 댓글 작성 GitHub 로그인 댓글 작성 Submit 버튼 클릭 Repository의 Issues 탭 확인 새로운 Issue가 자동 생성됨 Issue 제목이 포스트 경로로 표시됨 댓글 관리 Repository &gt; Issues 탭에서 댓글 관리 댓글별로 Issue 생성됨 Issue에서 직접 댓글 확인 및 답글 가능 댓글 삭제 방법 GitHub Issues에서 해당 댓글 삭제 또는 Issue 전체 닫기 스팸 차단 GitHub 계정이 필요하므로 스팸이 적음 필요시 Issue를 Lock하여 댓글 차단 트러블슈팅댓글 영역이 표시되지 않음 _config.yml의 active: utterances 확인 Repository가 Public인지 확인 GitHub Actions 빌드 성공 확인 브라우저 캐시 삭제 후 재확인Utterances App 권한 오류 Error: utterances is not installed on username/repository 메시지가 나타나는 경우 Utterances GitHub App 재설치 Repository 선택 확인Repository 이름 오류 _config.yml의 repo 값이 정확한지 확인 대소문자 구분 오타 확인 형식: username/repository-namePrivate Repository 문제 Utterances는 Public Repository만 지원 Settings &gt; General &gt; Danger Zone &gt; Change visibility &gt; Make publicUtterances vs 다른 댓글 시스템Utterances vs Giscus Utterances GitHub Issues 사용 간단한 설정 기본 기능 Giscus GitHub Discussions 사용 더 많은 기능 (반응, 답글 트리) 설정이 조금 복잡 Utterances vs Disqus Utterances 무료 오픈소스 광고 없음 GitHub 계정 필요 Disqus 광고 있음 (무료 플랜) 소셜 로그인 지원 더 많은 사용자 접근 가능 댓글 알림 설정 GitHub 알림 설정 방법 Settings &gt; Notifications Issues 알림 활성화 새 댓글 작성 시 이메일로 알림 수신 Reference Utterances 공식 사이트 Utterances GitHub Repository Jekyll 공식 문서 GitHub Issues API" }, { "title": "Jekyll 블로그 Google Analytics 연동", "url": "/posts/google-analytics-jekyll-integration/", "categories": "Blog", "tags": "google analytics, jekyll", "date": "2025-10-11 19:00:00 +0900", "snippet": "개요 Jekyll 블로그에 Google Analytics를 연동하여 방문자 통계를 추적하는 방법을 설명함Google Analytics란 Google Analytics 기능 웹사이트 방문자 수 추적 방문자 행동 분석 트래픽 소스 파악 실시간 방문자 모니터링 사전 준비사항필수 요소 Google 계정 Gmail 계정 또는 Google Workspace 계정 무료로 사용 가능 Jekyll 블로그 GitHub Pages 또는 다른 호스팅에 배포된 블로그 블로그 URL 필요 Google Analytics 계정 생성Google Analytics 접속 Google Analytics 접속 Google 계정으로 로그인계정 만들기 측정 시작 버튼 클릭 계정 이름 입력 예: My Blog Analytics 계정 데이터 공유 설정 필요에 따라 선택 기본 설정 유지 가능 속성 만들기 속성 이름 입력 예: mxxikr.github.io 보고 시간대 선택 한국: (GMT+09:00) 서울 통화 선택 KRW - 대한민국 원 비즈니스 정보 입력 업종 카테고리 선택 기술 또는 적절한 카테고리 비즈니스 규모 선택 소규모 또는 해당 규모 사용 목적 선택 필요에 따라 선택 데이터 스트림 설정 플랫폼 선택 웹 선택 웹사이트 URL 입력 https://username.github.io 스트림 이름 입력 블로그 이름 향상된 측정 설정 기본 설정 유지 가능 스트림 만들기 클릭측정 ID 확인 데이터 스트림 세부정보에서 측정 ID 확인 형식: G-XXXXXXXXXX 이 ID를 블로그에 설정할 예정 Jekyll 블로그에 Google Analytics 연동Chirpy 테마 사용 시 _config.yml 파일 열기 Google Analytics 설정 찾기 google_analytics: id: G-XXXXXXXXXX 측정 ID 입력 google_analytics: id: G-ABC1234567 파일 저장다른 테마 사용 시 _config.yml 파일 확인 Google Analytics 설정 섹션 찾기 테마마다 설정 방법이 다를 수 있음 설정이 없는 경우 _config.yml에 추가 google_analytics: G-XXXXXXXXXX HTML에 직접 추가하는 경우 _includes/head.html 또는 _layouts/default.html 파일 열기 &lt;/head&gt; 태그 바로 위에 추가 &lt;!-- Google tag (gtag.js) --&gt;&lt;script async src=\"https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX\"&gt;&lt;/script&gt;&lt;script&gt; window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-XXXXXXXXXX');&lt;/script&gt; 로컬에서 테스트 제외 _config.yml 설정 google_analytics: id: G-XXXXXXXXXX pv: proxy_endpoint: cache_path: 개발 환경에서 추적 비활성화 Jekyll 4.0 이상 google_analytics: id: G-XXXXXXXXXX # 개발 환경environment: development 변경사항 배포Git 커밋 및 푸시 변경사항 추가 git add _config.yml 커밋 git commit -m \"Add Google Analytics\" GitHub에 푸시 git push origin main 배포 대기 GitHub Actions에서 빌드 확인 배포 완료 대기 블로그 접속하여 확인Google Analytics 동작 확인실시간 보고서 확인 Google Analytics 콘솔 접속 왼쪽 메뉴에서 보고서 클릭 실시간 선택 현재 활성 사용자 확인테스트 방법 블로그 접속 본인의 블로그 URL 접속 Google Analytics 콘솔 확인 실시간 보고서에서 방문자 1명 표시 확인 다른 페이지 이동 페이지뷰 증가 확인 데이터 수집 확인 데이터 수집까지 시간 소요 실시간 보고서: 즉시 일반 보고서: 24-48시간 처음 설치 시 데이터 누적 필요주요 보고서 활용실시간 보고서 현재 방문자 수 실시간 접속자 확인 페이지뷰 현재 조회 중인 페이지 트래픽 소스 방문 경로 확인 사용자 보고서 사용자 속성 국가, 도시 브라우저, OS 기기 카테고리 신규 방문자 vs 재방문자트래픽 획득 보고서 트래픽 소스 Organic Search (검색엔진) Direct (직접 방문) Referral (다른 사이트) Social (소셜 미디어) 참여도 보고서 페이지뷰 가장 많이 조회된 페이지 평균 참여 시간 이벤트 수트러블슈팅데이터가 수집되지 않음 문제 상황 실시간 보고서에 데이터 없음 방문했지만 카운트 안 됨 확인 사항 측정 ID 정확한지 확인 G-XXXXXXXXXX 형식 _config.yml 저장 확인 GitHub에 푸시 확인 배포 완료 확인 브라우저 캐시 삭제 후 재접속 개발자 도구로 확인 브라우저 F12 키 Network 탭 google-analytics.com 또는 googletagmanager.com 요청 확인 로컬에서도 추적됨 문제 상황 localhost:4000 접속 시에도 카운트됨 해결 방법 _config.yml에 환경 변수 추가 # 프로덕션에서만 활성화google_analytics: id: G-XXXXXXXXXX Jekyll serve 시 추적 비활성화 JEKYLL_ENV=development bundle exec jekyll serve 측정 ID를 찾을 수 없음 문제 상황 Google Analytics에서 측정 ID가 보이지 않음 해결 방법 Google Analytics 콘솔 접속 관리 클릭 속성 선택 데이터 스트림 클릭 해당 웹 스트림 클릭 측정 ID 확인 이전 UA 코드 사용 중 문제 상황 UA-XXXXXXXXX 형식의 ID 사용 중 Universal Analytics 중단됨 해결 방법 Google Analytics 4 (GA4)로 전환 필요 새로운 GA4 속성 만들기 측정 ID (G-XXXXXXXXXX) 사용 개인정보 보호 고려사항Cookie 동의 쿠키 사용 안내 개인정보 처리방침에 명시 쿠키 사용 동의 배너 고려 IP 익명화 Google Analytics 설정 기본적으로 IP 익명화 적용 GA4는 자동으로 처리 데이터 보관 Google Analytics 설정 관리 &gt; 데이터 설정 &gt; 데이터 보관 기본: 14개월 필요시 조정 가능 추가 설정이벤트 추적 커스텀 이벤트 설정 버튼 클릭 다운로드 외부 링크 클릭 이벤트 코드 추가 예시 &lt;button onclick=\"gtag('event', 'button_click', { 'event_category': 'engagement', 'event_label': 'download_button'});\"&gt; 다운로드&lt;/button&gt; 전환 설정 목표 설정 특정 페이지 방문 특정 이벤트 발생 Google Analytics에서 설정 관리 &gt; 전환 새 전환 이벤트 만들기 Search Console 연결 Google Search Console 연동 Search Console 설정 속성 추가 및 소유권 확인 Google Analytics와 연결 검색 성능 데이터 확인 가능유용한 기능맞춤 보고서 맞춤 보고서 만들기 탐색 &gt; 맞춤 탐색 원하는 측정기준, 측정항목 선택 보고서 저장 알림 설정 맞춤 알림 방문자 급증 시 알림 특정 조건 충족 시 알림 관리 &gt; 맞춤 알림에서 설정대시보드 공유 보고서 공유 보고서 스냅샷 공유 이메일로 정기 보고서 전송 사용자 추가 관리 &gt; 속성 액세스 관리 다른 사용자 초대 가능 명령어 정리Jekyll 로컬 테스트# 개발 환경으로 실행 (GA 비활성화)JEKYLL_ENV=development bundle exec jekyll serve# 프로덕션 환경으로 테스트JEKYLL_ENV=production bundle exec jekyll serveGit 배포# 변경사항 확인git status# 파일 추가git add _config.yml# 커밋git commit -m \"Add Google Analytics\"# 푸시git push origin mainReference Google Analytics 공식 문서 Google Analytics 4 시작하기 Jekyll 공식 문서 GitHub Pages 문서 Google Tag Manager" }, { "title": "Jekyll 블로그 설치 및 로컬 실행 가이드", "url": "/posts/jekyll-blog-installation-guide/", "categories": "Blog", "tags": "jekyll, git blog", "date": "2025-10-11 18:50:00 +0900", "snippet": "개요 Jekyll 기반 GitHub Pages 블로그를 처음부터 설치하고 로컬에서 실행하는 과정을 설명함사전 준비사항필수 도구 확인 블로그 구축에 필요한 도구들 Git 버전 관리 시스템 GitHub Pages 배포에 필수 Ruby Jekyll이 동작하는 런타임 환경 버전 2.5 이상 권장 RubyGems Ruby 패키지 관리자 Ruby 설치 시 함께 설치됨 Bundler Ruby 의존성 관리 도구 Jekyll 프로젝트 관리에 필수 운영체제별 도구 설치Windows Ruby 설치 RubyInstaller 다운로드 RubyInstaller 공식 사이트 접속 Ruby+Devkit 최신 버전 다운로드 설치 과정 다운로드한 설치 파일 실행 “Add Ruby executables to your PATH” 옵션 체크 MSYS2 설치 단계에서 모든 옵션 선택 (1, 2, 3) 설치 확인 ruby -vgem -v Git 설치 Git for Windows 다운로드 Git 공식 사이트 접속 최신 버전 다운로드 설치 과정 기본 설정으로 설치 진행 설치 확인 git --version Bundler 설치 gem install bundler # 설치 확인bundle -v macOS Homebrew 설치 터미널에서 실행 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 설치 확인 brew --version Ruby 설치 rbenv를 통한 Ruby 설치 # rbenv 설치brew install rbenv ruby-build # rbenv 초기화rbenv init # .zshrc 또는 .bash_profile에 추가echo 'eval \"$(rbenv init - zsh)\"' &gt;&gt; ~/.zshrcsource ~/.zshrc # 설치 가능한 Ruby 버전 확인rbenv install -l # Ruby 설치 (최신 안정 버전)rbenv install 3.2.2rbenv global 3.2.2 # 설치 확인ruby -v Git 설치 # Git 설치brew install git # 설치 확인git --version Bundler 설치 gem install bundler # 설치 확인bundle -v Jekyll 테마 선택 및 설치테마 찾기 Jekyll 테마 사이트 Jekyll Themes 무료 Jekyll 테마 모음 카테고리별 분류 미리보기 제공 Jekyll Themes.io 무료/유료 테마 제공 인기순, 최신순 정렬 상세한 테마 설명 JamStack Themes - Jekyll JamStack 기반 테마 모음 Jekyll 테마 필터링 GitHub 스타 수 표시 GitHub Jekyll Theme 토픽 GitHub에서 직접 검색 최신 업데이트 확인 용이 이슈, PR 활동 확인 가능 인기 Jekyll 테마 소개 Chirpy 깔끔한 디자인의 블로그 테마 다크 모드 지원 카테고리, 태그, 검색 기능 내장 GitHub Repository Minimal Mistakes 가장 많이 사용되는 테마 중 하나 반응형 디자인 다양한 레이아웃 옵션 GitHub Repository Beautiful Jekyll 초보자 친화적인 테마 간단한 설정 빠른 시작 가능 GitHub Repository TeXt Theme 문서화 친화적 테마 다국어 지원 커스터마이징 용이 GitHub Repository Basically Basic 미니멀한 디자인 빠른 로딩 속도 접근성 중심 설계 GitHub Repository GitHub에서 테마 가져오기 방법 1, 2 중 선택 Fork 하기 GitHub에서 테마 Repository 접속 예시: Chirpy 테마 Jekyll Theme Chirpy 접속 Fork 버튼 클릭 Repository name을 username.github.io 형식으로 변경 username은 자신의 GitHub 사용자명 생성된 Repository 확인 로컬로 Clone # 원하는 디렉토리로 이동 cd ~/Documents # Repository Clone git clone https://github.com/username/username.github.io.git # 프로젝트 디렉토리로 이동 cd username.github.io Template 사용하기 GitHub에서 “Use this template” 버튼 클릭 Repository name 입력 username.github.io 형식 권장 Public으로 설정 GitHub Pages는 Public Repository에서만 무료 “Create repository from template” 클릭 생성된 Repository Clone git clone https://github.com/username/username.github.io.git cd username.github.io Jekyll 블로그 설정의존성 설치 Gemfile 확인 프로젝트 루트에 있는 Gemfile 열기 테마에서 제공하는 기본 Gemfile 사용 필요한 gem 패키지 목록 예시 source \"https://rubygems.org\" gem \"jekyll\"gem \"jekyll-theme-chirpy\" # Windows and JRuby does not include zoneinfo filesinstall_if -&gt; { RUBY_PLATFORM =~ %r!mingw|mswin|java! } do gem \"tzinfo\" gem \"tzinfo-data\"end # Performance-booster for watching directories on Windowsgem \"wdm\", :install_if =&gt; Gem.win_platform? # Jekyll compatibility with Ruby 3.0gem \"webrick\" Bundle 설치 실행 # 의존성 설치bundle install 설치 확인 # Jekyll 버전 확인bundle exec jekyll -v 블로그 기본 설정 _config.yml 파일 수정 기본 정보 설정 # 사이트 제목title: # 사이트 설명tagline: # 사이트 URLurl: \"https://username.github.io\" # GitHub 사용자명github: username: username # 소셜 정보social: name: Your Name email: your.email@example.com links: - https://github.com/username - https://twitter.com/username # 타임존 설정timezone: Asia/Seoul # 언어 설정lang: ko-KR 테마 설정 # 테마 모드theme_mode: dual # [light | dark | dual] # 아바타 이미지avatar: /assets/img/profile.jpg # TOC (Table of Contents) 설정toc: true # 댓글 시스템 설정comments: active: giscus # [disqus | utterances | giscus] # Giscus 설정 giscus: repo: username/username.github.io repo_id: YOUR_REPO_ID category: Comments category_id: YOUR_CATEGORY_ID # Google Analyticsgoogle_analytics: id: G-XXXXXXXXXX 프로필 이미지 추가 이미지 파일 준비 정사각형 이미지 권장 추천 크기: 512x512px 파일 형식 PNG, JPG 지원 파일 배치 assets/img 디렉토리에 이미지 파일 복사 _config.yml의 avatar 경로와 일치하도록 저장 로컬에서 블로그 실행하기Jekyll 개발 서버 시작 기본 실행 방법 # 프로젝트 디렉토리에서 실행bundle exec jekyll serve 자동 새로고침 옵션 # LiveReload 기능 활성화bundle exec jekyll serve --livereload # 브라우저에서 파일 수정 시 자동 새로고침됨 포트 변경 # 다른 포트로 실행 (기본: 4000)bundle exec jekyll serve --port 4001 빌드 캐시 초기화 # 기존 빌드 파일 삭제 후 실행bundle exec jekyll cleanbundle exec jekyll serve 브라우저에서 확인 로컬 서버 접속 주소창에 입력 http://localhost:4000 http://127.0.0.1:4000 블로그 메인 페이지 확인 메뉴 및 기능 테스트 변경사항 실시간 확인 파일 수정 후 저장 LiveReload 사용 시 자동 새로고침 수동 새로고침 필요 시 Windows: Ctrl + R 또는 F5 Mac: Cmd + R 브라우저 캐시 강제 새로고침 Windows: Ctrl + Shift + R Mac: Cmd + Shift + R 첫 번째 포스트 작성하기포스트 파일 생성 파일 이름 규칙 형식 YYYY-MM-DD-title.md 예시 2025-10-11-my-first-post.md 위치 _posts 디렉토리에 생성 포스트 파일 생성 _posts 디렉토리에 새 파일 생성 파일명: 2025-10-11-my-first-post.md 텍스트 편집기로 열기 VSCode, 메모장 등 사용 Front Matter 작성 기본 구조```yaml—title: “첫 번째 포스트”author: name: Your Name link: https://github.com/usernamedate: 2025-10-11 14:00:00 +0900category: [Blog]tags: [first post, jekyll, blog] ``` 주요 옵션 설명 title 포스트 제목 따옴표로 감싸기 권장 date 작성 날짜와 시간 타임존 포함 category 카테고리 분류 배열 형식으로 작성 대분류, 소분류 지원 tags 태그 목록 배열 형식으로 작성 pin 메인 페이지에 고정 true/false math 수학 수식 렌더링 활성화 true/false mermaid 다이어그램 렌더링 활성화 true/false 본문 작성 Markdown 기본 문법 # 제목 1## 제목 2### 제목 3 - 일반 텍스트 작성 - 들여쓰기를 통한 계층 구조 이미지 삽입 이미지 추가 방법 이미지 파일을 assets/img 폴더에 저장 Markdown에서 참조 ![이미지 설명](/assets/img/sample-image.jpg) 코드 블록 코드 작성 예시 def hello_world(): print(\"Hello, Jekyll!\") 링크 추가 외부 링크 Jekyll 공식 문서 GitHub Pages에 배포하기Git 설정 Git 사용자 정보 설정 # 전역 설정git config --global user.name \"Your Name\"git config --global user.email \"your.email@example.com\" # 설정 확인git config --list Git 저장소 확인 # 이미 Clone한 경우 이 단계는 건너뜀# Git 상태 확인git status 변경사항 커밋 작성한 포스트 추가 # 새 파일 추가git add _posts/2025-10-11-my-first-post.md # 또는 모든 변경사항 추가git add . # 상태 확인git status # 커밋git commit -m \"첫 번째 포스트 작성\" 설정 파일 변경사항 커밋 # 설정 파일 추가git add _config.yml # 커밋git commit -m \"블로그 기본 설정 완료\" GitHub에 푸시 원격 저장소 확인 # 원격 저장소 목록 확인git remote -v 변경사항 푸시 # main 브랜치에 푸시git push origin main # 또는 master 브랜치인 경우git push origin master GitHub Pages 설정 확인 GitHub Repository 설정 GitHub에서 Repository 접속 Settings 메뉴 클릭 Pages 섹션으로 이동 Source 설정 확인 Branch: main (또는 master) Folder: / (root) Save 버튼 클릭 배포 상태 확인 Actions 탭에서 빌드 진행 상황 확인 녹색 체크 표시가 나타나면 배포 완료 배포된 사이트 접속 브라우저에서 접속 https://username.github.io 포스트 확인 기능 테스트 주요 디렉토리 구조 이해하기Jekyll 프로젝트 구조username.github.io/├── _config.yml # 사이트 전역 설정├── _posts/ # 블로그 포스트│ └── YYYY-MM-DD-title.md├── _layouts/ # 레이아웃 템플릿│ ├── default.html│ └── post.html├── _includes/ # 재사용 가능한 컴포넌트│ ├── header.html│ └── footer.html├── _sass/ # SASS 스타일시트│ └── main.scss├── assets/ # 정적 파일│ ├── css/│ ├── js/│ └── img/├── _site/ # 생성된 사이트 (Git 무시)├── .gitignore # Git 무시 파일 목록├── Gemfile # Ruby 의존성 정의├── Gemfile.lock # 의존성 버전 고정└── index.html # 메인 페이지중요 디렉토리 설명 _posts 역할 블로그 포스트 저장 위치 파일 규칙 YYYY-MM-DD-title.md 형식 주의사항 날짜가 미래인 포스트는 표시되지 않음 –future 옵션으로 확인 가능 assets 역할 이미지, CSS, JavaScript 등 정적 파일 구조 img: 이미지 파일 css: 스타일시트 js: JavaScript 파일 참조 방법 Markdown: /assets/img/image.jpg HTML: /assets/img/image.jpg _site 역할 Jekyll이 생성한 정적 사이트 특징 빌드할 때마다 자동 생성 Git에 커밋하지 않음 주의사항 직접 수정하지 말 것 수정 사항은 소스 파일에서 테마 커스터마이징스타일 수정 SCSS 파일 위치 _sass 디렉토리 assets/css 디렉토리 커스텀 스타일 추가 _sass 디렉토리에 custom.scss 파일 생성 색상 변경 예시 // _sass/custom.scss // 메인 컬러 변경$primary-color: #007bff;$secondary-color: #6c757d; // 다크 모드 배경색$dark-bg: #1a1a1a; // 링크 색상a { color: $primary-color; &amp;:hover { color: darken($primary-color, 10%); }} 레이아웃 수정 레이아웃 파일 확인 _layouts 디렉토리 default.html 기본 레이아웃 post.html 포스트 레이아웃 page.html 페이지 레이아웃 커스텀 레이아웃 생성```html—layout: default— Jekyll 블로그 설치 및 로컬 실행 가이드 &lt;!DOCTYPE html&gt; Jekyll 블로그 이미지 자동 최적화 | MXXI.kr MXXI.kr Backend Developer HOME CATEGORIES TAGS ARCHIVES ABOUT Home Jekyll 블로그 이미지 자동 최적화 Post Cancel Jekyll 블로그 이미지 자동 최적화 Posted Oct 8, 2025 Updated Oct 12, 2025 By mxxikr read 15 min 개요&lt;/h2&gt; Jekyll 기반 블로그에서 이미지 자동 최적화 시스템을 구축하여 웹 성능을 개선한 과정을 소개함문제 상황 분석&lt;/h2&gt;초기 성능 문제&lt;/h3&gt; 기술 블로그에서 측정된 성능 지표 이미지 용량 149MB 페이지 로딩 시간 3-5초 (이미지 중심 페이지) 이미지 파일 수 1,000개 이상 이미지 현황 파악&lt;/h3&gt; # 이미지 디렉토리 용량 분석du -sh assets/img# 결과: 149M\tassets/img# 이미지 파일 개수 확인find assets/img -type f \\( -name \"*.png\" -o -name \"*.jpg\" -o -name \"*.jpeg\" \\) | wc -l# 결과: 1,000개 이상의 이미지 파일 이미지 파일 특성 파일 형식 PNG, JPEG 압축 상태 압축되지 않은 원본 파일 파일 수 1,000개 이상의 이미지 파일 Core Web Vitals 측정&lt;/h3&gt; Core Web Vitals 지표 Google이 정의한 웹사이트 사용자 경험을 측정하는 핵심 지표 측정 방법 측정 도구 Chrome DevTools, Lighthouse 측정 환경 로컬 Jekyll 서버 (localhost:4000) # Lighthouse CLI를 사용한 성능 측정 npm install -g lighthouse lighthouse http://localhost:4000 --output=json --output-path=./lighthouse-report.json 측정된 Core Web Vitals 지표 LCP (Largest Contentful Paint): 3.2초 페이지의 가장 큰 콘텐츠 요소가 화면에 렌더링되는 시간 좋은 점수: 2.5초 이하, 개선 필요: 4.0초 초과 이미지가 가장 큰 콘텐츠인 경우 로딩 시간에 직접 영향 CLS (Cumulative Layout Shift): 0.15 페이지 로딩 중 예상치 못한 레이아웃 변화의 정도 좋은 점수: 0.1 이하, 개선 필요: 0.25 초과 이미지 로딩 시 크기 변화로 인한 레이아웃 시프트 발생 FID (First Input Delay): 180ms 사용자가 페이지와 처음 상호작용할 때의 응답 시간 좋은 점수: 100ms 이하, 개선 필요: 300ms 초과 대용량 이미지 로딩으로 인한 메인 스레드 블로킹 영향 자동화 시스템 구성&lt;/h2&gt;이미지 최적화 도구 설치&lt;/h3&gt; # 이미지 최적화 도구 설치brew install pngquant jpegoptim# 설치 확인which pngquant &amp;&amp; which jpegoptim자동 최적화 스크립트 생성&lt;/h3&gt; 파일 생성 위치 프로젝트 루트 디렉토리에 auto-optimize-images.js 파일 생성 실행 권한 부여 chmod +x auto-optimize-images.js auto-optimize-images.js #!/usr/bin/env node const fs = require('fs'); const path = require('path'); const { execSync } = require('child_process'); // 설정 const IMG_DIR = 'assets/img'; const QUALITY = 85; const SKIP_FAVICONS = true; // 이미지 최적화 함수 function optimizeImage(filePath) { const ext = path.extname(filePath).toLowerCase(); try { if (ext === '.png') { execSync(`pngquant --force --ext .png --quality=65-${QUALITY} \"${filePath}\"`, { stdio: 'ignore' }); } else if (ext === '.jpg' || ext === '.jpeg') { execSync(`jpegoptim --max=${QUALITY} --strip-all \"${filePath}\"`, { stdio: 'ignore' }); } return true; } catch (error) { return false; } } // 새로 추가된 이미지 파일 찾기 function getNewImages() { try { const addedFiles = execSync('git diff --cached --name-status', { encoding: 'utf8' }); const newImages = []; const lines = addedFiles.split('\\n'); lines.forEach(line =&gt; { if (line.startsWith('A\\t') &amp;&amp; line.includes(IMG_DIR)) { const filePath = line.substring(2); const ext = path.extname(filePath).toLowerCase(); if (['.png', '.jpg', '.jpeg'].includes(ext)) { if (!SKIP_FAVICONS || !filePath.includes('favicon')) { newImages.push(filePath); } } } }); return newImages; } catch (error) { return []; } } // 메인 실행 function main() { console.log('이미지 자동 최적화 시작...'); const newImages = getNewImages(); if (newImages.length === 0) { console.log('최적화할 새 이미지가 없습니다.'); return; } console.log(`${newImages.length}개의 새 이미지를 발견했습니다.`); let optimized = 0; let failed = 0; newImages.forEach(imagePath =&gt; { console.log(`최적화 중: ${imagePath}`); if (optimizeImage(imagePath)) { optimized++; console.log(`완료: ${imagePath}`); } else { failed++; console.log(`실패: ${imagePath}`); } }); console.log(`최적화 완료: ${optimized}개 성공, ${failed}개 실패`); if (optimized &gt; 0) { console.log('최적화된 파일들을 Git에 다시 추가합니다...'); try { execSync(`git add ${newImages.join(' ')}`, { stdio: 'ignore' }); console.log('Git에 추가 완료!'); } catch (error) { console.log('Git 추가 실패:', error.message); } } } main(); Git 훅 설정&lt;/h3&gt; 파일 생성 위치 .git/hooks/pre-commit 파일 생성 실행 권한 부여 chmod +x .git/hooks/pre-commit pre-commit 훅 #!/bin/bash # 자동 이미지 최적화 Git 훅 echo \"이미지 최적화를 확인합니다...\" # Node.js가 설치되어 있는지 확인 if ! command -v node &amp;&gt; /dev/null; then echo \"Node.js가 설치되어 있지 않습니다. 이미지 최적화를 건너뜁니다.\" exit 0 fi # 이미지 최적화 도구가 설치되어 있는지 확인 if ! command -v pngquant &amp;&gt; /dev/null || ! command -v jpegoptim &amp;&gt; /dev/null; then echo \"이미지 최적화 도구가 설치되어 있지 않습니다.\" echo \"다음 명령어로 설치하세요: brew install pngquant jpegoptim\" exit 0 fi # 자동 최적화 스크립트 실행 node auto-optimize-images.js echo \"이미지 최적화 완료!\" 실시간 파일 감시 스크립트&lt;/h3&gt; 파일 생성 위치 프로젝트 루트 디렉토리에 watch-images.js 파일 생성 실행 권한 부여 chmod +x watch-images.js watch-images.js #!/usr/bin/env node const fs = require('fs'); const path = require('path'); const { execSync } = require('child_process'); // 설정 const IMG_DIR = 'assets/img'; const QUALITY = 85; // 이미지 최적화 함수 function optimizeImage(filePath) { const ext = path.extname(filePath).toLowerCase(); try { if (ext === '.png') { execSync(`pngquant --force --ext .png --quality=65-${QUALITY} \"${filePath}\"`, { stdio: 'ignore' }); } else if (ext === '.jpg' || ext === '.jpeg') { execSync(`jpegoptim --max=${QUALITY} --strip-all \"${filePath}\"`, { stdio: 'ignore' }); } return true; } catch (error) { return false; } } // 파일 감시 시작 function startWatching() { console.log('이미지 파일 감시를 시작합니다...'); console.log('감시 디렉토리:', IMG_DIR); console.log('품질 설정:', QUALITY + '%'); console.log('종료하려면 Ctrl+C를 누르세요\\n'); fs.watch(IMG_DIR, { recursive: true }, (eventType, filename) =&gt; { if (eventType === 'rename' &amp;&amp; filename) { const filePath = path.join(IMG_DIR, filename); const ext = path.extname(filename).toLowerCase(); if (['.png', '.jpg', '.jpeg'].includes(ext)) { setTimeout(() =&gt; { if (fs.existsSync(filePath)) { console.log(`새 이미지 발견: ${filename}`); if (optimizeImage(filePath)) { console.log(`최적화 완료: ${filename}`); } else { console.log(`최적화 실패: ${filename}`); } } }, 1000); } } }); } startWatching(); 사용 방법&lt;/h2&gt;Git 훅 방식&lt;/h3&gt; # 이미지 추가 후 커밋하면 자동으로 최적화됨git add assets/img/new-image.pnggit commit -m \"새 이미지 추가\"# 자동으로 최적화 후 커밋됨수동 실행&lt;/h3&gt; # 새로 추가된 이미지만 최적화npm run auto-optimize실시간 감시&lt;/h3&gt; # 터미널에서 실행하면 이미지 추가 시 실시간 최적화npm run watch-imagespackage.json 설정&lt;/h3&gt; 파일 생성 위치 프로젝트 루트 디렉토리의 package.json 파일에 scripts 섹션 추가 기존 scripts 섹션이 있다면 해당 내용을 추가 package.json { \"scripts\": { \"build\": \"gulp build\", \"dev\": \"gulp dev\", \"optimize-images\": \"node optimize-images-safe.js\", \"auto-optimize\": \"node auto-optimize-images.js\", \"watch-images\": \"node watch-images.js\", \"test\": \"echo 'Testing blog functionality...'\" } } 성능 최적화 결과&lt;/h2&gt;최적화 전후 비교&lt;/h3&gt; 용량 최적화 결과 # 최적화 전 du -sh assets/img # 결과: 149M\tassets/img # 최적화 후 du -sh assets/img # 결과: 45M\tassets/img 페이지 로딩 시간 개선 (Chrome DevTools 기준) 페이지 유형 최적화 전 최적화 후 개선율 이미지 중심 포스트 3-5초 1-2초 60-70% 일반 포스트 2-3초 0.8-1.5초 50-60% 메인 페이지 4-6초 1.5-2.5초 60-70% Core Web Vitals 개선 효과&lt;/h3&gt; Lighthouse 성능 점수 최적화 전 Performance: 65-70점 LCP: 3.2초 CLS: 0.15 FID: 180ms 최적화 후 Performance: 85-90점 LCP: 1.8초 (44% 개선) CLS: 0.05 (67% 개선) FID: 95ms (47% 개선) 최적화 결과 요약&lt;/h2&gt;핵심 성과&lt;/h3&gt; 항목 최적화 전 최적화 후 개선율 이미지 용량 149MB 45MB 70% 감소 페이지 로딩 시간 3-5초 1-2초 60-70% 단축 Lighthouse 점수 65-70점 85-90점 20-25점 향상 LCP 3.2초 1.8초 44% 개선 CLS 0.15 0.05 67% 개선 FID 180ms 95ms 47% 개선 적용된 기술&lt;/h3&gt; 이미지 압축 pngquant, jpegoptim 자동화 Git pre-commit 훅 모니터링 Lighthouse, Chrome DevTools 스크립트 Node.js 기반 최적화 도구 트러블슈팅&lt;/h2&gt;자주 발생하는 문제와 해결 방법&lt;/h3&gt; 이미지 최적화 도구 설치 오류 문제 pngquant 또는 jpegoptim 명령어를 찾을 수 없음 # 오류 메시지 command not found: pngquant command not found: jpegoptim 해결 방법 # macOS brew install pngquant jpegoptim # Ubuntu/Debian sudo apt-get install pngquant jpegoptim Git 훅 실행 권한 문제 문제 pre-commit 훅이 실행되지 않음 # 오류 메시지 .git/hooks/pre-commit: Permission denied 해결 방법 # 실행 권한 부여 chmod +x .git/hooks/pre-commit # 권한 확인 ls -la .git/hooks/pre-commit 이미지 최적화 실패 문제: 일부 이미지 파일이 최적화되지 않음 원인 분석 손상된 이미지 파일 권한 문제 디스크 공간 부족 해결 방법 # 이미지 파일 무결성 확인 file assets/img/problematic-image.png # 권한 확인 및 수정 chmod 644 assets/img/*.png chmod 644 assets/img/*.jpg # 디스크 공간 확인 df -h Node.js 버전 호환성 문제 문제 스크립트 실행 시 Node.js 버전 오류 해결 방법 # Node.js 버전 확인 node --version # nvm을 사용한 버전 관리 nvm install 16 nvm use 16 Git 훅이 실행되지 않는 문제 문제 pre-commit 훅을 설정했지만 이미지 최적화가 실행되지 않음 원인 분석 Git 훅이 비활성화되어 있음 훅 파일이 올바른 위치에 없음 Git 설정에서 훅이 무시됨 해결 방법 # Git 훅 활성화 확인 git config core.hooksPath # 훅 파일 위치 확인 ls -la .git/hooks/pre-commit # Git 훅 경로 설정 (필요시) git config core.hooksPath .git/hooks # 훅 테스트 git add assets/img/test-image.png git commit -m \"훅 테스트\" 이미지 품질 최적화 문제 문제 최적화 후 이미지 품질이 너무 낮아짐 일부 이미지에서 아티팩트 발생 원인 분석 압축 품질 설정이 너무 낮음 (85%) 이미지 유형에 따른 최적화 설정 부족 원본 이미지 품질 문제 해결 방법 # 품질 설정 조정 (auto-optimize-images.js 수정) const QUALITY = 90; // 85에서 90으로 상향 조정 # 이미지 유형별 품질 설정 if (ext === '.png') { // PNG는 더 높은 품질 유지 execSync(`pngquant --quality=80-95 \"${filePath}\"`); } else if (ext === '.jpg' || ext === '.jpeg') { // JPEG는 적당한 품질 execSync(`jpegoptim --max=90 \"${filePath}\"`); } # 원본 이미지 품질 확인 identify -verbose assets/img/sample-image.jpg Reference&lt;/h2&gt; pngquant 공식 문서 jpegoptim 공식 문서 Jekyll 공식 문서 Git Hooks 가이드 Blog jekyll performance automation Share Recently Updated Google Colab 환경의 Matplotlib 한글 폰트 깨짐 현상 Apache Kafka와 Spring Boot로 구축하는 실시간 데이터 처리 시스템 Apache Kafka 개념과 아키텍처 Jekyll 블로그 이미지 자동 최적화 Jekyll 블로그 설치 및 로컬 실행 가이드 Trending Tags knou os python cpp data information processing database java ubiquitous computing linux network Contents Further Reading 2025-10-11 Jekyll 블로그 설치 및 로컬 실행 가이드 개요 Jekyll 기반 GitHub Pages 블로그를 처음부터 설치하고 로컬에서 실행하는 과정을 설명함사전 준비사항필수 도구 확인 블로그 구축에 필요한 도구들 Git 버전 관리 시스템 GitHub Pages 배포에 필수 ... 2025-10-11 Jekyll 블로그 Google Analytics 연동 개요 Jekyll 블로그에 Google Analytics를 연동하여 방문자 통계를 추적하는 방법을 설명함Google Analytics란 Google Analytics 기능 웹사이트 방문자 수 추적 방문자 행동 분석 트래픽 소스 파악 실시간 방문자 모니터링 사전 준... 2025-10-11 Jekyll 블로그 Utterances 댓글 시스템 추가 개요 Jekyll 블로그에 Utterances 댓글 시스템을 추가하는 방법을 설명함Utterances란특징 GitHub Issues 기반 댓글 시스템 무료 오픈소스 광고 없음 가벼운 용량 마크다운 지원 GitHub 로그인 필요장점 설정이 간단함 GitHub Issues로 댓글 관리 용이 개발... [컴퓨터과학 개론] 3강 - 자료 구조 Jekyll 블로그 설치 및 로컬 실행 가이드 © 2025 mxxikr. Trending Tags knou os python cpp data information processing database java ubiquitous computing linux network &times; A new version of content is available. Update &lt;/div&gt;&lt;/article&gt;&lt;/div&gt;### 메뉴 커스터마이징- Chirpy 테마 메뉴 관리 - `_tabs` 디렉토리에서 관리 - 기본 메뉴 - about.md, archives.md, categories.md, tags.md- 새 메뉴 추가하기 - _tabs 디렉토리에 새 파일 생성 - 예: projects.md - Front Matter 설정 ```yaml --- layout: page title: Projects icon: fas fa-folder order: 5 --- # Projects - 여기에 프로젝트 내용 작성 ``` - order 값으로 메뉴 순서 조정 - 숫자가 작을수록 왼쪽에 배치 - 기본 메뉴들의 order 값 참고 - 아이콘 변경 - Font Awesome 아이콘 사용 - [Font Awesome Icons](https://fontawesome.com/icons) 참고## 트러블슈팅### 자주 발생하는 문제와 해결 방법#### Ruby 버전 호환성 문제- 문제 상황 - Jekyll 빌드 시 Ruby 버전 오류 발생 ```bash # 오류 메시지 Error: Your Ruby version is 2.7.0, but your Gemfile specified ~&gt; 3.0 ```- 해결 방법 - rbenv로 Ruby 버전 변경 ```bash # 설치 가능한 Ruby 버전 확인 rbenv install -l # 필요한 버전 설치 (Gemfile 요구사항에 맞는 버전) rbenv install [버전번호] # 프로젝트에 Ruby 버전 설정 rbenv local [버전번호] # 버전 확인 ruby -v # Bundle 재설치 bundle install ```#### Bundler 버전 충돌- 문제 상황 - Gemfile.lock에 명시된 Bundler 버전과 설치된 버전이 다름 ```bash # 오류 메시지 Bundler could not find compatible versions for gem \"bundler\" ```- 해결 방법 ```bash # Bundler 업데이트 gem install bundler bundle install # 또는 Gemfile.lock 삭제 후 재생성 # Windows PowerShell: Remove-Item Gemfile.lock # Git Bash / Mac / Linux: rm Gemfile.lock bundle install # 또는 특정 버전 설치 후 사용 (Gemfile.lock에 명시된 버전) gem install bundler -v [버전번호] bundle install포트 충돌 오류 문제 상황 4000번 포트가 이미 사용 중 # 오류 메시지Address already in use - bind(2) for 127.0.0.1:4000 해결 방법 # 다른 포트로 실행bundle exec jekyll serve --port 4001 # 또는 기존 프로세스 종료 (Windows)netstat -ano | findstr :4000taskkill /PID [프로세스ID] /F # 또는 기존 프로세스 종료 (Mac/Linux)lsof -ti:4000 | xargs kill -9 파일 변경사항이 반영되지 않음 문제 상황 파일 수정 후 변경사항이 보이지 않음 LiveReload가 작동하지 않음 해결 방법 # 캐시 삭제 후 재실행bundle exec jekyll cleanbundle exec jekyll serve --livereload # 브라우저 캐시 강제 새로고침# Windows: Ctrl + Shift + R# Mac: Cmd + Shift + R # _config.yml 변경 시 서버 재시작 필요# Ctrl + C로 중단 후 다시 실행 이미지가 표시되지 않음 문제 상황 Markdown에 이미지 추가했지만 화면에 나타나지 않음 원인 분석 이미지 경로 오류 파일 이름 대소문자 불일치 상대 경로 문제 해결 방법 절대 경로 사용 권장 올바른 방법 ![이미지 설명](/assets/img/sample.jpg) 잘못된 방법 ![이미지 설명](../../assets/img/sample.jpg) 파일 이름 확인 Linux/Mac은 대소문자 구분 sample.jpg ≠ Sample.jpg 이미지 파일 존재 확인 파일 탐색기에서 assets/img 디렉토리 확인 파일 이름과 경로가 정확한지 확인 GitHub Pages 배포 실패 문제 상황 Push 후 사이트가 업데이트되지 않음 GitHub Actions에서 빌드 실패 해결 방법 # 1. Actions 탭에서 오류 로그 확인# GitHub Repository &gt; Actions 탭 클릭# 실패한 워크플로우 클릭하여 로그 확인 # 2. 로컬에서 빌드 테스트bundle exec jekyll build # 3. Gemfile.lock 커밋 확인git add Gemfile.lockgit commit -m \"Update Gemfile.lock\"git push origin main # 4. GitHub Pages 설정 재확인# Settings &gt; Pages &gt; Source 확인 Liquid 문법 오류 문제 상황 포스트에서 중괄호 사용 시 빌드 오류 # 오류 메시지Liquid Exception: Liquid syntax error 해결 방법 Liquid 문법 이스케이프 raw 태그 사용 {{ 중괄호 내용을 그대로 표시 }} 코드 블록에서 자동 이스케이프 백틱 3개로 감싸기 print(\"\") 한글 깨짐 문제 문제 상황 Windows에서 한글이 깨져서 표시됨 해결 방법 # 파일 인코딩을 UTF-8로 저장# VSCode 설정# File &gt; Preferences &gt; Settings# \"files.encoding\": \"utf8\" 확인 # PowerShell 인코딩 설정chcp 65001 # _config.yml에 인코딩 명시encoding: utf-8 성능 최적화 팁이미지 최적화 이미지 압축 도구 사용 도구 설치 # macOSbrew install pngquant jpegoptim # Ubuntu/Debiansudo apt-get install pngquant jpegoptim # Windows# pngquant: https://pngquant.org/# jpegoptim: Linux/Mac 전용, Windows는 온라인 도구 사용 권장 이미지 압축 실행 # PNG 압축pngquant --quality=65-80 assets/img/*.png # JPEG 압축 (Mac/Linux)jpegoptim --max=85 assets/img/*.jpg WebP 형식 사용 변환 도구 설치 # macOSbrew install webp # Ubuntu/Debiansudo apt-get install webp # Windows# Google WebP 공식 사이트에서 다운로드# https://developers.google.com/speed/webp/download 이미지 변환 cwebp -q 80 input.jpg -o output.webp 빌드 시간 단축 Incremental 빌드 활성화 bundle exec jekyll serve --incremental 주의사항 불안정할 수 있으며 변경사항이 누락될 수 있음 파일 수정이 제대로 반영되지 않으면 jekyll clean 후 재실행 권장 프로덕션 빌드에서는 사용하지 않는 것을 권장 불필요한 플러그인 비활성화 _config.yml에서 사용하지 않는 플러그인 제거 개발 환경 설정 _config.yml 파일 분리 # _config.yml (프로덕션)environment: production # _config_dev.yml (개발)environment: development 개발 환경으로 실행 bundle exec jekyll serve --config _config.yml,_config_dev.yml 유용한 명령어 정리Jekyll 명령어# 새 Jekyll 사이트 생성jekyll new my-blog# 개발 서버 실행bundle exec jekyll serve# LiveReload로 실행bundle exec jekyll serve --livereload# 미래 날짜 포스트 포함bundle exec jekyll serve --future# 다른 포트로 실행bundle exec jekyll serve --port 4001# 증분 빌드 (주의: 불안정할 수 있음)bundle exec jekyll serve --incremental# 상세 로그 출력bundle exec jekyll serve --verbose# 빌드만 실행 (서버 미실행)bundle exec jekyll build# 캐시 삭제bundle exec jekyll clean# 버전 확인bundle exec jekyll -vGit 명령어# 저장소 클론git clone https://github.com/username/username.github.io.git# 상태 확인git status# 변경사항 추가git add .git add filename# 커밋git commit -m \"커밋 메시지\"# 푸시git push origin main# 풀git pull origin main# 브랜치 생성 및 전환git checkout -b new-branch# 브랜치 목록 확인git branch# 로그 확인git log --oneline# 변경사항 되돌리기git checkout -- filenameBundle 명령어# 의존성 설치bundle install# 의존성 업데이트bundle update# 특정 gem 업데이트bundle update jekyll# 설치된 gem 목록bundle list# gem 정보 확인bundle info jekyll# 실행 환경 확인bundle env# Gemfile.lock 삭제 후 재생성# Windows PowerShellRemove-Item Gemfile.lockbundle install# Git Bash / Mac / Linuxrm Gemfile.lockbundle installReference Jekyll 공식 문서 GitHub Pages 문서 Jekyll Theme Chirpy Markdown Guide Liquid Template Language Ruby 공식 사이트 RubyGems.org Bundler 공식 문서" }, { "title": "Jekyll 블로그 이미지 자동 최적화", "url": "/posts/image-auto-optimization/", "categories": "Blog", "tags": "jekyll, performance, automation", "date": "2025-10-08 18:50:00 +0900", "snippet": "개요 Jekyll 기반 블로그에서 이미지 자동 최적화 시스템을 구축하여 웹 성능을 개선한 과정을 소개함문제 상황 분석초기 성능 문제 기술 블로그에서 측정된 성능 지표 이미지 용량 149MB 페이지 로딩 시간 3-5초 (이미지 중심 페이지) 이미지 파일 수 1,000개 이상 이미지 현황 파악# 이미지 디렉토리 용량 분석du -sh assets/img# 결과: 149M\tassets/img# 이미지 파일 개수 확인find assets/img -type f \\( -name \"*.png\" -o -name \"*.jpg\" -o -name \"*.jpeg\" \\) | wc -l# 결과: 1,000개 이상의 이미지 파일 이미지 파일 특성 파일 형식 PNG, JPEG 압축 상태 압축되지 않은 원본 파일 파일 수 1,000개 이상의 이미지 파일 Core Web Vitals 측정 Core Web Vitals 지표 Google이 정의한 웹사이트 사용자 경험을 측정하는 핵심 지표 측정 방법 측정 도구 Chrome DevTools, Lighthouse 측정 환경 로컬 Jekyll 서버 (localhost:4000) # Lighthouse CLI를 사용한 성능 측정 npm install -g lighthouse lighthouse http://localhost:4000 --output=json --output-path=./lighthouse-report.json 측정된 Core Web Vitals 지표 LCP (Largest Contentful Paint): 3.2초 페이지의 가장 큰 콘텐츠 요소가 화면에 렌더링되는 시간 좋은 점수: 2.5초 이하, 개선 필요: 4.0초 초과 이미지가 가장 큰 콘텐츠인 경우 로딩 시간에 직접 영향 CLS (Cumulative Layout Shift): 0.15 페이지 로딩 중 예상치 못한 레이아웃 변화의 정도 좋은 점수: 0.1 이하, 개선 필요: 0.25 초과 이미지 로딩 시 크기 변화로 인한 레이아웃 시프트 발생 FID (First Input Delay): 180ms 사용자가 페이지와 처음 상호작용할 때의 응답 시간 좋은 점수: 100ms 이하, 개선 필요: 300ms 초과 대용량 이미지 로딩으로 인한 메인 스레드 블로킹 영향 자동화 시스템 구성이미지 최적화 도구 설치# 이미지 최적화 도구 설치brew install pngquant jpegoptim# 설치 확인which pngquant &amp;&amp; which jpegoptim자동 최적화 스크립트 생성 파일 생성 위치 프로젝트 루트 디렉토리에 auto-optimize-images.js 파일 생성 실행 권한 부여 chmod +x auto-optimize-images.js auto-optimize-images.js #!/usr/bin/env node const fs = require('fs'); const path = require('path'); const { execSync } = require('child_process'); // 설정 const IMG_DIR = 'assets/img'; const QUALITY = 85; const SKIP_FAVICONS = true; // 이미지 최적화 함수 function optimizeImage(filePath) { const ext = path.extname(filePath).toLowerCase(); try { if (ext === '.png') { execSync(`pngquant --force --ext .png --quality=65-${QUALITY} \"${filePath}\"`, { stdio: 'ignore' }); } else if (ext === '.jpg' || ext === '.jpeg') { execSync(`jpegoptim --max=${QUALITY} --strip-all \"${filePath}\"`, { stdio: 'ignore' }); } return true; } catch (error) { return false; } } // 새로 추가된 이미지 파일 찾기 function getNewImages() { try { const addedFiles = execSync('git diff --cached --name-status', { encoding: 'utf8' }); const newImages = []; const lines = addedFiles.split('\\n'); lines.forEach(line =&gt; { if (line.startsWith('A\\t') &amp;&amp; line.includes(IMG_DIR)) { const filePath = line.substring(2); const ext = path.extname(filePath).toLowerCase(); if (['.png', '.jpg', '.jpeg'].includes(ext)) { if (!SKIP_FAVICONS || !filePath.includes('favicon')) { newImages.push(filePath); } } } }); return newImages; } catch (error) { return []; } } // 메인 실행 function main() { console.log('이미지 자동 최적화 시작...'); const newImages = getNewImages(); if (newImages.length === 0) { console.log('최적화할 새 이미지가 없습니다.'); return; } console.log(`${newImages.length}개의 새 이미지를 발견했습니다.`); let optimized = 0; let failed = 0; newImages.forEach(imagePath =&gt; { console.log(`최적화 중: ${imagePath}`); if (optimizeImage(imagePath)) { optimized++; console.log(`완료: ${imagePath}`); } else { failed++; console.log(`실패: ${imagePath}`); } }); console.log(`최적화 완료: ${optimized}개 성공, ${failed}개 실패`); if (optimized &gt; 0) { console.log('최적화된 파일들을 Git에 다시 추가합니다...'); try { execSync(`git add ${newImages.join(' ')}`, { stdio: 'ignore' }); console.log('Git에 추가 완료!'); } catch (error) { console.log('Git 추가 실패:', error.message); } } } main(); Git 훅 설정 파일 생성 위치 .git/hooks/pre-commit 파일 생성 실행 권한 부여 chmod +x .git/hooks/pre-commit pre-commit 훅 #!/bin/bash # 자동 이미지 최적화 Git 훅 echo \"이미지 최적화를 확인합니다...\" # Node.js가 설치되어 있는지 확인 if ! command -v node &amp;&gt; /dev/null; then echo \"Node.js가 설치되어 있지 않습니다. 이미지 최적화를 건너뜁니다.\" exit 0 fi # 이미지 최적화 도구가 설치되어 있는지 확인 if ! command -v pngquant &amp;&gt; /dev/null || ! command -v jpegoptim &amp;&gt; /dev/null; then echo \"이미지 최적화 도구가 설치되어 있지 않습니다.\" echo \"다음 명령어로 설치하세요: brew install pngquant jpegoptim\" exit 0 fi # 자동 최적화 스크립트 실행 node auto-optimize-images.js echo \"이미지 최적화 완료!\" 실시간 파일 감시 스크립트 파일 생성 위치 프로젝트 루트 디렉토리에 watch-images.js 파일 생성 실행 권한 부여 chmod +x watch-images.js watch-images.js #!/usr/bin/env node const fs = require('fs'); const path = require('path'); const { execSync } = require('child_process'); // 설정 const IMG_DIR = 'assets/img'; const QUALITY = 85; // 이미지 최적화 함수 function optimizeImage(filePath) { const ext = path.extname(filePath).toLowerCase(); try { if (ext === '.png') { execSync(`pngquant --force --ext .png --quality=65-${QUALITY} \"${filePath}\"`, { stdio: 'ignore' }); } else if (ext === '.jpg' || ext === '.jpeg') { execSync(`jpegoptim --max=${QUALITY} --strip-all \"${filePath}\"`, { stdio: 'ignore' }); } return true; } catch (error) { return false; } } // 파일 감시 시작 function startWatching() { console.log('이미지 파일 감시를 시작합니다...'); console.log('감시 디렉토리:', IMG_DIR); console.log('품질 설정:', QUALITY + '%'); console.log('종료하려면 Ctrl+C를 누르세요\\n'); fs.watch(IMG_DIR, { recursive: true }, (eventType, filename) =&gt; { if (eventType === 'rename' &amp;&amp; filename) { const filePath = path.join(IMG_DIR, filename); const ext = path.extname(filename).toLowerCase(); if (['.png', '.jpg', '.jpeg'].includes(ext)) { setTimeout(() =&gt; { if (fs.existsSync(filePath)) { console.log(`새 이미지 발견: ${filename}`); if (optimizeImage(filePath)) { console.log(`최적화 완료: ${filename}`); } else { console.log(`최적화 실패: ${filename}`); } } }, 1000); } } }); } startWatching(); 사용 방법Git 훅 방식# 이미지 추가 후 커밋하면 자동으로 최적화됨git add assets/img/new-image.pnggit commit -m \"새 이미지 추가\"# 자동으로 최적화 후 커밋됨수동 실행# 새로 추가된 이미지만 최적화npm run auto-optimize실시간 감시# 터미널에서 실행하면 이미지 추가 시 실시간 최적화npm run watch-imagespackage.json 설정 파일 생성 위치 프로젝트 루트 디렉토리의 package.json 파일에 scripts 섹션 추가 기존 scripts 섹션이 있다면 해당 내용을 추가 package.json { \"scripts\": { \"build\": \"gulp build\", \"dev\": \"gulp dev\", \"optimize-images\": \"node optimize-images-safe.js\", \"auto-optimize\": \"node auto-optimize-images.js\", \"watch-images\": \"node watch-images.js\", \"test\": \"echo 'Testing blog functionality...'\" } } 성능 최적화 결과최적화 전후 비교 용량 최적화 결과 # 최적화 전 du -sh assets/img # 결과: 149M\tassets/img # 최적화 후 du -sh assets/img # 결과: 45M\tassets/img 페이지 로딩 시간 개선 (Chrome DevTools 기준) 페이지 유형 최적화 전 최적화 후 개선율 이미지 중심 포스트 3-5초 1-2초 60-70% 일반 포스트 2-3초 0.8-1.5초 50-60% 메인 페이지 4-6초 1.5-2.5초 60-70% Core Web Vitals 개선 효과 Lighthouse 성능 점수 최적화 전 Performance: 65-70점 LCP: 3.2초 CLS: 0.15 FID: 180ms 최적화 후 Performance: 85-90점 LCP: 1.8초 (44% 개선) CLS: 0.05 (67% 개선) FID: 95ms (47% 개선) 최적화 결과 요약핵심 성과 항목 최적화 전 최적화 후 개선율 이미지 용량 149MB 45MB 70% 감소 페이지 로딩 시간 3-5초 1-2초 60-70% 단축 Lighthouse 점수 65-70점 85-90점 20-25점 향상 LCP 3.2초 1.8초 44% 개선 CLS 0.15 0.05 67% 개선 FID 180ms 95ms 47% 개선 적용된 기술 이미지 압축 pngquant, jpegoptim 자동화 Git pre-commit 훅 모니터링 Lighthouse, Chrome DevTools 스크립트 Node.js 기반 최적화 도구 트러블슈팅자주 발생하는 문제와 해결 방법 이미지 최적화 도구 설치 오류 문제 pngquant 또는 jpegoptim 명령어를 찾을 수 없음 # 오류 메시지 command not found: pngquant command not found: jpegoptim 해결 방법 # macOS brew install pngquant jpegoptim # Ubuntu/Debian sudo apt-get install pngquant jpegoptim Git 훅 실행 권한 문제 문제 pre-commit 훅이 실행되지 않음 # 오류 메시지 .git/hooks/pre-commit: Permission denied 해결 방법 # 실행 권한 부여 chmod +x .git/hooks/pre-commit # 권한 확인 ls -la .git/hooks/pre-commit 이미지 최적화 실패 문제: 일부 이미지 파일이 최적화되지 않음 원인 분석 손상된 이미지 파일 권한 문제 디스크 공간 부족 해결 방법 # 이미지 파일 무결성 확인 file assets/img/problematic-image.png # 권한 확인 및 수정 chmod 644 assets/img/*.png chmod 644 assets/img/*.jpg # 디스크 공간 확인 df -h Node.js 버전 호환성 문제 문제 스크립트 실행 시 Node.js 버전 오류 해결 방법 # Node.js 버전 확인 node --version # nvm을 사용한 버전 관리 nvm install 16 nvm use 16 Git 훅이 실행되지 않는 문제 문제 pre-commit 훅을 설정했지만 이미지 최적화가 실행되지 않음 원인 분석 Git 훅이 비활성화되어 있음 훅 파일이 올바른 위치에 없음 Git 설정에서 훅이 무시됨 해결 방법 # Git 훅 활성화 확인 git config core.hooksPath # 훅 파일 위치 확인 ls -la .git/hooks/pre-commit # Git 훅 경로 설정 (필요시) git config core.hooksPath .git/hooks # 훅 테스트 git add assets/img/test-image.png git commit -m \"훅 테스트\" 이미지 품질 최적화 문제 문제 최적화 후 이미지 품질이 너무 낮아짐 일부 이미지에서 아티팩트 발생 원인 분석 압축 품질 설정이 너무 낮음 (85%) 이미지 유형에 따른 최적화 설정 부족 원본 이미지 품질 문제 해결 방법 # 품질 설정 조정 (auto-optimize-images.js 수정) const QUALITY = 90; // 85에서 90으로 상향 조정 # 이미지 유형별 품질 설정 if (ext === '.png') { // PNG는 더 높은 품질 유지 execSync(`pngquant --quality=80-95 \"${filePath}\"`); } else if (ext === '.jpg' || ext === '.jpeg') { // JPEG는 적당한 품질 execSync(`jpegoptim --max=90 \"${filePath}\"`); } # 원본 이미지 품질 확인 identify -verbose assets/img/sample-image.jpg Reference pngquant 공식 문서 jpegoptim 공식 문서 Jekyll 공식 문서 Git Hooks 가이드" }, { "title": "[컴퓨터과학 개론] 3강 - 자료 구조", "url": "/posts/knou-cs-3/", "categories": "Computer Science, CS Theory", "tags": "knou, cs", "date": "2025-10-06 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 이관용, 정광식 교수님의 '컴퓨터과학 개론' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 컴퓨터에서 다루고자 하는 데이터를 추상적인 개념으로 정의하고 각각의 자료 구조에 대한 특징과 장단점에 대해서 알아봄 자료 구조의 기본 개념과 가장 기본적인 자료 구조인 배열과 리스트를 살펴 봄 데이터에 대한 연산과 자료 구조와의 정의를 통해 자료의 시간적 관계가 표현 되는 스택과 큐에 대해서 알아봄학습 목표 자료 구조와 추상화에 대해서 이해할 수 있음 배열의 의미와 주 기억 장치 내에서의 저장 위치를 이해할 수 있음 스택과 큐의 자료 구조의 의미를 이해할 수 있음강의록자료 구조 기본 개념자료 구조의 개념추상화추상화와 구조화 자료의 추상화와 구조화가 적절히 이루어지지 못하면 소프트웨어는 비효율적으로 개발되거나 비효율적으로 수행되거나 소프트웨어의 확장성에 문제가 생기거나 소프트웨어의 유지 보수에 문제가 생기거나 할 수 있음추상화 공통적인 개념을 이용하여 같은 종류의 다양한 객체를 정의하는 것 수식, 프로그램 언어 등 자료(데이터) 추상화 다양한 객체를 컴퓨터에서 표현하고 활용하기 위해 필요한 데이터의 구조에 대해서 공통의 특징만을 뽑아 정의한 것자료의 추상화 자료 사이의 논리적 관계를 컴퓨터나 프로그램에 적용하기 위해서는 자료의 추상화가 필요함 자료 구조(data structure) 추상화를 통해 자료의 논리적 관계를 구조화한 것 자료가 복잡해지거나 소프트웨어가 복잡해질 수록 자료 구조의 중요성이 강조됨자료 구조의 종류와 관계 미리 정의 된 자료 구조 프로그래밍 언어에서 제공함 프로그래밍 설계나 컴파일러 구현 단계에서 정의되어 개발자에게 제공되는 자료 구조 사용자 정의 자료 구조 개발자가 정의하여 사용함 소프트웨어 개발 중에 개발자에 의해 만들어지는 자료 구조 리스트, 스택, 큐, 트리, 그래프 등 배열배열의 개념 배열(array) 동일한 자료형을 갖는 여러 개의 데이터를 동일한 변수 이름의 방에 일렬로 저장하는 자료 집합체(원소 + 인덱스) 원소(요소) 자료 집합체에서 각 원소의 항목 값 데이터 인덱스(첨자) 자료 집합체에서 각 원소가 저장 된 방을 접근하기 위한 방 번호에 해당하는 것 번호 1차원 배열에서의 주소 계산1차원 배열 개념 가장 간단한 형태의 배열임 한 개의 인덱스(첨자)를 사용해서 원소에 직접 접근함 배열의 원소들은 컴퓨터 메모리의 연속적인 기억 장소에 할당 되어 순차적으로 저장 됨 배열 A의 크기를 k라고 가정하고 시작 주소를 a라고 가정하면, A[i]의 저장 주소는 a + i * k 가 됨 1차원 배열에서의 주소 계산다차원 배열 2차원 배열 두 개의 첨자를 가지는 배열 동일한 크기의 1차원 배열을 모아 놓아 바둑판 형태로 만든 배열 하나의 원소는 두 개의 첨자 i와 j의 쌍으로 구분 됨 A[i][j] 행(row) 첨자 i에 해당하는 것 열(column) 첨자 j에 해당하는 것 3차원 배열 세 개의 첨자들을 가지는 배열 2차원 배열 저장 순서 열 우선 순서 저장 첫 열에 있는 각 행의 원소를 차례대로 컴퓨터 메모리에 저장하고 다음 열로 이동하여 각 행에 있는 원소를 차례대로 컴퓨터 메모리에 저장하는 방법 행 우선 순서 저장 첫 행에 있는 각 열의 원소를 차례대로 컴퓨터 메모리에 저장하고 다음 행으로 이동하여 각 열에 있는 원소부터 차례대로 컴퓨터 메모리에 저장하는 방법 희소 행렬(spare matrix) 개념 원소 값이 0인 원소가 그렇지 않은 원소보다 상대적으로 많은 행렬 0 값을 저장하기 위해 컴퓨터 메모리의 낭비를 막고 처리의 효율성을 높이기 위해 사용 됨 희소 행렬의 0인 원소는 저장하지 않고 0이 아닌 값 만을 따로 모아서 저장하는 방법 0이 아닌 각 원소를 (행 번호, 열 번호, 원소 값)의 형태로 나타내면 2차원 배열로 표현 가능함 희소 행렬의 일반적인 2차원 배열 표현희소 행렬의 효율적 표현리스트선형 리스트(linear list) 개념 순서 리스트(ordered list)라고도 함 1개 이상의 원소들이 순서를 가지고 구성됨 A = (a₁, a₂, …, aᵢ, aₙ)과 같이 표시하며 aᵢ는 i번째 원소를 나타내고 aₙ의 n은 리스트의 크기가 됨 ex) 요일 리스트 (월, 화, 수, 목, 금, 토, 일) ex) 전쟁 리스트 ((황산벌 전투, 660), (임진왜란, 1592), (세계 1차 대전, 1914), (세계 2차 대전, 1939)) 선형 리스트의 구현(배열) 개념 선형 리스트와 1차원 배열은 순차적인 구조를 가지고 있으므로 1차원 배열로 간단하게 표현할 수 있음 삽입 원소를 삽입하기 위해서는 삽입 될 위치 이후의 원소들의 순서를 그대로 유지하면서 원소를 삽입해야 함 삽입할 위치에 있는 원소와 그 다음의 원소들은 모두 한 칸씩 뒤로 이동 시켜야 함 삭제 원소 삭제의 경우에도 삭제할 원소를 찾아 삭제한 후, 그 뒤에 있는 모든 원소들을 한 칸씩 앞으로 이동 시켜야 함 선형 리스트의 구현(연결 리스트) 개념 노드 간의 포인터 연결을 통해서 구현 됨 각 노드는 적어도 두 종류의 필드, 원소 값을 저장하는 데이터 필드와 노드 연결을 위한 링크 필드를 가짐 선형 리스트의 논리적 순서만을 지원함 연결 리스트 종류 단일 연결 리스트(singly linked list) 특정 노드의 링크 필드를 사용해서 후행 노드를 가리킴 특정 노드의 후행 노드는 쉽게 접근할 수 있지만, 선행 노드에 대한 접근은 헤드 노드부터 새로 시작해야 함 이중 연결 리스트(doubly linked list) 특정 노드의 첫 번째 링크는 후행 노드를 가리키고 두 번째 링크는 선행 노드를 가리킴 특정 노드에서 후행 노드 뿐만 아니라 선행 노드에 대한 접근을 쉽게 제공하기 위한 것 스택과 큐스택(Stack) 개념 데이터의 삽입과 삭제가 한쪽 끝에서만 이루어지는 자료 구조 가장 먼저 입력 된 데이터가 가장 나중에 제거 되는 선입 후출(FILO, First-In-Last-out) 특징을 가짐 스택의 연산 스택 오버플로(overflow) 삽입 연산을 수행할 때 발생함 스택을 위해 할당 된 저장 공간을 초과해서 더 이상 데이터를 삽입할 수 없는 현상 스택 언더플로(underflow) 삭제 연산을 수행할 때 발생 함 스택에 데이터가 존재하지 않으면 삭제가 일어나지 않는 현상 스택의 동작큐(Queue) 개념 선형 리스트의 한쪽 끝에서는 데이터의 삭제만 이루어지고 다른 한쪽 끝에서는 데이터의 삽입만 이루어지는 자료 구조 가장 먼저 입력 된 데이터가 가장 먼저 제거 되는 선입 선출(FIFO, First-In-First-out) 특징 가짐 큐의 연산 오버플로(overflow) 삽입 연산을 수행할 때 발생함 큐를 위해 할당 된 저장 공간을 초과해서 더 이상 데이터를 삽입할 수 없는 현상 언더플로(underflow) 삭제 연산을 수행할 때 발생함 큐에 데이터가 존재하지 않으면 삭제가 일어나지 않는 현상 큐의 동작연산 후의 큐의 상태(만원 상태) 만원 상태 데이터가 큐에 삽입 됨에 따라 rear 변수 값이 증가하다가 n-1이 되면 더 이상 데이터가 삽입될 수 없는 상태가 됨 하지만, 이 경우가 반드시 큐에 n개의 항목이 가득 차 있다는 것을 의미하는 것을 아님 큐가 가득 채워진 상태를 결정하기 위한 다른 방법이 필요함 정리 하기 자료 구조 자료 사이의 논리적 관계를 컴퓨터나 프로그램이 보다 쉽게 이해하고 다룰 수 있도록 구성한 것 배열 같은 자료형을 갖는 여러 개의 데이터를 하나의 변수로 묶어 놓은 데이터의 집합체이며 각 원소를 구분하기 위해 인덱스와 데이터 값의 쌍으로 이루어짐 연결 리스트 노드들을 연결하여 구성하는 것으로 한 노드는 데이터 필드와 링크 필드로 구성 됨 스택 리스트의 한쪽 끝에서만 삽입과 삭제가 이루어지는 후입 선출(LIFO) 구조 큐 리스트의 한쪽 끝에서는 삽입, 다른 한쪽 끝에서는 삭제가 이루어지는 선입 선출(FIFO) 구조 연습 문제 자료들 사이의 논리적인 인접 구조에 따라 자료 구조를 구분할 때 비선형 자료 구조에 속하는 것은 어느 것인가? a. 트리 선형 구조는 일렬의 원소의 나열(1:1 대응 관계)을 의미하며 비선형은 원소의 나열이 일렬로 이루어지지 않은 구조(1:n/n:m 대응 관계)를 의미함 배열, 리스트, 큐에서 원소들은 하나의 일렬 구조를 이루고 있으며, 이를 선형 자료 구조라 함 트리는 일렬 구조를 따르지 않으므로 비선형 자료 구조라 함 배열에 대한 설명으로 올바른 것은? a. 삽입과 삭제 연산 수행 시 추가적인 연산으로 인해 오버 헤드가 발생하는 정적 구조를 갖는다. 두 개 이상의 서로 다른 구조를 가진 데이터 항목을 하나의 변수 이름으로 묶고 인덱스를 사용해서 구분하는 자료 구조는 레코드 자료 구조 배열의 기억 공간은 정적으로 할당이 이루어지며 선언문을 통해 정의 배열에서 각 원소에 대한 접근 시간은 인덱스를 통해 접근 되기 때문에 모든 원소의 접근 시간은 동일함 원소가 어느 위치에 저장 되어 있느냐에 따라 차이가 발생하는 자료 구조로는 리스트가 대표적인 예임 한쪽 끝에서 모든 삽입을 수행하고 다른 쪽 끝에서 모든 삭제를 수행하는 구조의 리스트 자료 구조를 무엇이라 하는가? a. 큐 뷔페 식당에서 빈 접시들이 가지런히 쌓여져 있는 상황에서 가장 위의 접시를 가져가거나 책상 위에 쌓여진 책 위에 책을 하나 올려놓는 것과 같은 일이 이루어지는 접시 더미나 쌓여있는 책 더미를 스택이라고 함 배열이란 똑같이 생긴 방을 연속해서 만들고 그 방안에 같은 종류의 자료를 저장하는 것임 마지막으로 역에서 기차표를 구입하기 위해서 줄 선 사람들은 매표 창구에서 표를 사서 가고 새로 온 사람들은 줄의 맨 끝에 서게 되는 일이 발생되는 사람들의 줄을 큐라고 함 정리 하기 자료 구조 자료 사이의 논리적 관계를 컴퓨터나 프로그램이 보다 쉽게 이해하고 다룰 수 있도록 구성한 것 배열 같은 자료형을 갖는 여러 개의 데이터를 하나의 변수로 묶어 놓은 데이터의 집합체이며 각 원소를 구분하기 위해 인덱스(또는 첨자)와 데이터 값의 쌍으로 이루어짐 배열의 원소들은 연속적인 기억 장소에 저장 되어 순차적으로 저장 되기 때문에 배열의 시작 주소와 각 자료형의 크기를 알면 i번째 원소의 주소를 알면 직접 접근이 가능함 다차원 배열이 저장 되는 방식으로는 열 우선 순서와 행 우선 순서가 있음 연결 리스트 노드들을 연결하여 구성하는 것으로 한 노드는 데이터 필드와 링크 필드로 구성됨 단일 연결 리스트 링크 필드가 하나이고 한 방향으로만 검색이 가능함 이중 연결 리스트 2개의 링크 필드를 사용해서 양방향(선행 노드 방향, 후행 노드 방향)의 검색이 가능함 원형 연결 리스트 마지막 노드의 링크 필드가 첫 번째 노드에 연결 되어 한 방향이지만 전체 연결 리스트를 원형으로 연결함 스택 리스트의 한쪽 끝에서만 삽입과 삭제가 이루어지는 후입 선출(LIFO) 구조 pop 연산과 push 연산이 가장 중요한 연산임 큐 리스트의 한쪽 끝에서는 삽입, 다른 한쪽 끝에서는 삭제가 이루어지는 선입 선출(FIFO) 구조 insert 연산과 delete 연산이 가장 중요한 연산임 " }, { "title": "[멀티미디어 시스템] 2강 - 멀티미디어 시스템 환경", "url": "/posts/knou-multimedia-2/", "categories": "Computer Science, CS Theory", "tags": "knou, multimedia", "date": "2025-09-26 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김형근 교수님의 '멀티미디어 시스템' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 멀티미디어 컴퓨터 시스템을 구성하는 하드웨어적 구성 요소와 사용자가 쉽고 편리하게 사용할 수 있게 해 주는 소프트웨어적인 구성 요소에 대해 살펴봄 다양한 멀티미디어 서비스를 제공 받을 수 있도록 하는 통신 시스템에 대해서도 살펴봄학습 목표 멀티미디어 시스템 환경을 이해할 수 있음 멀티미디어 컴퓨터 시스템의 하드웨어를 이해할 수 있음 멀티미디어 시스템의 소프트웨어를 이해할 수 있음 멀티미디어 통신 서비스의 개념을 이해할 수 있음 멀티미디어 통신 시스템을 이해할 수 있음주요 용어 디지털 미디어 장비 캡처, 프레젠테이션, 프로세싱 장비로 구성 아날로그 미디어 장비 소스, 싱크, 필터 장비로 구성 미디(MIDI) 전자 악기와 컴퓨터 간의 상호 정보 교환을 위한 규약 메타 데이터(meta data) 데이터에 관한 데이터로서, 정보 자원을 설명하는 요소들의 집합 종합 정보 통신 망(ISDN) 단일 통신망으로 음성, 문자, 영상 등 다양한 서비스를 종합적으로 제공하는 통신망 광대역 종합 정보 통신 망(B-ISDN) ISDN보다 고속 전송을 지원하는 종합 정보 통신 망 초고속 인터넷 망 디지털 가입자 회선 방식을 사용하는 초고속 인터넷 망으로, SDSL, ADSL, VDSL 방식이 있음 IMT-2000 국제 전기 통신 연합(ITU)이 정의한 3세대 이동 통신의 국제 표준 IMT-2020 국제 전기 통신 연합(ITU)이 정의한 5세대 이동 통신의 국제 표준 강의록멀티미디어 시스템 환경멀티미디어의 목적 멀티미디어 콘텐츠를 제작하고 사용자로 하여금 이 콘텐츠를 재생할 수 있게 하는 것멀티미디어 시스템 환경 멀티미디어에 관련된 전반적인 시스템 멀티미디어 제작을 위한 컴퓨터 시스템과 멀티미디어 서비스를 위한 통신 시스템으로 구성멀티미디어 시스템의 분류 저작 시스템(authoring system) 멀티미디어 콘텐츠를 저작할 수 있는 기능과 환경을 제공 재생 시스템(presentation system) 단순히 멀티미디어 콘텐츠를 이용하고 재생 멀티미디어 시스템 환경 구조 멀티미디어 컴퓨터 시스템 하드웨어 미디어 처리 장치 입력 장치 출력 장치 저장 장치 소프트웨어 운영 체제 데이터베이스 시스템 멀티미디어 편집 도구 멀티미디어 저작 도구 멀티미디어 통신 시스템 종합 정보 통신 망 초고속 인터넷 망 이동 통신 멀티미디어 컴퓨터 시스템멀티미디어 컴퓨터의 요구 사양 오디오/비디오 데이터를 모두 처리할 수 있는 성능의 PC 사운드 카드, 스피커, 마이크로 폰, 그리고 사운드 효과를 개발하는 데 필요한 오디오 디지타이저나 오디오 편집 소프트웨어 오디오 CD를 동작 시킬 수 있는 CD-ROM 드라이브 성능 높은 그래픽 카드, 비디오 보드, 고해상도 모니터 CD-ROM이나 DVD의 멀티미디어 지원 소프트웨어하드웨어 미디어 처리 장치 디지털 미디어 장비 캡처 원시 자료를 디지털로 표현 ex) 스캐너, 디지타이저 등 프레젠테이션 원시 자료를 재구성하여 보여주는 것 ex) 프린터, 모니터 등 프로세싱 디지털 신호와 사운드 및 이미지를 처리 ex) 인코더, 디코더 등 아날로그 미디어 장비 소스(source) 아날로그 신호를 생성 ex) 마이크로폰 싱크(sink) 출력 생성 ex) 스피커 필터(filter) 특성 변환 ex) 오디오 믹서 미디어 처리 장치의 예 그래픽 카드 컴퓨터와 모니터를 연결하는 장치 화면에 나타나는 정보를 저장하는 비디오 램과 그 내용을 읽어서 제어 신호로 바꾸어 내보내는 영상 제어 회로로 구성 MDA(Monochrome Display Adapter), CGA(Color Graphics Adapter), EGA(Enhanced Graphics Adapter), VGA(Video Graphic Array), SVGA(Super VGA)로 발전 비디오 보드 컴퓨터의 CD 드라이브나 DVD 드라이브로부터 비디오 영상을 컴퓨터 화면에 재생 프레임 그래버 보드 아날로그 영상을 디지털 영상으로 변환 시켜 컴퓨터에 저장 비디오 오버레이 보드 컴퓨터 내부에서 생성된 이미지/그래픽 정보와 TV와 같은 외부 영상 정보를 중첩하여 나타낸다 TV 수신 카드 디지털 방송이나 DMB를 수신할 수 있는 장치 사운드 카드 컴퓨터의 CD 드라이브를 오디오 CD 플레이어처럼 사용할 수 있도록 하는 장치 CD에 저장된 디지털 정보를 소리 정보로 해석 미디(MIDI) Musical Instrument Digital Interface 전자 악기와 컴퓨터 간의 상호 정보 교환을 위한 규약 일종의 멀티미디어 응용 장비 악기의 연주 정보를 디지털로 통신하는 디지털 인터페이스 입력 장치 소리, 영상 등의 데이터를 컴퓨터 내부로 읽어 들이는 장치 마이크, 스캐너, 디지털 카메라, 디지털 캠코더, 디지타이저 등 출력 장치 멀티미디어 정보를 사용자가 이용할 수 있도록 표시하는 장치 스피커, 모니터, 프린터, 프로젝터, HMD(Head Mounted Display) 등 저장 장치 멀티미디어 데이터를 기록하기 위한 장치 CD나 DVD와 같은 대용량 저장장 치가 사용 저장 장치의 예 CD(Compact Disk) 지름 12cm의 원반에 650MB 정도의 저장 용량 알루미늄 박막에 레이저로 홈을 파서 신호를 저장하고, 레이저로 신호를 읽기 때문에 자료의 손상이 없는 반 영구적인 매체 최근에는 저장 용량이 큰 DVD의 보급으로 저장장치의 역할보다는 가격이 저렴한 콘텐츠 배포용 매체로 사용 CD의 종류 CD-R (CD-Recordable) 데이터가 없는 상태의 CD로서 1회만 쓸 수 있다. CD-ROM (CD-Read Only Memory) 읽기 전용 CD로서, 데이터를 지우거나 추가할 수 없다. CD-RW (CD-ReWritable) 약 1,000번 이상 기록과 삭제가 가능, 백업용 매체로 사용 CD-ROM 배속 CD-ROM으로부터 주기억 장치로의 데이터 전송 속도 초기의 CD-ROM의 1배속은 150Kbps 이후 16, 32, 48, 52배속 등의 개발로 전송 속도 향상 ex) 48배속 CD 드라이브란? 150Kbps × 48 = 7,200Kbps의 전송 속도를 의미 차세대 DVD 블루레이(blu-ray) 디스크 최고 50GB 저장용량 삼성, LG, 소니 등이 주축으로 개발 2002년 표준규격 통일 HD-DVD 최고 25GB 저장용량 도시바, NEC를 주축으로 개발 2008년 개발 포기 소프트웨어 멀티미디어를 위한 소프트웨어 멀티미디어 운영체제 멀티미디어 데이터베이스 시스템 멀티미디어 처리 소프트웨어 멀티미디어 운영체제 가장 중요한 역할을 수행 사용자가 손쉽게 하드웨어를 설치하고 관리할 수 있도록 함 멀티미디어 장치와 편집 소프트웨어, 저작 도구 간의 인터페이스 제공 윈도(Windows) DOS 운영 체제는 멀티미디어 활용이 불편 윈도 운영 체제는 GUI환경을 통하여 손쉬운 멀티미디어 사용 가능 플러그 앤 플레이(plug &amp; play) 기술을 통해 편리한 멀티미디어 환경 조성 멀티태스킹(multitasking)기능 지원 멀티미디어 데이터베이스 시스템 기존 데이터베이스 시스템 숫자와 문자 데이터를 대상으로 처리 멀티미디어 데이터베이스 시스템 숫자나 문자 뿐만 아니라 멀티미디어 데이터를 효율적으로 저장, 검색할 수 있는 시스템 미디어 개체의 내용을 근거로 설명을 작성하고, 그 설명을 저장 : 메타 데이터 대용량의 저장 공간이 필요 메타 데이터베이스 메타 데이터로 이루어진 데이터베이스 메타 데이터 데이터에 관한 데이터(data about data) 정보 자원을 설명하는 요소들의 집합 도서관의 카드, 인덱스, 카탈로그 등이 하나의 예 도서관의 카드에는 메타 데이터인 제목, 저자, 주제 분류, 책꽂이 마크 등의 정보가 포함 메타 데이터의 기능 정보 자원의 접근과 탐색 개체 내용의 요약 개체 간의 의미적 상호 연동성 자원 관리 사용자 인터페이스 방법 멀티미디어 데이터베이스의 질의 처리 데이터베이스는 질의에 대한 효율적인 응답이 매우 중요 멀티미디어의 데이터 액세스는 메타 데이터베이스를 활용 멀티미디어 데이터베이스에서 메타 데이터의 역할은 매우 중요 메타 데이터의 역할이 중요한 이유 멀티미디어 데이터베이스에서는 완전한 내용 기반 검색 기능이 제공되지 못하고 메타 데이터베이스에서는 대체 기능에 대한 설명이 제공되기 때문 멀티미디어 메타 데이터 멀티미디어 데이터의 디지털 형식, 용어와 상태, 데이터의 위치 등 멀티미디어 처리 소프트웨어 디지털 멀티미디어 데이터를 생성, 저작, 저장, 편집하고 프레젠테이션할 수 있는 소프트웨어 편집 소프트웨어와 저작 소프트웨어로 구분 편집 소프트웨어 단일 미디어를 생성, 편집하고 프레젠테이션 그래픽 소프트웨어, 사운드 편집기, 이미지 편집기, MIDI 시퀀서, 애니메이션 소프트웨어, 비디오 편집기 등 ex) 어도비 포토샵 저작 소프트웨어 여러 미디어를 통합하여 멀티미디어 응용시스템을 저작 ex) 어도비 드림 위버 멀티미디어 통신 시스템개요 다양한 멀티미디어에 대한 사용자의 요구와 정보통신 기술의 발전으로 멀티미디어 통신 기술이 대두 정보 통신 망은 다양한 매체를 통한 정보 교환을 위해서는 필수 정보 교환을 위해서는 상호 작용이 중요 인간과 컴퓨터의 상호 작용 사용자가 일상생활에서 대하는 대화 환경을 멀티미디어 처리 기능을 가지고 실현 인간과 인간의 상호 작용 원거리의 사용자들이 다양한 매체를 통하여 인간의 대화 환경을 실현 이러한 상호 작용을 실현하는 것이 멀티미디어 통신 서비스멀티미디어 통신 서비스의 정의 멀티미디어 정보를 종합적으로 생성, 저장, 전송, 재생하는데 사용되는 각종 기술과 제품으로 두 가지 이상의 미디어를 동일한 시스템에서 동시에 대화형으로 필요한 정보를 제공하는 것 멀티미디어 서비스를 위한 통신 시스템 광섬유의 기술과 데이터 압축 기술의 발전으로 시간과 장소에 관계 없이 멀티미디어 서비스를 이용할 수 있게 됨 멀티미디어 데이터는 기존 데이터와는 다른 통신량과 형태를 가지므로 새로운 통신 시스템이 필요 멀티미디어 통신 시스템은 개별 기술인 컴퓨터, 통신, 방송 기술들이 디지털 기술에 의해 하나로 수렴되는 과정에서 자연스럽게 발전네트워크를 이용한 통신 시스템 종합 정보 통신 망(ISDN: Integrated Services Digital Networks) 단일 통신 망으로 음성, 문자, 영상 등 다양한 서비스를 종합적으로 제공하는 통신망 기존의 전화 망에 비해 다양한 서비스를 고속, 고품질로 제공 그러나 동선을 사용한 64Kbps를 기본으로, 광섬유를 이용하면 1.5Mbps~2Mbps 정도로 멀티미디어 통신을 위해서는 미흡 따라서 TV 영상과 같은 멀티미디어 통신을 위해서는 10배 이상의 고속 전송이 가능한 ISDN이 필요 → B-ISDN 광대역 종합정보 통신 망(B-ISDN: Broadband ISDN) ISDN 보다 고속 전송을 지원 B-ISDN의 정보 전달 방식 회선 전달 방식과 패킷 전달 방식을 통합한 비동기식 전달 방식 비동기식 전달 방식(ATM: Asynchronous Transfer Mode) 150Mbps~600Mbps의 초고속 대용량 데이터의 디지털 전송이 가능하여 영상 통신이나 멀티미디어 통신에 이용 초고속 인터넷망 디지털 가입자 회선 방식(xDSL)을 사용하는 초고속 인터넷 망 단선 디지털 가입자 회선(SDSL) 비대칭 디지털 가입자 회선(ADSL) 초고속 디지털 가입자 회선(VDSL) ADSL(Asymmetric Digital Subscriber Line) 기존의 전화 선을 사용하면서 고속 데이터 통신이 가능한 방식 전송 속도는 수신의 경우 최고 9 Mbps, 송신은 640 Kbps 정도 VDSL(Very high data rate Digital Subscriber Line) ADSL 보다 상위 개념의 초고속 인터넷 방식 ADSL에 비해 송, 수신의 속도 차이가 없으며, 2~5배 빠른 전송 속도를 가짐 전송 속도는 수신의 경우 최대 52Mbps, 송신의 경우 최대 26Mbps를 갖음 VOD나 고화질 TV등 다양한 분야에 적용 케이블 망 양방향 특성을 가지며, 최대 10Mbps의 전송 속도 이통 통신 시스템이통 통신 시스템 표준 (IMT) IMT-2000 동일한 시스템이라도 지역 별로 표준 및 주파수 대역이 다름 따라서 다양한 무선 개인 통신 시스템을 통합하여 하나의 무선 구조로 통합 필요 IMT-2000(International Mobile Telecommunication-2000) 이 등장 국제 전기 통신 연합(ITU)이 정의한 3세대 이동 통신의 국제 표준 지상이나 위성에서 음성, 고속 데이터, 영상 등의 멀티미디어 서비스를 제공하고 글로벌 로밍 서비스를 제공하는 유무선 통합 차세대 통신 서비스 미래 공중 육상 이동 통신 시스템(FPLMTS)라고도 부름 IMT-Advanced 국제 전기 통신 연합(ITU)에서 채택한 4세대 이동 통신의 공식 명칭 IMT-2020 국제 전기 통신 연합(ITU)에서 채택한 5세대 이동 통신의 공식 명칭 ITU에서는 3G, 4G, 5G 등 세대 구분 용어를 사용하지 않고 IMT-2000, IMT-Advanced, IMT-2020의 용어를 사용이통 통신의 발전 과정 1세대(1G) 이통 통신 음성 통신만 가능한 아날로그 방식의 이통 통신 시스템 AMPS(Advanced Mobile Phone System) 2세대(2G) 이통 통신 디지털 방식의 이통 통신 시스템 음성과 문자 서비스 제공 유럽 방식의 GSM(Global System for Mobile Communications)과 미국방식의 CDMA(Code Division Multiple Access) 3세대(3G) 이통 통신 IMT-2000 동영상을 포함한 본격적인 멀티미디어 서비스 CDMA2000, WCDMA, HSDPA, LTE, Wibro 4세대(4G) 이통 통신 IMT-Advanced 데이터 이용량의 급속한 증가와 트래픽의 폭증으로 4G 기술 개발 3G의 WCDMA에 기반한 LTE Advanced 와 3G의 Wibro에 기반한 Wibro Advanced 기술 4G의 표준 전송규격은 1Gbps 5세대(5G) 이통 통신 IMT-2020 모바일 환경의 급변으로 5G 이통 통신 네트워크 기술 필요 5G는 4세대 LTE 보다 데이터 전송 속도가 1000배 빠른 차세대 이통 통신 기술 LTE의 최고 속도 : 75Mbps 5G : 75Gbps~100Gbps(체감 속도 1Gbps 예상) 5G의 개발 효과 사물 인터넷(IoT), 증강 현실, 홀로그램 등 미래형 서비스 제공 5G의 기술 개발 현황 METIS 2020 : 유럽 9개국 컨소시움 IMT-2020(5G) Promotion Group : 중국 2020 and Beyond Ad hoc : 일본 5G 포럼 : 한국 정리 하기 멀티미디어 시스템 환경이란 멀티미디어에 관련된 전반적인 시스템을 말함 멀티미디어 콘텐츠를 제작하고 재생하는 하드웨어 환경과 소프트웨어 환경을 합쳐서 멀티미디어 컴퓨터 시스템 또는 멀티미디어 플랫폼(Multimedia Platform)이라고 함 멀티미디어 컴퓨터 시스템은 하나의 멀티미디어 콘텐츠를 제작하기 위해 필요한 하드웨어와 소프트웨어로 구성되어 있음 멀티미디어를 위한 소프트웨어는 멀티미디어 운영 체제와 데이터베이스 시스템, 그리고 멀티미디어 처리 소프트웨어로 나눌 수 있음 멀티미디어 통신 서비스는 멀티미디어 정보를 종합적으로 생성, 저장, 전송, 재생하는 데 사용되는 각종 기술과 제품을 말함" }, { "title": "[컴퓨터과학 개론] 2강 - 컴퓨터와 데이터", "url": "/posts/knou-cs-2/", "categories": "Computer Science, CS Theory", "tags": "knou, cs", "date": "2025-09-25 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 이관용, 정광식 교수님의 '컴퓨터과학 개론' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 데이터 표현이라는 관점에서 컴퓨터 내부에서 데이터를 어떻게 표현하는 지에 대해서 살펴봄 데이터와 정보의 개념적인 차이를 이해하고, 정수와 실수, 그리고 문자 표현과 관련된 다양한 개념과 방법들을 학습함학습 목표 데이터와 정보의 개념적 차이, 그리고 데이터 표현 단위 등을 이해하고 설명할 수 있음 다양한 진법 간의 변환을 수행할 수 있음 정수와 실수의 표현 방법을 이해하고 설명할 수 있음 문자 표현의 개념과 문자 코드의 종류를 이해하고 설명할 수 있음강의록데이터와 정보데이터와 정보의 관계 I = P(D) 데이터 현실 세계로부터 관찰이나 측정을 통해 단순히 얻어지는 값/사실 정보 어떤 상황에 대해 적절한 의사 결정을 수행할 수 있게 하는 지식 데이터의 표현 형태 데이터의 유형과 무관하게 일관된 표현 방식 사용 문자, 정수/실수, 이미지, 오디오, 비디오 등 비트 패턴 메모리에 저장된 데이터 유형에 맞는 해석과 처리가 필요 입출력 장치나 프로그램의 책임/역할 데이터의 표현 단위 비트(binaryd digit) 바이트(byte) KB(2¹⁰≈10³), MB(2²⁰≈10⁶), GB(2³⁰≈10⁹), TB(2⁴⁰≈10¹²), PB(2⁵⁰≈10¹⁵), EB(2⁶⁰≈10¹⁸), ZB(2⁷⁰≈10²¹), YB(2⁸⁰≈10²⁴) 워드(word) 컴퓨터 연산의 기본 단위가 되는 정보의 양 보통 32 bit, 64 bit 진법진법(number system) 수를 세는 방법 또는 단위 r 진법 0, 1, ⋯, (r - 1)까지의 숫자만을 사용하는 진법 r 진수 진법의 각 숫자는 위치에 따른 서로 다른 가중치(자릿 값)를 가짐 r 진법의 자릿 값 rˣ x는 숫자의 위치를 나타내는 정수 2진수를 10진수로 변환 10진수 = ∑(각 비트 값 * 해당 비트 위치의 가중치) 8/16진수를 10진수로 변환 10진수 = ∑(각 숫자 값 * 해당 위치의 가중치) 10진수를 r진수로 변환(r = 2, 8, 16) 정수 부분과 소수 부분을 구분하여 각각의 방법으로 처리한 후, 각 결과를 단순히 연결해서 나열 정수 60 60 % 2 = 0 30 % 2 = 0 15 % 2 = 1 7 % 2 = 1 3 % 2 = 1 1 % 2 = 1 소수 6875 0.6875 * 2 = 1.375 0.375 * 2 = 0.75 0.75 * 2 = 1.5 0.5 * 2 = 1.0 10진수_정수 부분 → r 진수 알고리즘 입력값 = 10진수(정수 부분); // 변환하고 싶은 10진수 정수 i = 0; 몫 = 입력값 / r; // 몫은 정수 부분만 나머지 = 입력값 mod(%) r; // 나머지는 입력값에서 r을 나눈 나머지 값을 가짐 결과(i) = 나머지; // 순서대로 기록 while (몫 ≠ 0) \t입력값 = 몫; // 나눠진 결과를 몫으로 \ti = i+1; // 자리 하나 증가 \t몫 = 입력값 / r; \t나머지 = 입력값 mod r; \t결과(i) = 나머지 end 출력[결과(i), 결과(i- 1), …, 결과(0)]; // 나머지를 역순으로 나열 몫과 나머지(%)를 반복해서 구함 나머지는 결과 배열에 차곡차곡 쌓음 반복 종료 후, 결과를 거꾸로 읽어주면 원하는 진법의 수가 됨 10진수_소수 부분 → r 진수 (r = 2, 6, 18) 알고리즘 입력값 = 10진수(소수 부분); // 변환하고 싶은 10진수 소수 부분만 출력 i = 0; while (입력값 ≠ 0) \t임시변수 = 입력값 * r; \t결과(i) = 임시변수의 정수 부분; // 곱한 값의 정수 부분 \ti = i + 1; \t입력값 = 임시변수의 소수 부분; // 곱한 값의 소수 부분은 다음 단계의 입력 end 출력[0.결과(0), 결과(1), …, 결과(i)]; 10진수 소수 부분 × 진법(r) 곱한 결과의 정수 부분을 진법 소수점 아래에 기록 곱한 결과의 소수 부분을 다음 단계에서 다시 x r 반복 후, 차례대로 기록한 값이 r진수의 소수점 아래 자리 수가 됨 r 진수 간의 변환(r = 2, 8, 16) 2진수의 3 자릿수 = 8진수의 1 자릿수 2진수의 4 자릿수 = 16진수의 1 자릿수정수 표현정수 표현 방법 부호 없는 정수 부호(+, -) 비트 미존재 n비트 → 0 ~ 2ⁿ - 1 부호 있는 정수 최상위 비트 = 부호 비트 (0: 양수, 1: 음수) 양의 정수는 모두 동일, 음의 정수는 서로 다른 형태 가짐 부호화-크기 절대 값으로 표현 -(2⁽ⁿ⁻¹⁾ - 1) ~ +(2⁽ⁿ⁻¹⁾ - 1) +0(00000000) -0(10000000) 1의 보수 양수에 대한 보수로서 표현 -(2⁽ⁿ⁻¹⁾ - 1) ~ +(2⁽ⁿ⁻¹⁾ - 1) +0(00000000) -0(11111111) 2의 보수 (1의 보수 + 1)로 음수 표현 -2⁽ⁿ⁻¹⁾ ~ +(2⁽ⁿ⁻¹⁾ - 1) 부호 없는 정수 주어진 수 → 2진수 변환 → n 비트 할당(n = 8) 115 → 1110011 → 01110011 275 → 100010011 → 1/00010011 (overflow 발생) 부호 있는 정수 n = 8 비트인 경우 양수 : 0 음수 : 1 124 : 01111100 124 부호화-크기 절대 값 11111100 1의 보수 0 → 1, 1 → 0 1000011 2의 보수 (1의 보수) + 1 1000011 + 1 = 1000100 정수 표현 방법의 비교 이진 표현 부호 없는 정수 부호 있는 정수(부호화-크기) 부호 있는 정수(1의 보수) 부호 있는 정수(2의 보수) 00000000 0 +0 +0 +0 00000001 1 +1 +1 +1 00000010 2 +2 +2 +2 00000011 3 +3 +3 +3 … … … … … 01111100 124 +124 +124 +124 01111101 125 +125 +125 +125 01111110 126 +126 +126 +126 01111111 127 +127 +127 +127 10000000 128 -0 - 127 - 128 10000001 129 - 1 - 126 - 127 10000010 130 -2 - 125 - 126 10000011 131 -3 - 124 - 125 … … … … … 11111100 252 - 124 -3 -4 11111101 253 - 125 -2 -3 11111110 254 - 126 - 1 -2 11111111 255 - 127 -0 - 1 2의 보수 방식의 응용 뺄셈 24 - 17 이진수 10001100은 십진수로 얼마인가? 8비트, 2의 보수 방식 10001101 - 1 = 10001100 보수 계산 11110011 십진수 변환 -115 실수 표현실수 표현 과학적 표기법을 활용한 부동 소수점 방식으로 표현 1,234,000,000,000 → 1.234 * 10¹² -0.0000000005678 → -5.678 * 10⁻¹⁰ (- 1)ˢ * M * Bᵉ 초과 표기법 부동 소수점 방식의 지수 부분의 표현만을 위한 정수 표현 방법 매직 넘버 → 지수 부분이 m 비트로 구성 → 2ᵐ⁻¹ 또는 2ᵐ⁻¹ - 1 정규화 가수를 표현할 때 표준화 된 형식 필요 실수 표현의 예IEEE 부동 소수점 방식의 표준 형식 단정도(single precision) → 4 바이트 배정도(double precision) → 8 바이트 문자 표현문자 표현 키보드를 통해 입력되는 문자는 내부적으로 2진수로 표현되어 처리 각 문자마다 유일한 값으로써 코드를 할당할 수 있는 약속된 문자 체계가 필요 문자 체계의 종류 ASCII, 유니코드, … ASCII American Standard Code for Information Interchange 미국 표준 협회(ANSI) 7비트 코드 → 128개(2⁷)의 서로 다른 문자 표현 확장된 아스키(Extended ASCII) → 1비트 + 7비트 1비트 0 패러티(parity) 비트 짝수 패러티 → 11001100 홀수 패러티 → 01001100 A(1000001) S(1010011) C(1000011) I(1001001) I(1001001) 유니코드 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계 된 표준 1990년 애플 컴퓨터, IBM, MS 등의 컨소시엄으로 설립한 유니코드(Unicode)가 첫 버전 발표 1995년 국제 표준으로 제정 공식 명칭: ISO/IC 10646- 1 사용 중인 플랫폼, 프로그램, 언어에 무관 16비트 코드 체계 65,636개(216)의 서로 다른 문자 표현 기타 코드 체계 EBCDIC(Extended Binary Coded Decimal Interchange Code) IBM 개발 IBM 메인 프레임에서만 사용 8비트 코드 실제 사용되는 문자 코드는 128개 BCD(Binary Coded Decimal) 4비트로 구성 된 10개의 코드로 10진수를 표현하는 방식 8421 코드 정리 하기 데이터와 정보 정보 = P(데이터), 비트 패턴 데이터 표현 단위 비트, 바이트, KB, MB, GB, TB, PB, EB, ZB, YB, 워드 진법 변환 2/8/16진수 ↔ 10진수 8진수 ↔ 2진수 ↔ 16진수 정수 표현 부호 없는 정수 부호 있는 정수 양수는 동일 음수 표현 부호화-크기 1의 보수 2의 보수 실수 표현 (-1)ˢ * M * 2ᵉ 초과 표기 법 정규화 문자 표현 ASCII 유니코드 연습 문제 주어진 여러 진법의 수 중에서 가장 작은 값을 나타내는 것은? a. 0.43(8) 0.43(8) = 4 * 8⁻¹ + 3 * 8⁻² = 4 * 0.125 + 3 * 0.015625 = 0.546875(10) 0.98(16) = 9 * 16⁻¹ + 8 * 16⁻² = 9 * 0.062375 + 8 * 0.004 = 0.59375(10) 0.10011(2) = 1 * 2⁻¹ + 0 * 2⁻² + 0 * 2⁻³ + 1 * 2⁻⁴ + 1 * 2⁻⁵ = 1 * 0.5 + 1 * 0.0625 + 1 * 0. 03125 = 0.59375(10) 이진수 1100101.10011을 8진수와 16진수로 각각 올바르게 변환한 것은? a. 145.46 65.98 2진수를 8진수 또는 16진수로 변환하기 위해서는 2진수 표현에서 소수점을 기준으로 정수 부분에 대해서는 왼쪽 방향, 소수 부분에 대해서는 오른쪽 방향으로 세 자리씩 묶어서 나타내면 8진수의 한 자릿수가 되고, 네 자리씩 묶어서 나타내면 16진수의 한 자릿수가 됨 8진수로의 변환 1100101.10011 → 001 100 101 . 100 110 → 1 4 5 . 4 6 (8) 16진수로의 변환 1100101.10011 → 0110 0101 . 1001 1000 → 6 5 . 9 8 (16) 2의 보수 방식을 사용해서 8비트로 표현된 정수 10100001은 10진수로 얼마인가? a. -95 주어진 음수를 2의 보수 방식으로 표현하기 위해서는 주어진 음수의 절대 값을 이 진수로 변환 이진수의 각 비트에 대해서 보수(0은 1로, 1은 0으로 바꿈)를 취함 그 결과에 1을 더하면 됨 하지만 주어진 문제는 반대의 경우이기 때문에 위의 과정(주어진 음의 정수를 2의 보수 방법으로 변환하는 과정)의 역 순으로 처리하면 됨 즉 2의 보수로 표현된 수에서 1을 빼고(10100001 - 1 = 10100000), 그 결과에 대해서 보수를 취하면 01011111이 되고, 이것을 십진수로 변환하면 95가 되는데, 2의 보수 방식으로 표현된 수의 부호 비트가 1이므로 음의 정수 -95가 됨 십진수 53.625를 부동 소수점 방식의 실수 표현으로 올바르게 것은? (단, 주어진 부동소수점은 16비트를 사용한다. 이 중에서 지수를 위해 5비트를 할당하며 초과_15 표기법을 사용한다.) a. 0 10100 1010110100 주어진 실수를 이 진수로 변환(정수 부분과 소수 부분으로 구분하여 처리)하면 110101.101가 되고, 이에 대해 정규화를 수행하면 1.10101101 * 2⁵가 됨 부호 비트(1비트) → 주어진 수가 0보다 크므로 0이 됨 지수 → 지수 값 5와 매직 넘버 15를 더한 값 20을 이진수로 변환해서 5비트에 할당하면 10100이 됨 가수 → 소수점의 왼쪽 1을 제외한 나머지 부분(10101101)을 10비트(16비트 중에서 부호 1비트와 지수 5비트를 사용하고 남은 비트)에 할당하면 1010110100이 됨 다음 설명에 해당하는 문자 코드 체계는 무엇인가? 1995년 국제 표준으로 제정되었으며, 공식 명칭은 ISO/IEC 10646- 1이다. 16비트 코드 체계로서, 세계의 모든 문자를 표현할 수 있다. a. 유니코드 유니코드는 애플 컴퓨터, IBM, MS 등의 컨소시엄을 통해 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준으로, 사용 중인 플랫폼, 프로그램 등에 무관한 특징을 갖음 정리 하기 데이터와 정보 I = P(D) 데이터와 정보의 관계 데이터 D를 대상으로 처리기 P에서 처리해서 얻은 결과가 정보 I임 데이터 현실 세계로부터 관찰이나 측정을 통해 단순히 얻어지는 사실이나 값 정보 어떤 상황에 대해 적절한 의사 결정을 수행할 수 있게 하는 지식 데이터 처리(정보 처리) 데이터를 정보로 가공하고 변환하는 일련의 과정 모든 데이터는 유형에 무관하게 비트 패턴이라는 일관된 방식으로 표현 데이터의 표현 단위 bit, byte, KB, MB, GB, TB, PB, EB, ZB, YB 워드(word) 컴퓨터 연산의 기본 단위가 되는 정보의 양 진법 r진법 0, 1, …, (r - 1)까지의 숫자만을 사용해서 수를 표현하는 방식/단위 2 진법, 8 진법, 10 진법, 16 진법 간의 변환이 필요 2진수/8진수/16진수를 10진수로 변환 각 위치에서의 숫자 값과 해당 위치에서의 가중치(자릿 값)를 곱한 후, 그 결과들을 모두 더함 10진수를 r진수로 변환 정수 부분과 소수 부분을 나눠서 각각 변환한 후, 그 결과를 단순히 연결해서 표현함 정수 부분에 대해서는 나눗셈을 적용한 후 나머지를 결과로 활용, 소수 부분에 대해서는 곱셈을 적용한 후 정수 부분을 결과로 활용 2진수와 8진수/16진수의 관계 2진수의 3 자릿수 = 8진수의 1 자릿수 2진수의 4 자릿수 = 16진수의 1 자릿수 정수 표현 정수 표현 방법의 종류 부호 없는 정수 부호 있는 정수 부호화-크기 방식 1의 보수 방식 2의 보수 방식 부호 없는 정수 부호 비트가 없으며, 주어진 n비트 전체를 사용해서 정수(0 ~ 2ⁿ - 1)를 표현 부호 있는 정수 부호화-크기 방식 최상위 1 비트를 부호 비트로 사용하고, 음의 정수는 음수에 대한 절대 값으로 표현 1의 보수 방식 부호 비트 사용 음의 정수는 양의 정수 표현에 대해 보수(0 → 1, 1 → 0)를 취해서 표혐 2의 보수 방식 부호 비트 사용 음의 정수는 1의 보수 방식의 결과에 1을 더해서 표현 실수 표현 부동 소수점 방식을 사용해서 표현 표현 형식 (-1)부호 × 가수 × 2지수 (-1)ˢ × M × 2ᵉ 부호(1비트) + 지수(m비트) + 가수(n비트) 지수의 표현 초과 표기법 부동 소수점의 지수 부분만을 위한 표기 방법 지수를 m비트로 표현하는 경우 두 개의 매직 넘버(2ᵐ⁻¹, 2ᵐ⁻¹ - 1) 중에서 하나를 사용 지수 값을 저장하는 경우 (지수 값 + 매직 넘버)를 2진수로 표현/저장 저장 된 지수 값을 해석하는 경우 (지수 부분의 2진수 값 - 매직 넘버) 가수의 표현 정규화 소수점 바로 왼쪽에 오직 하나의 1만 있도록 소수점의 위치를 조정 가수 값을 저장하는 경우에는 소수점 이하 부분만 저장 문자 표현 키보드로 입력 되는 문자를 내부적으로 2진수로 변환하여 처리하기 위해서는 문자마다 유일한 코드를 부여할 수 있는 약속 된 문자 체계가 필요 대표적인 문자 체계의 종류 ASCII (또는 확장된 ASCII) 유니코드 " }, { "title": "[멀티미디어 시스템] 1강 - 멀티미디어 개요", "url": "/posts/knou-multimedia-1/", "categories": "Computer Science, CS Theory", "tags": "knou, multimedia", "date": "2025-08-21 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김형근 교수님의 '멀티미디어 시스템' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 멀티미디어의 정의와 발전 배경을 살펴보고 멀티미디어의 여러 가지 특성에 대해 설명함 멀티미디어 시스템의 핵심 요소인 멀티미디어 콘텐츠의 전반적인 개요에 대해 살펴봄학습 목표 미디어 데이터와 멀티미디어 데이터를 이해할 수 있음 멀티미디어의 발전 배경을 이해할 수 있음 멀티미디어가 갖고 있는 특성을 설명할 수 있음 멀티미디어 콘텐츠의 개념을 이해할 수 있음 멀티미디어 콘텐츠의 제작에 대해 이해할 수 있음주요 용어 멀티미디어 텍스트, 사운드, 이미지, 그래픽, 비디오, 애니메이션 등의 여러 미디어들을 이용하여 표현되는 정보 멀티미디어 데이터 다양하게 표현 가능한 미디어를 컴퓨터가 읽을 수 있는 형태로 표현된 것으로서 텍스트, 사운드, 이미지, 그래픽, 비디오, 애니메이션 등을 말함 MPC 멀티미디어가 처리될 수 있는 PC 인간-컴퓨터 상호 작용(HCI) 기술 컴퓨터를 보다 편리하고 쉽게 이용할 수 있도록 하는 기술 GUI(Graphical User Interface) 사용자의 편리성 제공을 위해 그래픽스 기술이 적용된 인터페이스 멀티미디어 콘텐츠 멀티미디어 데이터들을 디지털화하여 생산되고 처리된 각종 정보 또는 그 내용물록멀티미디어의 정의 강의록멀티미디어의 정의멀티미디어란? 여러(multi) 매체(media)라는 의미 텍스트, 사운드, 이미지, 그래픽, 비디오, 애니매이션 등의 여러 미디어들을 이용하여 표현되는 정보 멀티미디어 콘텐츠 멀티미디어가 갖는 궁극적인 가치 멀티미디어 데이터로 구성 미디어 데이터 원시 미디어 가공되지 않은 미디어 자연 그대로의 물리적 요소 종이, 돌, 잉크, 그림, 음악 등 디지털 미디어 컴퓨터에 의존 디지털 이미지, 디지털 비디오, 디지털 오디오 등 멀티미디어 데이터 디지털 미디어들의 결합된 형태 다양하게 표현 가능한 미디어를 컴퓨터가 읽을 수 있는 형태로 표현한 것 텍스트, 사운드, 이미지, 그래픽, 비디오, 애니메이션 등멀티미디어의 발전 과정컴퓨터 성능의 향상 멀티미디어 데이터 처리를 위해서는 컴퓨터의 성능이 중요 멀티미디어 데이터가 컴퓨터에 저장될 때는 엄청난 양의 기억 장소가 필요 멀티미디어 데이터 종류에 따른 메모리 용량 멀티미디어 데이터의 종류 메모리 용량 A4 용지 텍스트 1장 0.002MB 이미지(정지 화상) 1장 1MB CD 오디오 수준의 음악 1분 10MB 비디오(동영상) 1초 27MB 많은 양의 정보를 실시간에 처리하기 위해서는 빠른 컴퓨터의 처리 속도가 필요 MPC(Multimedia PC) 멀티미디어가 처리될 수 있는 PC 멀티미디어 관련 기술의 발전 저장 매체 기술의 발전 CD(Compact Disc) 약 650MB의 데이터 저장 용량 다른 기억 장치에 비해 매우 값싼 저장 장치 DVD(Digital Video Disc) 고해상도의 영화 한편을 스테레오 사운드 수준으로 저장할 수 있는 용량을 가진 저장매체 블루레이 디스크(Blu-ray Disc) 고선명(HD) 비디오를 위한 디지털 데이터를 저장할 수 있는 광 기록 방식 저장 매체 용량은 DVD의 5배 정도 멀티미디어의 표준화 제정 멀티미디어 기술이 발전하고 데이터의 호환 요구가 증가함에 따라 자연히 표준화의 필요성이 대두 멀티미디어 분야의 표준은 다양 멀티미디어 데이터의 압축과 복원에 관한 표준 데이터의 전송에 관한 표준 인터넷 웹에 관련한 표준 대표적인 멀티미디어 관련 기술 멀티미디어 관련 장치 및 기술 설명 저장 매체 CD, DVD, 블루레이 디스크 등 멀티미디어 관련 주변 장치 사운드 카드, 그래픽/비디오 가속 보드 등 데이터 압축 및 복원 기술 JPEG, MPEG, MP3 등 아날로그-디지털 데이터 변환 기술 PCM, ADPCM 등 멀티미디어 소프트웨어 도구의 개발 멀티미디어 편집 도구와 저작 도구 등 하이퍼미디어 기술 HTML, XML, DHTML 등 멀티미디어 정보의 호환을 위한 표준화 JPEG, MPEG, XML, SMIL, SVG 등 멀티미디어 통신 기술 이동 통신, 무선 인터넷 등 모바일 멀티미디어 WAP, WML 등 인간과 컴퓨터의 상호 작용 기술의 발전 컴퓨터를 이용하여 다양한 정보를 다루기 위해서는 컴퓨터의 사용이 쉽고 편리해야 함 컴퓨터를 보다 편리하고 쉽게 이용할 수 있도록 인간과 컴퓨터의 상호작용에 관한 기술이 필요 오늘 날의 컴퓨터 사용자에게 편리한 다양한 인터페이스(interface) 제공 인간-컴퓨터 상호 작용(HCI: Human COmputer Interaction) 기술 멀티미디어 데이터는 다양하고 큰 용량을 가지므로 일반 사용자의 정보 검색 쉽지 않음 HCI 기술 멀티미디어 데이터의 입력, 처리, 제어 등을 상호 대화 형태의 조작이 가능하도록 함으로써 인간과 컴퓨터 간의 상호 작용을 쉽고 편리하게 개선하는데 목적 GUI(Graphical User Interface) 기술 사용자의 편리성 제공을 위해 그래픽스 기술이 적용 된 인터페이스 GUI 기술을 이용하여 사용자에게 보다 나은 상호 작용을 지원 음성 인식 기술, 제스처 인식 기술 등 정보 통신 기술의 발전 멀티미디어 데이터를 생성하는 데는 많은 비용과 시간이 필요 따라서 멀티미디어 정보의 공유는 효율성이나 경제성 측면에서 매우 중요 저장 매체를 이용한 멀티미디어 데이터의 저장과 공유는 한계가 있음 따라서 데이터 전송을 위한 정보 통신 망의 발전은 멀티미디어 활용을 위해 필수 멀티미디어 활용 영역은 대부분 인터넷 환경에서 이루어짐 대화형 인터넷 쇼핑, 온라인 게임, 주문형 비디오, 화상회의, 원격 의료, 가상 대학 등 결국 멀티미디어 활용을 위해서는 정보 통신 망의 발전은 필수 요소 특히 초고속 정보 통신 망의 구축은 매우 중요 멀티미디어의 특성멀티미디어의 특성 정보의 디지털화 멀티미디어 데이터를 컴퓨터에서 사용하기 위해서는 디지털화가 필요 정보의 통합 효과적인 정보 전달을 위해서는 멀티미디어 데이터를 통합하여 사용 정보의 상호 작용 개별 사용자의 요구에 맞게 원하는 형태로 데이터를 구성 정보의 공유 인터넷으로 인한 정보의 독점이 없어지고 서로 연결 된 열린 지식 형태 정보의 디지털화 멀티미디어가 컴퓨터에서 처리되기 위해서는 정보가 디지털화 되어야 함 디지털화(digitization) 이미지나 사운드 등의 아날로그 신호를 컴퓨터의 입력으로 사용하기 위해 디지털 형태로 변환하는 것 디지털화의 장점 아날로그 데이터로 존재할 때보다 데이터의 가공과 편집이 용이 데이터의 전송이나 출력에 의한 데이터의 품질 저하를 방지 디지털 데이터로 존재하기 때문에 랜덤 액세스가 가능하여 원하는 데이터의 검색이 용이 정보의 통합 여러 종류의 미디어 매체들이 통합되어 동적인 정보를 전달할 수 있는 특성 과거에는 텍스트, 이미지, 소리, 동영상이 각각의 전용 장치에서만 이용 가능 최근에는 멀티미디어 데이터 정보 처리 기술로 인해 하나의 소프트웨어나 장치를 통해 다양한 형태의 정보를 동시에 저장하고 조작할 수 있음 따라서 그래픽, 오디오, 비디오, 텍스트 등의 멀티미디어 데이터를 광범위하게 통합하여 사용자에게 훨씬 더 효과적인 정보 전달 가능 정보의 상호 작용 개별 사용자의 요구에 맞게 사용자가 원하는 형태로 데이터를 만들어 주는 특성 주문형 비디오(VOD: Video On Demand) 주문형 음악(MOD: Music On Demand) 주문형 게임(GOD: Game On Demand) 주문형 뉴스(NOD: News On Demand) 인터넷 프로토콜 텔레비전(IPTV: Internet Protocol Television) 주문형 비디오나 기존 웹에서 이루어지던 정보 검색과 쇼핑, VoIP(Voicd over Internet Protocol) 등과 같은 인터넷 서비스를 부가적으로 제공 정보의 공유 멀티미디어 정보가 인터넷 상에서 많은 사용자에 의하여 공유 검색 사이트와 포털 방대한 자료를 한데 모아서 하나의 묶음으로 제공함으로써 많은 사용자들이 모이고, 정보를 공유 월드 와이드 웹(WWW: World Wide Web)의 발전 정보의 공유에 대한 개념이 더욱 확산됨 팀 버너스 리(Tim Berners-Lee) 오늘 날의 웹을 웹 2.0으로 정의 웹 2.0 데이터의 소유자나 독점자 없이 누구나 손쉽게 데이터를 생성하고 인터넷에서 공유할 수 있도록 한 사용자 참여 중심의 인터넷 환경 멀티미디어 콘텐츠멀티미디어 콘텐츠의 정의 텍스트, 사운드, 이미지 등의 멀티미디어 데이터를 디지털화하여 생산되고 처리된 각종 정보, 또는 그 내용물 인터넷에서 제공되는 각종 프로그램이나 정보 내용물 비디오 테이프나 CD에 담긴 영화나 음악 전자 출판 등의 출판물 영화나 광고와 같은 영상 각종 게임과 온라인 또는 네트워크 형태로 제공되는 멀티미디어 서비스 등 멀티미디어 콘텐츠의 특징 디지털 데이터 기존의 콘텐츠가 아날로그 위주인데 반해 멀티미디어 콘텐츠는 디지털 데이터로 구성 정보의 상호 작용 사용자와 정보 제공자가 양방향으로 정보를 주고 받는, 즉 생산 소비자(프로슈머: prosumer)의 경향을 보임 시공간 제약의 완화 인터넷의 발달로 인해 시간과 공간의 제약이 완화되어 정보의 확장이 가능 정보에 대한 비선형적인 접근 책을 읽는 것처럼 순차적으로 정보를 받아들이는 것이 아니라 개개인의 능력에 따라 정보의 습득이 비선형적으로 되어 정보 습득 경로가 다양해짐 멀티미디어 콘텐츠의 종류 내용 구성으로 본 콘텐츠 정보 제공이나 교육, 홍보, 엔터테인먼트 등을 위한 콘텐츠 문화 콘텐츠 예술, 디자인, 인문 사회학 등의 문화적 요소를 창의성과 기술을 바탕으로 디지털화한 콘텐츠 상호 작용을 위한 콘텐츠 사용자와의 상호 작용이 가능한 콘텐츠는 사용자의 흥미를 유발 시키고 참여를 유도하는 효과를 얻을 수 있음 멀티미디어 콘텐츠 제작 영화나 게임을 제작하는 것과 매우 유사 멀티미디어 콘텐츠를 성공적으로 제작하기 위해서는 전문가들로 이루어진 개발 인력과 제작 팀 구성원 프로젝트 매니저: 전반적인 관리 및 수행 프로젝트 디자이너: 프로젝트의 기술적인 면을 수행 콘텐츠 전문가: 스토리 보드부터 콘텐츠 제작까지 수행 프로그래머: 준비된 콘텐츠를 S/W 등을 이용하여 제품으로 완성 카피라이터: 프로젝트에 들어갈 텍스트를 준비 그래픽 디자이너: 제품의 시각적인 효과를 위해 준비 제작 목적에 맞춰진 완벽한 제작 과정이 필요 제작 과정 설계 단계 요구 사항 및 구조 디자인 단계 스토리 보드 단계 콘텐츠 제작 단계 저작 단계 평가 단계 배포 단계 유지 보수 단계 정리 하기 멀티미디어란 여러 종류의 미디어인 텍스트, 이미지, 그래픽, 애니메이션 뿐만 아니라 오디오와 비디오를 이용하여 정보가 표현되는 것을 말함 멀티미디어 데이터는 컴퓨터가 읽을 수 있는 형태로 표현된 텍스트, 사운드, 그래픽, 이미지, 애니메이션, 동영상 등을 말함 HCI 기술은 멀티미디어 데이터의 입력, 처리, 제어를 상호 대화 형태의 조작이 가능하도록 함으로써 인간과 컴퓨터 간의 상호 작용을 쉽고 편리하게 개선하는 데 목적이 있음 멀티미디어의 특성은 정보의 디지털화, 정보의 통합, 정보의 상호 작용, 정보의 공유 등 이라고 할 수 있음" }, { "title": "[컴퓨터과학 개론] 1강 - 컴퓨터와 자료", "url": "/posts/knou-cs-1/", "categories": "Computer Science, CS Theory", "tags": "knou, cs", "date": "2025-08-19 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 이관용, 정광식 교수님의 '컴퓨터과학 개론' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 컴퓨터 과학의 주요 분야에 대한 본격적인 학습에 앞서 전체적인 관점에서 기본적인 몇 가지의 개념을 살펴봄 컴퓨터, 컴퓨터 과학이라는 것이 무엇인지를 살펴보고, 컴퓨터 시스템을 구성하는 요소에 대해서 학습함학습 목표 컴퓨터의 정의와 특징을 이해하고 설명할 수 있음 다양한 관점에서의 컴퓨터 과학의 정의를 이해하고 설명할 수 있음 하나의 완전한 컴퓨터 시스템의 구성 요소를 이해하고 설명할 수 있음강의록컴퓨터데이터 처리기(data processor) 컴퓨터의 기능적 측면(입력→ 처리 → 출력)만 정의 너무 포괄적 어떤 형태의 작업을 처리할 수 있는지 불명확함 프로그램이 가능한 데이터 처리기(programmable data processor)프로그램 컴퓨터가 데이터를 어떻게 처리할 지를 알려주는 일련의 명령어 집합 처리 가능한 작업의 유형과 연산의 집합을 결정 컴퓨터 특수 목적의 작업을 처리하는 기계가 아니라 다양한 형태의 작업을 수행할 수 있는 범용의 기계 프로그래밍 과정의 결과물 주어진 문제의 해결 방법과 절차(알고리즘)를 찾음 그것을 적절한 프로그래밍 언어를 사용해 컴퓨터가 이해할 수 있는 형태로 표현 컴퓨터의 장점 신속한 처리 ms(10^-3초), μs(10^-6초), ns(10^-9초), ps(10^-12초) 처리 결과의 정확성 유효한 입력/프로그램이 주어지면 항상 정확한 결과 생성 자동 프로그램 지시에 따라 자동으로 처리 → 사람의 개입이 불필요 대용량 대용량의 데이터 저장 및 처리 컴퓨터 과학데이터의 표현, 저장, 조작, 검색과 밀접히 관련된 분야 컴퓨터 프로그램을 통해서 데이터를 입력하여 처리, 저장, 검색, 출력하는 전자적 장치 데이터의 획득(acquisition), 표현(representation), 처리(processing), 저장(storage), 통신(communication), 접근(access)을 위한 방법들의 실행 가능성, 구조화, 표현, 기계화에 관련 된 내용을 다루는 분야컴퓨터, 데이터, 프로그램 알고리즘에 대한 분야알고리즘과 관련된 이슈를 다루는 분야 주어진 문제를 해결하기 위한 처리 과정을 절차적으로 나열한 명령어들의 집합 알고리즘의 존재 여부 = 문제의 해결 여부 → 컴퓨터의 한계 컴퓨터 과학의 특성 비교적 짧은 역사, 빠른 변화 및 엄청난 영향력 다른 분야와의 밀접한 연관 폭 넓은 연구/응용 범위 수학, 공학, 심리학, 생물학, 언어학, 경영 과학, 물리학, 철학, … 컴퓨터 공학 vs 컴퓨터 과학 컴퓨터 공학 가격 대비 성능 특성이 좋은 컴퓨팅 엔진을 만들기 위해 하드웨어와 소프트웨어 요소의 조립에 중점 컴퓨터 과학 현재의 기술에 덜 의존적인 방식으로 주어진 문제에 대한 해결책의 효율성과 실현 가능성에 보다 중점 컴퓨터를 활용한 문제 해결에 대한 학문 컴퓨터 과학은 퍼즐을 푸는 것과 같아서 멋진 해결 방법을 찾으려는 열정 해결 방법을 평가하기 위해 수학적 분석과 논리 정연함을 사용할 수 있는 능력 추상화를 통해 복잡한 문제의 모델링 과정에서 발휘할 수 있는 창의성 상세한 내용에 숨겨진 가정에 대해 주의를 기울일 수 있는 능력 동일한 문제라도 다른 환경에서의 차이점을 인지할 수 있는 능력 잘 알려진 효율적 해결 방법을 새로운 환경의 문제에 적용할 수 있는 능력컴퓨터 시스템컴퓨터 시스템의 구성 요소 데이터, 하드웨어, 소프트웨어, 사용자 시스템 특정한 목적을 달성하기 위해 여러가지 구성 요소들이 상호작용하고 유기적으로 이루어진 것 하드웨어 컴퓨터라는 기계를 구성하고 있는 모든 물리적인 기계 장치/전자 장치 핵심 장치 폰 노이만 모델에서 제시한 4개의 서브 시스템 폰 노이만(John von Neumann) 모델 컴퓨터의 내부 구조와 처리 과정을 정의한 모델 모든 컴퓨터는 폰 노이만 모델에 기반을 두고 있음 중앙 처리 장치(CPU: Central Processing Unit) 제어 장치(CU: Control Unit) 산술 논리 연산 장치(ALU: Arithmetic and Logic Unit) 기억 장치 주 기억 장치, 보조 기억 장치 처리할 입력 데이터, 처리를 담당하는 프로그램, 중간 결과, 출력할 데이터 산술 논리 연산 장치 산술 연산과 논리 연산의 수행을 통해 직접적인 데이터 처리가 이루어지는 장치 제어 장치 컴퓨터의 기억 장치, 산술 논리 연산 장치, 입 출력 장치의 동작을 제어하는 장치 입력 장치 키보드, 마우스, 마이크 등 보조 기억 장치(디스크,..) 출력 장치 모니터, 프린터, 스피커 등 보조 기억 장치(디스크,..) 하드웨어 요소 간의 통신폰 노이만 모델의 주요 개념 내장 프로그램(stored program) 실행될 프로그램은 메모리에 저장되어야 한다. 초기 컴퓨터에서는 데이터만 메모리에 저장되고, 프로그램은 컴퓨터 외부에 표현되는 방식 프로그램과 데이터가 동일한 형식으로 메모리에 표현된다는 의미 동일한 형식 → 비트 패턴 프로그램은 유한 개의 명령어의 나열이다. 미리 정의된 기본 명령어의 유한 개의 조합으로 구성됨 제어 장치가 메모리에서 한 번에 하나씩 명령어를 가져와서(fetch) 해석하고(decode) 산술 논리 연산 장치가 실행함(execute) 명령어의 재 사용으로 인해 프로그래밍 작업이 간단해짐 소프트웨어 모든 종류의 프로그램을 총체적으로 표현하는 용어 컴퓨터가 데이터를 어떻게 처리할 것인 가를 규정하는 명령어들의 나열 컴퓨터가 이해할 수 있도록 표현된 알고리즘 하드웨어와 소프트웨어의 관계 분류 시스템 소프트웨어 컴퓨터 자체의 작업 관리와 특정 기능의 수행을 통해 컴퓨터의 전체적인 운영을 담당하는 프로그램 운영체제, 컴파일러 등 응용 소프트웨어 사용자가 요구하는 작업을 직접적으로 수행하는 프로그램 워드프로세서, 그래픽 프로그램, 웹 브라우저 등 데이터 모든 데이터는 유형에 관계 없이 비트 패턴으로 표현 비트 패턴 이진 상태를 나타내는 비트 0, 1이 나열 된 형태 폰 노이만 모델에서는 데이터의 표현 및 저장 형태에 대해서 정의하지 않음 데이터의 입출력을 위해서는 적절한 형태로의 변환 필요 사용자 사용자, 오퍼레이터 컴퓨터의 설계부터 효율적인 이용에 이르기까지 전반적인 데이터 처리 과정에서 유능하고 지식이 풍부한 사람의 적극적인 개입 필요 정리 하기 컴퓨터 프로그램이 가능한 데이터 처리기 장점 신속, 정확, 자동, 대용량 컴퓨터 과학 데이터의 획득, 표현, 처리, 저장, 통신, 접근과 관련 된 학문 컴퓨터, 데이터, 프로그램, 알고리즘에 대한 학문 알고리즘과 관련 된 이슈를 다루는 학문 컴퓨터를 활용한 문제 해결에 대한 학문 컴퓨터 시스템 구성 요소 하드웨어, 소프트웨어, 데이터, 사용자 핵심 하드 웨어 CPU(산술 논리 연산 장치, 제어 장치), 기억 장치, 입출력 장치 폰 노이만 모델 내장 프로그램, 프로그램은 유한 개의 명령어 나열 연습 문제 컴퓨터를 데이터 처리기라는 관점으로 정의하려고 한다. 이때 처리 가능한 작업의 유형과 연산의 집합을 결정하는 것은 무엇인가? a. 프로그램 컴퓨터 → 프로그램이 가능한 데이터 처리기(programmable data processor) 데이터 처리기의 기본 기능 데이터의 입력(input) → 처리(process) → 결과 출력(output) 프로그램은 컴퓨터에서 처리 가능한 작업의 유형과 연산의 집합을 결정하며, 이를 통해 컴퓨터는 다양한 형태의 작업을 처리할 수 있는 범용의 기계가 됨 컴퓨터 과학은 데이터 처리 관점에 필요한 다음과 같은 4가지 요소를 통해서 정의할 수 있다. 빈칸에 들어갈 내용으로 적절하지 못한 것은? 컴퓨터 과학은 ( ), ( ), ( ), ( ) 분야의 연구를 통해 효율적인 자료 처리를 위한 제반 기술과 방법을 제공한다. a. 정보 다양한 관점에서의 컴퓨터 과학의 정의 데이터의 획득, 표현, 처리, 저장, 통신, 접근을 위한 방법들의 실행 가능성, 구조화, 표현, 기계화에 관련된 내용을 다루는 학문 분야 컴퓨터, 데이터, 프로그램, 알고리즘 분야의 연구를 통해 효율적인 자료 처리를 위한 제반 기술과 방법들을 제공하기 위한 학문 알고리즘과 관련된 이슈를 다루는 학문 → 컴퓨터 과학의 모든 관련 분야를 “알고리즘” 중심으로 이해 가능 컴퓨터를 활용한 문제 해결에 대한 학문 하나의 완전한 컴퓨터 시스템을 구성하는 4가지 요소로서 거리가 먼 것은? a. 인터넷 완전한 컴퓨터 시스템을 구성하는 4가지 요소 하드웨어, 소프트웨어, 데이터, 사용자 폰 노이만 모델과 관련된 설명 중 올바르지 못한 것은? a. 데이터는 비트 패턴으로 저장되어야 함을 정의하고 있다. 폰 노이만 모델 컴퓨터의 내부 구조와 처리 과정을 정의한 모델 4개의 서브 시스템(기억 장치, 산술 논리 연산 장치, 제어 장치, 입출력 장치)으로 구성 기존 프로그래밍의 개념을 완전히 바꿔 놓은 주요 개념 내장 프로그램 데이터와 함께 실행될 프로그램은 메모리에 저장되어야 함 데이터와 프로그램이 같은 메모리에 저장된다는 것은 같은 형식(“비트 패턴”)으로 저장된다는 의미를 내포 하지만 실제로 데이터가 컴퓨터에 어떻게 저장되어야 하는 지에 대해서는 정의하고 있지 않음 프로그램은 명령어의 나열임 기본 명령어들을 미리 정의하고, 이들의 유한 개의 조합으로 원하는 프로그램을 작성할 수 있음 명령어들의 재 사용성으로 인해 프로그래밍 작업이 간단해질 수 있음 폰 노이만 모델과 관련 된 설명은? 컴퓨터의 내부 구조와 처리 과정을 정의한 모델임 내장 프로그램(stored-program) 방식을 제안하고 있음 데이터와 함께 실행될 프로그램도 메모리에 저장되어야 함 정리 하기 컴퓨터 컴퓨터 프로그램이 가능한 데이터 처리기 프로그램 컴퓨터가 데이터를 어떻게 처리(조작)할 지를 알려주는 일련의 명령어의 집합으로, 컴퓨터에서 처리 가능한 작업의 유형과 연산의 집합을 결정 컴퓨터 장점(특징) 신속, 정확, 자동, 대용량 컴퓨터 과학 데이터의 획득, 표현, 처리, 저장, 통신, 접근을 위한 방법들의 실행 가능성, 구조화, 표현, 기계화에 관련된 내용을 다루는 학문 분야 컴퓨터, 데이터, 프로그램, 알고리즘 분야의 연구를 통해 효율적인 자료 처리를 위한 제반 기술과 방법들을 제공하기 위한 학문 알고리즘과 관련된 이슈를 다루는 학문 컴퓨터를 활용한 문제 해결에 대한 학문 컴퓨터 공학 vs 컴퓨터 과학 컴퓨터 공학 가격 대비 성능 특성이 가장 좋은 컴퓨터 엔진을 만들기 위해 하드웨어와 소프트웨어 요소를 조립하는 방법에 중점을 둠 컴퓨터 과학 현재의 기술에 덜 의존적인 방식으로 주어진 문제에 대한 해결책이 효율적이고 실현 가능하도록 하는데 초점을 맞춤 컴퓨터 시스템 하나의 완전한 컴퓨터 시스템을 구성하는 4가지 요소 하드웨어, 소프트웨어, 데이터, 사용자 하드웨어 기계를 구성하고 있는 모든 물리적 기계 장치 및 전자 장치 핵심 장치 중앙 처리 장치(산술 논리 연산 장치, 제어 장치) 기억 장치(주 기억 장치, 보조 기억 장치) 입력 장치 출력 장치 소프트웨어 모든 프로그램을 총체적으로 표현하는 것 시스템 소프트웨어와 응용 소프트웨어로 구분 데이터 컴퓨터가 처리하는 대상으로 컴퓨터 내부에서 비트 패턴으로 변환되어 처리되며, 우리가 알아볼 수 있도록 적절한 변환 과정을 다시 거쳐 출력 됨 사용자 컴퓨터가 데이터를 처리하는 전반적인 과정에 다양하고 적극적인 형태로 사람의 개입이 필요 폰 노이만 모델 컴퓨터의 내부 구조와 처리 과정을 정의한 모델 모든 컴퓨터는 폰 노이만 모델에 기반을 둠 4개의 서브 시스템(산술 논리 연산 장치, 제어 장치, 기억 장치, 입출력 장치)으로 구성 내장 프로그램 방식 데이터와 함께 실행될 프로그램은 메모리에 저장되어야 함 데이터와 프로그램이 같은 메모리에 저장된다는 것은 같은 형식(“비트 패턴”)으로 저장된다는 의미를 내포 프로그램은 명령어의 나열임 기본 명령어들을 미리 정의하고, 이들의 유한 개의 조합으로 원하는 프로그램이 구성 됨 " }, { "title": "[C++ 프로그래밍] 15강 - 예외 처리", "url": "/posts/knou-cpp-15/", "categories": "Language, CPP", "tags": "knou, cpp", "date": "2025-07-02 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 이병래 교수님의 'C++ 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 프로그램이 동작하는 상황은 항상 정상적인 것은 아니며, 때로는 정상적인 동작을 할 수 없는 상황이 발생할 수 있음 이러한 경우를 고려하지 않고 프로그램을 작성하면 프로그램이 실행되는 동안 여러 가지 문제가 발생하여 비정상적인 에러가 발생하게 됨 그러므로 프로그램을 설계할 때는 정상적이지 않은 상황이 발생하는 것을 고려하여 이에 적절히 대처할 수 있도록 대비하는 것이 필요함 이러한 처리를 예외 처리라고 하며 C++에서는 예외를 처리하기 위한 문장과 클래스를 제공함학습 목표 예외의 개념을 설명할 수 있음 C++ 언어의 예외 처리 체계를 설명할 수 있음 예외 처리를 위한 구문을 사용하여 정상적이지 않은 상황에 대처할 수 있는 프로그램을 작성할 수 있음 예외 처리를 클래스를 이용하여 다양한 상황에 대한 예외의 발생 및 관련 데이터를 전달할 수 있는 프로그램을 작성할 수 있음주요 용어 예외(exception) 프로그램이 실행되는 도중에 발생할 수 있는 비정상적인 상황 예외 처리(exception handling) 프로그램 실행 중 예외가 발생하였을 때를 대비하여 마련해 놓은 처리 절차에 따라 대응하는 것 활성화 레코드(activation record) 함수가 호출되었을 때 복귀할 지점, 매개 변수, 지역 변수 등을 저장하는 데이터 집합 스마트 포인터(smart pointer) 자동적인 메모리 관리 기능 등이 추가된 포인터를 구현하는 추상 데이터 타입 예외 처리 클래스 예외 상황 발생 및 이에 대한 구체적 원인 등을 예외 처리 블록에 전달하기 위한 목적으로 선언한 클래스 강의록예외의 개념예외 예외(exception)란? 프로그램 실행 도중에 발생할 수 있는 비정상적인 사건 비정상적인 데이터, 자원의 부족 등 예외 상황에 대한 적절한 대비를 하지 않으면 프로그램이 안정적으로 실행되지 않는 문제가 일어날 수 있음 예외 처리(exception handling) 프로그램 실행 중 예외가 발생하였을 때를 대비하여 마련해 놓은 처리 절차에 따라 대응하는 것 예외가 발생하는 상황의 예 정상적인 처리를 할 수 없는 데이터 기본 코드 double hmean(double a, double b) // 조화평균 { return 2.0 * a * b / (a + b); } a == -b인 경우 실행 중 프로그램 비정상 종료 exit()사용 double hmean(double a, double b) // 조화평균 { if (a == -b) { cout &lt;&lt; \"나누기를 할 수 없습니다.\" &lt;&lt; endl; exit(EXIT_FAILURE); // 프로그램 강제 종료 } return 2.0 * a * b / (a + b); } a == -b인 경우 이를 알리고, 프로그램 강제 종료 프로그램이 요청하는 자원을 할당할 수 없는 경우 new(nothrow)사용 void f() { int *p = new(nothrow) int[100000000]; // 할당된 메모리의 활용 } 메모리 할당에 실패한 경우 실행 중 에러가 발생하여 프로그램이 비정상적으로 종료함 new(nothrow)를 이용한 메모리 할당 오류 검사 void f() { int *p = new(nothrow) int[100000000]; if (!p) { // p가 nullptr이면 cerr &lt;&lt; \"메모리 할당 오류\" &lt;&lt; endl; exit(EXIT_FAILURE); } } 메모리 할당이 이루어지지 않은 경우 new(nothrow)는 nullptr를 반환하므로, 이를 이용하여 메모리 할당 오류를 검사함 C++ 언어의 예외 처리 체계C++ 언어의 예외 처리 구문 try블록, catch블록, 그리고 throw문장으로 구성 예외를 처리하는 함수 RetType1 someFunction() { try { // 예외가 발생할 수 있는 부분 someDangerousFunction(); } catch (eClass e) { // 발생한 예외를 처리하는 부분 exceptionProcRtn(); } } 예외를 던지는 함수 RetType2 someDangerousFunction() { if (예외검출조건) throw eObj; // 예외 발생을 알림 else // 정상적인 처리 } 예외 처리의 예 - HMean.cpp HMean.cpp #include &lt;iostream&gt; using namespace std; double hmean(double a, double b) // 조화평균 { if (a == -b) // 예외 검출 throw \"조화평균을 계산할 수 없습니다!\"; return 2.0 * a * b / (a + b); } int main() { double x, y, z; char cFlag = 'y'; while (cFlag != 'n') { cout &lt;&lt; \"\\\\n두 수를 입력하시오 : \"; cin &gt;&gt; x &gt;&gt; y; try { // 예외 발생 가능성이 있는 코드 z = hmean(x, y); cout &lt;&lt; \"조화평균 = \" &lt;&lt; z &lt;&lt; endl; } catch (const char* s) { // 예외 처리 cout &lt;&lt; s &lt;&lt; endl; } cout &lt;&lt; \"계속 할까요? (y/n) : \"; cin &gt;&gt; cFlag; } return 0; } 예외 유형 별 처리 하나의 try블록에 여러 개의 catch블록 사용 try { // 예외가 발생할 가능성이 있는 함수 호출 } // throw된 객체의 자료형에 맞는 매개변수가 선언된 catch 블록에서 예외 처리함 catch (eClass1 e) { // 예외 처리 블록1 } catch (eClass2 e) { // 예외 처리 블록2 } catch (...) { // 그 외의 모든 예외 처리 } // 다음 문장 제어의 전달 정상적인 제어의 흐름 정상적인 호출 및 복귀 절차에 따라 실행됨 예외가 발생한 경우 제어의 흐름 발생된 예외를 처리하기 위한 catch블록으로 함수 호출 스택을 따라 이동 예외 처리에 따른 자원 관리 문제 자원 소실이 가능한 상황 void f() { int *p = new int[1000]; for (int i = 0; i &lt; 1000; i++) p[i] = i; if (ex_condition) throw \"exception\"; delete[] p; // throw 명령이 실행되면 나머지 문장들은 실행되지 않음 } 예외를 처리할 catch블록으로 복귀할 때 f()가 호출될 때까지 거쳐온 함수들의 지역 변수들은 정상적인 소멸 과정을 거침 스마트 포인터의 활용 unique_ptr 할당된 메모리를 한 개의 포인터만 가리킬 수 있음 다른 unique_ptr에 대입할 수 없으며, 이동 대입만 할 수 있음 unique_ptr가 제거되거나 nullptr를 대입하면 가리키고 있던 메모리를 반납함 shared_ptr 할당된 메모리를 여러 개의 포인터로 가리킬 수 있음 다른 shared_ptr에 대입 및 이동 대입 가능 포인터가 제거되거나 nullptr를 대입하는 등의 처리로 그 메모리를 가리키는 shared_ptr이 더 이상 없으면 메모리를 반납함 스마트 포인터의 활용 예 #include &lt;iostream&gt; #include &lt;memory&gt; using namespace std; int main() { unique_ptr&lt;int&gt; p1{ new int }; unique_ptr&lt;int&gt; p2; *p1 = 10; cout &lt;&lt; *p1 &lt;&lt; endl; p2 = move(p1); // p2 = p1;은 불가 cout &lt;&lt; *p2 &lt;&lt; endl; p2 = nullptr; // 가리키고 있던 메모리는 해제됨 return 0; } 예외 처리로 인한 자원 소실 방지 unique_ptr활용 #include &lt;memory&gt; void f() { std::unique_ptr&lt;int[]&gt; p { new int[1000] }; for (int i = 0; i &lt; 1000; i++) p[i] = i; if (ex_condition) throw \"exception\"; } vector활용 #include &lt;vector&gt; void f() { std::vector&lt;int&gt; p(1000); for (int i = 0; i &lt; 1000; i++) p[i] = i; if (ex_condition) throw \"exception\"; } noexcept지정자 noexcept함수 지정 함수가 예외를 일으키지 않음을 지정 template &lt;typename T&gt; T max(const vector&lt;T&gt;&amp; v) noexcept { auto p = v.begin(); T m = *p; for (; p != v.end(); p++) if (m &lt; *p) m = *p; return m; } 예외 처리 클래스클래스에서 예외 처리 활용하기 예외 처리 클래스의 활용 클래스 설계 시 예외 처리 기능을 포함 시킴으로써 객체에서 예외가 발생하였을 때 그 위치나 원인 등의 식별을 용이하게 할 수 있음 클래스 선언문 내에 예외 처리 담당 클래스를 선언하여 활용함 클래스의 예외 처리 활용 예 - IntArray1.h 클래스 정의 const int DefaultSize = 10; class Array { int *buf; int size; public: Array(int s = DefaultSize); virtual ~Array() { delete[] buf; } int&amp; operator[](/assets/img/knou/cpp/2025-07-02-knou-cpp-15/int offset); const int&amp; operator[](/assets/img/knou/cpp/2025-07-02-knou-cpp-15/int offset) const; int getsize() const { return size; } friend ostream&amp; operator&lt;&lt;(ostream&amp;, Array&amp;); class BadIndex {}; // exception class }; 클래스의 예외 처리 활용 예 - IntArray1.cpp 생성자 및 operator[]구현 #include \"IntArray1.h\" using namespace std; Array::Array(int s) : size(s) { buf = new int[s]; memset(buf, 0, sizeof(int) * s); } int&amp; Array::operator[](/assets/img/knou/cpp/2025-07-02-knou-cpp-15/int offset) { if (offset &lt; 0 || offset &gt;= size) // 예외조건 검사 throw BadIndex(); // 예외객체 생성 및 전달 return buf[offset]; } 클래스의 예외 처리 활용 예 - IA1Main.cpp 메인 함수 및 예외 처리 #include &lt;iostream&gt; #include \"IntArray1.h\" using namespace std; int main() { Array arr(10); try { for (int i = 0; i &lt; 10; i++) arr[i] = i; // arr[10] = 10; // 인덱스 범위를 벗어나는 접근 } catch (Array::BadIndex e) { cerr &lt;&lt; \"인덱스 범위 오류\" &lt;&lt; endl; } cout &lt;&lt; arr &lt;&lt; endl; return 0; } 예외 객체의 멤버를 통한 예외 정보 전달 IntArray1.h class Array { public: class BadIndex { public: int wrongIndex; BadIndex(int n) : wrongIndex(n) {} }; }; IntArray1.cpp int&amp; Array::operator[](/assets/img/knou/cpp/2025-07-02-knou-cpp-15/int offset) { if (offset &lt; 0 || offset &gt;= size) throw BadIndex(offset); return buf[offset]; } IA1Main.cpp int main() { // Array 객체 사용 // try { // } catch (Array::BadIndex e) { cout &lt;&lt; \"인덱스 범위 오류 --&gt; \" &lt;&lt; e.wrongIndex &lt;&lt; endl; } // } exception클래스 exception클래스 C++ 언어에서 예외를 처리하기 위해 예외 처리 담당 클래스의 기초 클래스를 제공하는 클래스 헤더 파일 &lt;exception&gt;을 소스 파일에 포함 시킴 가상 함수 what()을 멤버 함수로 가지고 있음 예외의 종류를 char*형태로 반환함 exception의 파생 클래스에서 재 정의하여 사용함 IntArray1.h 수정 #include &lt;exception&gt; class Array { public: class BadIndex : public exception { public: int wrongIndex; BadIndex(int n) : wrongIndex(n), exception() {} const char* what() const { return \"Array Exception::\"; } }; }; 예외 객체의 다시 던지기 catch블록에서 처리를 완결 할 수 없는 예외의 전달 현 단계의 catch블록에서 처리를 완결할 수 없는 예외에 대한 후속 처리를 할 수 있게 예외 객체를 다시 throw할 수 있음 class ExceptionClass:public exception {};int f(int a) { if (a &lt; 0) throw ExceptionClass();}int g(int x) { try { f(x); } catch (ExceptionClass e) { // 현 단계의 예외 처리 throw; // 예외 객체를 다시 던지기 }}int h(int c) { try { g(c); } catch (ExceptionClass e) { throw; // 후속 예외 처리 }}연습 문제 위 지문과 같이 함수가 정의되어 있다. condition이 false일 경우 함수 f()에 의해 출력되는 내용은? class eCls { }; void g() { if (condition) throw 10; else throw eCls(); } void f() { try { g(); } catch (char* s) { cout &lt;&lt; \"예외1 발생\"; } catch (int e) { cout &lt;&lt; \"예외2 발생\"; } catch (...) { cout &lt;&lt; \"예외3 발생\"; } } a. 예외3 발생 condition이 false이면 함수 g()는 eCls 객체를 전달함 함수 f()의 catch블록은 char*, int, 그외의 모든 예외 객체(‘…‘으로 표기함)에 대해 정의되어 있으며, eCls 객체는 char*도 아니고 int도 아니므로 catch (...)에 의해 처리 됨 다음 중 프로그램 실행 중 예외 발생하였음을 알리기 위해 사용하는 명령은? a. throw 예외가 발생할 가능성이 있는 곳에서는 이를 검사하여 예외 상황에 해당되는 경우 throw명령으로 예외 객체를 던짐 이렇게 발생한 예외를 처리하는 구문은 try블록과 catch블록으로 구성함 try블록에는 예외가 발생할 가능성이 있는 처리를 하는 부분이며, 만일 예외 상황에 해당되는 경우 throw명령으로 예외 객체를 던짐 이 예외는 catch블록에서 선택적으로 받아 예외의 종류에 맞는 처리를 함 함수를 선언할 때 noexcept를 지정하는 것은 어떤 의미인가? a. 그 함수가 예외를 일으키지 않음을 지정함 noexcept는 함수가 예외를 발생 시키지 않는다는 것을 지정하기 위한 키워드임 이것은 예외가 발생되지 않을 것이 확실한 경우 컴파일러가 예외 처리 시퀀스를 고려할 필요가 없음을 알림으로써 컴파일러가 최적화를 하는 데 도움을 줌 위 지문 함수 f()의 실행에 대한 설명으로 옳은 것은? class A { }; void f( ) { int *p = new int[100]; A objA; if (ex_condition) throw \"exception\"; delete[ ] p; } a. ex_condition이 참일 경우 할당된 메모리가 소실되는 문제가 있다. ex_condition이 참이면 throw명령을 실행하게 되되, 이때 함수의 나머지 명령은 실행하지 않음 따라서 new연산자로 동적으로 할당되어 p가 가리키고 있는 메모리에 대한 delete연산이 실행되지 않으며, 결과적으로 할당된 메모리를 어느 것도 가리키고 있지 않아 메모리 소실이 일어남 그러나 throw명령으로 함수에서 나가는 경우에도 지역 변수는 제거되며, 이 과정에서 객체의 소멸자가 동작함 정리 하기 예외란 프로그램이 실행되는 도중에 발생할 수 있는 비정상적인 사건을 의미함 try블록은 예외가 발생할 가능성이 있는 문장을 포함함 catch블록은 throw명령을 통해 전달 된 예외 객체의 유형에 따라 적절한 예외 처리를 하는 문장을 포함함 예외 상황이 발생되면 throw명령으로 이를 알림 클래스 내에 예외 처리 담당 클래스를 선언하여 발생한 예외의 위치나 원인을 식별하게 할 수 있음 exception클래스는 예외 처리 담당 클래스의 기초 클래스로서, 예외의 종류를 char*형태로 반환하는 가상함수 what()을 포함함" }, { "title": "[C++ 프로그래밍] 14강 - 템플릿", "url": "/posts/knou-cpp-14/", "categories": "Language, CPP", "tags": "knou, cpp", "date": "2025-06-30 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 이병래 교수님의 'C++ 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 C++ 언어에서는 프로그램 작성에 유용하게 활용할 수 있는 표준 템플릿 라이브러리(STL)를 제공함 STL에서 제공하는 컨테이너, 반복자, 알고리즘을 이해하고, 이를 활용하기 위한 여러 가지 구문들에 대하여 학습함 STL 컨테이너 중 vector와 map의 예를 통해 순차 컨테이너와 연상 컨테이너의 활용 방법에 대하여 학습함학습 목표 표준 템플릿 라이브러리(STL)의 구성 요소를 이해할 수 있음 STL의 vector클래스 템플릿을 사용할 수 있음 STL의 map클래스 템플릿을 사용할 수 있음주요 용어 표준 템플릿 라이브러리(STL) C++의 표준 라이브러리로 제공되는 컨테이너 클래스 템플릿 순차 컨테이너 선형적인 구조로 객체들을 저장하는 컨테이너 연상 컨테이너 인덱스 구조를 이용하여 키를 이용한 검색 기능을 제공하는 컨테이너 무순서 연상 컨테이너 해시 함수를 이용하여 키를 이용한 검색 기능을 제공하는 컨테이너 반복자(iterator) STL에서 컨테이너에 저장된 객체에 대한 포인터 역할을 하는 것 STL 알고리즘 STL에서 컨테이너의 원소에 대해 적용할 수 있도록 제공되는 여러 가지 연산의 집합 함수 객체(function object, functor) 마치 함수인 것처럼 호출하여 사용할 수 있는 객체 강의록표준 템플릿 라이브러리(STL)표준 템플릿 라이브러리 표준 템플릿 라이브러리(Standard Template Library, STL)이란? C++에 제공되는 표준 컨테이너 클래스 템플릿 라이브러리 벡터, 리스트, 스택, 큐 등의 컨테이너와 이들을 처리하기 위해 사용할 수 있는 여러 가지 연산을 포함함 STL의 구성 요소 컨테이너(container) 데이터 저장 반복자(iterator) 포인터의 역할 알고리즘(algorithm) 데이터 처리 기능 STL 컨테이너 데이터 저장을 위한 템플릿의 집합 int나 float과 같은 기본 자료형 데이터나 사용자 정의 클래스의 객체 등을 저장함 다양한 연산이 제공되어 편리하게 데이터를 활용할 수 있음 배열 역시 일종의 컨테이너의 역할을 하지만, 배열을 조작하기 위한 연산(데이터 삽입, 삭제, 검색 등)을 프로그래머가 모두 구현해야 함 STL 컨테이너의 종류 순차 컨테이너 동일한 자료형의 객체들을 선형적인 구조로 저장함 종류 특성 vector 크기의 확장이 가능한 배열   []연산자로 지정한 첨자를 이용하여 빠른 직접 접근   끝에 삽입(또는 삭제)하는 것은 빠르나 그 외의 위치에 삽입(또는 삭제)하는 것은 느림 list 이중 연결 리스트   어느 위치든 삽입이나 삭제가 효율적임   직접 접근이 비효율적이므로 제공하지 않음 deque vector와 list의 혼합 형태로, 이들의 특성이 모두 필요할 때 사용할 수 있으나 성능은 낮음 연상 컨테이너 탐색 트리와 같은 인덱스 구조를 이용하는 컨테이너 키를 이용한 효율적인 검색 기능을 제공함 종류 특성 set 키 객체만 저장하며, 키가 중복되지 않음 multiset 키 객체만 저장하며, 동일한 키가 중복될 수 있음 map (키 객체, 값 객체)의 쌍을 저장   키가 중복되지 않음 multimap (키 객체, 값 객체)의 쌍을 저장   동일한 키가 중복될 수 있음 무순서 연산 컨테이너 연산 컨테이너처럼 키를 이용한 검색 기능을 제공 해시 함수를 이용하여 데이터 검색 시간이 일정함 종류 특성 unordered_set set, multiset, map, multimap과 같으나 해시 함수를 이용하여 저장 및 검색을 함 unordered_multiset set, multiset, map, multimap과 같으나 해시 함수를 이용하여 저장 및 검색을 함 unordered_map set, multiset, map, multimap과 같으나 해시 함수를 이용하여 저장 및 검색을 함 unordered_multimap set, multiset, map, multimap과 같으나 해시 함수를 이용하여 저장 및 검색을 함 컨테이너 어댑터 기본 컨테이너를 기반으로 특정 용도에 맞게 유도된 컨테이너 종류 특성 queue FIFO(First In, First Out) 구조 priority_queue 우선 순위에 따라 데이터를 액세스할 수 있는 구조 stack LIFO(Last In, First Out) 구조 반복자(iterator)란? 포인터의 개념이 일반화된 것 컨테이너의 유형에 따라 서로 다른 형태의 반복자가 사용됨 종류 특성 순방향(forward) 반복자 컨테이너의 순방향으로만 움직일 수 있음   ++연산자 사용 양방향(bidirectional) 반복자 컨테이너의 순방향과 역방향으로 움직일 수 있음   ++, --연산자 사용 랜덤 액세스 반복자 양방향 반복자의 기능과 함께 임의의 위치로 이동할 수 있음 STL 활용 예 - vectorvector vector란? 1차원 배열의 개념을 구현한 순차 컨테이너 유형의 클래스 템플릿 배열의 일반적인 기능을 포함하면서 여러 가지 유용한 멤버 함수 및 관리 기능이 도입되어 있음 배열처럼 크기가 고정되어 있지 않고 필요에 따라 저장 공간을 확장할 수 있음 필요한 헤더 파일 &lt;vector&gt; vector객체의 선언 구문 vector&lt;ClassName&gt; objName(n); n 벡터에 저장할 객체의 수 ex) 10개의 float 값을 저장하는 vector의 선언 vector&lt;float&gt; fVector(10); []연산자 vector에 대한 직접 접근 연산자 배열처럼 첨자를 지정하여 원소를 직접 접근할 수 있게 함 []연산자의 사용 예 vector&lt;float&gt; fVector(10); fVector[2] = 10.0f; cout &lt;&lt; fVector[2]; 첨자가 올바른 범위의 값인지 검사하지 않음 vector&lt;float&gt; fVector(10); fVector[12] = 10.0f; // 실행 중 에러 발생 멤버 함수 at() 직접 접근을 위한 멤버 함수 첨자의 범위를 검사함 지정된 첨자가 범위를 벗어날 경우 예외 발생 at()함수의 사용 예 vector&lt;int&gt; iVector = { 1, 2, 3, 4 }; iVector.at(2) = 10; cout &lt;&lt; iVector.at(2) &lt;&lt; endl; cout &lt;&lt; iVector.at(4) &lt;&lt; endl; // 예외 발생 멤버 함수 size()와 capacity() vector는 크기는 실행 중 확장할 수 있음 미래의 확장에 대비하여 여분의 공간을 미리 확보할 수 있음 논리적인 vector의 크기와 실제 할당된 메모리의 크기는 다를 수 있음 멤버 함수 push_back()과 pop_back() vector의 끝에 데이터를 저장하거나 꺼냄 멤버 함수 insert()와 erase() vector의 지정된 위치에 데이터를 삽입하거나 삭제함 함수의 실행에 따라 size()의 값은 증가하거나 감소함 capacity()의 값은 데이터 추가로 인해 확보된 메모리가 부족하여 확장될 때 바뀜 vector의 사용 예 - Vector1.cpp#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; intVec(5); // 벡터 객체 생성 for (int i = 0; i &lt; intVec.size(); i++) { intVec[i] = i + 1; } cout &lt;&lt; \"벡터의 논리적 크기 : \" &lt;&lt; intVec.size() &lt;&lt; endl; cout &lt;&lt; \"벡터의 물리적 크기 : \" &lt;&lt; intVec.capacity() &lt;&lt; endl; cout &lt;&lt; \"저장된 데이터 : \"; for (int i = 0; i &lt; intVec.size(); i++) { cout &lt;&lt; intVec[i] &lt;&lt; \" \"; } cout &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; \"1개의 데이터 push_back\" &lt;&lt; endl; intVec.push_back(11); cout &lt;&lt; \"벡터의 논리적 크기 : \" &lt;&lt; intVec.size() &lt;&lt; endl; cout &lt;&lt; \"벡터의 물리적 크기 : \" &lt;&lt; intVec.capacity() &lt;&lt; endl; cout &lt;&lt; \"저장된 데이터 : \"; for (int i = 0; i &lt; intVec.size(); i++) cout &lt;&lt; intVec[i] &lt;&lt; \" \"; cout &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; \"5개의 데이터 push_back\" &lt;&lt; endl; for (int i = 1; i &lt;= 5; i++) intVec.push_back(i + 11); cout &lt;&lt; \"벡터의 논리적 크기 : \" &lt;&lt; intVec.size() &lt;&lt; endl; cout &lt;&lt; \"벡터의 물리적 크기 : \" &lt;&lt; intVec.capacity() &lt;&lt; endl; cout &lt;&lt; \"저장된 데이터 : \"; for (int i = 0; i &lt; intVec.size(); i++) cout &lt;&lt; intVec[i] &lt;&lt; \" \"; cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; \"3개의 데이터 pop_back\" &lt;&lt; endl; for (int i = 0; i &lt; 3; i++) { intVec.pop_back(); } cout &lt;&lt; \"벡터의 논리적 크기 : \" &lt;&lt; intVec.size() &lt;&lt; endl; cout &lt;&lt; \"벡터의 물리적 크기 : \" &lt;&lt; intVec.capacity() &lt;&lt; endl; cout &lt;&lt; \"저장된 데이터 : \"; for (int i = 0; i &lt; intVec.size(); i++) { cout &lt;&lt; intVec[i] &lt;&lt; \" \"; } cout &lt;&lt; endl; return 0;}// 벡터의 논리적 크기 : 5// 벡터의 물리적 크기 : 5// 저장된 데이터 : 1 2 3 4 5// 1개의 데이터 push_back// 벡터의 논리적 크기 : 6// 벡터의 물리적 크기 : 7// 저장된 데이터 : 1 2 3 4 5 11// 5개의 데이터 push_back// 벡터의 논리적 크기 : 11// 벡터의 물리적 크기 : 15// 저장된 데이터 : 1 2 3 4 5 11 12 13 14 15 16// 3개의 데이터 pop_back// 벡터의 논리적 크기 : 8// 벡터의 물리적 크기 : 15// 저장된 데이터 : 1 2 3 4 5 11 12 13vector의 크기 확장 및 데이터 조작 함수 함수 용도 push_back(value) 끝에 데이터를 추가 pop_back() 끝에 있는 데이터를 제거 resize(n) 논리적 크기의 변경 reserve(n) capacity()가 최소한 n을 반환하도록 확장 empty() 비어 있는 벡터의 경우 true반환 erase(it) 반복자 it가 가리키는 위치 삭제 erase(it1, it2) [it1, it2)범위의 데이터 삭제 insert(it, value) 반복자 it가 가리키는 위치에 value삽입 vector와 반복자 반복자의 선언 vector&lt;ClassName&gt;::iterator it; 반복자의 값을 구하는 vector의 멤버 함수 begin() 첫 번째 원소를 가리키는 랜덤 액세스 반복자를 반환함 end() 마지막 원소의 다음 위치를 가리키는 랜덤 액세스 반복자를 반환함 vector의 반복자 활용 예 - Vector2.cpp#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){ vector&lt;int&gt; intVec(5); for (int i = 0; i &lt; intVec.size(); i++) intVec[i] = i + 1; vector&lt;int&gt;::iterator it = intVec.begin(); cout &lt;&lt; \"저장된 데이터 : \"; for (; it &lt; intVec.end(); it++) cout &lt;&lt; *it &lt;&lt; \" \"; cout &lt;&lt; endl; it = intVec.begin(); cout &lt;&lt; \"3번째 데이터 : \"; cout &lt;&lt; *(it + 2) &lt;&lt; endl; return 0;}// 저장된 데이터 : 1 2 3 4 5// 3번째 데이터 : 3알고리즘의 활용sort()함수 sort()의 용법 랜덤 액세스 반복자에 의해 지정된 범위의 값들을 정렬함 sort(first, last); sort(first, last, comp); first 정렬할 범위의 시작 원소에 대한 포인터 last 정렬할 범위의 마지막 원소의 다음 위치에 대한 포인터 comp 정렬 순서를 정하는 함수(callback 함수) a의 순서가 b보다 앞인 경우 comp(a, b) == true merge()함수 merge()의 용법 동일한 기준으로 정렬된 두 개의 데이터 집합을 동일한 기준으로 정렬된 하나의 데이터 집합으로 결합하는 함수 merge(first1, last1, first2, last2, dest); merge(first1, last1, first2, last2, dest, comp); first1, last1 첫 번째 정렬된 데이터의 범위 first2, last2 두 번째 정렬된 데이터의 범위 dest 합병 결과가 저장될 시작 위치 comp 합병 순서를 정하는 함수 알고리즘의 활용 예 - Vector3.cpp#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;using namespace std;int main(){ srand((unsigned)time(NULL)); // 난수 발생기 초기화 vector&lt;int&gt; iv1(5); // 크기 5짜리 벡터 생성 cout &lt;&lt; \"벡터1 : \"; for (auto &amp;i : iv1) { i = rand() % 100; // 0~99의 난수 발생 cout &lt;&lt; i &lt;&lt; \" \"; } cout &lt;&lt; endl; sort(iv1.begin(), iv1.end()); // 정렬 알고리즘 cout &lt;&lt; \"정렬된 벡터1 : \"; for (auto i : iv1) { cout &lt;&lt; i &lt;&lt; \" \"; } cout &lt;&lt; endl &lt;&lt; endl; vector&lt;int&gt; iv2(5); cout &lt;&lt; \"벡터2 : \"; for (auto &amp;i : iv2) { i = rand() % 100; // 0~99의 난수 발생 cout &lt;&lt; i &lt;&lt; \" \"; } cout &lt;&lt; endl; sort(iv2.begin(), iv2.end()); // 정렬 알고리즘 cout &lt;&lt; \"정렬된 벡터2 : \"; for (auto i : iv2) { cout &lt;&lt; i &lt;&lt; \" \"; } cout &lt;&lt; endl &lt;&lt; endl; // 합병 결과를 저장할 벡터 vector&lt;int&gt; iv3(iv1.size() + iv2.size()); // iv1과 iv2를 합병한 결과를 iv3에 저장 merge(iv1.begin(), iv1.end(), iv2.begin(), iv2.end(), iv3.begin()); cout &lt;&lt; \"벡터1과 벡터2를 합병한 결과 : \"; for (auto i : iv3) { cout &lt;&lt; i &lt;&lt; \" \"; } cout &lt;&lt; endl; return 0;}// 벡터1 : 97 62 77 57 69// 정렬된 벡터1 : 57 62 69 77 97// 벡터2 : 47 99 48 99 33// 정렬된 벡터2 : 33 47 48 99 99// 벡터1과 벡터2를 합병한 결과 : 33 47 48 57 62 69 77 97 99 99정렬 순서의 결정 정렬 순서 지정을 위한 콜백 함수 전달 sort(first, last, comp); template&lt;typename T&gt; bool gt(const T &amp;a, const T &amp;b) { return a &gt; b; } void f(vector&lt;int&gt;&amp; iv) { // 내림차순 정렬 sort(iv.begin(), iv.end(), gt&lt;int&gt;()); } 함수 객체를 이용한 콜백 함수 전달 함수 객체 함수처럼 사용될 수 있는 객체 ()연산자를 다중 정의함 template&lt;typename T&gt; class GREATER { public: bool operator()(const T &amp;a, const T &amp;b) const { return a &gt; b; } }; GREATER&lt;int&gt; greaterthan; if (greaterthan(20, 10)) cout &lt;&lt; \"20은 10보다 큼\"; template&lt;typename T&gt; class GREATER { public: bool operator()(const T &amp;a, const T &amp;b) const { return a &gt; b; } }; void f(vector&lt;int&gt;&amp; iv) { // 내림차순 정렬 sort(iv.begin(), iv.end(), GREATER&lt;int&gt;()); } STL 활용 예 - mapmap map이란? 저장하는 데이터의 형태는 (키, 값)의 쌍 키를 이용하여 데이터에 직접 접근할 수 있는 연상 컨테이너 키(key) 데이터 집합에서 특정 데이터를 검색하거나 데이터 집합을 정렬하는 기준이 되는 속성 ex) (이름, 전화번호) 쌍이 저장되어 있는 연락처 목록 이름을 키로 하여 전화번호 검색 map에 저장되는 데이터는 키가 모두 다름 트리 형태의 데이터 구조를 이용함으로써 검색 시간이 데이터 수의 로그 함수에 비례함 필요한 헤더 파일 &lt;map&gt; map의 활용 map객체의 선언 map&lt;KeyType, ValueType, Traits&gt; objName; KeyType 키의 자료형 ValueType 키와 연관된 데이터의 자료형 Traits map 내에서의 상대적 순서를 결정하는 함수 객체의 클래스 디폴트는 less&lt;KeyType&gt; 키가 이름, 값이 주소이고, 각각을 string으로 표현할 때, (이름, 주소)의 쌍을 저장하는 map map&lt;string, string&gt; addrbook; 데이터 저장 insert()함수 map&lt;string, string&gt; addrbook; addrbook.insert(make_pair(\"김철수\", \"서울시 종로구\")); addrbook.insert({\"홍길동\", \"서울시 중구\"}); addrbook.insert({\"김철수\", \"서울시 성동구\"}); // 삽입 불가능 pair first와 second라는 2개의 데이터 멤버를 포함하는 템플릿 구조체 make_pair pair객체를 반환하는 함수 템플릿 동일한 키를 갖는 데이터가 이미 존재할 경우 삽입이 이루어지지 않음 []연산자 키를 이용한 데이터 직접 접근 addrbook (\"김철수\", \"서울시 종로구\") (\"홍길동\", \"서울시 중구\") (\"박영식\", \"대전시 동구\") “서울시 중구” 출력 cout &lt;&lt; addrbook[\"홍길동\"]; (“박영식”, “대전시 동구”) 삽입 addrbook[\"박영식\"] = \"대전시 동구\"; “김철수”의 데이터 수정 addrbook[\"김철수\"] = \"서울시 성동구\"; find()함수를 이용한 검색 지정된 키를 갖는 데이터를 가리키는 반복자 반환 addrbook (\"김철수\", \"서울시 종로구\") (\"홍길동\", \"서울시 중구\") (\"박영식\", \"대전시 동구\") it는 pair객체 (“박영식”, “대전시 동구”)를 가리킴 auto it = addrbook.find(\"박영식\"); it에 addrbook.end()가 저장됨 auto it = addrbook.find(\"이서연\"); erase()함수를 이용한 데이터 삭제 삭제할 데이터를 가리키는 반복자를 지정하는 방법 it가 가리키는 데이터 삭제 addrbook.erase(it1); 삭제할 데이터를 가리키는 반복자의 범위를 지정하는 방법 [it1, it2)범위의 데이터 삭제 addrbook.erase(it1, it2); 키를 지정하여 데이터를 삭제하는 방법 키가 “박영식”인 데이터 삭제 addrbook.erase(\"박영식\"); map의 활용 예 - PBookMap.cpp#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;template&lt;typename T&gt;class LESS_T {public: bool operator()(const T &amp;a, const T &amp;b) const { return a &lt; b; }};int main(){ map&lt;string, string, LESS_T&lt;string&gt;&gt; pBook { {\"한정훈\", \"010-2233-4354\"}, {\"박영철\", \"010-2233-4455\"} }; pBook[\"김철수\"] = \"010-1234-5678\"; pBook.insert(make_pair(\"최승호\", \"010-7531-3456\")); pBook.insert({\"박영철\", \"010-1357-2468\"}); // 동일 키이므로 삽입 안 됨 for (auto pb = pBook.begin(); pb != pBook.end(); ++pb) { cout &lt;&lt; pb-&gt;first &lt;&lt; \" \" &lt;&lt; pb-&gt;second &lt;&lt; endl; } cout &lt;&lt; pBook.size() &lt;&lt; \"명이 등록되어 있습니다.\" &lt;&lt; endl; cout &lt;&lt; endl; string str; cout &lt;&lt; \"찾을 이름 : \"; cin &gt;&gt; str; auto result = pBook.find(str); if (result != pBook.end()) { cout &lt;&lt; result-&gt;first &lt;&lt; \"님의 전화번호는 \" &lt;&lt; result-&gt;second &lt;&lt; \" 입니다.\" &lt;&lt; endl; } else { cout &lt;&lt; str &lt;&lt; \"님을 찾을 수 없습니다.\" &lt;&lt; endl; } return 0;}// 김철수 010-1234-5678// 박영철 010-2233-4455// 최승호 010-7531-3456// 한정훈 010-2233-4354// 4명이 등록되어 있습니다.// 찾을 이름 : 박영철// 박영철님의 전화번호는 010-2233-4455 입니다.정리 하기 표준 템플릿 라이브러리는 컨테이너, 알고리즘, 반복자로 구성 됨 STL에서 제공하는 컨테이너에는 순차 컨테이너, 연상 컨테이너, 무순서 연상 컨테이너가 있음 반복자(iterator)는 컨테이너 내의 객체를 가리키는 포인터의 개념에 해당 됨 STL의 컨테이너에 대해서는 템플릿에 선언된 멤버 함수들 외에 STL 알고리즘을 통해 여러 가지 유용한 연산을 적용할 수 있음 vector는 확장 가능한 배열에 해당되는 STL 컨테이너 클래스 템플릿임 sort(), merge()등의 알고리즘에 콜백 함수를 전달할 때 함수 객체를 이용하면 일반적인 함수를 전달하는 것에 비해 효율적으로 동작할 수 있음 STL의 map을 이용하면 트리 형태의 데이터 구조를 이용하여 (키, 값) 쌍의 데이터를 저장하고, 키를 이용하여 데이터에 직접 접근할 수 있음연습 문제 STL의 세 가지 구성 요소 중 포인터의 역할을 하는 것은? a. 반복자(iterator) STL을 구성하는 세 가지 요소는 컨테이너, 반복자, 알고리즘임 컨테이너는 자료형 데이터나 사용자 정의 클래스의 객체 등을 저장하는 역할을 하고, 반복자는 포인터와 같은 기능을 제공하며, 알고리즘은 컨테이너의 원소에 대해 적용할 수 있는 여러 가지 연산을 제공함 다음 중 순차 컨테이너에 해당되는 것은? a. vector 순차 컨테이너는 객체들을 선형적인 구조로 저장하는 컨테이너로서, vector, list, deque, stack, queue, priority_queue등이 이에 해당 됨 다음 중 vector에 대한 올바른 설명은? a. vector객체의 논리적 크기는 실제로 할당된 메모리의 크기와 다를 수 있음 vector는 배열과 같은 기능을 제공하나, 크기가 필요에 따라 확장될 수 있음 크기를 확장할 때는 논리적 크기를 수용할 수 있도록 확장되나, 실제 크기가 논리적 크기와 일치하지 않을 수 있으며, 미래의 확장에 대비해 공간을 확장함으로써 논리적 크기가 변화할 때마다 저장 공간을 새로 할당함에 따른 비효율성을 줄임 pop_back()함수는 벡터의 논리적 크기를 감소 시킴 위 지문은 함수 객체를 정의하기 위한 클래스 템플릿을 선언한 것이다. ㈀에 넣을 적절한 내용은? template&lt;typename T&gt; class GREATER { public: bool // ________(ㄱ)________ (const T&amp; a, const T&amp; b) const { return a &gt; b; } }; a. operator() 함수 객체는 마치 함수를 호출하는 것처럼 사용할 수 있는 객체로, 함수 객체를 만들기 위해서는 ()연산자를 다중 정의 해야 함 STL의 map에 대한 올바른 설명은? a. (키, 값)의 쌍을 저장하여 키를 이용하여 데이터에 직접 접근할 수 있는 연상 컨테이너이다. map은 (키, 값)의 쌍을 저장하여 키를 이용한 직접 접근을 할 수 있는 연상 컨테이너임 이때 map객체에 저장된 데이터의 키는 모두 서로 달라야 함 데이터가 트리 형태의 데이터 구조로 저장되므로, 특정 키를 갖는 항목을 검색하는 데 드는 시간은 데이터 수의 로그 함수에 비례함 정리 하기 표준 템플릿 라이브러리는 컨테이너, 알고리즘, 반복자로 구성됨 STL에서 제공하는 컨테이너에는 순차 컨테이너, 연상 컨테이너, 무순서 연상 컨테이너가 있음 반복자(iterator)는 컨테이너 내의 객체를 가리키는 포인터의 개념에 해당 됨 STL의 컨테이너에 대해서는 템플릿에 선언된 멤버 함수들 외에 STL 알고리즘을 통해 여러 가지 유용한 연산을 적용할 수 있음 vector는 확장 가능한 배열에 해당되는 STL 컨테이너 클래스 템플릿임 sort(), merge()등의 알고리즘에 콜백 함수를 전달할 때 함수 객체를 이용하면 일반적인 함수를 전달하는 것에 비해 효율적으로 동작할 수 있음" }, { "title": "[C++ 프로그래밍] 13강 - 템플릿", "url": "/posts/knou-cpp-13/", "categories": "Language, CPP", "tags": "knou, cpp", "date": "2025-06-29 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 이병래 교수님의 'C++ 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 컨테이너 클래스는 객체들을 저장하는 클래스임 만일 여러 가지 클래스의 객체에 대해 각각 컨테이너 클래스가 필요하다면 여러 개의 컨테이너 클래스가 선언되어야 할 것임 이 경우 동일한 코드를 반복적으로 작성해야 하는 번거로움이 따르는데 템플릿은 이러한 경우 유용하게 활용할 수 있는 기능임 클래스 템플릿을 선언해 놓으면 그 안에서 대상으로 하는 객체의 클래스 등을 인수로 전달하여 필요한 클래스가 선언된 효과를 얻게 됨 클래스 템플릿을 선언하고 활용하는 방법에 대하여 학습함 클래스 및 클래스의 멤버 함수 뿐만 아니라 일반 함수도 템플릿으로 선언함으로써, 여러 가지 대상에 맞는 함수가 선언된 효과를 얻을 수 있음 함수 템플릿을 선언하여 활용하는 방법에 대하여 학습함학습 목표 컨테이너 클래스 및 템플릿의 개념을 설명할 수 있음 클래스 템플릿을 선언하고, 이를 이용하여 객체를 정의할 수 있음 함수 템플릿을 선언할 수 있음주요 용어 컨테이너 클래스(container class) 객체를 저장하는 클래스 클래스 템플릿(class template) 클래스를 선언하기 위한 형판으로, 전달된 템플릿 인수에 따라 이에 맞는 클래스가 선언됨 일반화 프로그래밍(generic programming) 클래스, 함수 등을 대상 자료형 등을 특정하지 않은 상태로 선언한 후, 필요할 때 자료형 등을 파라미터를 통해 전달하여 정의하는 프로그래밍 방식 정렬(sorting) 데이터를 정해진 기준에 맞는 순서로 다시 배열하는 것 강의록컨테이너 클래스와 템플릿컨테이너 클래스 컨테이너 클래스(container class)란? 객체를 저장하는 클래스 int형 데이터를 저장하는 스택 클래스 - Stack1.h typedef int STACK_ITEM; class Stack { public: enum { MAXSTACK=20 }; int top; STACK_ITEM item[MAXSTACK]; public: Stack(); // 생성자 bool empty() const; bool full() const; void initialize(); void push(STACK_ITEM s); STACK_ITEM pop(); }; float형 데이터를 저장하는 스택 클래스 typedef float STACK_ITEM; class Stack { public: enum { MAXSTACK=20 }; int top; STACK_ITEM item[MAXSTACK]; public: Stack(); // 생성자 bool empty() const; bool full() const; void initialize(); void push(STACK_ITEM s); STACK_ITEM pop(); }; int형 스택과 float형 스택이 모두 필요할 경우 typedef int INT_ITEM; class StackInt { INT_ITEM item[MAXSTACK]; }; void StackInt::push(INT_ITEM n) { item[--top] = n; } typedef float FLOAT_ITEM; class StackFloat { FLOAT_ITEM item[MAXSTACK]; // StackInt와 동일한 코드 // 단 INT_ITEM만 FLOAT_ITEM으로 변경 }; void StackFloat::push(FLOAT_ITEM n) { item[--top] = n; } 동일 코드 반복 발생 템플릿 템플릿(template)이란? 클래스, 함수 등을 선언하기 위한 형판 특정 자료형이 아닌 일반 자료형을 대상으로 템플릿을 선언함 자료형, 상수 등을 매개 변수를 통해 템플릿에 전달하면 이에 따라 클래스나 함수가 자동으로 선언됨 일반화 프로그래밍(generic programming) 여러 가지 대상을 위한 클래스나 함수를 템플릿으로 선언함으로써, 동일한 코드를 반복적으로 작성하는 것을 방지함 클래스 템플릿클래스 템플릿의 선언 클래스 템플릿의 선언 형식 template &lt;templateParameters&gt; class ClassTemplateName { }; templateParameters 템플릿 매개 변수 목록 자료형을 받을 템플릿 매개 변수 typename T또는 class T로 표기 (T는 사용자 정의 명칭) ClassTemplateName 클래스 템플릿 이름 예: Stack 클래스 템플릿 - StackT.h template &lt;typename T&gt; class Stack { public: T *buf; // buffer pointer int top; // stack top int size; // 스택의 크기 public: Stack(int s); // 생성자 virtual ~Stack(); // 소멸자 bool full() const; bool empty() const; void push(const T&amp; a); void push(T&amp;&amp; a); T&amp;&amp; pop(); }; 클래스 템플릿의 멤버 함수 선언 템플릿 선언문 외부에서 멤버 함수를 선언하는 형식 template &lt;templateParameters&gt; ReturnType ClassTemplateName&lt;args&gt;::funcName(fParameterList) { } ReturnType 멤버 함수의 반환 자료형 funcName 멤버 함수의 이름 args templateParameters의 매개 변수 fParameterList 멤버 함수의 형식 매개 변수 목록 예: Stack 클래스 템플릿 - StackT.h template &lt;typename T&gt; Stack&lt;T&gt;::Stack(int s) : size(s), top(0) { buf = new T[s]; } template &lt;typename T&gt; Stack&lt;T&gt;::~Stack() { delete[] buf; } template &lt;typename T&gt; bool Stack&lt;T&gt;::full() const { return top == size; } template &lt;typename T&gt; bool Stack&lt;T&gt;::empty() const { return top == 0; } template &lt;typename T&gt; void Stack&lt;T&gt;::push(const T&amp; a) { buf[top++] = a; } template &lt;typename T&gt; void Stack&lt;T&gt;::push(T&amp;&amp; a) { buf[top++] = move(a); } template &lt;typename T&gt; T&amp;&amp; Stack&lt;T&gt;::pop() { return move(buf[--top]); } 클래스 템플릿의 객체 정의 클래스 템플릿의 객체 정의의 형식 ClassTemplateName&lt;ClassName&gt; objName(constrArgs); ClassName 템플릿 매개 변수에 전달할 클래스 또는 자료형 이름 등의 템플릿 인수 objName 정의할 객체의 이름 constrArgs 생성자에 전달할 인수 클래스 템플릿의 객체 사용 예: char을 저장하는 스택의 활용 - StackMain.cpp #include \"StackT.h\" #include \"MyString.h\" using namespace std; int main() { Stack&lt;char&gt; sc(100); // char 스택 선언 sc.push('a'); // char 스택 사용 sc.push('b'); cout &lt;&lt; \"CHAR STACK : \"; while (!sc.empty()) { cout &lt;&lt; sc.pop(); } cout &lt;&lt; endl; } template &lt;typename T&gt; class Stack { public: T *buf; // buffer pointer int top; // stack top int size; // 스택의 크기 public: Stack(int s); // 생성자 virtual ~Stack(); // 소멸자 bool full() const; bool empty() const; void push(const T&amp; a); void push(T&amp;&amp; a); T&amp;&amp; pop(); }; 예: int를 저장하는 스택의 활용 - StackMain.cpp int main() { Stack&lt;int&gt; si(50); // int 스택 선언 si.push(5); // int 스택 사용 si.push(10); cout &lt;&lt; \"INT STACK : \"; while (!si.empty()) { cout &lt;&lt; si.pop(); } cout &lt;&lt; endl; Stack&lt;MyString&gt; msStack(10); // MyString 스택 선언 MyString s1(\"KNOU\"); } template &lt;typename T&gt; class Stack { public: T *buf; // buffer pointer int top; // stack top int size; // 스택의 크기 public: Stack(int s); // 생성자 virtual ~Stack(); // 소멸자 bool full() const; bool empty() const; void push(const T&amp; a); void push(T&amp;&amp; a); T&amp;&amp; pop(); }; 예: MyString을 저장하는 스택의 활용 - StackMain.cpp int main() { Stack&lt;MyString&gt; msStack(10); // MyString 스택 선언 MyString s1(\"KNOU\"); MyString s2(\"Dep.\"); MyString s3(\"CS\"); msStack.push(s1); // MyString 스택 사용 msStack.push(s2 + s3); cout &lt;&lt; \"MYSTRING STACK : \"; while (!msStack.empty()) { cout &lt;&lt; msStack.pop() &lt;&lt; \" \"; } cout &lt;&lt; endl; return 0; } template &lt;typename T&gt; class Stack { public: T *buf; // buffer pointer int top; // stack top int size; // 스택의 크기 public: Stack(int s); // 생성자 virtual ~Stack(); // 소멸자 bool full() const; bool empty() const; void push(const T&amp; a); void push(T&amp;&amp; a); T&amp;&amp; pop(); }; 클래스 템플릿의 대상 객체 관련 유의 사항 사용자가 선언한 클래스의 객체를 저장하는 컨테이너 기본 자료형 외에도 사용자 정의 클래스 객체를 저장하기 위해 컨테이너 클래스 템플릿을 사용할 수 있음 ex) MyString 객체를 저장하기 위한 스택 이 경우 클래스 템플릿에서 필요로 하는 멤버 함수가 대상 클래스에 포함되어 있어야 함 클래스 템플릿 Stack에 저장할 객체에는 디폴트 생성자, 대입 연산자, 이동 대입 연산자 등이 필요함 ex) class Person { \tstring name; public: Person(const string&amp; n) : name(n) {} void print() { cout &lt;&lt; name; } }; int main() { Stack&lt;Person&gt; pStack(10); // 에러 발생 } template &lt;typename T&gt; Stack&lt;T&gt;::Stack(int s) : size(s), top(s) { buf = new T[s]; // Person에 디폴트 생성자가 필요함 } 비 자료형 템플릿 매개 변수 템플릿 매개 변수를 통해 전달할 수 있는 인자 자료형 매개 변수 기본 자료형, 클래스, 구조체 등 비 자료형 매개 변수 정수형 자료형의 상수식 객체나 함수에 대한 포인터 객체나 함수에 대한 l-value 참조 멤버에 대한 포인터 비자료형 매개 변수의 사용 예 template &lt;typename T, int size&gt; class Buffer { T buf[size]; }; void f() { Buffer&lt;char, 128&gt; buf1; // 크기가 128개인 char형 버퍼 선언 Buffer&lt;Complex1, 20&gt; buf2; // 크기가 20개인 complex1 버퍼 선언 int n = 10; Buffer&lt;char, n&gt; buf3; // 에러! - 실행시 값이 결정되는 수식 } 함수 템플릿함수 템플릿의 선언 함수 템플릿 선언 형식 template &lt;templateParameters&gt; ReturnType funcName(fParameterList) { // 함수 몸체 } templateParameters 템플릿 매개 변수 선언 funcName 함수 템플릿 이름 함수 템플릿의 활용 예 - swapFT 함수 템플릿 선언 - SwapFunc.h #ifndef SWAP_FUNCTION_TEMPLATE_H_INCLUDED #define SWAP_FUNCTION_TEMPLATE_H_INCLUDED #include &lt;utility&gt; // for std::move template &lt;typename ANY&gt; void swapFT(ANY &amp;a, ANY &amp;b) { ANY temp = move(a); // 이동 대입 연산자가 필요함 a = move(b); b = move(temp); } #endif 함수 템플릿을 이용한 프로그램 - SwapFTMain.cpp #include &lt;iostream&gt; #include \"SwapFT.h\" #include \"MyString.h\" using namespace std; int main() { int x = 10, y = 20; cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; \", y = \" &lt;&lt; y &lt;&lt; endl; cout &lt;&lt; \"값 교환 후 -&gt; \"; swapFT(x, y); cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; \", y = \" &lt;&lt; y &lt;&lt; endl &lt;&lt; endl; MyString s1(\"KNOU\"), s2(\"CS\"); cout &lt;&lt; \"s1 = \" &lt;&lt; s1 &lt;&lt; \", s2 = \" &lt;&lt; s2 &lt;&lt; endl; swapFT(s1, s2); cout &lt;&lt; \"값 교환 후 -&gt; \"; cout &lt;&lt; \"s1 = \" &lt;&lt; s1 &lt;&lt; \", s2 = \" &lt;&lt; s2 &lt;&lt; endl; return 0; } 함수 템플릿의 활용 예 - sortFT 버블 정렬 배열의 선두에서 시작하여 차례로 인접한 두 값을 비교하여 앞의 값이 크면 값을 교환하는 것을 반복 함수 템플릿의 활용 예 - sortFT 함수 템플릿 선언 - SortFT.h #include \"SwapFT.h\" // bubble sort algorithm template &lt;typename T&gt; void sortFT(T arr[], int size) { bool doAgain = true; for (int i = 1; doAgain; i++) { doAgain = false; for (int j = 0; j &lt; size - i; j++) { if (arr[j] &gt; arr[j + 1]) { swapFT(arr[j], arr[j + 1]); doAgain = true; } } } } 함수 템플릿을 이용한 프로그램 - SortMain.cpp #include &lt;iostream&gt; #include \"SortFT.h\" #include \"MyString.h\" using namespace std; int main() { int x[10] = { 6, 0, 3, 1, 2, 9, 4, 5, 7, 8 }; sortFT(x, 10); for (auto i : x) cout &lt;&lt; i &lt;&lt; \" \"; cout &lt;&lt; endl; } 연습 문제 객체를 저장하기 위한 클래스를 나타내는 것은? a. 컨테이너 클래스 컨테이너 클래스는 스택, 큐, 배열, 리스트 등 객체들을 저장하기 위한 클래스를 통칭하는 것임 지정된 개수의 객체를 저장할 수 있는 배열을 나타내는 컨테이너 클래스 템플릿을 선언하고자 한다. 위 지문 문장의 ㈀, ㈁, ㈂, ㈃에 넣을 적절한 내용은? // (ㄱ) &lt;typename (ㄴ)&gt; class Array { T* buf; int size; public: Array(int s) : size(s) { buf = // (ㄷ); } ~Array() { delete [] buf; } // (ㄹ) operator [] (int i) { return buf[i]; } }; a. ㈀ template, ㈁ T, ㈂ new T[s], ㈃ T&amp; ㈀에는 템플릿 선언을 위한 키워드인 template이 필요하며, ㈁에는 이 컨테이너 클래스가 저장하고자 하는 자료형에 해당되는 매개 변수가 필요함 선언문의 내용으로 볼 때 buf의 자료형으로 사용된 T가 이에 해당됨을 알 수 있음 ㈂에는 T클래스의 객체를 동적 할당하는 명령이 필요하며, ㈃은 buf[i]가 T클래스 객체이므로 []연산자는 T의 참조를 반환하도록 함 위 지문과 같이 클래스 템플릿이 선언 되었을 때, double형 값을 저장하는 Array객체를 선언하는 올바른 문장은? template &lt;class T&gt; class Array { T* buf; int size; public: Array(int s) : size(s) { buf = new T[s]; } T&amp; operator [] (int i) { return buf[i]; } }; a. Array&lt;double&gt; dArr(20); 클래스템플릿이름 형태로 템플릿을 사용함 정리 하기 컨테이너 클래스는 스택, 큐, 배열, 리스트 등과 같이 객체를 저장하는 클래스를 의미함 템플릿은 클래스, 함수 등을 선언하기 위한 형판임 하나의 클래스 템플릿에 서로 다른 템플릿 인수를 전달하여 사용하면 여러 가지 클래스가 선언된 것과 같음 클래스 템플릿의 템플릿 인수로 전달할 클래스는 클래스 템플릿에서 필요로 하는 메소드들을 포함하고 있어야 함 클래스(또는 자료형) 이름 외에도 함수 이름이나 상수를 템플릿에 인수로 전달할 수 있음" }, { "title": "[C++ 프로그래밍] 12강 - 상속", "url": "/posts/knou-cpp-12/", "categories": "Language, CPP", "tags": "knou, cpp", "date": "2025-06-27 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 이병래 교수님의 'C++ 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 추상 클래스와 다중 상속에 대하여 학습함 클래스를 선언할 때 그 클래스의 객체를 직접 만들기 위한 것이 아니라, 파생 클래스에 상속할 공통인 속성이나 메소드를 담고 있게 할 수 있음 특히 파생 클래스에서 반드시 가지고 있어야 할 메소드에 대해 구현 부분이 없이 선언만을 포함하도록 선언한 클래스를 추상 클래스라고 함 이를 통해 이 클래스의 파생 클래스라면 공통적으로 갖추게 되는 행위를 지정할 수 있어 파생 클래스의 표준화하는 효과를 얻을 수 있음 다중 상속은 여러 개의 클래스로부터 상속을 받을 수 있게 하는 기법임 그 결과 트리 형태의 클래스 계층이 아닌 그래프 형태의 클래스 계층이 만들어질 수 있음 다중 상속을 활용하면서, 이 과정에서 발생할 수 있는 중복 상속의 문제를 해결하기 위한 방법에 대하여 학습함학습 목표 추상 클래스의 목적을 설명할 수 있음 순수 가상 함수를 통해 추상 클래스를 선언할 수 있음 추상 클래스에서 파생 된 상세 클래스를 선언할 수 있음 2개 이상의 기초 클래스로부터 상속을 받는 파생 클래스를 선언할 수 있음 다중 상속 결과 발생할 수 있는 기초 클래스 멤버의 중복 상속을 방지할 수 있음주요 용어 추상 클래스(abstract class) 유사한 성격을 갖는 클래스들의 공통적 요소들을 뽑아서 만든 클래스로, 일부 메소드의 구체적 구현이 없어 직접적인 사례가 존재하지 않는 클래스 상세 클래스(concrete class) 클래스의 모든 요소가 구체적으로 구현되어 직접적인 사례가 존재하는 클래스 순수 가상 함수 (pure virtual function) 행위의 구현 부분이 없이 선언 된 가상 함수 다중 상속(multiple inheritance) 2개 이상의 기초 클래스로부터 상속을 받는 것 공통 기초 클래스 다중 상속 과정에서 동시에 상속 받은 2개 이상의 부모 클래스가 공통적으로 상속을 받은 기초 클래스 강의록추상 클래스추상 클래스와 상세 클래스추상 클래스 추상 클래스 유사한 성격을 갖는 클래스들의 공통적 요소를 뽑아서 만든 클래스로, 일부 메서드의 구체적 구현이 없어 직접적인 사례가 존재하지 않는 클래스 추상 클래스로 객체를 직접 정의할 수 없음 추상 클래스는 그 자체로 사용되는 것이 아니라 파생 클래스를 통해 구현되어 사용됨 사용 목적 특정 그룹에 속하는 클래스들(추상 클래스의 파생 클래스들)이 반드시 가지고 있어야 할 행위를 지정함으로써 필요한 행위를 정의하는 것을 누락하지 않도록 함 ex) 도형 클래스 도형에 속하는 클래스(삼각형, 원 등)의 객체는 draw및 move등의 메서드가 정의되어 있어야 함을 지정함 도형 클래스 자체는 draw및 move등의 메서드를 정의할 수 없어 객체를 만들 수 없음 상세 클래스 클래스의 모든 요소가 구체적으로 구현되어 직접적인 사례가 존재하는 클래스 상속 클래스는 객체를 정의할 수 있음 ex) 삼각형 및 원 클래스 추상 클래스인 ‘도형’에서 구현되지 않은 상태로 상속 받은 draw, move등을 구체적으로 정의할 수 있음 삼각형이나 원 클래스의 객체를 정의할 수 있음 멤버 함수 중 순수 가상 함수가 포함된 클래스를 선언 순수 가상 함수 구현 부분이 없는 가상 함수 순수 가상 함수의 선언 virtual RetType functionName(fParameterList) = 0; class AClass { // 추상 클래스 public: virtual void vf() const = 0; // 순수 가상 함수 void f1() const { cout &lt;&lt; \"Abstract\" &lt;&lt; endl; } }; AClass objA; // Error - 추상 클래스의 객체 정의 불가 상세 클래스의 선언 순수 가상 함수를 포함하지 않는 클래스를 선언 상속 받은 순수 가상 함수가 있다면 반드시 재 정의 해야 함 class AClass { // 추상 클래스 public: virtual void vf() const = 0; // 순수 가상 함수 }; class CClass : public AClass { // 상세 클래스 public: void vf() const { cout &lt;&lt; \"순수 가상 함수 구현\" &lt;&lt; endl; } void f2() const { cout &lt;&lt; \"Concrete\" &lt;&lt; endl; } }; CClass objC; // OK - CClass는 상속 클래스 예제: 추상 클래스의 활용 도형 클래스 2차원 도형에 해당하는 원을 나타내는 클래스와 삼각형을 나타내는 클래스를 선언하고자 한다. 이 클래스들은 모두 공통적으로 도형이므로 도형을 그리기 위한 선의 색과 도형 내부를 채워 칠하기 위한 색을 속성으로 가지고 있어야 하며, 이러한 속성을 이용하여 그리는 방법을 설명할 수 있어야 한다. 또한 그래픽 객체를 (dx, dy)만큼 이동할 수 있으며, 2차원 좌표 원점을 기준으로 확대/축소하는 크기 조정을 할 수 있다. 프로그램은 현재 속성이라는 객체가 있다. 속성 객체는 선의 색과 내부 영역을 칠하기 위한 색을 표현하며, 그 값을 설정하거나 얻어낼 수 있다. 도형 객체를 만들면 현재 속성에 따라 만들어진다. 또한 도형 객체의 선 색 및 채우기 색을 변경할 수 있다. 예제: 추상 클래스의 활용 - GrAttrib 클래스 그래픽 속성 클래스 GrAttrib의 메서드 및 속성 메서드 비고 GrAttrib() 생성자 void setLineColor(const string&amp;) 지정 된 색으로 선 색 지정 void setFillColor(const string&amp;) 지정 된 색으로 내부 영역 색 지정 string getLineColor() 선 색 반환 string getFillColor() 내부 영역 색 반환 속성 비고 string lineColor 선 색 속성 string fillColor 내부 영역 색 속성 예제: 추상 클래스의 활용 - GrAttrib.hclass GrAttrib { // 그래픽 속성 클래스 string lineColor; // 선 색 속성 string fillColor; // 내부 영역 색 속성public: // 그래픽 속성 객체 생성자 GrAttrib() : lineColor(\"검정색\"), fillColor(\"흰색\") {} // 기본 값 lineColor 검정색 fillColor 흰색 GrAttrib(const string&amp; lc, const string&amp; fc) : lineColor(lc), fillColor(fc) {} // 매개변수로 선 색상, 내부 색상 받아서 그 값으로 초기화 // 속성 지정 멤버 함수 void setLineColor(const string&amp; lc) { // 선 색상 지정 lineColor = lc; } void setFillColor(const string&amp; fc) { // 내부 색상 지정 fillColor = fc; } // 속성 값을 얻는 멤버 함수 string getLineColor() const { return lineColor; } string getFillColor() const { return fillColor; }};extern GrAttrib curAttrib; // 현재 속성을 나타내는 전역 객체예제: 추상 클래스의 활용 - Figure 클래스 도형 클래스 Figure의 메서드 및 속성 메서드 비고 Figure() 생성자, 현재 속성에 따라 도형을 생성 void setLineColor(const string&amp;) 지정된 색으로 선 색 지정 void setFillColor(const string&amp;) 지정된 색으로 내부 영역 색 지정 void move(double dx, double dy) 도형을 (dx, dy)만큼 이동 void scale(double s) 도형을 원점 기준으로 s배 크기 조정 void draw() 도형을 그림 속성 비고 GrAttrib attrib 도형의 그래픽 속성 class Figure { protected: GrAttrib attrib; // 그래픽 속성 public: // 현재 그래픽 속성에 따라 도형 객체 생성 Figure() : attrib(curAttrib) {} // 선 색 속성 지정 void setLineColor(const string&amp; c) { attrib.setLineColor(c); } // 내부 영역의 색 지정 void setFillColor(const string&amp; c) { attrib.setFillColor(c); } // 도형의 이동, 원점 기준 크기 조정, 그리기 멤버 함수 (순수 가상 함수) virtual void move(double dx, double dy) = 0; virtual void scale(double s) = 0; virtual void draw() const = 0; }; 예제: 추상 클래스의 활용 - Circle 클래스 원 클래스 Circle의 메서드 및 속성 메서드 비고 Circle(double x, double y, double r) 생성자 void move(double dx, double dy) 원을 (dx, dy)만큼 이동 void scale(double s) 원을 원점 기준으로 s배 크기 조정 void draw() 원을 그림 속성 비고 double cx, cy 원의 중심 좌표 double radius 원의 반경 예제: 추상 클래스의 활용 - Circle.hclass Circle : public Figure { double cx, cy; // 원의 중심 좌표 double radius; // 원의 반경public: // 현재의 그래픽 속성에 따라 원 객체 생성 // (x, y) : 중심좌표 // r : 반경 Circle(double x, double y, double r) : cx(x), cy(y), radius(r) {} // 원의 이동, 원점 기준 크기 조정, 그리기 멤버 함수 void move(double dx, double dy); void scale(double s); void draw() const;};예제: 추상 클래스의 활용 - Circle.cpp#include \"Circle.h\"// 원의 중심좌표를 (dx, dy)만큼 이동void Circle::move(double dx, double dy) { cx += dx; cy += dy;}// 원점 기준으로 s배 크기 조정void Circle::scale(double s) { cx *= s; cy *= s; radius *= s;}// 원을 그리는 방법 출력void Circle::draw() const { cout &lt;&lt; \"원 그리기\" &lt;&lt; endl; cout &lt;&lt; \"(\" &lt;&lt; cx &lt;&lt; \", \" &lt;&lt; cy &lt;&lt; \")로부터 \"; // 중심좌표 출력 cout &lt;&lt; \"radius \" &lt;&lt; radius &lt;&lt; \"만큼 떨어진 모든 점들을 \"; // 반지름 출력 cout &lt;&lt; attrib.getLineColor() &lt;&lt; \"으로 그리고\" &lt;&lt; endl; // 선 색상 출력 cout &lt;&lt; \"내부를 \" &lt;&lt; attrib.getFillColor(); // 내부 색상 출력 cout &lt;&lt; \"으로 채운다.\" &lt;&lt; endl;}예제: 추상 클래스의 활용 - Triangle 클래스 삼각형 클래스 Triangle 메서드 및 속성 메서드 비고 Triangle(double v[3][2]) 생성자 void move(double dx, double dy) 삼각형을 (dx, dy)만큼 이동 void scale(double s) 삼각형을 원점 기준으로 s배 크기 조정 void draw() 삼각형을 그림 속성 비고 double x1, y1 삼각형의 꼭짓점 좌표 double x2, y2 삼각형의 꼭짓점 좌표 double x3, y3 삼각형의 꼭짓점 좌표 예제: 추상 클래스의 활용 - Triangle.hclass Triangle : public Figure { // 삼각형의 세 꼭짓점 좌표 (x1, y1), (x2, y2), (x3, y3) double x1, y1, x2, y2, x3, y3;public: // 현재의 그래픽 속성에 따라 삼각형 객체 생성 // v : 세 개의 꼭짓점 좌표 배열 Triangle(const double v[3][2]); // 삼각형의 이동, 원점 기준 크기 조정, 그리기 멤버 함수 void move(double dx, double dy); void scale(double s); void draw() const;};예제: 추상 클래스의 활용 - Triangle.cpp#include \"Triangle.h\"// 생성자: 세 꼭짓점 좌표를 초기화Triangle::Triangle(const double v[3][2]) { x1 = v[0][0]; y1 = v[0][1]; x2 = v[1][0]; y2 = v[1][1]; x3 = v[2][0]; y3 = v[2][1];}// 세 꼭짓점 좌표를 (dx, dy)만큼 이동void Triangle::move(double dx, double dy) { x1 += dx; y1 += dy; x2 += dx; y2 += dy; x3 += dx; y3 += dy;}// 세 꼭짓점 좌표를 s배 만큼 조정void Triangle::scale(double s) { x1 *= s; y1 *= s; x2 *= s; y2 *= s; x3 *= s; y3 *= s;}// 삼각형을 그리는 방법 출력void Triangle::draw() const { cout &lt;&lt; \"삼각형 그리기\" &lt;&lt; endl; cout &lt;&lt; \"(\" &lt;&lt; x1 &lt;&lt; \", \" &lt;&lt; y1 &lt;&lt; \"), \"; cout &lt;&lt; \"(\" &lt;&lt; x2 &lt;&lt; \", \" &lt;&lt; y2 &lt;&lt; \"), \"; cout &lt;&lt; \"(\" &lt;&lt; x3 &lt;&lt; \", \" &lt;&lt; y3 &lt;&lt; \")의 좌표를 잇는 선분을 \"; cout &lt;&lt; attrib.getLineColor() &lt;&lt; \"으로 그리고\" &lt;&lt; endl; cout &lt;&lt; \"내부를 \" &lt;&lt; attrib.getFillColor(); cout &lt;&lt; \"으로 채운다.\" &lt;&lt; endl;}예제: 추상 클래스의 활용 - FigMain.cpp#include &lt;iostream&gt;#include &lt;string&gt;#include \"GrAttrib.h\"#include \"Figure.h\"#include \"Circle.h\"#include \"Triangle.h\"using namespace std;// 현재의 그래픽 속성GrAttrib curAttrib(\"검정색\", \"흰색\");void drawFigs(const Figure * const figs[], int n){ for (int i = 0; i &lt; n; i++) { figs[i]-&gt;draw(); // 각 도형의 draw() 실행 } cout &lt;&lt; endl;}int main(){ Figure *figs[2]; figs[0] = new Circle(0, 20, 10); // 중심(0,20), 반지름 10인 원 생성 double v[3][2] = { {0, 0}, {20, 0}, {10, 15} }; // 삼각형 꼭짓점 배열 curAttrib.setLineColor(\"빨강\"); curAttrib.setFillColor(\"노랑\"); figs[1] = new Triangle(v); drawFigs(figs, 2); // 모든 도형 그리기 방법 출력 figs[0]-&gt;scale(2); // 첫번쨰 원의 크기 조정 figs[1]-&gt;move(5, 10); // 두번째 삼각형의 이동 drawFigs(figs, 2); // 모든 도형 그리기 방법 출력 return 0;}다중 상속다중 상속의 개념 다중 상속(multiple inheritance) 2개 이상의 기초 클래스로부터 상속을 받는 것 다중 상속의 예 - MIStudent.h#ifndef MISTUDENT_H_INCLUDED#define MISTUDENT_H_INCLUDED#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Student { string school; // 학교 이름 저장 변수public: Student(const string&amp; s) : school(s) {} // 생성자에서 학교명 초기화 void printSchool() const { cout &lt;&lt; school &lt;&lt; endl; } // 학교명 출력 함수};#endif // MISTUDENT_H_INCLUDED다중 상속의 예 - MIEmployee.h#ifndef MIEMPLOYEE_H_INCLUDED#define MIEMPLOYEE_H_INCLUDED#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Employee { string company; // 회사 이름 저장 변수public: Employee(const string&amp; c) : company(c) {} // 생성자에서 회사명 초기화 void printCompany() const { cout &lt;&lt; company &lt;&lt; endl; } // 회사명 출력 함수};#endif // MIEMPLOYEE_H_INCLUDED다중 상속의 예 - MIParttime.h#ifndef MIPARTTIME_H_INCLUDED#define MIPARTTIME_H_INCLUDED#include &lt;string&gt;#include \"MIStudent.h\"#include \"MIEmployee.h\"using namespace std;// Student와 Employee를 모두 상속받음class Parttime : public Student, public Employee {public: Parttime(const string&amp; s, const string&amp; c) // 생성자: 학교명, 회사명 전달 : Student(s), Employee(c) {} // 부모 클래스 생성자 호출};#endif // MIPARTTIME_H_INCLUDED다중 상속의 예 - MIMain.cpp#include \"MIParttime.h\"int main(){ Parttime chulsoo(\"ABC Univ.\", \"DEF Co.\"); // 학교, 회사 이름으로 객체 생성 chulsoo.printSchool(); // Student의 멤버 함수 호출 chulsoo.printCompany(); // Employee의 멤버 함수 호출 return 0;}다중 상속에서 모호성의 해결 2개 이상의 기초 클래스로부터 동일한 이름의 멤버를 상속 받은 경우 다중 상속에서 공통 기초 클래스의 중복 상속가상 기초 클래스 - VBPerson.h#ifndef VBPERSON_H_INCLUDED#define VBPERSON_H_INCLUDED#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person { string name;public: Person(const string &amp;n) : name(n) {} virtual ~Person() {} // 가상 소멸자(상속 대비) virtual void print() const { cout &lt;&lt; name; } // 이름 출력함수(가상 함수)};#endif // VBPERSON_H_INCLUDED가상 기초 클래스 - VBStudent.h#include \"VBPerson.h\"using namespace std;// virtual 이용해 Person을 가상 기초 클래스로 상속class Student : virtual public Person { string school;public: Student(const string&amp; n, const string&amp; s) // 생성자: 이름, 학교명 전달 : Person(n), school(s) {} void print() const { // print 함수 오버라이드 Person::print(); // 이름 출력(부모 함수 호출) cout &lt;&lt; \" goes to \" &lt;&lt; school &lt;&lt; endl; }};가상 기초 클래스 - VBEmployee.h#include \"VBPerson.h\"using namespace std;// virtual 이용해 Person을 가상 기초 클래스로 상속class Employee : virtual public Person { string company;public: Employee(const string&amp; n, const string&amp; c) : Person(n), company(c) {} void print() const { Person::print(); cout &lt;&lt; \" is employed by \" &lt;&lt; company &lt;&lt; endl; }};VBParttime.h#include \"VBStudent.h\"#include \"VBEmployee.h\"// Student와 Employee를 상속class Parttime : public Student, public Employee {public: // Person의 생성자를 명시적으로 호출함 Parttime(const string&amp; n, const string&amp; s, const string&amp; c) : Person(n), Student(n, s), Employee(n, c) {} // Person(n)에서만 Person 생성자 호출이 가능 void print() const { Student::print(); Employee::print(); }};가상 기초 클래스 - VBMain.cpp#include \"VBParttime.h\"int main(){ Parttime chulsoo(\"Chulsoo\", \"ABC Univ.\", \"DEF Co.\"); chulsoo.print(); return 0;}// Chulsoo goes to ABC Univ. Chulsoo is employed by DEF Co.연습 문제 추상 클래스와 상세 클래스에 대한 위 지문의 문장 중 올바른 것을 모두 나열한 것은? ㈀ 추상 클래스의 객체를 직접 정의할 수 있다. ㈁ 순수 가상함수를 포함하고 있는 클래스는 추상 클래스이다 ㈂ 상세 클래스는 객체를 직접 정의할 수 있다. ㈃ 추상 클래스의 파생 클래스 선언문 내에 순수 가상함수가 포함되어 있지 않다면 그 파생 클래스는 상세 클래스이다. a. ㈁ 순수 가상 함수를 포함하고 있는 클래스는 추상 클래스이다. ㈂ 상세 클래스는 객체를 직접 정의할 수 있다. ㈀ 추상 클래스는 일부 메소드의 구체적 구현이 없어(순수 가상 함수) 객체를 만들 수 없음 ㈃ 파생 클래스 내에서 순수 가상 함수를 선언하지 않은 것만으로 상세 클래스가 되는 것은 아니고, 기초 클래스에서 상속 받은 모든 순수 가상 함수를 재 정의함으로써, 상속 받은 멤버를 포함한 모든 멤버 함수 중 순수 가상 함수가 없어야 상세 클래스가 됨 위 지문의 클래스가 추상 클래스가 되게 하려고 한다. ㈀에 넣을 멤버 함수 선언문으로 올바른 것은? class Figure { int lineColor; public: void setLineColor(int c) { lineColor = c; } // _______㈀_______ }; a. virtual void draw( ) = 0; 키워드 virtual을 사용하여 가상 함수임을 알리고, = 0을 사용하여 순수 가상 함수임을 알림 위 지문은 다중 상속의 예이다. 이 경우 A가 두 번 중복 상속 되는 것을 방지하기 위해 ㈀에 넣을 키워드는? class A { // 클래스 선언 부분 생략 }; class B : // _______㈀_______ public A { // 클래스 선언 부분 생략 }; class C :// _______㈀_______ public A { // 클래스 선언 부분 생략 }; class D : public B, public C { // 클래스 선언 부분 생략 }; a. virtual 가상 기초 클래스로 상속을 받도록 하기 위해 virtual이라는 키워드를 사용함 정리 하기 추상 클래스는 그 클래스에서는 구체적으로 정의할 수는 없으나 파생 클래스에서 구체적으로 정의해야 하도록 강제하는 순수 가상 함수를 포함함 추상 클래스는 객체를 직접 정의할 수 없음 추상 클래스의 순수 가상 함수를 모두 재 정의한 파생 클래스는 상세 클래스임 다중 상속이란 2개 이상의 기초 클래스로부터 상속을 받는 것임 다중 상속의 결과 공통 기초 클래스가 발생할 경우 가상 기초 클래스로 상속 받아 중복 상속을 방지함" }, { "title": "[C++ 프로그래밍] 11강 - 상속", "url": "/posts/knou-cpp-11/", "categories": "Language, CPP", "tags": "knou, cpp", "date": "2025-06-27 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 이병래 교수님의 'C++ 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 상속을 활용하여 기초 클래스와 파생 클래스를 선언함으로써 클래스 계층 구조를 만들었을 경우, 기초 클래스의 포인터는 기초 클래스의 객체뿐만 아니라 해당 클래스 계층 구조에 속하는 파생 클래스들의 객체를 가리키게 할 수 있음 이 때 기초 클래스 포인터가 가리키고 있는 객체가 정확히 어느 클래스의 객체인가에 따라 그 객체에 맞는 동작이 이루어지게 하는 것이 필요함 이러한 클래스 계층 구조에 따른 포인터 활용 및 멤버 함수의 자동 선택이 이루어지게 하는 방법에 대하여 학습함학습 목표 클래스의 포인터로 객체를 가리켜서 포인터를 통해 객체를 사용할 수 있음 동적 연결을 사용하여 포인터가 가리키는 객체에 맞는 멤버 함수가 자동적으로 선택되어 동작하게 할 수 있음 dynamic_cast연산자를 이용하여 안전하게 다운 캐스트를 할 수 있음주요 용어 정적 연결(static binding) 이름과 그 이름에 해당하는 대상의 연결이 프로그램의 실행이 시작되기 전에 이루어지게 하는 것 동적 연결(dynamic binding) 이름과 그 이름에 해당하는 대상의 연결이 프로그램의 실행되는 동안 결정되게 하는 것 가상 함수(virtual function) 클래스 계층 구조에서 함수를 재 정의 할 때 동적 연결 방식으로 함수가 실행되도록 선언된 함수 업 캐스팅(upcasting) 파생 클래스 포인터를 기초 클래스 포인터로 변환하는 것 다운 캐스팅(downcasting) 기초 클래스 포인터를 파생 클래스 포인터로 변환하는 것 강의록상속과 포인터클래스 계층 구조와 포인터 포인터(참조)로 가리킬 수 있는 대상 int main() { Person *pPrsn1, *pPrsn2; Person dudley(\"Dudley\"); Student *pStdnt1, *pStdnt2; Student harry(\"Harry\", \"Hogwarts\"); pPrsn1 = &amp;dudley; // 부모 포인터에 부모 객채 OK pStdnt1 = &amp;harry; // 자식 포인터에 자식 객체 OK pPrsn2 = &amp;harry; // 부모 포인터에 자식 객체(업캐스팅) OK pStdnt2 = &amp;dudley; // 자식 포인터에 부모 객체(다운캐스팅) Error! return 0; } 예제: 객체 포인터 배열 객체 포인터의 배열 Person 및 Student 클래스의 객체를 가리키는 포인터를 저장하는 배열을 선언하여 객체를 가리키게 하고, 배열에 저장된 객체들을 출력하는 함수를 통해 출력하는 프로그램을 작성하라. 예제: 객체 포인터 배열 - Person.h#ifndef PERSON_H_INCLUDED#define PERSON_H_INCLUDED#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person { string name;public: Person(const string&amp; n) : name(n) { } string getName() const { return name; } void print() const { cout &lt;&lt; name; }};#endif // PERSON_H_INCLUDED예제: 객체 포인터 배열 - Student.h#include \"Person.h\"class Student : public Person { string school;public: Student(const string&amp; n, const string&amp; s) : Person(n), school(s) { } string getSchool() const { return school; } void print() const { // print() 함수 오버라이딩 Person::print(); // 부모 클래스의 print() 함수를 명시적으로 호출 cout &lt;&lt; \" goes to \" &lt;&lt; school; }};예제: 객체 포인터 배열 - PArrMain.cpp#include &lt;iostream&gt;#include \"Person.h\"#include \"Student.h\"using namespace std;void PrintPerson(const Person * const p[], int n){ for (int i=0; i &lt; n; i++) { p[i]-&gt;print(); cout &lt;&lt; endl; }}int main(){ Person dudley(\"Dudley\"); Student harry(\"Harry\", \"Hogwarts\"); Student ron(\"Ron\", \"Hogwarts\"); dudley.print(); cout &lt;&lt; endl; harry.print(); cout &lt;&lt; endl &lt;&lt; endl; Person *pPerson[3]; pPerson[0] = &amp;dudley; pPerson[1] = &amp;harry; pPerson[2] = &amp;ron; PrintPerson(pPerson, 3); return 0;}// Dudley// Harry goes to Hogwarts// Dudley// Harry// Ron가상 함수객체 포인터와 재정의 된 멤버 함수 호출정적 연결 - Sbinding.cpp#include &lt;iostream&gt;#include \"Person.h\"#include \"Student.h\"using namespace std;int main(){ Person *p1 = new Person(\"Dudley\"); p1-&gt;print(); // Person::print() 호출 cout &lt;&lt; endl; Person *p2 = new Student(\"Harry\", \"Hogwarts\"); p2-&gt;print(); // Person::print() 호출 cout &lt;&lt; endl; ((Student *)p2)-&gt;print(); // Student::print() 호출 -&gt; p2가 Student 객체를 가리키고 있으리라는 보장이 없음 cout &lt;&lt; endl; return 0;}// Dudley// Harry// Harry goes to Hogwarts동적 연결 동적 연결(dynamic binding) 객체 포인터를 통해 객체의 멤버 함수를 호출할 경우 포인터가 가리키는 실제 객체가 무엇인 가에 따라 실행 중에 멤버 함수를 결정하는 것 C++에서는 가상 함수(virtual function)로 동적 연결을 구현함 기초 클래스에서 가상 함수로 선언한 멤버 함수를 재 정의한 파생 클래스의 함수는 역시 가상 함수이며, 동적 연결이 적용됨 정적 연결로 컴파일하여 동작하는 객체 class Person { void print() const { cout &lt;&lt; name; } }; class Student : public Person { void print() const { Person::print(); cout &lt;&lt; \" goes to \" &lt;&lt; school; } }; 동적 연결로 동작하는 객체 class Person { virtual void print() const { cout &lt;&lt; name; } }; class Student : public Person { void print() const { Person::print(); cout &lt;&lt; \" goes to \" &lt;&lt; school; } }; 예: 동적 연결의 활용 - PArrMain.cppvoid PrintPerson(const Person* const p[], int n){ for (int i=0; i &lt; n; i++) { p[i]-&gt;print(); cout &lt;&lt; endl; }}int main(){ Person dudley(\"Dudley\"); Student harry(\"Harry\", \"Hogwarts\"); Student ron(\"Ron\", \"Hogwarts\"); dudley.print(); cout &lt;&lt; endl; harry.print(); cout &lt;&lt; endl; Person *pPerson[3]; pPerson[0] = &amp;dudley; pPerson[1] = &amp;harry; pPerson[2] = &amp;ron; PrintPerson(pPerson, 3); return 0;}// Dudley// Harry goes to Hogwarts// Dudley// Harry goes to Hogwarts// Ron goes to Hogwarts소멸자의 동적 연결 소멸자를 가상 함수로 선언하지 않은 경우 기초 클래스의 포인터에 연결된 파생 클래스 객체를 제거할 때 기초 클래스의 소멸자만 동작함 파생 클래스의 소멸자가 동작하지 않아 필요한 작업이 누락 됨 class BaseClass { int *ptB; public: BaseClass(int n) { ptB = new int[n]; } ~BaseClass() { delete [] ptB; } }; class DrvClass : public BaseClass { int *ptD; public: DrvClass(int n1, int n2) : BaseClass(n1) { ptD = new int[n2]; } ~DrvClass() { delete [] ptD; } }; BaseClass *pB1 = new BaseClass(5); BaseClass *pB2 = new DrvClass(10, 15); delete pB1; // 기초 클래스의 소멸자 동작 delete pB2; // 기초 클래스의 소멸자만 동작 (메모리 누수 발생) 소멸자를 가상 함수로 선언한 경우 기초 클래스의 포인터에 연결 된 파생 클래스 객체를 제거할 때 파생 클래스의 소멸자가 동작할 수 있게 함 class BaseClass { int *ptB; public: BaseClass(int n) { ptB = new int[n]; } virtual ~BaseClass() { delete [] ptB; } // virtual 선언 }; class DrvClass : public BaseClass { int *pD; public: DrvClass(int n1, int n2) : BaseClass(n1) { pD = new int[n2]; } ~DrvClass() { delete [] pD; } }; BaseClass *pB1 = new BaseClass(5); BaseClass *pB2 = new DrvClass(10, 15); delete pB1; // 기초 클래스의 소멸자 동작 delete pB2; // 파생 클래스와 기초 클래스의 소멸자가 모두 동작 업 캐스팅과 다운 캐스팅 업 캐스팅(upcasting) 파생 클래스 포인터를 기초 클래스 포인터로 변환하는 것 묵시적 형 변환을 통해 업 캐스팅을 할 수 있음 다운 캐스팅(downcasting) 기초 클래스 포인터를 파생 클래스 포인터로 변환하는 것 묵시적 형 변환을 할 수 없으며, 형 변환 연산자로 명시적 형 변환을 해야 함 Person *pPrsn1 = new Person(\"Dudley\"); Student *pStdnt1 = new Student(\"Harry\", \"Hogwarts\"); Person *pPrsn2 = pStdnt1; // upcasting Student *pStdnt2 = pPrsn2; // downcasting - Error(묵시적 형 변환 불가) static_cast연산자를 사용한 다운 캐스팅 Person 클래스의 포인터 pPrsn2가 Student 클래스의 객체를 가리키고 있었기 때문에 정상적인 동작을 함 Person *pPrsn1 = new Person(\"Dudley\"); Student *pStdnt1 = new Student(\"Harry\", \"Hogwarts\"); Person *pPrsn2 = pStdnt1; // upcasting Student *pStdnt2 = static_cast&lt;Student*&gt;(pPrsn2); cout &lt;&lt; pStdnt2-&gt;getSchool() &lt;&lt; endl; pPrsn2가 Student 클래스의 객체를 가리키고 있지 않다면 부적절한 변환을 하게 되는 문제가 있음 Person *pPrsn1 = new Person(\"Dudley\"); Student *pStdnt1 = new Student(\"Harry\", \"Hogwarts\"); Person *pPrsn2 = pPrsn1; Student *pStdnt2 = static_cast&lt;Student*&gt;(pPrsn2); cout &lt;&lt; pStdnt2-&gt;getSchool() &lt;&lt; endl; // 부적절한 호출 static_cast연산자를 사용하여 다운 캐스팅을 하는 것은 부적절한 변환의 위험이 있음 dynamic_cast연산자를 사용한 다운 캐스팅 dynamic_cast는 pPrsn1이 가리키는 대상이 Student 객체가 아니므로 nullptr을 반환함 Person *pPrsn1 = new Person(\"Dudley\"); Student *pStdnt1 = new Student(\"Harry\", \"Hogwarts\"); Person *pPrsn2 = pPrsn1; // upcasting Student *pStdnt2 = dynamic_cast&lt;Student*&gt;(pPrsn1); // nullptr if (pStdnt2) cout &lt;&lt; pStdnt2-&gt;getSchool() &lt;&lt; endl; pPrsn2가 Student 객체를 가리키고 있으므로 dynamic_cast로 정상적인 다운 캐스팅이 됨 Person *pPrsn1 = new Person(\"Dudley\"); Student *pStdnt1 = new Student(\"Harry\", \"Hogwarts\"); Person *pPrsn2 = pStdnt1; // upcasting Student *pStdnt2 = dynamic_cast&lt;Student*&gt;(pPrsn2); if (pStdnt2) cout &lt;&lt; pStdnt2-&gt;getSchool() &lt;&lt; endl; dynamic_cast를 사용하려면 클래스 선언문에 가상 함수를 포함하고 있어야 함 심화 학습override 가상 함수의 재정의 virtual은 기초 클래스의 가상 함수를 재 정의할 때는 지정할 필요가 없으며, 파생 클래스에서 새롭게 가상 함수를 선언하고자 할 때만 사용하는 것이 좋음 파생 클래스에서 어떤 함수가 가상 함수인지 명확히 알기 어려울 수 있으므로, 가상 함수를 재 정의함을 명시적으로 알리고자 할 때에는 override를 지정함 class A { virtual void f() { } }; class B : public A { void f() { } virtual void g() { } }; class A { virtual void f() { } }; class B : public A { void f() override { } virtual void g() { } }; final 가상 함수의 재정의 금지 가상 함수를 더 이상 재 정의 하지 못하게 하려면 final을 지정함 class A { virtual void f() { } }; class B : public A { void f() override final { // final 지정으로 재정의 금지 } }; class C : public B { void f() override { // error! } }; 연습 문제 DrvClass가 BaseClass의 파생 클래스이고, 이 클래스들의 객체와 포인터가 위 지문과 같이 정의 되었을 때 사용할 수 없는 문장을 모두 나열한 것은? BaseClass baseObj; DrvClass drvObj; BaseClass* basePt; DrvClass* drvPt; basePt = &amp;baseObj; // ㈀ basePt = &amp;drvObj; // ㈁ drvPt = &amp;baseObj; // ㈂ drvPt = &amp;drvObj; // ㈃ a. drvPt = &amp;baseObj; 기초 클래스 포인터는 파생 클래스 객체를 가리킬 수 있으나, 파생 클래스 포인터는 기초 클래스 객체를 가리킬 수 없음 클래스 B과 D에 대해 위 지문 문장의 실행 결과 출력 되는 결과는? class B { public: virtual void f() { cout &lt;&lt; \"B \"; } }; class D : public B { public: void f() { cout &lt;&lt; \"D \"; } }; D *pD = new D; B *pB = pD; pB-&gt;f(); pD-&gt;f(); a. D D f()를 가상 함수로 선언하였으므로 포인터에 연결된 객체가 무엇인가에 따라 함수가 선택되어 실행 됨 DrvClass가 BaseClass의 파생 클래스이고, drvPt와 basePt가 각각 DrvClass와 BaseClass의 포인터라고 하자. 위 지문의 문장을 실행하였을 때 만일 basePt가 BaseClass의 객체를 가리키고 있다면 nullptr이 drvPt에 저장되도록 하려면 ㈀에 무엇을 넣어야 하는가? drvPt = // ____㈀____(basePt); a. dynamic_cast&lt;DrvClass*&gt; dynamic_cast는 포인터를 다운 캐스팅 할 때 만일 형 변환이 안전하게 일어날 수 없을 때는 nullptr를 반환함으로써 포인터를 오용 할 가능성을 예방할 수 있게 함 위 지문은 클래스 A의 소멸자를 선언하는 문장의 일부이다. 클래스 B가 A의 파생 클래스이고, A의 포인터 pA가 동적 할당된 B의 객체를 가리키고 있다. delete연산자로 pA가 가리키고 있는 객체를 반납할 때 클래스 B의 소멸자가 동작하게 하려면 공란에 어떤 단어를 넣어야 하는가? class A { // ___________~A() { } }; a. virtual 소멸자를 가상 함수로 선언함으로써 포인터에 연결된 객체에 맞는 소멸자가 동작하도록 함 정리 하기 클래스 계층 구조에서 기초 클래스의 포인터는 해당 클래스의 객체 뿐 아니라 파생 클래스의 객체도 가리킬 수 있음 그러나 파생 클래스의 포인터로 기초 클래스의 객체를 가리키게 하면 안 됨 파생 클래스에서 재 정의하는 함수를 기초 클래스에서 가상 함수로 선언하면 기초 클래스의 포인터에 연결된 객체에 따라 해당 함수를 선택하여 동작하게 하는 동적 연결을 할 수 있음 클래스의 계층 구조에서 클래스의 소멸자는 가상 함수로 선언하여 동적 연결에 따라 소멸자가 동작할 수 있게 함 포인터의 업 캐스팅은 묵시적 형 변환을 할 수 있으나, 다운 캐스팅은 명시적으로 형 변환을 지정해야 함 가상 함수를 포함하고 있는 클래스의 경우 dynamic_cast연산자를 이용하여 더 안전하게 다운 캐스팅을 할 수 있음" }, { "title": "[C++ 프로그래밍] 10강 - 상속", "url": "/posts/knou-cpp-10/", "categories": "Language, CPP", "tags": "knou, cpp", "date": "2025-06-24 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 이병래 교수님의 'C++ 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 상속은 일반화와 특수화를 통해 계층적으로 클래스를 선언함으로써 추상화를 하는 유용한 기능임 기초 클래스의 일반적 속성 및 메소드는 파생 클래스들에 상속 됨으로써 파생 클래스들에 공통적으로 필요한 속성 및 메소드를 중복적으로 프로그래밍 하지 않아도 됨 기초 클래스와 파생 클래스로 구성되는 클래스 계층 구조를 구현하는 클래스를 선언하고 파생 클래스의 객체를 통해 기초 클래스에 포함된 멤버를 활용하는 방법에 대하여 학습함 심화 학습 주제로 final을 이용하여 파생 클래스를 더 이상 선언하지 못하게 막는 방법과 동일 이름이 선언된 영역에 따라 어떻게 사용할 수 있는지 학습함학습 목표 계층 관계로 표현되는 대상들을 기초 클래스와 파생 클래스로 표현할 수 있음 기초 클래스의 멤버를 파생 클래스에서 어떻게 사용할 수 있는지 가시성과 연관 지어 설명할 수 있음 기초 클래스와 파생 클래스의 생성자 및 소멸자가 어떻게 실행되는지 설명할 수 있음 파생 클래스의 멤버로서 기초 클래스로부터 상속된 멤버의 가시성을 지정할 수 있음주요 용어 상속(inheritance) 상위 클래스가 갖는 일반적 속성 및 행위를 하위 클래스가 이어 받게 하는 기능 기초 클래스(base class) 클래스 계층 구조에서 일반적 속성 및 메소드를 포함하는 상위 클래스 파생 클래스(derived class) 클래스 계층 구조에서 상위 클래스의 일반적 개념을 상속 받으면서, 해당 클래스에 특수한 속성 및 메소드가 추가된 하위 클래스 클래스 멤버의 가시성 (visibility) 클래스의 멤버가 외부에 공개되는 범위 멤버 함수 재정의(overriding) 기초 클래스에 정의된 멤버 함수와 동일한 멤버 함수를 파생 클래스에서 그것에 맞게 다시 정의하는 것 이름 은폐(name hiding) 어떠한 영역에 선언된 이름을 그 영역에 내포 된 영역에서 다시 선언하면 내포 된 영역에서는 바깥 영역의 이름이 은폐 되는 것 강의록기초 클래스와 파생 클래스클래스의 상속 공통적인 멤버를 포함하는 유사한 유형의 클래스 일반화와 특수화를 통한 클래스 계층 구조 설계 파생 클래스의 선언 파생 클래스 선언 형식 class DClassName : visibilitySpec BClassName { visibilitySpec_1: 데이터 멤버 또는 멤버 함수 리스트; visibilitySpec_2: 데이터 멤버 또는 멤버 함수 리스트; }; DClassName 파생 클래스 이름 BClassName 기초 클래스 이름 visibilitySpec 가시성 지시어 Person 클래스와 Student 클래스 Person 클래스 사람을 나타내는 클래스를 선언하고자 한다. 사람 객체는 이름을 가지고 있으며, 이름을 지정하거나 이름을 알릴 수 있다. ex) Dudley Student 클래스 학생을 나타내는 클래스를 선언하고자 한다. 학생 객체는 사람의 기능을 상속 받으면서, 학교 이름을 지정하거나 저장된 학교 이름을 알리는 기능이 추가된다. ex) Harry goes to Hogwarts 클래스 구조 Person 클래스의 선언 - Person1.h#ifndef PERSON1_H_INCLUDED#define PERSON1_H_INCLUDED#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person {public: string name; void setName(const string&amp; n) { name = n; } string getName() const { return name; } void print() const { cout &lt;&lt; name; }};#endif // PERSON1_H_INCLUDEDStudent 클래스의 선언 - Student1.h#include \"Person1.h\"// 파생 클래스 Student를 Person을 상속 받아 선언함class Student : public Person {public: string school; void setSchool(const string&amp; s) { school = s; } string getSchool() const { return school; } void print() const { Person::print(); cout &lt;&lt; \" goes to \" &lt;&lt; school; }};Person 및 Student 객체의 사용#include &lt;iostream&gt;#include \"Person1.h\"#include \"Student1.h\"using namespace std;int main() { Person dudley; // 기초 클래스의 객체 선언 dudley.setName(\"Dudley\"); // 기초 클래스의 함수 호출 Student harry; // 파생 클래스의 객체 선언 harry.setName(\"Harry\"); // 파생 클래스의 함수 호출 harry.setSchool(\"Hogwarts\"); // 파생 클래스의 함수 호출 dudley.print(); // 기초 클래스의 함수 호출 cout &lt;&lt; endl; harry.print(); // 파생 클래스의 함수 호출 cout &lt;&lt; endl; dudley.print(); // 기초 클래스의 함수 호출 cout &lt;&lt; endl; harry.Person::print(); // 기초 클래스의 함수 호출 cout &lt;&lt; endl; return 0;}// Dudley// Harry goes to Hogwarts// Harry클래스 계층파생 클래스의 생성자 및 소멸자파생 클래스의 생성자 및 소멸자 생성자 선언 형식 DClassName(fParameterList) : BClassName(bArgsList) { // 파생 클래스 생성자에서 추가되는 사항 } DClassName 파생 클래스 생성자 파생 클래스 이름을 사용 BClassName 기초 클래스 생성자 기초 클래스 이름을 사용 fParameterList 파생 클래스 생성자 형식 매개 변수 목록 bArgsList 기초 클래스 생성자에 전달할 인수 목록 생성자 및 소멸자의 실행 순서 생성자 기초 클래스 생성자 → 파생 클래스 생성자 파생 클래스는 기초 클래스의 내용을 바탕으로 하고 있음 객체의 기초 클래스 해당 내용이 먼저 준비 된 후 파생 클래스에 선언된 내용을 초기화할 필요가 있음 소멸자 파생 클래스 소멸자 → 기초 클래스 소멸자 기초 클래스의 속성이 제거되기 전에 이를 활용할 가능성이 있는 파생 클래스 객체를 제거해야 함 Person 클래스와 Student 클래스 (생성자/소멸자 추가)Person 클래스의 선언 - Person2.hclass Person { string name;public: Person(const string&amp; n) { cout &lt;&lt; \"Person의 생성자\" &lt;&lt; endl; name = n; } ~Person() { cout &lt;&lt; \"Person의 소멸자\" &lt;&lt; endl; } string getName() const { return name; } void print() const { cout &lt;&lt; name; }};Student 클래스의 선언 - Student2.hclass Student : public Person { string school;public: Student(const string&amp; n, const string&amp; s) : Person(n) { cout &lt;&lt; \"Student의 생성자\" &lt;&lt; endl; school = s; } ~Student() { cout &lt;&lt; \"Student의 소멸자\" &lt;&lt; endl; }};생성자 및 소멸자 동작 - Student2.cpp#include &lt;iostream&gt;#include \"Person2.h\"#include \"Student2.h\"using namespace std;int main() { Student harry(\"Harry\", \"Hogwarts\"); cout &lt;&lt; harry.getName() &lt;&lt; \" goes to \" &lt;&lt; harry.getSchool() &lt;&lt; endl; return 0;}// Person의 생성자// Student의 생성자// Harry goes to Hogwarts// Student의 소멸자// Person의 소멸자엑세스 제어가시성 가시성 지시어 가시성 지시어 공개 범위 private(디폴트) 소속 클래스의 멤버 함수   친구 클래스의 멤버 함수 및 친구 함수 protected 소속 클래스의 멤버 함수   친구 클래스의 멤버 함수 및 친구 함수   파생 클래스의 멤버 함수   파생 클래스의 친구 클래스의 멤버 함수 및 친구 함수 public 전 범위 가시성의 상속 기초 클래스로부터 상속 받은 멤버의 가시성 class DClassName : visibilitySpec BClassName { }; visibilitySpec 기초 클래스로부터 상속 된 멤버가 파생 클래스의 멤버로서 가지게 되는 가시성을 제어함 private, protected, public class를 선언할 때는 private이 디폴트 struct를 선언할 때는 public이 디폴트 visibilitySpec에 지시된 것이 가시성의 상한이 되도록 제한됨 가시성의 상속 기초 클래스로부터 상속 받은 멤버의 가시성 가시성 상속 지시어 B의 public멤버는 B의 protected멤버는 class D1 : private B {} D1의 private멤버 D1의 private멤버 class D2 : protected B {} D2의 protected멤버 D2의 protected멤버 class D3 : public B {} D3의 public 멤버 D3의 protected멤버 기초 클래스 class BaseC { private: int a; protected: int b; public: int c; int geta() const { return a; } void set(int x, int y, int z) { a = x; b = y; c = z; } }; public파생 클래스 class Drvd1 : public BaseC { public: int sum() const { return geta() + b + c; } void printbc() const { cout &lt;&lt; \"b &lt;&lt; \" &lt;&lt; b &lt;&lt; \", c \" &lt;&lt; c; } }; 객체 사용 // 객체 사용 int main() { Drvd1 d1; // d1.a = 1; // 에러(private 멤버) // d1.b = 2; // 에러(protected 멤버) d1.c = 3; // OK d1.set(10, 20, 30); // 값 설정 d1.printbc(); // b와 c 출력 return 0; } protected파생 클래스 class Drvd1 : protected BaseC { public: int sum() const { return geta() + b + c; } void printbc() const { cout &lt;&lt; \"b &lt;&lt; \" &lt;&lt; b &lt;&lt; \", c \" &lt;&lt; c; } }; 객체 사용 // 객체 사용 int main() { Drvd1 d1; // d1.a = 1; // 에러(private 멤버) // d1.b = 2; // 에러(protected 멤버) // d1.c = 3; // 에러(protected 멤버) // d1.set(10, 20, 30); // 값 설정 (protected) d1.printbc(); // b와 c 출력 (public) return 0; } 심화 학습final클래스 파생 클래스 선언의 금지 final클래스로 선언된 클래스는 파생 클래스를 더 이상 정의할 수 없음 class A { ...... }; class B : public A { ...... }; class C : final public B { ...... }; class D : public C { ...... }; // 에러 final은 키워드가 아닌 식별자(identifier)임 final클래스 지정과 같이 특별히 정해진 위치에 사용되지 않은 경우 식별자(예: 변수 이름)의 용도로 사용할 수도 있음(바람직한 용법은 아님) 이름 은폐 이름 은폐(name hiding) 어떤 영역에 선언된 이름을 그 영역에 내포된 영역에서 다시 선언하면 내포된 영역에서는 바깥 영역의 이름이 은폐 됨 void f(int x) { cout &lt;&lt; \"f(int x) --&gt; \" &lt;&lt; x &lt;&lt; endl; } void f(double x) { cout &lt;&lt; \"f(double x) --&gt; \" &lt;&lt; x &lt;&lt; endl; } int main() { f(10); // int f(20.0); // double } // f(int x) --&gt; 10 // f(double x) --&gt; 20 void f(int x) { cout &lt;&lt; \"f(int x) --&gt; \" &lt;&lt; x &lt;&lt; endl; } void f(double x) { cout &lt;&lt; \"f(double x) --&gt; \" &lt;&lt; x &lt;&lt; endl; } int main() { \tvoid f(int x); f(10); // int f(20.0); // int ::f(30.0); // double } // f(int x) --&gt; 10 // f(int x) --&gt; 20 // f(double x) --&gt; 30 void f(int x) { cout &lt;&lt; \"f(int x) --&gt; \" &lt;&lt; x &lt;&lt; endl; } void f(const char *x) { cout &lt;&lt; \"f(const char *x) --&gt; \" &lt;&lt; x &lt;&lt; endl; } int main() { void f(int x); f(10); // void f(int x); f(\"abc\"); // 에러 ::f(\"abc\"); // void f(const char* x) } 클래스 상속에서의 이름 은폐 기초 클래스에 선언된 이름을 파생 클래스에서 재정의하면 파생 클래스의 객체에서 기초 클래스의 이름이 은폐 됨 class A { public: void f(int x) { cout &lt;&lt; \"A::f() --&gt; \" &lt;&lt; x &lt;&lt; endl; } }; class B : public A { public: void f(double x) { cout &lt;&lt; \"B::f() --&gt; \" &lt;&lt; x &lt;&lt; endl; } }; int main() { B objB; objB.f(10.0); objB.f(20); } // B::f() --&gt; 10 // B::f() --&gt; 20 class A { public: void f(int x) { cout &lt;&lt; \"A::f() --&gt; \" &lt;&lt; x &lt;&lt; endl; } }; class B : public A { public: using A::f; // A 클래스의 f도 보이게 만듦 void f(double x) { cout &lt;&lt; \"B::f() --&gt; \" &lt;&lt; x &lt;&lt; endl; } }; int main() { B objB; objB.f(10.0); objB.f(20); } // B::f() --&gt; 10 // A::f() --&gt; 20 연습 문제 다음 중 클래스 계층 구조를 설계할 경우 나머지 클래스의 기초 클래스가 될 수 있는 것은? a. 자동차 기초 클래스는 일반적인 개념, 파생 클래스는 기초 클래스의 성질을 공유하면서 개개의 특수한 성질을 갖는 하위 개념을 정의할 수 있어야 함 위 지문과 같이 클래스가 선언 되었을 때 ㈀에서 사용할 수 없는 문장은? class A { char addr[20]; protected: char name[10]; public: void printA() { cout &lt;&lt; name &lt;&lt; addr; } }; class B : public A { char dep[10]; public: void f() // { (ㄱ) } }; a. cout &lt;&lt; addr; 파생 클래스의 멤버 함수에서는 기초 클래스의 protected멤버와 public멤버를 직접 사용할 수 있으며, private멤버인 addr은 직접 액세스 할 수 있음 사용할 수 있는 문장 cin &gt;&gt; name; cin &gt;&gt; dep; printA(); 위 지문의 ㈀은 클래스 B의 생성자를 선언하는 문장이다. 두 개의 정수를 인수로 전달 받아 첫 번째 인수는 A의 a, 두 번째 인수는 B의 b에 초기화한다. ㈀에 넣을 내용은 무엇인가? class A { int a; public: A(int x) : a(x) {} void display() const { cout &lt;&lt; a; } }; class B : public A { int b; public: // (ㄱ) void display() const { A::display(); cout &lt;&lt; \" \" &lt;&lt; b; } }; a. B(int x, int y) : A(x), b(y) {} 생성자의 초기화 리스트로 기초 클래스의 생성자가 호출 되도록 함 소멸자에 대한 올바른 설명은? a. 파생 클래스 객체가 제거될 때는 파생 클래스 소멸자가 실행된 후 기초 클래스의 소멸자가 실행된다. 파생 클래스 객체는 기초 클래스를 바탕으로 만들어지므로, 기초 클래스의 속성이 정리되기 전에 이를 활용할 가능성이 있는 파생 클래스 객체의 정리 작업이 이루어져야 함 위 지문과 같이 클래스 A와 B가 선언되었다. 가시성을 고려하였을 때 ㈀과 ㈁에서 사용할 수 있는 문장을 나열한 것은? class A { int a1; protected: int a2; public: int a3; }; class B : protected A { int b1; protected: int b2; public: int b3; int f() // { (ㄱ) } }; int main() { B objB; // (ㄴ) } a. ㈀ cin &gt;&gt; a2;   ㈁ objB.f( ); B의 멤버 함수에서는 A의 protected멤버와 public멤버, B의 모든 멤버를 직접 액세스할 수 있음 클래스 B는 가시성 상속 지시어 protected로 A로부터 상속을 받으므로 A의 protected와 public멤버는 클래스 B의 protected멤버가 됨 정리 하기 클래스의 계층 구조에서 기초 클래스는 일반적 속성 및 메소드를 파생 클래스는 특수한 속성 및 메소드를 포함함 기초 클래스의 protected멤버는 파생 클래스에서 액세스할 수 있음 파생 클래스의 객체가 생성 될 때 기초 클래스의 생성자가 먼저 실행 된 후 파생 클래스의 생성자 몸체 블록이 실행 됨 파생 클래스 객체가 소멸될 때는 파생 클래스 생성자 몸체 블록이 먼저 실행된 후 기초 클래스의 생성자가 실행 됨 기초 클래스로부터 상속 받은 멤버의 가시성은 가시성 상속 지시어에 의해 공개 범위의 상한이 결정 됨 final로 선언된 클래스는 파생 클래스를 더 이상 정의할 수 없음" }, { "title": "[C++ 프로그래밍] 9강 - 연산자 다중 정의", "url": "/posts/knou-cpp-9/", "categories": "Language, CPP", "tags": "knou, cpp", "date": "2025-06-23 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 이병래 교수님의 'C++ 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 복사와 이동을 용도에 맞게 활용할 수 있는 대입 및 이동 대입 연산자의 다중 정의에 대하여 학습함 두 가지 클래스의 예를 통하여 연산자 다중 정의를 적용해봄 먼저 배열을 표현하는 클래스를 통해 첨자를 통해 객체의 데이터를 액세스하기 위한 연산자를 구현하여 본 후, 문자열을 표현하기 위한 클래스를 구현해 봄 C++의 표준 라이브러리에는 문자열을 보다 편리하게 사용할 수 있게 하는 string이라는 클래스를 제공하고 있는데, string 클래스와 유사한 처리를 할 수 있는 클래스를 직접 만들어 보면서, 그 과정에서 다양한 연산자를 다중 정의해 볼 것임 이 과정에서 자료형의 변환 연산자를 정의하는 방법도 함께 살펴볼 것임학습 목표 대입 및 이동 대입 연산자를 필요에 맞게 다중 정의할 수 있음 배열 첨자 연산자를 다중 정의할 수 있음 문자열을 처리하기 위한 여러 가지 연산자를 다중 정의할 수 있음 자료형을 변환하는 연산자를 다중 정의할 수 있음주요 용어 이동 대입 연산자 좌측 피 연산자에 대입할 우측 피 연산자가 rvalue일 때 우측 피 연산자의 내용을 좌측 피 연산자로 이동하는 대입 연산자 강의록대입 및 이동 대입 연산자대입 연산자의 다중 정의 대입 연산자 (=) 묵시적인 대입 연산자 우측 피 연산자 데이터 멤버를 좌측 피 연산자에 그대로 복사함 객체에 동적 할당 된 메모리를 가리키는 포인터가 포함되어 있을 경우 얕은 복사로 인해 의도하지 않은 공유 상태의 문제가 발생할 수 있음 깊은 복사를 할 수 있는 대입 연산자를 다중 정의할 필요가 있음 VecF 클래스의 대입 연산자 다중 정의 VecF&amp; VecF::operator=(const VecF&amp; fv) { if (n != fv.n) { // 벡터의 크기가 다르다면 delete[] arr; // 기존 메모리를 반환하고 arr = new float[n = fv.n]; // 새로 메모리를 할당함 } memcpy(arr, fv.arr, sizeof(float)*n); // 데이터 복사 return *this; // 자기 자신을 참조로 돌려줌 } 이동 대입 연산자의 다중 정의 이동 대입 연산자 (=) 좌측 피 연산자에 대입 할 우측 피 연산자가 rvalue일 때 사용됨 대입 후 우측 피 연산자의 내용이 더 이상 필요 없는 상황 우측 피 연산자의 내용을 좌측 피 연산자로 이동하여 불필요한 복사를 피함으로써 효율성을 높일 수 있음 VecF 클래스의 이동 대입 연산자 다중 정의 VecF&amp; VecF::operator=(VecF&amp;&amp; fv) { // 임시로 만들어진 VecF 객체와 자원을 이동 delete[] arr; // 기존 메모리를 반환하고 n = fv.n; // 우측 피 연산자의 내용을 이동함 arr = fv.arr; fv.arr = nullptr; // nullptr로 바꿔 fv가 배열을 가리키지 않도록 함 return *this; } 대입 및 이동 대입 연산자의 활용 VFMain3.cpp #include &lt;iostream&gt; using namespace std; int main() { float a[3] = { 1, 2, 3 }; float b[3] = { 2, 4, 6 }; VecF v1(3, a); VecF v2(3, b); VecF v3(3); // 대입 연산자 (l-value를 사용한 깊은 복사) v3 = v1; // 복사 대입 연산자 호출 cout &lt;&lt; v3 &lt;&lt; endl; // 이동 대입 연산자 (r-value를 사용한 이동) v3 = v1.add(v2); // v1과 v2를 더한 결과를 새로 만들어 임시 객체로 반환 cout &lt;&lt; v1 &lt;&lt; \" + \" &lt;&lt; v2 &lt;&lt; \" = \" &lt;&lt; v3 &lt;&lt; endl; return 0; } // [ 1 2 3 ] // [ 1 2 3 ] + [ 2 4 6 ] = [ 3 6 9 ] 복사 대입 이동 대입 이동 대입에서는 v1.add(v2)로 생성된 임시 객체의 메모리 소유권이 v3로 효율적으로 이동 됨 std::move함수의 활용 두 VecF 객체를 교환하는 함수의 구현 아래 swapVecF함수는 대입 연산자를 사용하므로 비효율적인 복사가 두 번 발생함 void swapVecF(VecF&amp; v1, VecF&amp; v2) { VecF tmp(v1); // 복사 생성 v1 = v2; // 대입 연산자 사용 v2 = tmp; // 대입 연산자 사용 } int main() { float a[3] = { 1, 2, 3 }; float b[3] = { 2, 4, 6 }; VecF vec1(3, a); VecF vec2(3, b); swapVecF(vec1, vec2); } std::move함수 인수로 전달되는 객체의 rvalue 참조를 반환 lvalue를 rvalue처럼 사용할 수 있게 함 이동 생성자나 이동 대입 연산자를 강제로 호출할 수 있음 VecF tmp = std::move(v1); v1의 rvalue 참조를 구하여 tmp의 초기화에 사용 이동 생성자를 이용하여 tmp 생성 v1 = std::move(v2); v2의 rvalue 참조를 구하여 v1에 대입 이동 대입 연산자 실행 두 VecF 객체를 교환하는 함수의 구현 - std::move 활용 std::move를 사용하면 불필요한 데이터 복사 없이 포인터의 교환만으로 함수를 구현할 수 있어 효율적임 void swapVecF(VecF&amp; v1, VecF&amp; v2) { VecF tmp = move(v1); // 이동 생성자 v1 = move(v2); // 이동 대입 연산자 사용 v2 = move(tmp); // 이동 대입 연산자 사용 } int main() { float a[3] = { 1, 2, 3 }; float b[3] = { 2, 4, 6 }; VecF vec1(3, a); VecF vec2(3, b); swapVecF(vec1, vec2); } 실행 과정 VecF tmp = move(v1); tmp가 v1의 데이터 소유권을 이전 받음 v1의 포인터는 nullptr가 됨 v1 = move(v2); v1이 v2의 데이터 소유권을 이전 받음 v2의 포인터는 nullptr가 됨 v2 = move(tmp); v2가 tmp의 데이터 소유권을 이전 받음 tmp의 포인터는 nullptr가 됨 결과적으로 v1과 v2의 내용물이 효율적으로 교환 됨 []연산자의 다중 정의SafeIntArray클래스 요구 사항 배열처럼 지정 된 개수의 int 값을 저장할 수 있음 SafeIntArray a(10); // 10개의 int 값을 저장하는 객체 각각의 값들은 0번부터 시작하는 일련 번호를 첨자로 지정하여 액세스함 a[5] = 10; // 6번째 위치에 10을 저장함 첨자가 지정 된 범위를 벗어날 경우 오류 메시지를 출력한 후 프로그램을 종료함 cout &lt;&lt; a[11]; // 범위를 벗어나므로 오류 발생 []연산자의 다중 정의 []연산자 배열의 첨자를 지정하는 이항 연산자 피 연산자 배열과 첨자 데이터를 저장하기 위해 사용할 [] 연산자 SafeIntArray a(10); a[5] = 10; // a -&gt; *this, 5 -&gt; i // SafeIntArray 클래스 내부 int&amp; SafeIntArray::operator[](/assets/img/knou/cpp/2025-06-23-knou-cpp-9/int i) { // 정수 변수의 참조를 반환하기 때문에 a(n)의 값을 직접 바꾸거나 읽을 수 있음 return arr[i]; // *this 객체의 멤버인 배열의 원소를 참조로 반환 } []연산자의 다중 정의 const객체를 위한 []연산자 데이터를 읽기만 할 수 있도록 []연산자를 정의 const로 선언된 객체는 내부 데이터를 변경할 수 없으므로, 데이터를 읽기만 하는 const멤버 함수만 호출할 수 있음 const객체에 대해 []연산자를 사용하려면 const버전의 operator[]를 별도로 정의(다중 정의)해야 함 void f(const SafeIntArray&amp; x) { // x가 const이기 때문에 값을 바꿀 수 없음 for (int i=0; i &lt; x.size(); i++) cout &lt;&lt; x[i] &lt;&lt; endl; // []는 x의 값을 수정할 수 있는 연산자임 -&gt; 에러 발생 } // int&amp; SafeIntArray::operator[](/assets/img/knou/cpp/2025-06-23-knou-cpp-9/int i) { // const가 아닌 operator[]는 멤버를 수정할 수 있는 int&amp;를 반환하므로 const 객체에 대해 호출될 수 없음 // } int SafeIntArray::operator[](/assets/img/knou/cpp/2025-06-23-knou-cpp-9/int i) const { // const 한정자를 붙이고 값을 반환(l-value가 아닌)하도록 operator[]를 다중 정의 } SafeIntArray.h#include &lt;iostream&gt;class SafeIntArray { int limit; // 원소의 개수 int *arr; // 데이터 저장 공간public: // 생성자 SafeIntArray(int n) : limit(n) { arr = new int[n]; // 공간 할당 } // 소멸자 ~SafeIntArray() { delete[] arr; // 공간 반환 } // 배열의 크기를 반환 int size() const { return limit; } // l-value로 사용될 수 있는 operator[] (non-const 객체용) int&amp; operator[](/assets/img/knou/cpp/2025-06-23-knou-cpp-9/int i) { // i번 원소를 반환하는 멤버 함수 if(i &lt; 0 || i &gt;= limit) { std::cout &lt;&lt; \"첨자가 범위를 벗어나 프로그램을 종료합니다.\"; exit(EXIT_FAILURE); } return arr[i]; // i번 원소 반환 } // r-value로 사용될 수 있는 operator[] (const 객체용) int operator[](/assets/img/knou/cpp/2025-06-23-knou-cpp-9/int i) const { if(i &lt; 0 || i &gt;= limit) { std::cout &lt;&lt; \"첨자가 범위를 벗어나 프로그램을 종료합니다.\"; exit(EXIT_FAILURE); } return arr[i]; // i번 원소 반환 }};SafeArr.cpp#include &lt;iostream&gt;#include \"SafeIntArray.h\"using namespace std;int main(){ SafeIntArray a(10); // 10개의 원소를 갖는 객체 생성 for (int i = 0; i &lt; 10; i++) a[i] = i; cout &lt;&lt; a[5] &lt;&lt; endl; // 올바른 범위의 원소 액세스 cout &lt;&lt; a[12] &lt;&lt; endl; // 범위를 벗어난 액세스 return 0;}문자열 클래스C 스타일 문자열 문자열의 저장 문자열의 끝을 알리기 위해 널(null) 문자('\\0')를 사용함 Null-terminated string 문자열을 저장하기 위한 char형 배열 char str1[40] = \"C style string\"; char str2[] = \"Object-Oriented \"; 문자열 리터럴 const char* str3 = \"Programming\"; C 스타일 문자열 처리 함수 (헤더 파일: #include &lt;cstring&gt;) 문자열의 길이 구하기 size_t strlen(const char* str); n = strlen(\"abcde\");→ n = 5 널 문자는 길이에 포함되지 않음 문자열 복사하기 char* strcpy(char* strDestination, const char* strSource); char str1[10] = \"KNOU\"; strcpy(str1, \"CS\"); 문자열 연결하기 char* strcat(char* strDestination, const char* strSource); char str2[10] = \"KNOU\"; strcat(str2, \"CS\"); MyString클래스 요구 사항 문자열을 저장하되 다음의 다중 정의된 연산자를 포함하며, 실행 시 필요에 따라 저장 공간을 늘릴 수 있음 연산자 기능 = 대입 연산자, C 스타일 문자열이나 MyString 객체를 복사함 + 문자열 연결 연산자, 두 문자열을 연결한 문자열을 구힘 += 문자열을 뒤에 추가함 ==, &gt;, &lt; 관계 연산자, 두 문자열의 등호 및 순서를 비교함 &lt;&lt; 스트림 출력 연산자, 출력 스트림으로 문자열을 출력함 [] 문자열 내의 개별 문자 접근 생성자 및 소멸자 MyString(); MyString(const char* str); MyString(const MyString&amp; mstr); MyString(MyString&amp;&amp; mstr); MyString(int s); // private - 내부용으로만 사용함 ~MyString(); 기타 메소드 int length() const; // 문자열 길이 반환 데이터 멤버 데이터 멤버 용도 int len 문자열의 길이를 저장함 int bufSize 최대로 저장할 수 있는 문자열의 길이를 저장함 char* buf 문자열 저장 공간 MyString.h#include &lt;iostream&gt;class MyString { int len; // 문자열의 길이 int bufSize; // 저장 가능한 문자열의 길이 char* buf; MyString(int s); // 생성자(private)public: MyString(); // 디폴트 생성자 MyString(const char* str); // 생성자 MyString(const MyString&amp; mstr); // 복사 생성자 MyString(MyString&amp;&amp; mstr); // 이동 생성자 ~MyString(); // 소멸자 int length() const; // 문자열 길이 반환 메소드 // --- 연산자 다중 정의 --- MyString&amp; operator=(const MyString&amp; mstr); // 대입 연산자 MyString&amp; operator=(MyString&amp;&amp; mstr); // 이동 대입 연산자 MyString operator+(const MyString&amp; mstr) const; // 문자열 연결 연산자 MyString&amp; operator+=(const MyString&amp; mstr); // 문자열 추가 연산자 bool operator==(const MyString&amp; mstr) const; // == 연산자 bool operator&gt;(const MyString&amp; mstr) const; // &gt; 연산자 bool operator&lt;(const MyString&amp; mstr) const; // &lt; 연산자 char&amp; operator[](/assets/img/knou/cpp/2025-06-23-knou-cpp-9/int i); // [] 연산자 char operator[](/assets/img/knou/cpp/2025-06-23-knou-cpp-9/int i) const; // const [] 연산자 // 스트림 출력 연산자 (friend 함수로 선언) friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const MyString&amp; mstr); // 외부 함수나 클래스가 클래스 내부에 접근 가능};// 스트림 출력 연산자 구현 (inline)inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const MyString&amp; mstr){ os &lt;&lt; mstr.buf; return os;}MyString.cpp#include &lt;iostream&gt;#include &lt;cstring&gt;#include \"MyString.h\"// private 생성자MyString::MyString(int s) : len(s), bufSize(s + 1) { // 멤버 변수 값 선언 시 초기화 buf = new char[s + 1]; buf[s] = '\\0';}// 디폴트 생성자MyString::MyString() : len(0), bufSize(1) { buf = new char[1]; buf[0] = '\\0';}// 생성자MyString::MyString(const char* str) { len = bufSize = strlen(str); // 문자열 길이 buf = new char[len + 1]; // 문자열 저장 공간 할당 strcpy(buf, str); // 문자열 복사}// 복사 생성자MyString::MyString(const MyString&amp; mstr) : len(mstr.len), bufSize(mstr.len) { buf = new char[len + 1]; strcpy(buf, mstr.buf);}// 이동 생성자MyString::MyString(MyString&amp;&amp; mstr) : len(mstr.len), bufSize(mstr.bufSize), buf(mstr.buf) { mstr.buf = nullptr;}// 소멸자MyString::~MyString() { delete[] buf;}// 문자열 길이 반환 메소드int MyString::length() const { return len;}// 대입 연산자MyString&amp; MyString::operator=(const MyString&amp; mstr) { if (bufSize &lt; mstr.len) { // 문자열 공간이 필요량보다 작으면 delete[] buf; // 기존 공간 반환 len = bufSize = mstr.len; // 새로운 문자열의 길이 buf = new char[len + 1]; // 새로운 공간 할당 } else { // 그렇지 않으면 len = mstr.len; // 문자열의 길이만 수정 } strcpy(buf, mstr.buf); return *this;}// 이동 연산자MyString&amp; MyString::operator=(MyString&amp;&amp; mstr) { delete[] buf; len = mstr.len; bufSize = mstr.bufSize; buf = mstr.buf; mstr.buf = nullptr; return *this;}// 문자열 연결 연산자MyString MyString::operator+(const MyString&amp; mstr) const { MyString tmstr(len + mstr.len); // private으로 정의한 생성자 strcpy(tmstr.buf, buf); strcpy(tmstr.buf + len, mstr.buf); return tmstr;}MyString&amp; MyString::operator+=(const MyString&amp; mstr) { if (bufSize &lt; len + mstr.len) { char* tbuf = new char[bufSize = len + mstr.len + 1]; strcpy(tbuf, buf); delete[] buf; buf = tbuf; } strcpy(buf + len, mstr.buf); len += mstr.len; return *this;}char cstr1[10] = \"C string\";char cstr2[10];char* cstr3;MyString mstr1(\"MyString 객체\");MyString mstr2;// cstr2 = cstr1; // 에러cstr3 = cstr1; // 포인터 복사mstr2 = mstr1; // deep copyMSMain.cppint main() { MyString str1(\"MyString class\"); MyString str2(\"Object Oriented \"); MyString str3; cout &lt;&lt; str1 &lt;&lt; endl; // 문자열 출력 str3 = \"Programming\"; // 묵시적 형 변환 및 이동 대입 cout &lt;&lt; str3 &lt;&lt; \"의 문자열 길이는 \"; cout &lt;&lt; str3.length() &lt;&lt; endl; // 문자열 길이를 구하는 메소드 str1 = str2; // 대입 연산자로 문자열 복사 cout &lt;&lt; str1 &lt;&lt; endl; str1 = str1 + str3; // 문자열 연결 연산자, 이동 대입 연산자 }string string이란? 문자열을 저장하기 위한 표준 C++ 라이브러리의 클래스 basic_string&lt;char&gt; 헤더 파일 #include &lt;string&gt; 연산자 [], +, +=, =, ==, !=, &gt;, &gt;=, &lt;, &lt;=, 스트림 입출력(&lt;&lt;, &gt;&gt;) 등 멤버 함수 length, append, find, c_str등 함수 stoi, stod, to_string, swap, getline등 자료형의 변환묵시적 형 변환 MyString 클래스의 묵시적 형 변환 str3 = \"Programming\"; // 묵시적 변환 (자동) str3 = MyString(\"Programming\"); // 명시적 객체 생성 MyString&amp; operator=(const MyString&amp; mstr); // 복사 대입 연산자 MyString&amp; operator=(MyString&amp;&amp; mstr); // 이동 대입 연산자 MyString(\"Programming\")은 임시 객체 → rvalue MyString&amp;&amp;이동 대입 연산자가 호출 됨 형 변환 연산자를 정의하는 위치 값을 제공하는 송신 측 클래스에서 정의하는 방법 값을 받는 수신 측 클래스의 이름으로 연산자를 정의함 MyString 클래스의 객체를 C 스타일 문자열로 변환하기 class MyString { operator char*() const { char* pt = new char[length()+1]; strcpy(pt, buf); return pt; } }; 값을 제공 받는 수신 측 클래스에서 정의하는 방법 송신 측 클래스의 객체를 인수로 받는 1인수 생성자를 정의함 MyString(const char* str); 문제점 송신 측 클래스의 private멤버를 액세스해야 변환이 가능한 경우 변환 대상 송신 측 클래스의 private멤버를 액세스할 수 있는 멤버 함수가 송신 측 클래스에 정의되어 있어야 함 Meter 클래스와 Feet 클래스 class Meter { int m; int cm; public: int getM() const { return m; } int getCM() const { seturn cm; } }; class Feet { int ft; int in; public: Feet(const Meter&amp; m) { int cmeter = m.getM()*100 + m.getCM(); in = static_cast&lt;int&gt;(cmeter/2.54+0.5); ft = in / 12; in %= 12; } }; 생성자를 이용한 묵시적 형 변환의 금지 explicit으로 선언된 생성자 class MyString { explicit MyString(const char* str); // 생성자 }; 묵시적 변환 금지 에러 발생 MyString str; str = \"Programming\"; // 자동 변환 안됨 명시적 변환 시켜 사용 str = MyString{ \"Programming\" }; str = static_cast&lt;MyString&gt;(\"Programming\"); 연습 문제 int형 값을 저장하는 배열을 표현하는 클래스에서 배열 멤버의 원소를 액세스하기 위한  []연산자의 원형을 올바르게 작성한 것은? a. int&amp; operator [ ] (int i); 값을 읽거나 값을 저장할 수 있어야 하므로 참조형을 사용할 필요가 있음 원소를 참조하기 위한 첨자는 int형 값으로 해야 하며, 2항 연산자로서 배열 객체와 첨자를 각각 좌측과 우측 피 연산자로 간주하여 연산자의 매개변수로 int형 첨자를 받을 수 있게 선언함 위 지문은 두 객체의 내용을 서로 교환하기 위한 함수를 작성한 것이다. ㈀에 넣을 적절한 내용은? void swap(C1&amp; a, C2&amp; b) { C1 tmp = // ___㈀___(a); // C1의 이동 생성자 a = // ___㈀___(b); // C1의 이동 대입 연산자 사용 b = // ___㈀___(tmp); // C1의 이동 대입 연산자 사용 } a. std::move std::move함수는 인수로 전달되는 객체의 rvalue 참조를 반환함으로써 이 함수에서 이동 생성자 및 이동 대입 연산자가 사용될 수 있게 함 int형 값을 저장하는 배열을 표현하는 클래스에서 배열 멤버의 원소를 액세스하기 위한 []연산자의 원형을 올바르게 작성한 것은? class MyString { int len, bufSize; char* buf; public: bool operator &gt;= (const MyString&amp; mstr) const { return // ___㈀___; } }; a. strcmp(buf, mstr.buf) &gt;= 0 strcmp(str1, str2)는 str1과 str2가 같으면 0, str1이 str2보다 사전 순서로 앞서면 음, 그렇지 않으면 양의 값을 반환함 위 지문의 클래스에서 Pencils 객체를 int형인 연필 자루 수로 형 변환하는 연산자를 선언하기 위해 ㈀에 넣을 내용은? class Pencils { int dozen; // 타 int np; // 낱개 public: // ___㈀___ { return dozen * 12 + np; } }; a. operator int( ) const 변환하고자 하는 자료형을 연산자로 선언하면 형 변환 연산자가 만들어짐 정리 하기 대입 연산자는 우측 피 연산자의 내용을 좌측 피 연산자에 복사하고, 이동 대입 연산자는 rvalue인 우측 피 연산자를 이동하는 연산자임 std::move함수는 인수로 전달되는 객체의 rvalue 참조를 반환함 첨자 연산자([])는 첨자에 의해 지정되는 객체에 값을 저장하는 용도와 읽기 전용의 용도를 모두 고려하여 정의함 string은 문자열을 저장하기 위한 표준 C++ 라이브러리의 클래스로서, 문자열을 저장하고 처리하기 위한 유용한 기능을 제공함 형 변환 연산자는 값을 제공하는 클래스에서 값을 받는 수신 측 클래스의 이름으로 연산자를 제공하거나, 값을 제공 받는 클래스에서 값을 제공하는 클래스의 객체를 인수로 받는 1인수 생성자를 정의하여 만듬" }, { "title": "[C++ 프로그래밍] 8강 - 연산자 다중 정의", "url": "/posts/knou-cpp-8/", "categories": "Language, CPP", "tags": "knou, cpp", "date": "2025-06-18 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 이병래 교수님의 'C++ 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 C++에는 기본 자료형의 데이터에 사용할 수 있는 여러 가지 연산자가 제공 됨 연산자를 우리가 선언하는 클래스의 객체에도 사용할 수 있도록 하는 연산자 다중 정의에 대해 학습함 1개의 피연산자를 갖는 단항 연산자 및 2개의 피연산자를 갖는 이항 연산자의 다중 정의 구문 형식을 익히고, 연산자를 다중 정의하는 과정에서 유의해야 할 여러 가지 사항을 학습함학습 목표 연산자 다중 정의의 개념을 설명할 수 있음 단항 연산자를 다중 정의 할 수 있음 이항 연산자를 다중 정의 할 수 있음 friend를 활용할 수 있음주요 용어 다중 정의(overloading) 하나의 이름에 대하여 두 가지 이상의 서로 다른 선언을 하는 것 연산자 다중 정의(operator overloading) C++에 정의된 연산자를 사용자가 선언한 클래스의 객체에 대하여 사용할 수 있도록 정의 하는 것 강의록연산자 다중 정의의 개념연산자 다중 정의 피 연산자의 자료형과 연산자 동일한 연산자라도 구체적인 처리 방법은 피 연산자의 자료형에 따라 다름 10 + 20 -&gt; int형 + 연산자 10.0 + 20.0 -&gt; double형 + 연산자 연산자는 피 연산자의 자료형에 따라 그것에 맞는 처리 절차가 정의되어 있음 C++ 언어의 연산자 다중 정의 연산자 다중 정의란? C++에 정의된 연산자를 사용자가 선언한 클래스의 객체에 대하여 사용할 수 있도록 정의 하는 것 연산자 다중 정의를 할 때 주의 사항 연산자의 의미를 임의로 바꾸지 않음 연산자의 고유한 특성이 유지되도록 함 연산자의 우선 순위나 피 연산자 수 불변 전위 표기와 후위 표기 연산자의 의미 유지 주요 연산자 다중 정의의 대상 클래스의 객체 간 대입 및 이동 대입 연산자 특히 동적 할당을 받는 포인터를 포함하는 경우 고려 필요가 있음 수치형 객체의 산술 연산자 다중 정의 교환 법칙도 함께 고려함 두 객체를 비교하기 위한 관계 연산자의 다중 정의 스트림 입력 및 출력을 위한 &gt;&gt;, &lt;&lt;연산자 다중 정의를 할 수 없는 연산자 멤버 선택 연산자 (.) 멤버에 대한 포인터 연산자 (.*) 유효 범위 결정 연산자 (::) 조건 연산자 (? :) 연산자 다중 정의의 위치 클래스의 멤버로 정의하는 방법 연산자의 구현 과정에서 객체의 멤버를 액세스 할 수 있음 클래스 외부에서 정의하는 방법 클래스의 멤버가 아니므로, 객체의 private멤버는 직접 사용할 수 없음 필요하다면 private멤버를 액세스할 수 있는 방법을 마련해야 함 단항 연산자의 다중 정의단항 연산자 단항 연산자 피 연산자가 1개인 연산자 전위 표기법과 후위 표기법 수식 (a가 10일 때) 실행 결과 a의 값 실행 결과 b의 값 b = ++a; 11 11 b = a++; 11 10 b = --a; 9 9 b = a--; 9 10 전위 표기법 단항 연산자의 다중 정의 다중 정의의 형식 ReturnClass ClassName::operator opSymbol() { } opSymbol ++, -등의 단항 연산자 기호 형식 매개 변수 없음 전위 표기 ++ 연산자의 다중 정의 class IntClass1 { int a; public: IntClass1(int n=0) : a(n) {} // 생성자 IntClass1&amp; operator ++ () { // 전위 표기 ++ 연산자 다중 정의 ++a; return *this; } int getValue() const { return a; } }; IntClass1 i; cout &lt;&lt; (++i).getValue() &lt;&lt; endl; // 1 후위 표기법 단항 연산자의 다중 정의 다중 정의의 형식 ReturnClass ClassName::operator opSymbol(int) { } opSymbol ++, -등의 단항 연산자 기호 형식 매개 변수 표기 위치의 int는 인수 전달의 의미가 아니라 단지 후위 표기법을 사용하는 단항 연산자임을 나타냄 후위 표기 ++ 연산자의 다중 정의 class IntClass2 { int a; public: IntClass2(int n=0) : a(n) {} // 생성자 IntClass2 operator ++ (int) { // 후위 표기 ++ 연산자 다중 정의 IntClass2 tmp(*this); ++a; return tmp; } int getValue() const { return a; } }; IntClass2 i; cout &lt;&lt; (i++).getValue() &lt;&lt; endl; // 0 예제 : Pencils 클래스 Pencils 클래스 n타 m자루 형태로 연필의 개수를 표현하는 클래스를 정의한다(1타는 12자루). 낱개의 수를 1개 증가 시키는 전위 및 후위 표기 ++연산자를 포함하며, 연필의 수량을 출력하는 멤버 함수를 포함한다. 행위 멤버 함수 비고 Pencils() 생성자 (0으로 초기화) Pencils(int n) 생성자 (n을 타와 낱개로 변환) Pencils(int d, int n) 생성자 (d타 n자루로 초기화) Pencils&amp; operator ++() 전위 표기 ++연산자 Pencils operator ++(int) 후위 표기 ++연산자 void display() 콘솔에 내용 출력 속성 데이터 멤버 비고 int dozens 타 수 int np 낱개의 수 Pencils 클래스 - Pencils.h#ifndef PENCILS_H_INCLUDED#define PENCILS_H_INCLUDEDclass Pencils { int dozens; // 타 int np; // 낱개public: Pencils() : dozens(0), np(0) {}; Pencils(int n) { dozens = n / 12; np = n % 12; } Pencils(int d, int n) : dozens(d), np(n) {} Pencils&amp; operator ++ (); // ++ 연산자(전위 표기) Pencils operator ++(int); // ++ 연산자(후위 표기) void display() const;};#endifPencils 클래스 - Pencils.cpp#include &lt;iostream&gt;#include \"Pencils.h\"using namespace std;Pencils&amp; Pencils::operator ++() { // ++ 연산자(전위 표기) if (++np &gt;= 12) { // 낱개를 1 증가시키고 결과가 12보다 크면 ++dozens; np = 0; // 타 수를 1 증가시키고 낱개는 0 } return *this; // 증가된 결과를 반환}Pencils Pencils::operator ++(int) { // ++ 연산자(후위 표기) Pencils tmp(*this); // 현재 객체를 보존 if (++np &gt;= 12) { // 낱개를 1 증가시키고 결과가 12보다 크면 ++dozens; np = 0; // 타 수를 1 증가시키고 낱개는 0 } return tmp; // 보존된 객체를 반환}void Pencils::display() const{ if (dozens) { cout &lt;&lt; dozens &lt;&lt; \"타 \"; if (np) cout &lt;&lt; np &lt;&lt; \"자루\"; cout &lt;&lt; endl; } else cout &lt;&lt; np &lt;&lt; \"자루\" &lt;&lt; endl;}Pencils 클래스 - PnclMain.cppint main(){ Pencils p1(5, 7); Pencils p2(23); p1.display(); // 5타 7자루 (++p1).display(); // 5타 8자루 p1.display(); // 5타 8자루 cout &lt;&lt; endl; p2.display(); // 1타 11자루 p1 = p2++; p1.display(); // 1타 11자루 p2.display(); // 2타 return 0;}이항 연산자의 다중 정의이항 연산자의 다중 정의 다중 정의의 형식 ReturnClass ClassName::operator opSymbol(ArgClass arg) { } opSymbol +, *, /, &amp;&amp;, ||등의 이항 연산자 기호 객체 자신이 좌측 피 연산자, arg가 우측 피 연산자에 해당됨 예 : Complex2 클래스 복소수 객체와 복소수 객체의 덧셈 연산자 수식 complex2Obj1 + complex2Obj2 complex2Obj1 *this complex2Obj2 c 구현 Complex2 Complex2::operator + (const Complex2 &amp;c) const { Complex2 tmp(*this); tmp.rPart += c.rPart; tmp.iPart += c.iPart; return tmp; } Complex2 Complex2::operator + (const Complex2 &amp;c) const { return Complex2(rPart + c.rPart, iPart + c.iPart); } 복소수 객체와 실수의 덧셈 연산자 수식 complex2Obj + 10.0 구현 Complex2 Complex2::operator + (double r) const { return Complex2(rPart + r, iPart); } Complex2(double r=0, double i=0)라는 생성자가 정의되어 있어 double값이 묵시적으로 Complex2 객체로 형 변환되므로, 이 연산자를 정의하지 않아도 Complex2 객체 간 덧셈 연산자를 이용하여 수식을 처리할 수 있음 실수와 복소수 객체의 덧셈 연산자 좌측 피 연산자가 실수이므로 Complex2 클래스의 멤버로 연산자를 정의할 수 없음 클래스에 속하지 않는 외부의 별도 연산자로 정의함 수식 10.0 + complex2Obj 10.0 r complex2Obj c 초기 구현 시도 (오류 발생) Complex2 operator + (double r, const Complex2 &amp;c) { // 오류! private 멤버 사용 불가 return Complex2(r + c.rPart, c.iPart); } 해법 1 - Complex2에 private멤버를 액세스할 수 있는 멤버 함수 정의 class Complex2 { double rPart, iPart; public: double real() const { return rPart; } // 실수 부의 값 반환 double imag() const { return iPart; } // 허수 부의 값 반환 }; Complex2 operator + (double r, const Complex2 &amp;c) { return Complex2(r + c.real(), c.imag()); } 해법 2- Complex2에서 다중 정의된 연산자를 friend로 선언 class Complex2 { double rPart, iPart; public: friend Complex2 operator + (double r, const Complex2&amp; c); }; Complex2 operator + (double r, const Complex2 &amp;c) { return Complex2(r + c.rPart, c.iPart); } 복소수 객체의 복합 대입 연산자 수식 complex2Obj1 += complex2Obj2 구현 Complex2&amp; Complex2::operator += (const Complex2 &amp;c) { rPart += c.rPart; iPart += c.iPart; return *this; } 스트림 출력 연산자의 다중 정의스트림 출력 연산자(&lt;&lt;) 다중 정의 스트림 출력 연산자를 정의할 위치 Complex2 c(1.0, 2.0); cout &lt;&lt; c; cout &lt;&lt; c; 좌측 피 연산자인 cout이 Complex2의 객체가 아니며, cout이 속한 ostream클래스를 일반 프로그래머가 수정할 수 없음 클래스에 속하지 않는 외부의 별도 연산자로 정의함 &lt;&lt;연산자가 Complex2 객체의 private멤버를 액세스할 수 있게 friend로 지정 스트림 출력 연산자가 반환할 값 cout을 통한 연속적인 출력 문장 cout &lt;&lt; \"변수 a에 저장된 값 \" &lt;&lt; a; // 출력 후 cout 반환 반환 된 cout에 a를 출력 cout &lt;&lt; a; 스트림 출력 연산자 다중 정의의 예 클래스 내 friend선언 class Complex2 { friend ostream&amp; operator&lt;&lt;(ostream &amp;os, const Complex2 &amp;c); }; 연산자 구현 ostream&amp; operator&lt;&lt;(ostream&amp; os, const Complex2&amp; c) { os &lt;&lt; \"(\" &lt;&lt; c.rPart; // 실수 부 출력 if (c.iPart &gt; 0) os &lt;&lt; \"+j\" &lt;&lt; c.iPart; // 허수 부 출력 else if (c.iPart &lt; 0) os &lt;&lt; \"-j\" &lt;&lt; -c.iPart; os &lt;&lt; \")\"; return os; } main함수 예제 #include &lt;iostream&gt; #include \"Complex2.h\" using namespace std; int main() { Complex2 a(10, 20); Complex2 b(5, -3); cout &lt;&lt; a &lt;&lt; \" + \" &lt;&lt; b &lt;&lt; \" = \" &lt;&lt; a + b &lt;&lt; endl; return 0; } // (10+j20) + (5-j3) = (15+j17) 연습 문제 연산자를 다중 정의하는 것에 대한 올바른 설명은? a. 연산자의 의미를 임의로 바꾸지 않는다. 연산자 다중 정의를 통해 연산자의 우선 순위 피 연산자의 수 등 연산자 사용 방법을 바꿀 수 없음 연산자의 다중 정의를 하더라도 그 의미가 유지되게 하는 것이 좋은 방법임 위 지문의 클래스 선언문에서 ++ 연산자를 다중 정의하기 위해 ㈀에 넣을 적절한 내용은? class ClassA { int value; public: ClassA(int x) : value(x) { } ClassA // ㈀ { ClassA tmp(*this); ++value; return tmp; } }; a. operator++ (int) ++ 연산자를 다중 정의하는 것임 기존 객체의 내용을 복사한 후 이를 반환하는 것으로 보아 후위 표기법을 정의한 것으로 보는 것이 타당하므로, 후위 표기 단항 연산자 ++를 정의하는 문장이 사용 됨 어떤 클래스 ClassB에 위 지문과 같은 연산자를 정의하였다. 이에 대한 올바른 설명은? (x와 y는 이 클래스의 객체라고 가정함) ClassB ClassB::operator+(const ClassB&amp; a) const { // ㈀ } a. x+y 라는 수식이 사용되었을 때 ㈀에서 *this는 x이다. 클래스의 멤버로 다중 정의된 + 연산자이므로 객체 자신(즉, ㈀ 영역에서 *this)이 좌측 피 연산자, 인수로 전달된 a가 우측 피 연산자임 위 지문과 같이 ClassA의 private멤버를 자유롭게 사용하는 함수 f를 정의할 수 있도록 하려면 ㈀에 어떤 단어가 필요한가? class ClassA { int x, y; \t// ㈀ int f(const ClassA&amp; a); }; int f(const ClassA&amp; a) { return a.x + a.y; } a. friend 함수 f가 ClassA의 private멤버를 액세스할 수 있으려면 함수 f를 ClassA의 친구 함수로 선언해야 함 정리 하기 사용자가 선언한 클래스에서 C++에 정의된 연산자를 의미와 목적에 맞게 다중 정의하여 사용할 수 있음 멤버 선택 연산자, 멤버에 대한 포인터 연산자, 유효 범위 결정 연산자, 조건 연산자는 다중 정의할 수 없음 단항 연산자인 ++와 -연산자는 전위 표기와 후위 표기 각각에 대해 다중 정의할 수 있음 이항 연산자의 다중 정의는 좌측 피 연산자에 해당되는 클래스에서 하며, 이때 this가 좌측 피 연산자, 형식 매개 변수가 우측 피 연산자에 해당 됨 특정 클래스에 속하지 않은 연산자 다중 정의를 할 경우 피 연산자가 모두 매개 변수를 통해 전달 되도록 연산자 다중 정의를 함 필요하다면 피 연산자의 private멤버를 자유롭게 사용할 수 있도록 friend지정을 함" }, { "title": "[C++ 프로그래밍] 7강 - 클래스와 객체", "url": "/posts/knou-cpp-7/", "categories": "Language, CPP", "tags": "knou, cpp", "date": "2025-06-17 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 이병래 교수님의 'C++ 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 클래스 선언, 객체의 정의 및 활용 방법을 프로그램 예를 통해 복습함 스택을 표현하는 클래스를 활용하는 예를 학습함 스택은 Last-In-First-Out 특성을 갖는 자료 구조임 복소수를 표현하는 클래스를 활용하는 예를 학습함 클래스를 선언하는 형식, 생성자의 활용, 여러 가지 멤버의 선언 방법 등을 다시 한번 익혀 봄 C++11 이후 사용할 수 있는 생성자의 활용법을 심화 학습함학습 목표 스택을 클래스로 선언하여 활용할 수 있음 복소수를 표현하는 클래스를 선언하여 활용할 수 있음 소속 클래스의 다른 생성자를 이용하여 다른 생성자를 정의할 수 있음 초기화 리스트 생성자를 정의할 수 있음주요 용어 스택(stack) push와 pop연산을 이용하여 데이터를 저장하고 인출할 수 있는 자료 구조로서, 나중에 저장된 데이터가 먼저 인출될 수 있는 특성(LIFO: Last In, First Out)을 갖음 위임 생성자(delegating constructor) 클래스의 다른 생성자를 이용하여 선언되는 생성자로서, 생성자를 작성하는 코드의 중복을 줄일 수 있음 초기화 리스트 생성자(initializer-list constructor) 첫 번째 매개 변수가 std::initializer_list&lt;Type&gt;인 생성자 강의록스택 클래스 - CharStack스택의 개념 스택(stack) 데이터를 저장하는 자료 구조의 하나 스택의 기본 연산 push 데이터를 저장하는 연산 pop 마지막으로 저장한 데이터를 인출하는 연산 LIFO(Last In, First Out) 스택의 동작 push('a'), push('b'), push('c')에 의해 스택에 데이터가 추가 됨 pop()에 의해 스택에 데이터 인출 됨 c → b → a 순서로 인출 됨 스택 구현을 위한 구조 설계 예제 - CharStack 클래스 CharStack 클래스 문자를 최대 20개까지 저장할 수 있는 스택 객체를 만들 수 있는 CharStack 클래스를 선언하라. CharStack 객체는 문자 데이터를 저장(push)하거나 인출(pop)할 수 있으며, 스택이 비어있는지, 가득 차 있는 지를 검사할 수 있다. 행위 멤버함수 비고 CharStack() 생성자 bool chkEmpty() 스택이 비어 있는지 검사함 bool chkFull() 스택이 가득 차 있는지 검사함 bool push(char) 스택에 데이터를 저장함 char pop() 스택에서 데이터를 꺼냄 속성 데이터 멤버 비고 int top 가장 위에 있는 데이터 위치를 가리킴 char buf[20] 데이터 저장 공간 예제: CharStack 클래스 - CharStack.hclass CharStack { enum { size = 20 }; // 스택의 크기 int top; // 마지막 데이터를 가리키는 포인터 char buf[size]; // 스택의 저장 공간public: CharStack() : top{ size } {} // 생성자 bool chkEmpty() const { // 스택에 데이터가 없으면 true return top == size; } bool chkFull() const { // 스택이 가득 차 있으면 true return !top; } bool push(char ch); // 스택에 데이터를 넣음 char pop(); // 스택에서 데이터를 꺼냄};예제: CharStack 클래스 - CharStack.cpp#include &lt;iostream&gt;#include \"CharStack.h\"using namespace std;bool CharStack::push(char ch){ if (chkFull()) { cout &lt;&lt; \"스택이 가득 차 있습니다.\" &lt;&lt; endl; return false; } buf[--top] = ch; // 스택에 공간이 있으면 저장 return true;}char CharStack::pop(){ if (chkEmpty()) { cout &lt;&lt; \"스택에 데이터가 없습니다.\" &lt;&lt; endl; return 0; } return buf[top++]; // top 위치의 데이터 반환} push('b') pop()→ b 반환 예제: CharStack 클래스 - CSMain.cpp#include &lt;iostream&gt;#include \"CharStack.h\"using namespace std;int main(){ CharStack chStack; // 20개의 문자를 저장할 수 있는 스택 char str[20]; cout &lt;&lt; \"영어 단어를 입력하시오 : \"; cin &gt;&gt; str; char* pt = str; // 포인터로 문자열 시작 위치를 가리킴 while (*pt) // 문자열의 끝이 아니면 반복 { chStack.push(*(pt++)); // 스택에 문자를 넣음 } cout &lt;&lt; \"역순 단어 출력 : \"; while (!chStack.chkEmpty()) // 스택이 비어 있지 않으면 반복 { cout &lt;&lt; chStack.pop(); // 스택에서 인출한 문자를 출력 } cout &lt;&lt; endl; return 0;}복소수 클래스 - Complex1복소수 복소수(Complex Number) 실수 부(real part)와 허수 부(imaginary part)로 구성될 수 있는 수 복소수의 표현 a + jb a 실수 부의 값 b 허수 부의 값 j 허수 단위로서, j^2 = -1임 켤레 복소수 (complex conjugate) 허수 부의 부호가 반대인 복소수 a + jb의 켤레 복소수는 a - jb임 복소수 연산 덧셈(뺄셈) 실수 부의 합(차)과 허수 부의 합(차)을 각각 구함 (a + jb) + (d + je) = (a + d) + j(b + e) (a + jb) - (d + je) = (a - d) + j(b - e) 곱셈 (a + jb)(d + je) = (ad - be) + j(ae + bd) 나눗셈 a + jb / d + je = ad + be / d^2 + e^2 + j (bd - ae) / (d^2 + e^2) 예제: Complex1 클래스 Complex1 클래스 복소수를 표현하는 클래스를 선언하라. 복소수의 사칙 연산 및 켤레 복소수를 구하는 멤버 함수를 포함하며, 실수 부의 값이 a, 허수 부의 값이 b일 때 (a + jb) 형태로 출력할 수 있도록 한다. 행위 멤버 함수 비고 Complex1(double r, double i) 생성자 Complex1 conj() 켤레 복소수 반환 Complex1 add(const Complex1&amp; c) 덧셈 Complex1 sub(const Complex1&amp; c) 뺄셈 Complex1 mul(const Complex1&amp; c) 곱셈 Complex1 div(const Complex1&amp; c) 나눗셈 void display() 복소수의 값 출력 속성 데이터 멤버 비고 double rPart 실수 부의 값 double iPart 허수 부의 값 예제: Complex1 클래스 - Complex1.hclass Complex1 { double rPart, iPart; // 실수 부 및 허수 부 public: // 생성자 Complex1(double r=0, double i=0) : rPart(r), iPart(i) {} Complex1 conj() const { return Complex1(rPart, -iPart); // Complex1 클래스의 임시 객체를 생성 -&gt; 문장 실행 후 소멸 } Complex1 add(const Complex1&amp; c) const { return Complex1(rPart + c.rPart, iPart + c.iPart); // Complex1 클래스의 임시 객체를 생성 -&gt; 문장 실행 후 소멸 } Complex1 sub(const Complex1&amp; c) const { return Complex1(rPart - c.rPart, iPart - c.iPart); // Complex1 클래스의 임시 객체를 생성 -&gt; 문장 실행 후 소멸 } Complex1 mul(const Complex1&amp; c) const; Complex1 div(const Complex1&amp; c) const; void display() const; // 복소수 값을 출력};예제: Complex1 클래스 - Complex1.cpp#include &lt;iostream&gt;#include \"Complex1.h\"using namespace std;Complex1 Complex1::mul(const Complex1&amp; c) const{ double r = rPart * c.rPart - iPart * c.iPart; double i = rPart * c.iPart + iPart * c.rPart; return Complex1(r, i);}Complex1 Complex1::div(const Complex1&amp; c) const{ double d = c.rPart * c.rPart + c.iPart * c.iPart; Complex1 c1 = mul(c.conj()); return Complex1(c1.rPart/d, c1.iPart/d);}void Complex1::display() const{ cout &lt;&lt; \"(\" &lt;&lt; rPart; if (iPart &gt; 0) cout &lt;&lt; \"+\" &lt;&lt; iPart &lt;&lt; \"j\"; else if (iPart &lt; 0) cout &lt;&lt; \"-\" &lt;&lt; -iPart &lt;&lt; \"j\"; cout &lt;&lt; \")\";}복소수 클래스 - C1Main.cpp#include &lt;iostream&gt;#include \"Complex1.h\"using namespace std;int main(){ Complex1 c1(1, 2); Complex1 c2(2, 3); Complex1 c3 = c1.add(c2); c1.display(); cout &lt;&lt; \" + \"; c2.display(); cout &lt;&lt; \" = \"; c3.display(); cout &lt;&lt; endl; c3 = c1.mul(10.0); // 묵시적 형 변환 -&gt; c3 = c1.mul(Complex1(10.0, 0.0)); c1.display(); cout &lt;&lt; \" * 10 = \"; c3.display(); cout &lt;&lt; endl; return 0;}// (1+2j) + (2+j3) = (3+j5)// (1+j2) * 10 = (10+j20)심화 학습생성자 처리의 위임 (C++11 이후) 위임 생성자 (delegating constructor)의 선언 멤버 초기화 리스트에 클래스의 다른 생성자를 사용하여 새로운 생성자를 선언할 수 있음 위임 생성자 클래스의 다른 생성자를 이용하여 선언되는 생성자 타겟 생성자 위임의 대상이 되는 생성자 생성자를 작성하는 코드의 중복을 줄일 수 있음 VecF 클래스 class VecF { int n; float *arr; public: VecF(int d, const float* a=nullptr) : n{ d } { arr = new float[d]; if (a) memcpy(arr, a, sizeof(float) * n); } VecF(const VecF&amp; fv) : n{ fv.n } { arr = new float[n]; memcpy(arr, fv.arr, sizeof(float)*n); } }; class VecF { int n; float *arr; public: VecF(int d, const float* a=nullptr) : n{ d } { // 타겟 생성자 arr = new float[n]; if (a) memcpy(arr, a, sizeof(float) * n); } VecF(const VecF&amp; fv) : VecF(fv.n, fv.arr) {} // 위임 생성자 }; 초기화 리스트 생성자 초기화 리스트 생성자(initializer-list constructor) 첫 번째 매개 변수가 std::initializer_list&lt;Type&gt;인 생성자 std::initializer_list&lt;Type&gt; 지정된 자료형의 값들을 { }안에 나열한 리스트 헤더 파일 #include &lt;initializer_list&gt; 멤버 함수 용도 begin() 첫 번째 요소에 대한 포인터를 반환함 end() 마지막 요소의 다음 위치에 대한 포인터를 반환함 size() initializer_list의 원소 수를 반환함 initializer_list&lt;int&gt; ilst{ 1, 2, 3 }; 초기화 리스트 생성자의 활용 class VecF { int n; float *arr; public: VecF(int d, const float* a=nullptr) : n{ d } { arr = new float[d]; if (a) memcpy(arr, a, sizeof(float) * n); } VecF(initializer_list&lt;float&gt; lst) : n{ static_cast&lt;int&gt;(lst.size()) } { arr = new float[n]; copy(lst.begin(), lst.end(), arr); } }; int main() { float a[4] = {1.0f, 2.0f, 3.0f, 4.0f}; VecF v1(4, a); VecF v2{2.0f, 4.0f, 6.0f, 8.0f}; // 초기화 리스트 생성자 호출 } 연습 문제 다음 중 스택에서 데이터를 인출하는 순서에 대한 올바른 설명은? a. Last In, First Out 스택은 나중에 저장된 데이터가 먼저 인출되는 구조를 가지고 있음 First In, First Out과 같이 저장된 순서에 따라 인출하는 자료구조는 큐(queue)임 생성자를 직접 호출하는 형식의 문장 사용에 대한 올바른 설명은? a. 이름이 없는 임시 객체가 생성된다. 생성자를 직접 호출하는 명령은 임시 객체를 만들며, 그 문장을 수행한 후 제거 됨 위 지문과 같이 선언된 ClassA의 객체 obj1과 obj2에 대한 다음 문장에 대한 올바른 설명은? obj1 = obj2.add(10); class ClassA { int x, y; public: ClassA(int a=0, int b=0) : x(a), y(b) {} ClassA add(const ClassA&amp; objA) { x += objA.x; y += objA.y; return *this; } }; a. 10은 생성자(a는 10, b는 디폴트 값인 0이 사용됨)를 이용하여 ClassA의 객체로 자동 형변환이 되어 add()의 형식 매개변수로 전달된다. int 값을 인수로 전달 받는 add()는 선언되지 않았지만, 생성자를 이용하여 int 값이 ClassA의 객체로 자동 형 변환이 이루어질 수 있으므로 명령은 올바로 실행 됨 그 결과 obj2의 x에는 10이, y에는 0이 더해지며, 변화된 obj2가 obj1에 대입 됨 정리 하기 스택은 push와 pop연산을 이용하여 데이터를 저장하고 인출할 수 있는 자료 구조로서, 나중에 저장된 데이터가 먼저 인출될 수 있는 특성(LIFO: Last In, First Out)을 갖음 배열과 top을 이용하여 스택을 구현할 수 있음 push는 top을 1 감소 시킨 후 배열의 top 위치에 값을 저장하고, pop은 top 위치의 값을 반환하며 top을 1 증가 시킴 실수 부와 허수 부의 값을 저장하는 데이터 멤버와 사칙 연산 등 필요한 연산을 멤버 함수로 정의하여 복소수 클래스를 구현할 수 있음 생성자를 직접 호출하는 형식의 연산은 해당 클래스의 임시 객체를 만듬 어떤 클래스의 객체가 필요한 위치에 그 클래스의 생성자의 형식 매개변수에 해당되는 값을 사용하면 묵시적 형 변환을 통해 그 클래스의 객체로 변환 됨 위임 생성자는 클래스에 선언된 다른 생성자를 이용하여 선언되는 생성자로서, 코드 중복을 줄일 수 있음 std::initialize_list는 지정된 자료형의 값을 임의 개수 나열한 리스트를 만드는 데 사용되며, 첫 번째 매개변수가 std::initializer_list&lt;Type&gt;인 생성자를 초기화 리스트 생성자(initializer-list constructor)라고 함" }, { "title": "[C++ 프로그래밍] 6강 - 클래스와 객체", "url": "/posts/knou-cpp-6/", "categories": "Language, CPP", "tags": "knou, cpp", "date": "2025-06-12 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 이병래 교수님의 'C++ 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 클래스에 포함할 수 있는 여러 가지 유형의 생성자에 대하여 학습함 기본적인 생성자의 용법을 설명하였는데, 이 밖에도 다양한 상황을 위한 여러 가지 생성자를 활용할 수 있음 특정 객체가 아닌 클래스에 속한 객체 전체에 대한 처리나 데이터를 정의하는 static멤버에 대하여 학습함학습 목표 디폴트 생성자를 정의하여 활용할 수 있음 복사 생성자 및 이동 생성자를 용도에 맞게 정의하여 활용할 수 있음 static데이터 멤버 및 static멤버 함수를 활용할 수 있음주요 용어 디폴트 생성자(default constructor) 매개 변수가 없거나 모든 매개 변수에 디폴트 인수가 지정된 생성자 복사 생성자(copy constructor) 동일 클래스의 객체를 복사하여 객체를 만드는 생성자 얕은 복사(shallow copy) 동객체를 복사할 때 객체의 데이터 멤버의 값을 그대로 복사하는 방식 깊은 복사(deep copy) 복사 된 객체가 소스 객체와 공유하는 자원이 없는 별개의 복사본이 될 수 있도록 복사하는 방식 glvalue 객체 등의 아이덴티티를 결정하는 식 prvalue 객체 등을 초기화하거나 연산자의 피연산자 값을 계산하는 식으로, 아이덴티티는 없음 xvalue glvalue 중 보유하고 있는 자원을 재활용할 수 있는(일반적으로 생명 주기의 마지막에 도달하여 보유할 필요가 없게 되는 경우에 해당됨) 객체 등에 해당되는 식 lvalue glvalue 중 xvalue를 제외한 것으로, 그 아이덴티티가 유지되어야 하는 식 rvalue prvalue 또는 xvalue에 해당되는 식 이동 생성자(move constructor) rvalue 참조로 전달된 같은 클래스의 객체의 내용을 이동하여 객체를 만드는 생성자 강의록디폴트 생성자디폴트 생성자(default constructor) 매개 변수가 없는 생성자, 또는 모든 매개 변수에 디폴트 인수가 지정된 생성자 클래스를 선언할 때 생성자를 선언하지 않으면 컴파일러는 묵시적으로 디폴트 생성자를 정의함 묵시적 디폴트 생성자는 아무런 처리도 포함하지 않음 생성자를 하나라도 선언하면 컴파일러는 묵시적 디폴트 생성자를 정의하지 않음디폴트 생성자의 활용 묵시적 디폴트 생성자 Counter.h 클래스 정의 class Counter { int value; public: // Counter() {} // 생성자를 선언하지 않으면 컴파일러가 디폴트 생성자가 하나 있다고 생각함 void reset() { value = 0; } void count() { ++value; } int getValue() const { return value; } }; main()함수 int main() { Counter cnt; // 초기화가 되지 않은 상태로 value 데이터 멤버 가지고 있는 객체 생성 } 생성자를 한 개라도 명시적으로 선언하면 묵시적 디폴트 생성자는 포함되지 않음 디폴트 생성자가 없는 클래스 CounterM.h 클래스 정의 class CounterM { const int maxValue; int value; \t public: CounterM(int mVal) : maxValue(mVal), value{0} {} // mVal 인수 이용해 초기화 void reset() { value = 0; } void count() { value = value &lt; maxValue ? value + 1 : 0; } }; main()함수 int main() { CounterM cnt1(999); // 생성자에 해당하는 형태로 객체 생성해야 함 CounterM cnt2; // 에러 } 객체 배열의 선언 Counter.h 클래스 정의 class Counter { int Value; public: // Counter() { } // 묵시적 디폴트 생성자 void reset() { value = 0; } void count() { ++value; } int getValue() const { return value; } }; main()함수 int main() { Counter cntArr[4]; // OK Counter *pt = new Counter[10]; // OK -&gt; 카운터 객체를 동적으로 10개 생성 } CounterM.h 클래스 정의 class CounterM { const int maxValue; int value; public: // CounterM의 디폴트 생성자 없음 CounterM(int mVal) : maxValue(mVal), value{0} {} void reset() { value = 0; } }; main()함수 int main() { CounterM cntMArr1[3]; // 에러 CounterM cntMArr2[3] = {CounterM(99), CounterM(99), CounterM(999)}; // OK -&gt; 인수 전달해 초기 값 제공 CounterM *pt = new CounterM[10]; // 에러 } 복사 생성자복사 생성자의 개념 복사 생성자(copy constructor) 동일 클래스의 객체를 복사하여 객체를 만드는 생성자 반드시 자기 자신 타입의 참조를 매개 변수로 받아야 함 일반 생성자는 그 외의 인자를 받아서 객체를 생성함 묵시적 복사 생성자 객체의 데이터 멤버들을 그대로 복사하여 객체를 만들도록 묵시적으로 정의된 복사 생성자 명시적 복사 생성자를 정의하는 형식 class ClassName { public: ClassName(const ClassName &amp; obj){ // 생성되는 객체에 obj를 복사하는 처리 } }; 묵시적 복사 생성자 CounterM.h 클래스 정의 class CounterM { const int maxValue; int value; public: CounterM(int mVal) : maxValue(mVal), value{0} {} // CounterM(const CounterM &amp;c) // 묵시적인 복사 생성자 있다고 가정 // : maxValue(c.maxValue), // value(c.value) {} void reset() { value = 0; } }; main()함수 int main() { CounterM cnt4(99); // 생성자 이용해 객체 생성 CounterM cnt5(cnt4); CounterM cnt6 = cnt4; } CounterM.h 클래스 정의 (명시적 복사 생성자) class CounterM { const int maxValue; int value; public: CounterM(int mVal) : maxValue(mVal), value{0} {} CounterM(const CounterM &amp;c) // 복사 생성자 : maxValue(c.maxValue), value(c.value) {} void reset() { value = 0; } }; main()함수 int main() { CounterM cnt4(99); CounterM cnt5(cnt4); CounterM cnt6 = cnt4; } 얕은 복사의 문제점 - VecF 클래스 VecF 클래스 벡터 객체를 만들 수 있는 VecF 클래스를 정의하고자 한다. VecF 객체는 저장할 수 있는 float 값의 수를 인수로 지정하여 생성되며, 저장할 값의 배열이 제공될 경우 그 값으로 초기화한다. 인수로 전달된 VecF 객체와 덧셈한 결과를 반환할 수 있으며, 객체에 저장된 벡터를 출력할 수 있다. 행위 멤버 함수 비고 VecF(int d, const float* a) 생성자 ~VecF() 소멸자 VecF add(const VecF&amp; fv) fv와 덧셈한 결과를 반환함 void print() 벡터를 출력함 속성 데이터 멤버 비고 int n 벡터의 크기를 저장함 float* arr 벡터의 저장 공간 포인터 VecF.h #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; class VecF { int n; // private 멤버 float* arr; // private 멤버 public: VecF(int d, const float* a=nullptr) : n{d} { arr = new float[d]; if (a) memcpy(arr, a, sizeof(float) * n); // 배열이 전달 되었다면 메모리에 들어있는 내용을 다른 메모리 영역으로 복사함 } ~VecF() { // 소멸자 delete[] arr; // 할당 받은 메모리 시스템에 반납 } VecF add(const VecF&amp; fv) const { VecF tmp(n); // 벡터의 덧셈 결과를 저장할 임시 객체 for (int i = 0; i &lt; n; i++) tmp.arr[i] = arr[i] + fv.arr[i]; return tmp; // 덧셈 결과를 반환함 } void print() const { cout &lt;&lt; \"[ \"; for (int i = 0; i &lt; n; i++) cout &lt;&lt; arr[i] &lt;&lt; \" \"; cout &lt;&lt; \"]\"; } }; VFMain1.cpp #include &lt;iostream&gt; using namespace std; #include \"VecF.h\" int main() { float a[3] = { 1, 2, 3 }; VecF v1(3, a); // 1, 2, 3을 저장하는 벡터 VecF v2(v1); // v1을 복사하여 v2를 만듦 -&gt; 복사 생성자가 없기 때문에 묵시적인 복사 생성자가 생김 v1.print(); cout &lt;&lt; endl; v2.print(); cout &lt;&lt; endl; return 0; } // [ 1 2 3 ] // [ 1 2 3 ] 데이터 멤버는 별개지만 데이터 멤버 안에 있는 포인터가 가리키고 있는 메모리가 같은 자원을 가리킴 동일한 메모리를 가리킴 = shallow copy main함수가 끝나게 되면서 v1, v2, a 배열 사라지게 됨 v1, v2 소멸자 동작 v1 객체의 delete [] arr;실행 arr에 해당하는 메모리를 시스템에 반납 v2 객체의 delete [] arr;실행 이미 반납 된 arr의 메모리를 반납하려고 해서 오류 발생 복사 생성자의 활용 - VecF.h 수정본 VecF.h 수정본 class VecF { \tint n; \tfloat *arr; public: VecF(int d, const float* a=nullptr) : n{d} { arr = new float[d]; if (a) memcpy(arr, a, sizeof(float) * n); } VecF(const VecF&amp; fv) : n(fv.n) { // 명시적인 복사 생성자 추가 arr = new float[n]; memcpy(arr, fv.arr, sizeof(float)*n); // 데이터를 저장할 수 있는 메모리 별도 할당 } }; VFMain1.cpp #include &lt;iostream&gt; using namespace std; #include \"VecF.h\" int main() { float a[3] = { 1, 2, 3 }; VecF v1(3, a); // 1, 2, 3을 저장하는 벡터 VecF v2(v1); // v1을 복사하여 v2를 만듦 -&gt; 별도로 메모리 만들어서 데이터 복사 v1.print(); cout &lt;&lt; endl; v2.print(); cout &lt;&lt; endl; return 0; } // [ 1 2 3 ] // [ 1 2 3 ] deep copy 포인터가 있어 포인터에 동적으로 할당 받는 메모리가 있는 경우에 포인터 부분까지 그대로 저장 공간을 새로 할당 받아 그대로 복사 내용은 같지만 완전히 분리 된 새로운 객체가 만들어짐 main함수가 끝나게 되면서 v1, v2, a 배열 사라지게 됨 v1, v2 소멸자 동작 v1 객체의 delete [] arr;실행 arr에 해당하는 메모리를 시스템에 반납 v2 객체의 delete [] arr;실행 분리 된 객체에 저장 되기 때문에 소멸자 동작 시 오류 발생하지 않음 이동 생성자불필요한 복사의 비효율성class VecF { VecF(int d, const float* a = nullptr) { ...... } VecF(const VecF&amp; fv) : n{fv.n} { arr = new float[n]; memcpy(arr, fv.arr, sizeof(float)*n);} ~VecF() { ...... } VecF add(const VecF&amp; fv) const { VecF tmp(n); // 벡터의 덧셈 결과를 저장할 임시 객체 for (int i = 0; i &lt; n; i++) tmp.arr[i] = arr[i] + fv.arr[i]; return tmp; // 덧셈 결과를 반환함 }};int main() {\tfloat a[3] = { 1, 2, 3 };\tfloat b[3] = { 2, 4, 6 };\tVecF v1(3, a);\tVecF v2(3, b);\tVecF v3(v1.add(v2)); // 반환 객체는 v3에 복사된 후 제거됨} rvalue 참조를 이용한 이동 생성자로 효율 개선 가능rvalue 참조 전통적 의미의 lvalue와 rvalue a = b + 10; a lvalue 값을 저장할 수 있는 실체가 있는 요소 b + 10 rvalue 전달할 값이 만들어지기만 하면 됨 C++11 이후의 식의 분류 rvalue 참조의 선언 &amp; 기호로 선언하는 lvalue 참조와 달리 rvalue 참조는 &amp;&amp; 기호로 선언함 lvalue 참조와 rvalue 참조의 사용 예 VecF v1(3), v2(3); VecF&amp; vLRef = v1; // lvalue 참조로 lvalue를 참조함 int&amp; a = 10; // 오류: lvalue 참조로 rvalue를 참조할 수 없음 const int&amp; b = 20; // 상수 lvalue 참조로는 rvalue를 참조할 수 있음 int&amp;&amp; c = 30; // rvalue는 rvalue 참조로 참조할 수 있음 VecF&amp;&amp; vRRef1 = v1.add(v2); // 함수의 반환 객체는 rvalue임 VecF&amp;&amp; vRRef2 = v2; // 오류: rvalue 참조로 lvalue를 참조할 수 없음 이동 생성자의 개념 이동 생성자(move constructor) rvalue 참조로 전달된 같은 클래스의 객체의 내용을 이동하여 객체를 만드는 생성자 이동 생성자의 선언 형식 class ClassName { public: ClassName(ClassName&amp;&amp; obj){ // r value 참조한 이동 생성자 // 생성되는 객체에 obj의 내용을 이동하는 처리 } }; 이동 생성자의 활용 - VecF.h 수정본2 class VecF { int n; float *arr; public: // 복사 생성자 VecF(const VecF&amp; fv) : n(fv.n) { arr = new float[n]; memcpy(arr, fv.arr, sizeof(float)*n); } // 이동 생성자 VecF(VecF&amp;&amp; fv) : n{fv.n}, arr(fv.arr) { // r value 참조 fv.arr = nullptr; // 자기 자신이 가지고 있던 메모리를 생성 된 객체에다가 옮겨준 다음에 객체에 해당되는 내용을 nullptr로 해 자원 이동 시킴 fv.n = 0; } ~VecF() { delete[] arr; // 가지고 있는 포인터가 nullptr일 때는 아무 일도 하지않음 } }; main()함수 int main() { float a[3] = { 1, 2, 3 }; float b[3] = { 2, 4, 6 }; VecF v1(3, a); VecF v2(3, b); VecF v3(v1.add(v2)); } static데이터 멤버와 static멤버 함수객체의 메모리 공간 객체를 저장하기 위한 메모리 공간 데이터 멤버들을 저장할 수 있는 메모리 공간이 각각의 객체마다 존재 해야함 static데이터 멤버 클래스에 속하는 모든 객체들이 공유하는 데이터 멤버 객체 생성과 관계 없이 프로그램이 시작되면 static데이터 멤버를 위한 메모리 공간이 할당됨 일반 데이터 멤버와는 달리, static데이터 멤버는 클래스 선언문 내에서는 선언만 하고 클래스 외부에서 별도로 정의해야 함 static멤버 함수 특정 객체에 대한 처리를 하는 것이 아니라, 소속 클래스 단위의 작업을 수행하는 함수 static멤버 함수는 객체가 정의되지 않아도 사용할 수 있음 static멤버 함수 안에서는 일반 멤버를 사용할 수 없으며, static멤버만 사용할 수 있음 예제 : NamedObj 클래스 이름을 갖는 객체를 만들 수 있는 VecF 클래스를 정의하고자 한다. 객체가 생성될 때 고유 번호를 가지게 되는데, 이 번호는 NamedObj 객체가 생성됨에 따라 1번부터 시작하여 차례로 부여되는 일련번호이다. 객체는 자기 자신의 일련번호와 이름을 출력할 수 있으며, 현재 존재하는 NamedObj 클래스의 객체 수를 구할 수 있다. 행위 멤버함수 비고 NamedObj(const char* s) 생성자 - 이름을 s로 초기화함 ~NamedObj() 소멸자 void display() ID와 이름을 출력함 static int nObj() 현재 존재하는 객체의 수를 구함 속성 데이터 멤버 비고 char* name 이름을 저장함 int id ID 번호를 저장함 static int nConstr 생성된 객체의 수 static int nDestr 소멸된 객체의 수 NamedObj 클래스 NamedObj.h class NamedObj { char* name; int id; // static 데이터 멤버 - 클래스 전체에 하나씩만 만들어짐 static int nConste; // 생성된 객체 수 static int nDestr; // 소멸된 객체 수 public: NamedObj(const char* s); // 생성자 ~NamedObj(); // 소멸자 void display() const { // 객체의 속성 출력 cout &lt;&lt; \"ID : \" &lt;&lt; id &lt;&lt; \" 이름 : \" &lt;&lt; name &lt;&lt; endl; } static int nObj() { // static 멤버함수: 존재하는 객체 수 반환 return nConste - nDestr; // 객체가 없는 상태에서도 동작 가능해야 함 (static 멤버만 사용해야 함) } }; NamedObj.cpp #include &lt;cstring&gt; #include \"NamedObj.h\" NamedObj::NamedObj(const char* s) { name = new char[strlen(s)+1]; // 문자열을 복사할 공간을 할당 strcpy(name, s); id = ++nConste; // 생성된 객체의 수를 증가시키고 이를 ID로 부여함 } NamedObj::~NamedObj() { ++nDestr; // 소멸된 객체의 수를 증가시킴 delete [] name; } // static 데이터 멤버의 정의 및 초기화 int NamedObj::nConste = 0; // static 데이터 멤버는 클래스 선언문 안에서 선언만 해주고 별도의 cpp 파일에서 정의를 해줘야 함 int NamedObj::nDestr = 0; StaticDM.cpp void f() { NamedObj x(\"Third\"); // 세 번째 객체의 생성 x.display(); // 함수 반환 후 x는 소멸됨 } int main() { // 객체 생성 전이지만 static 멤버 함수이기 때문에 클래스 이름 이용해 호출 가능 cout &lt;&lt; \"NamedObj 클래스의 객체 수 : \" &lt;&lt; NamedObj::nObj() &lt;&lt; endl; NamedObj a(\"First\"); // 첫 번째 객체 생성 NamedObj b(\"Second\"); // 두 번째 객체 생성 f(); NamedObj c(\"Fourth\"); // 네 번째 객체 생성 c.display(); cout &lt;&lt; \"NamedObj 클래스의 객체 수 : \" &lt;&lt; NamedObj::nObj() &lt;&lt; endl; return 0; } 연습 문제 디폴트 생성자에 대한 올바른 설명은? a. 매개 변수가 없거나, 모든 매개 변수에 디폴트 인수가 지정된 생성자이다. 디폴트 생성자는 매개변수가 없거나, 모든 매개변수에 디폴트 인수가 지정된 생성자임 만일 클래스 선언문에 생성자가 없다면 컴파일러가 아무런 처리도 하지 않는 디폴트 생성자를 만듬 생성자를 하나라도 선언하였다면 컴파일러는 디폴트 생성자를 자동적으로 선언하지 않음 위 지문에서 클래스 Copycat의 ㈀에 넣을 복사 생성자의 머리부 내용은? class Copycat { char* name; public: Copycat(const char* n) { name = new char[strlen(n)+1]; strcpy(name, n); } // (ㄱ) { name = new char[strlen(cc.name)+1]; strcpy(name, cc.name); } }; a. Copycat(const Copycat&amp; cc) 복사 생성자는 참조 호출을 해야 함 이렇게 전달 된 원본 객체인 실 매개 변수를 보호할 수 있도록 const인수로 선언하는 것이 일반적임 Copycat(Copycat cc), Copycat(const Copycat cc)와 같이 값 호출을 하면 객체를 복사해야 함 복사 생성자는 복사를 담당하는 생성자이므로 복사가 필요한 값 호출을 할 수 없음 ClassA라는 클래스의 이동 생성자를 선언하기 위한 머리 부를 올바르게 작성한 것은? a. ClassA(ClassA&amp;&amp; obj) 이동 생성자는 rvalue 참조를 받을 수 있도록 매개 변수를 선언해야 하며, 이동 후 매개변수로 전달된 객체의 내용이 이동 됨으로써 객체의 내용이 바뀌어야 하므로 복사 생성자처럼 const매개 변수로 전달하는 것은 의미가 맞지 않음 클래스의 static멤버에 대한 올바른 설명은? a. 객체가 하나도 생성되지 않은 상태라도 클래스의 static 멤버 함수를 호출할 수 있다. static멤버는 특정 객체가 아닌 해당 클래스 전체를 대상으로 하는 데이터나 처리를 위해 선언 됨 static데이터 멤버는 특정 객체에 속하는 데이터가 아닌 클래스 전체에 대한 데이터이며, 객체 생성 여부와 관계없이 클래스에 대해 하나만 만들어짐 static멤버 함수는 클래스 전체를 대상으로 한 처리를 정의하며, 객체 생성 여부와 관계없이 호출될 수 있음 따라서 static멤버 함수 내에서 일반 멤버를 액세스할 수 없고 반드시 static멤버만 사용할 수 있음 정리 하기 디폴트 생성자는 인수를 지정하지 않고 객체를 생성할 수 있게 하며, 생성자를 명시적으로 선언하지 않으면 아무런 처리도 하지 않는 디폴트 생성자가 묵시적으로 정의 됨 복사 생성자는 기존의 동일 클래스 객체를 복사하여 새로운 객체를 만들 수 있게 함 rvalue 참조는 이동을 할 수 있는 대상을 참조하는 용도로 사용함 이동 생성자는 매개 변수로 전달 된, 앞으로 더 이상 필요하지 않을 객체의 내용을 이동하여 새로운 객체를 생성하기 위해 사용함 클래스에 속하는 모든 객체가 공유하는 데이터 멤버는 static멤버로 선언하며, 객체 생성과 무관하게 프로그램을 시작할 때 생성 됨 클래스의 static멤버 함수는 특정 객체가 아닌 소속 클래스 단위의 작업을 수행하는 함수이며, static멤버 함수 안에서는 static멤버만 사용할 수 있음" }, { "title": "[C++ 프로그래밍] 5강 - 클래스와 객체", "url": "/posts/knou-cpp-5/", "categories": "Language, CPP", "tags": "knou, cpp", "date": "2025-06-10 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 이병래 교수님의 'C++ 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 객체 지향 프로그래밍의 기본적 개념을 바탕으로 클래스를 선언하고 객체를 정의하여 사용하는 기본적인 구문에 대하여 학습함 클래스 선언문의 기본 형식과 클래스를 선언하기 위해 소스 파일을 구성하는 방법 등 프로그램 작성을 위한 기본적인 사항을 다룸 생성자와 소멸자를 이용하여 객체가 생성될 때와 소멸될 때 처리해야 할 작업이 자동적으로 이루어지도록 프로그램을 작성하는 방법을 학습함학습 목표 데이터 멤버와 멤버 함수로 구성되는 클래스를 선언할 수 있음 클래스 선언을 위해 필요한 소스 파일을 만들어 프로젝트를 구성할 수 있음 생성자를 이용하여 객체 생성과 함께 초기화되도록 클래스를 선언할 수 있음 소멸자를 이용하여 객체 소멸 과정에서 필요한 정리 작업을 수행할 수 있도록 클래스를 선언할 수 있음주요 용어 클래스(class) 프로그램이 표현하고자 하는 대상(객체)이 어떠한 속성(데이터 멤버)을 저장하고 있어야 하고, 어떤 행위(멤버 함수)을 할 수 있는 가를 선언한 것 객체(object) 클래스의 실제 사례(instance)에 해당되며, 고유한 속성 값(데이터 멤버의 값)을 가지며, 이를 바탕으로 클래스에 정의된 행위를 할 수 있음 캡슐화(encapsulation) 객체 내부의 상세한 구현 부분과 사용자의 관점을 분리하는 것을 나타냄 사용자는 객체의 내부 요소를 직접 사용할 수 없으며, 공개된 인터페이스를 통해 객체를 사용함 생성자(constructor) 객체가 생성될 때 수행할 작업을 정의하는 특수한 멤버 함수로, 객체의 초기화 작업을 수행함 소멸자(destructor) 객체가 소멸될 때 수행할 작업을 정의하는 특수한 멤버 함수로, 객체가 가지고 있는 자원을 반납하는 등의 처리를 담당함 강의록클래스 선언과 객체 정의객체 객체(object)란? 소프트웨어 시스템 안의 어떠한 대상을 표현한 것으로 정해진 처리를 수행할 수 있음 행위, 메소드, 멤버 함수 처리 과정에 따라 내부 상태가 변화할 수 있음 속성, 데이터 멤버 다른 객체와 상호 작용 할 수 있음 메시지 전달(멤버 함수 호출) 클래스 클래스(class)란? 객체의 설계도 객체가 포함할 데이터 멤버의 선언과 멤버 함수의 정의를 포함함 클래스 선언 클래스 선언문의 형식 class ClassName { 가시성_지시어_1: 데이터 멤버 선언; 멤버함수 선언; // 원형 선언 또는 멤버 함수 정의 가시성_지시어_2: 데이터 멤버 선언; 멤버함수 선언; // 원형 선언 또는 멤버 함수 정의 }; 가시성 지시어 클래스의 멤버가 공개되는 범위를 나타냄 종류 private, public, protected 공개 범위 가시성 지시어 공개 범위 private (디폴트) 소속 클래스의 멤버 함수   친구 클래스의 멤버 함수 및 친구 함수   그 외의 범위에는 비공개 public 전 범위 용도 가시성 지시어 용도 private (디폴트) 정보 은닉을 위해 사용됨   클래스의 구현을 위한 내부 상태(데이터 멤버)는 일반적으로 private으로 지정함 public 주로 외부에 제공할 인터페이스를 공개하기 위해 사용됨 캡슐화(encapsulation) 객체 내부의 상세한 구현 부분과 외부 사용자의 관점을 분리함 내부 속성 등 구현에 대한 부분은 공개하지 않으며(정보 은닉), 객체 외부에서는 공개된 인터페이스를 통해 객체를 사용할 수 있음 클래스의 예 - Counter클래스 Counter클래스 계수기를 나타내는 클래스를 선언하라. 계수기 객체는 값을 0으로 지울 수 있고, 값을 1씩 증가 시킬 수 있으며, 현재의 계수기 값을 알려줄 수 있다. 행위 멤버함수 비고 void reset() 계수기의 값을 0으로 지움 void count() 계수기의 값을 +1 증가 시킴 int getValue() 계수기의 현재 값을 알려 줌 속성 Counter -value: int +reset(): void +count(): void +getValue(): int Counter 클래스의 선언 - Counter.h#ifndef COUNTER_H_INCLUDED#define COUNTER_H_INCLUDEDclass Counter { // 클래스 Counter의 선언 시작 /** * Counter의 멤버 선언 **/};#endif // COUNTER_H_INCLUDED객체의 정의 및 사용 객체 정의 형식 ClassName objName; ClassName objName1, objName2, ······; ex) int main() { Counter c1, c2; } 객체 사용 형식 객체 이름에 멤버 선택 연산자(.)를 사용하여 객체의 멤버를 액세스함 cin &gt;&gt; objName.dataMember; objName.memFunc( ); 객체의 멤버 함수 안에서 그 객체에 속한 멤버를 사용할 때는 멤버 이름만으로 액세스함 ex) class Counter { int value; public: void reset() { value = 0; } void count() { ++value; } int getValue() const { return value; } }; int main() { Counter c; c.reset(); c.count(); } Counter 객체의 정의 및 사용 - CntMain.cpp private멤버 접근하기 때문에 오류 발생 #include &lt;iostream&gt; #include \"Counter.h\" using namespace std; int main() { Counter cnt; // Counter 객체의 정의 cnt.value = 0; // 계수기를 0으로 지움 cout &lt;&lt; \"계수기의 현재 값 : \" &lt;&lt; cnt.value &lt;&lt; endl; cnt.value++; // 계수기를 1 증가시킴 cnt.value++; cout &lt;&lt; \"계수기의 현재 값 : \" &lt;&lt; cnt.value &lt;&lt; endl; return 0; } class Counter { int value; public: void reset() { value = 0; } void count() { ++value; } int getValue() const { return value; } }; 올바른 사용 법 #include &lt;iostream&gt; #include \"Counter.h\" using namespace std; int main() { Counter cnt; // Counter 객체의 정의 cnt.reset(); // 계수기를 0으로 지움 cout &lt;&lt; \"계수기의 현재 값 : \" &lt;&lt; cnt.getValue() &lt;&lt; endl; cnt.count(); // 계수기를 1 증가시킴 cnt.count(); cout &lt;&lt; \"계수기의 현재 값 : \" &lt;&lt; cnt.getValue() &lt;&lt; endl; return 0; } cnt:Counter -value ? cnt:Counter -value 0 cnt:Counter -value 1 cnt:Counter -value 2 const멤버 함수 데이터 멤버의 값을 수정하지 않는 멤버 함수 Counter.h class Counter { int value; public: void reset() { value = 0; } void count() { ++value; } int getValue() const { return value; } }; const Counter c; int n = c.getValue(); // OK! c.count(); // 오류 Counter.h class Counter { int value; public: void reset() { value = 0; } void count() { ++value; } int getValue() { return value; } }; void f(Counter&amp; c) { c.count(); cout &lt;&lt; c.getValue(); } 오류 void g(const Counter&amp; c) { cout &lt;&lt; c.getValue(); } Counter.h class Counter { int value; public: void reset() { value = 0; } void count() { ++value; } int getValue() const { return value; } }; void f(Counter&amp; c) { c.count(); cout &lt;&lt; c.getValue(); } void g(const Counter&amp; c) { cout &lt;&lt; c.getValue(); } 소스 파일의 구성생성자생성자 생성자(constructor) 객체가 생성될 때 수행할 작업을 정의하는 특수한 멤버 함수 생성자에 인수를 전달할 수 있도록 매개 변수를 선언할 수 있음 생성자를 여러 개 다중정의할 수 있음 생성자의 특성 클래스의 이름을 사용하여 선언함 생성자 머리에 반환 자료형을 표시하지 않으며, return명령으로 값을 반환할 수 없음 생성자를 public으로 선언해야 클래스 외부에서 객체를 생성할 수 있음 생성자 선언 형식 class ClassName { public: // 생성자 ClassName(fParameterList){ // 객체 생성을 위한 준비 작업 } }; 생성자의 예 - Counter클래스 Counter.h (생성자 없는 버전) class Counter { int value; public: void reset() { value = 0; } void count() { ++value; } int getValue() const { return value; } }; CntMain.cpp int main() { Counter cnt; cnt.reset(); cout &lt;&lt; \"계수기의 현재 값 : \" &lt;&lt; cnt.getValue() &lt;&lt; endl; cnt.count(); cnt.count(); cout &lt;&lt; \"계수기의 현재 값 : \" &lt;&lt; cnt.getValue() &lt;&lt; endl; return 0; } cnt:Counter -value 0 Counter.h (생성자 있는 버전) class Counter { int value; public: Counter() { value = 0; } void reset() { value = 0; } void count() { ++value; } int getValue() const { return value; } }; CntMain.cpp int main() { Counter cnt; // cnt.reset(); cout &lt;&lt; \"계수기의 현재 값 : \" &lt;&lt; cnt.getValue() &lt;&lt; endl; cnt.count(); cnt.count(); cout &lt;&lt; \"계수기의 현재 값 : \" &lt;&lt; cnt.getValue() &lt;&lt; endl; return 0; } cnt:Counter -value 0 초기화 리스트 초기화 리스트 생성자의 머리에 데이터 멤버를 초기화하는 값들을 나열한 리스트 데이터멤버이름{초깃값}형태로 초깃 값을 지정 Counter.h class Counter { int value; public: Counter() : value{0} { } // 생성자 }; 소멸자소멸자 소멸자(destructor) 객체가 소멸될 때 수행할 작업을 정의하는 특수한 멤버 함수 소멸자의 특성 클래스의 이름에 ~를 붙여 선언함 소멸자 머리에 반환 자료형을 표시하지 않으며, return명령으로 값을 반환할 수 없음 매개 변수가 없으며, 클래스에 하나의 소멸자만 정의할 수 있음 public으로 선언하는 것이 일반적임 상속을 통해 파생 클래스를 정의하는 경우 virtual을 지정하여 가상 함수가 되도록 하는 것이 좋음 소멸자 선언 형식 class ClassName { public: ClassName(fParameterList) { // 생성자 // 객체 생성을 위한 준비 작업 } ~ClassName() { // 소멸자 // 객체 제거를 위한 정리 작업 } }; Person클래스의 명세 Person클래스 사람을 나타내는 클래스를 선언하고자 한다. 사람 객체는 ‘···에 사는 ···입니다.’라고 자신을 알릴 수 있으며, 주소를 변경할 수 있다. 행위 멤버 함수 비고 Person(char* name, char* addr) 생성자 ~Person() 소멸자 void print() ‘···에 사는 ···입니다’ 라고 출력함 void chAddr(char* newAddr) 주소를 변경함 속성 데이터 멤버 비고 char* name 이름을 저장함 char* addr 주소를 저장함 Person 클래스의 선언 - Person.h#ifndef PERSON_H_INCLUDED#define PERSON_H_INCLUDEDclass Person { // 클래스 Person의 선언 시작 char* name; // 이름을 저장하는 데이터멤버 char* addr; // 주소를 저장하는 데이터멤버public: // public 멤버함수 Person(const char* name, const char* addr); // 생성자 ~Person(); // 소멸자 void print() const; // 이름과 주소 출력 void chAddr(const char* newAddr); // 주소 변경};#endif // PERSON_H_INCLUDEDPerson 클래스의 선언 - Person.cpp#include &lt;iostream&gt;#include &lt;cstring&gt;#include \"Person.h\"using namespace std;Person::Person(const char* name, const char* addr){ // 이름을 저장할 공간 할당 this -&gt; name = new char[strlen(name) + 1]; // 데이터 멤버 name에 이름을 복사 strcpy(this -&gt; name, name); // 주소를 저장할 공간 할당 this -&gt;addr = new char[strlen(addr) + 1]; // 데이터 멤버 addr에 주소를 복사 strcpy(this -&gt; addr, addr); cout &lt;&lt; \"Person 객체 생성함(\" &lt;&lt; name &lt;&lt; \")\" &lt;&lt; endl;}Person::~Person() // 소멸자{ cout &lt;&lt; \"Person 객체 제거함(\" &lt;&lt; name &lt;&lt; \")\" &lt;&lt; endl; delete[] name; // 이름 저장공간 반납 delete[] addr; // 주소 저장공간 반납}void Person::print() const{ cout &lt;&lt; addr &lt;&lt; \"에 사는 \" &lt;&lt; name &lt;&lt; \"입니다.\" &lt;&lt; endl;}void Person::chAddr(const char* newAddr){ delete[] addr; // 기존 공간 반납 // 새로운 주소에 맞는 공간 할당 addr = new char[strlen(newAddr) + 1]; strcpy(addr, newAddr); // 데이터멤버 addr에 새로운 주소를 복사}Person 클래스의 선언 - PrsnMain.cpp#include &lt;iostream&gt;#include \"Person.h\"using namespace std;int main(){ Person* p1 = new Person(\"이철수\", \"서울시 종로구\"); Person* p2 = new Person(\"박은미\", \"강원도 동해시\"); p1-&gt;print(); p2-&gt;print(); cout &lt;&lt; endl &lt;&lt; \"주소 변경 : \"; p2-&gt;chAddr(\"대전시 서구\"); p2-&gt;print(); delete p1; delete p2; return 0;} 출력 화면 Person 객체 생성함(이철수) Person 객체 생성함(박은미) 서울시 종로구에 사는 이철수입니다. 강원도 동해시에 사는 박은미입니다. 주소 변경 : 대전시 서구에 사는 박은미입니다. Person 객체 제거함(이철수) Person 객체 제거함(박은미) 연습 문제 다음 중 클래스 선언문에서 정보 은닉을 위해 사용되는 가시성 지시어는? a. private 클래스의 구현을 위한 내부 상태인 데이터 멤버는 일반적으로 private으로 지정하며,정보 은닉을 위해 사용됨 외부에 제공할 인터페이스로 공개하기 위해서는 public으로 지정함 위 지문의 클래스 선언문에서 멤버 함수 memF1()의 몸체 (가)에서 사용할 수 있는 문장은? class ClassA { int a, b; public: int memF1() const { // (가) } }; a. return a * b; 멤버 함수 memF1()은 const멤버 함수로 선언되었으므로, 함수 내에서 데이터 멤버 a나 b에 대해서는 값을 읽을 수만 있고 값을 변경하는 문장은 사용할 수 없음 위 지문의 클래스 선언문에서 const키워드를 넣는 것이 바람직한 곳을 모두 나열한 것은? class Counter { int value; public: Counter() // ___(ㄱ)___ {value = 0;} void reset() // ___(ㄴ)___ {value = 0;} void count() // ___(ㄷ)___ {++value;} int getValue() // ___(ㄹ)___ {return value;} }; a. ㄹ 데이터 멤버의 값을 수정하지 않는 멤버 함수에 대하여 const를 지정함 위 지문의 클래스에서 객체가 생성될 때 데이터 멤버 x가 0으로 초기화되도록 공란에 생성자를 선언한 것으로 적절한 것은? class ClassB { int x; public: // ______ }; a. ClassB() : x{0} {  } 생성자는 클래스의 이름과 같고 결과 값을 반환하지 않으며, 이러한 경우 일반 함수에서는 함수의 머리 부에 반환 자료형을 void로 표기하나, 생성자의 경우는 이마저도 표기하지 않음 함수의 몸체에서는 x에 0을 대입하는 문장을 사용하거나, 초기화 리스트를 이용하여 x를 초기화함 위 지문은 ClassA의 선언문 일부이다. 소멸자의 머리부 ㈀에 넣을 적절한 내용은? class ClassA { int x; public: // __(ㄱ)__ { } }; a. ~ClassA() 소멸자는 클래스의 이름에 ~를 붙인 이름을 사용하며, 인수를 전달 받을 수 없음 또한 return명령으로 값을 반환 할 수 없으며, 일반 함수처럼 void라고 표기하지도 않음 정리 하기 클래스는 프로그램이 표현하고자 하는 대상(객체)이 어떠한 속성(데이터 멤버)를 저장하고 있어야 하고, 어떤 행위(멤버 함수)를 할 수 있는 가를 선언한 것임 클래스에 해당 되는 실제 사례(instance)를 객체(object)라고 함 객체는 고유한 속성 값(데이터 멤버의 값)을 가지며, 이를 바탕으로 클래스에 정의 된 행위를 할 수 있음 가시성 지시어 private, public, protected는 클래스의 멤버가 공개 되는 범위를 지정하기 위해 사용 되는데, 정보 은닉을 위해 private을, 외부에 제공할 인터페이스를 공개하기 위해 public을 사용함 클래스에서 데이터 멤버의 값을 변경하지 않는 멤버 함수는 const멤버 함수로 정의함 생성자는 객체가 생성 될 때 수행하는 작업을 정의하는 특수한 멤버 함수로서, 클래스 이름과 동일한 이름으로 선언하며, 일반적으로 객체를 초기화 하는 작업을 수행함 소멸자는 객체가 소멸 될 때 수행할 작업을 정의하는 특수한 멤버 함수로, 클래스 이름과 동일한 이름 앞에 ~를 붙여 선언하며, 객체가 가지고 있는 자원을 반납하는 등의 처리를 담당함" }, { "title": "[C++ 프로그래밍] 4강 - 함수", "url": "/posts/knou-cpp-4/", "categories": "Language, CPP", "tags": "knou, cpp", "date": "2025-06-09 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 이병래 교수님의 'C++ 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 함수는 C++ 프로그램을 구성하는 기본 단위임 함수의 기본적인 형식과 함께, 함수에 인수를 전달하는 방법, 개념적으로 동일한 처리를 대상에 맞게 정의할 수 있게 하는 함수 다중 정의, 효율적인 프로그램 작성이 매우 중요한 경우 활용할 수 있는 inline 함수에 대하여 학습함 함수 자체는 C 언어에서와 동일하나, 참조 호출, 함수 다중 정의와 같은 기능은 C++에서 확장된 부분으로 많이 사용되는 내용임학습 목표 함수의 머리부와 몸체부를 문법에 맞게 작성할 수 있음 값 호출과 참조 호출을 할 경우 형식 매개변수와 실 매개변수 사이에 인수가 어떻게 전달되는지 설명할 수 있음 동일한 이름의 함수가 인수에 따라 서로 다른 동작을 하도록 함수를 정의할 수 있음 필요한 경우 함수의 호출 과정이 효율적으로 이루어질 수 있도록 지정할 수 있음주요 용어 순환 호출(recursive call) 함수에서 직접 또는 간접적으로 그 함수를 호출하는 것 인수(argument) 함수 호출 문장에서 함수에 전달하기 위해 나열된 식 실 매개변수(actual parameter) 함수 호출 문장에서 함수의 형식 매개변수에 전달할 인수 형식 매개변수(formal parameter) 인수를 전달 받기 위해 함수에 선언된 매개 변수 값 호출(call-by-value) 실 매개 변수의 값을 형식 매개변수에 복사하는 매개변수 전달 방식 참조 호출(call-by-reference) 실 매개 변수의 참조를 형식 매개변수에 전달하는 매개변수 전달 방식 함수 다중 정의 동일한 이름을 갖는 함수를 여러 개 정의하는 것 강의록함수의 정의와 호출함수의 개념 다음 프로그램이 하는 작업은? int main() { double a[50], b[100]; // 생략: a와 b에 각각 50개와 100개의 데이터 준비 double max = a[0]; for (int i = 1; i &lt; 50; i++) if (max &lt; a[i]) max = a[i]; cout &lt;&lt; max &lt;&lt; endl; max = b[0]; for (int i = 1; i &lt; 100; i++) if (max &lt; b[i]) max = b[i]; cout &lt;&lt; max &lt;&lt; endl; } 함수를 이용하여 작성된 프로그램 double maximum(const double arr[], int n) { double max = arr[0]; for (int i = 1; i &lt; n; i++) if (max &lt; arr[i]) max = arr[i]; return max; } int main() { double a[50], b[100]; // 생략: a와 b에 각각 50개와 100개의 데이터 준비 cout &lt;&lt; maximum(a, 50) &lt;&lt; endl; cout &lt;&lt; maximum(b, 100) &lt;&lt; endl; } 함수란? 특정 작업을 수행하는 프로그램 문장들을 하나의 단위로 모아 놓고 이름을 부여한 것 함수에 정의된 처리가 필요한 부분에서 호출하여 사용함 매개 변수를 통해 함수에서 처리할 데이터(인수)를 전달함 호출된 함수로 이동하여 함수 몸체 블록을 실행함 정해진 처리를 한 후 결과 값을 반환할 수 있음 함수의 실행을 완료하면 호출한 곳으로 복귀함 C++ 프로그램은 함수를 기본 단위로 하여 구성됨 함수 사용 형식 함수 정의 형식 ReturnType functionName(fParameterList) // 머리부 { // 몸체 블록 Type1 localVar1; // 지역변수 선언 Type2 localVar2; statement1; // 처리 작업을 수행하는 문장 statement2; return returnExpression; // 결과 값을 반환함 } fParameterList 인수를 받기 위한 형식 매개 변수 선언 ReturnType 함수의 결과로 반환하는 값의 자료형 returnExpression 함수의 결과로 반환하는 값 return명령 함수를 마치고 함수를 호출한 곳으로 복귀하는 명령 함수 안의 어느 곳이든 복귀를 위해 사용할 수 있음 returnExpression은 함수 머리 부에 선언한 ReturnType과 일치하는 자료형의 수식 또는 묵시적 형 변환이 가능한 자료형의 수식을 사용함 반환하는 값이 없는 함수는 ReturnType은 void로 선언함 main함수에서는 return명령을 만나지 않은 상태로 함수의 끝에 도달하면 return 0;을 실행한 것 같음 함수 호출 형식 functionName(aParameterList); varName = functionName(aParameterList); aParameterList 인수로 전달할 실 매개 변수 나열 형식 1 반환 값 유무에 관계없이 사용 가능함 형식 2 ReturnType이 void가 아닌 함수에 사용할 수 있음 함수 사용 예 - ConvFtoC.cpp#include &lt;iostream&gt;using namespace std;// 화씨온도를 섭씨온도로 변환하는 함수// 매개변수 float fahr: 화씨온도// 반환값 섭씨온도(float)float FahrToC(float fahr){ return (fahr - 32) * 5 / 9;}int main(){ float fTemp, cTemp; cout &lt;&lt; \"화씨온도 : \"; cin &gt;&gt; fTemp; cTemp = FahrToC(fTemp); // 함수 호출 cout &lt;&lt; \"---&gt; 섭씨온도 : \" &lt;&lt; cTemp &lt;&lt; endl; return 0;}함수의 원형float FahrToC(float fahr); // 함수의 원형int main(){ float fTemp, cTemp; cout &lt;&lt; \"화씨온도 : \"; cin &gt;&gt; fTemp; cTemp = FahrToC(fTemp); // 함수 호출 cout &lt;&lt; \"---&gt; 섭씨온도 : \" &lt;&lt; cTemp &lt;&lt; endl; return 0;}float FahrToC(float fahr){ return (fahr - 32) * 5 / 9;}함수의 순환 호출 순환 호출 (recursive call) 함수를 정의하는 몸체 블록 안에서 직접 또는 간접적으로 그 함수를 호출하도록 코드를 작성하는 것 순환 호출의 예 팩토리얼 계산 함수의 순환 호출 구현 int factorial(int n) { if (n &lt;= 1) **return 1; else return n * factorial(n - 1); } 함수의 장점과 단점 장점 크고 복잡한 프로그램을 작은 크기의 의미 있는 작업 단위로 분할하여 구성 간결하고 이해하기 쉬운 프로그램을 만들 수 있음 반복 사용되는 코드의 중복 방지 잘 설계된 함수는 다른 응용에서 재 사용할 수 있음 단점 함수 호출과 복귀 과정에서 처리 시간이 추가됨 매우 효율적으로 동작해야 하는 함수라면 inline함수로 선언함 인수의 전달인수(argument)와 매개 변수(parameter) 인수(argument) 함수 호출 문장에서 함수에 전달하는 식(expression) 여러 개의 인수가 있을 경우 콤마(,)로 구분하여 나열함 매개 변수를 통해 인수를 전달함 실 매개 변수(actual parameter) 함수 호출 문장에서 함수의 형식 매개 변수에 전달할 인수 int main() { // ... cTemp = FahrToC(fTemp); // fTemp : 실 매개 변수 // ... } 형식 매개 변수(formal parameter) 인수를 전달 받기 위해 함수에 선언된 매개 변수 함수 헤더에 매개 변수의 자료형과 이름을 선언함 float FahrToC(float fahr) // fahr : 형식 매개 변수 { return (fahr - 32) * 5 / 9; } 인수 전달 방식 - 값 호출 값 호출(call-by-value) 실 매개 변수의 값을 형식 매개 변수에 복사하는 방식 float FahrToC(float fahr) // fahr에 값 복사 { return (fahr - 32) * 5 / 9; } int main() { float fTemp, cTemp; cout &lt;&lt; \"화씨온도 : \"; cin &gt;&gt; fTemp; cTemp = FahrToC(fTemp); // 함수 호출 cout &lt;&lt; \"---&gt; 섭씨온도 : \" &lt;&lt; cTemp &lt;&lt; endl; return 0; } 형식 매개 변수의 값을 변경해도 실 매개 변수는 변함 없음 float FahrToC(float fahr) // 형식 매개변수 수정 (복사본) { fahr -= 32; return fahr * 5 / 9; } int main() { float fTemp, cTemp; cout &lt;&lt; \"화씨온도 : \"; cin &gt;&gt; fTemp; cTemp = FahrToC(fTemp); // 원본은 변함 없음 cout &lt;&lt; \"---&gt; 섭씨온도 : \" &lt;&lt; cTemp &lt;&lt; endl; return 0; } 값 호출 방식의 장점과 단점 장점 실 매개 변수와 형식 매개 변수는 별개의 데이터이므로 불필요한 부작용이 발생하지 않음 단점 구조체와 같이 많은 양의 데이터로 구성된 인수를 전달할 경우 데이터의 복사 량이 많아짐 인수 전달 방식 - 참조 호출 참조 호출(call-by-reference) 실 매개 변수의 참조를 형식 매개 변수에 전달하는 방식 참조 호출의 용도 함수에서 처리한 결과를 매개 변수를 통해 받아 오려는 경우 함수에서 형식 매개 변수의 값을 변경하는 것은 실 매개 변수의 값을 변경하는 것과 같음 많은 양의 데이터로 구성되는 구조체와 같은 인수를 함수에 효율적으로 전달하는 경우 형식 매개 변수에 복사 되는 데이터의 양은 실 매개 변수의 크기와 관계 없이 일정함 참조 호출의 예 - SwapInt.cpp #include &lt;iostream&gt; using namespace std; void SwapValues(int&amp; x, int&amp; y); // 원형 int main() { int a, b; cout &lt;&lt; \"두 수를 입력하시오 : \"; cin &gt;&gt; a &gt;&gt; b; if (a &lt; b) SwapValues(a, b); // 순서를 바꿔 a에 큰 값을 넣음 cout &lt;&lt; \"큰 수 = \" &lt;&lt; a &lt;&lt; \" 작은 수 = \" &lt;&lt; b &lt;&lt; endl; return 0; } void SwapValues(int&amp; x, int&amp; y) { int temp = x; x = y; y = temp; } 참조 호출을 통한 효율적인 인수 전달 많은 양의 데이터로 구성되는 객체나 객체를 인수로 전달하는 경우 값 호출을 사용하는 것에 비해 참조 호출을 사용하는 것이 효율적임 함수 호출의 효율성을 위해 참조 호출을 하지만 실 매개 변수의 값이 변경되는 것을 원하지 않는 경우에는 형식 매개 변수에 const한정어를 지정하여 실 매개 변수를 보호 const매개변수 const한정어를 이용한 실 매개 변수 보호 - PrintRec.cpp struct SalesRec { char pID[10]; int dYear, dMonth, dDate; char deliverAddr[40]; }; // 62바이트(64바이트) void PrSalesRec(SalesRec srec) // 64바이트 복사 { cout &lt;&lt; \"품목코드 : \" &lt;&lt; srec.pID &lt;&lt; endl; cout &lt;&lt; \"배달일자 : \" &lt;&lt; srec.dYear &lt;&lt; \"년 \"; cout &lt;&lt; srec.dMonth &lt;&lt; \"월 \"; cout &lt;&lt; srec.dDate &lt;&lt; \"일\" &lt;&lt; endl; cout &lt;&lt; \"배달주소 : \" &lt;&lt; srec.deliverAddr &lt;&lt; endl; } struct SalesRec { char pID[10]; int dYear, dMonth, dDate; char deliverAddr[40]; }; // 62바이트(64바이트) void PrSalesRec(SalesRec &amp;srec) // 4바이트 복사 { cout &lt;&lt; \"품목코드 : \" &lt;&lt; srec.pID &lt;&lt; endl; cout &lt;&lt; \"배달일자 : \" &lt;&lt; srec.dYear &lt;&lt; \"년 \"; cout &lt;&lt; srec.dMonth &lt;&lt; \"월 \"; cout &lt;&lt; srec.dDate &lt;&lt; \"일\" &lt;&lt; endl; cout &lt;&lt; \"배달주소 : \" &lt;&lt; srec.deliverAddr &lt;&lt; endl; } struct SalesRec { char pID[10]; int dYear, dMonth, dDate; char deliverAddr[40]; }; // 62바이트(64바이트) void PrSalesRec(const SalesRec &amp;srec) // srec 보호 { cout &lt;&lt; \"품목코드 : \" &lt;&lt; srec.pID &lt;&lt; endl; cout &lt;&lt; \"배달일자 : \" &lt;&lt; srec.dYear &lt;&lt; \"년 \"; cout &lt;&lt; srec.dMonth &lt;&lt; \"월 \"; cout &lt;&lt; srec.dDate &lt;&lt; \"일\" &lt;&lt; endl; cout &lt;&lt; \"배달주소 : \" &lt;&lt; srec.deliverAddr &lt;&lt; endl; } 디폴트 인수 인수의 디폴트 값을 지정하는 방법 일반적으로 사용되는 디폴트 값이 있는 인수의 경우 함수를 정의할 때 그 값을 미리 지정할 수 있음 ex) istream&amp; getline(char* str, int count, char delimiter='\\n'); char str1[10], str2[10]; cin.getline(str1, 10, ','); // ','가 나올 때까지 최대 9자 입력 cin.getline(str2, 10); // cin.getline(str2, 10, '\\\\n')과 동일 반올림 함수 Round - Round.cpp double Round(double x, int d = 0); int main() { double a; cout &lt;&lt; \"값 = \"; cin &gt;&gt; a; cout &lt;&lt; \"반올림 --&gt; \" &lt;&lt; Round(a) &lt;&lt; endl; cout &lt;&lt; \" \" &lt;&lt; Round(a, 1) &lt;&lt; endl; cout &lt;&lt; \" \" &lt;&lt; Round(a, 2) &lt;&lt; endl; cout &lt;&lt; \" \" &lt;&lt; Round(a, 3) &lt;&lt; endl; return 0; } double Round(double x, int d) { double a = x &gt;= 0 ? 0.5 : -0.5; double pow10 = pow(10, d); return trunc(x * pow10 + a) / pow10; } // 값 = 12.3456 // 반올림 --&gt; 12 // 12.3 // 12.35 // 12.346 주의 사항 디폴트 인수는 인수 중 끝에만 위치할 수 있음 ex) void f(int x, int y=10, int z=20); // OK void g(int x, int y=10, int z); // 오류 f(5); // x=5, y=10, z=20 전달 f(5, 100); // x=5, y=100, z=20 전달 f(5, 100, 200); // x=5, y=100, z=200 전달 f(5, ,300); // 오류: f(5, 10, 300);으로 작성 함수의 다중 정의함수 다중 정의의 개념 다중 정의(overloading) 동일한 이름에 대하여 여러 가지 의미를 부여하는 것 함수 다중 정의 동일한 이름을 갖는 함수를 여러 개 정의하는 것 동일한 개념의 처리를 여러 가지 데이터나 객체에 대해 각각의 대상에 맞는 처리를 해야 할 경우 사용함 다중 정의 된 함수의 구분 기준 인수의 개수 및 자료형 함수의 반환 자료형으로 함수를 구분할 수 없음 함수 다중 정의의 예 - TimeCalc.cpp 시간 구조체 TimeRec struct TimeRec { int hours; int minutes; }; AddTime함수의 다중 정의 void AddTime(TimeRec&amp; t1, const TimeRec&amp; t2); void AddTime(TimeRec&amp; t, int minutes); struct TimeRec { int hours; int minutes;};// 시간을 더하는 함수// 인수 TimeRec &amp;t1 : 누계할 시간// const TimeRec &amp;t2 : 더할 시간// 반환값 없음void AddTime(TimeRec &amp;t1, const TimeRec &amp;t2){ t1.minutes += t2.minutes; t1.hours += t2.hours + t1.minutes / 60; t1.minutes %= 60;}void AddTime(TimeRec &amp;t, int minutes){ t.minutes += minutes; t.hours += t.minutes / 60; t.minutes %= 60;}int main(){ TimeRec tRec1 = { 2, 30 }; TimeRec tRec2 = { 1, 45 }; cout &lt;&lt; tRec1.hours &lt;&lt; \"시간 \" &lt;&lt; tRec1.minutes &lt;&lt; \"분 + \"; cout &lt;&lt; tRec2.hours &lt;&lt; \"시간 \" &lt;&lt; tRec2.minutes &lt;&lt; \"분 = \"; AddTime(tRec1, tRec2); // void AddTime(TimeRec &amp;t1, const TimeRec &amp;t2) 호출 cout &lt;&lt; tRec1.hours &lt;&lt; \"시간 \" &lt;&lt; tRec1.minutes &lt;&lt; \"분\" &lt;&lt; endl; cout &lt;&lt; tRec1.hours &lt;&lt; \"시간 \" &lt;&lt; tRec1.minutes &lt;&lt; \"분 + \"; cout &lt;&lt; \"135분 = \"; AddTime(tRec1, 135); // void AddTime(TimeRec &amp;t, int minutes) 호출 cout &lt;&lt; tRec1.hours &lt;&lt; \"시간 \" &lt;&lt; tRec1.minutes &lt;&lt; \"분\" &lt;&lt; endl; return 0;}주의: 모호한 함수 다중 정의 반환 자료형만 다른 경우 void f(int a) { cout &lt;&lt; a * a; } void f(int a, int b) { cout &lt;&lt; a * b; } int f(int a, int b) { // 에러! (반환 자료형만 다름) cout &lt;&lt; a * b; } int main() { f(10); f(10, 20); } 선택 기준이 모호한 경우 (디폴트 인수) void g(int a) { cout &lt;&lt; a * a; } void g(int a, int b = 100) { cout &lt;&lt; a * b; } int main() { g(10, 20); g(10); // 에러! (선택 기준이 모호함) } 형 변환 대상이 모호한 경우 void h(int a) { cout &lt;&lt; a * a; } void h(float a) { cout &lt;&lt; a * b; } int main() { h(10); h(10.0f); h(10.0); // 에러! (형 변환 대상이 모호함) } inline함수inline함수의 개념 inline함수란? 함수 호출 절차를 따르지 않고 함수 호출 위치에 함수의 처리 문장이 삽입되게 번역하도록 선언된 함수 함수를 사용함으로써 얻을 수 있는 모듈화의 장점을 살리면서, 함수 호출에 따른 부수적인 처리 시간이 생략됨 함수 호출 루틴으로부터 함수로 넘어가는 부분의 코드 최적화가 가능해짐 매우 빈번히 호출되며 빠른 실행이 요구되는 함수를 inline함수로 선언하면 성능을 높이는데 도움이 됨 주의 inline함수로 선언하더라도 반드시 inline으로 번역되는 것은 아님 inline선언을 무시하고 일반 함수로 번역하는 경우 함수가 너무 큰 경우 순환 호출(recursive call)을 하는 경우 프로그램 내에서 그 함수에 대한 포인터를 사용하는 경우 연습 문제 위 지문의 함수에서 ㈀에 넣을 내용은? // ___㈀___ f(int a, int b) { if (a &lt; b) cout &lt;&lt; \"작은 수 = \" &lt;&lt; a &lt;&lt; endl; else cout &lt;&lt; \"작은 수 = \" &lt;&lt; b &lt;&lt; endl; } a. void 값을 반환하지 않는 함수는 void형으로 선언함 다음 중 값 호출(call-by-value)에 대한 올바른 설명은? a. 함수에서 형식 매개 변수의 값을 변경해도 실 매개 변수의 값은 변하지 않는다. 실 매개 변수의 값을 형식 매개 변수에 복사하는 인수 전달 방식으로, 함수 내에서 형식 매개 변수의 값을 수정하는 것은 복사본을 수정하는 것이므로 원본인 실 매개 변수의 값에는 영향이 없음 함수 f를 위 지문과 같이 선언하였다. int형 변수 a와 b에 각각 10, 15가 저장되어 있을 때, f(a, b)를 호출한 후 변수 a와 b의 값은 무엇인가? int f(int x, int &amp;y) { x *= x; y /= 2; return x * y; } a. a = 10, b = 7 x는 값 호출, y는 참조 호출 방식으로 인수를 전달 받음 그러므로 x를 변화 시켜도 x에 값을 전달한 변수 a는 변화하지 않는 반면, y를 변화 시키는 것은 이에 대한 실 매개 변수의 값을 변화 시킨 것이 됨 위 지문에서 함수의 몸체인 ㈀에서 사용할 수 있는 명령은? int g(const int arr[ ]) { // ___㈀___ } a. cout &lt;&lt; arr[0]; arr은 상수를 저장하는 배열이므로, arr[1]++;이나 cin &gt;&gt; arr[1];와 같이 arr의 원소 값을 변경할 수 없음 또한 int 형 함수이므로 return명령은 int 형 수식을 반환하도록 해야 함 함수 다중 정의에 대한 올바른 설명은? a. 동일한 이름으로 함수를 정의하되, 인수의 자료형이나 개수 등으로 구분할 수 있게 다중 정의한다. 함수 다중 정의는 동일한 이름의 함수를 여러 개 정의하는 것임 함수의 이름은 갖지만, 인수의 자료형 및 개수가 형식 매개 변수와 맞는 것을 선택하여 호출할 수 있음 정리 하기 함수는 특정 작업을 수행하는 프로그램 문장들을 하나의 단위로 모아 놓고 이름을 부여한 것으로 함수에 정의된 처리가 필요한 부분에서 호출하여 사용할 수 있음 함수를 호출할 때 함수의 처리에 사용할 인수를 매개 변수를 통해 전달함 C++에서는 실 매개 변수의 값을 형식 매개 변수에 복사하는 값 호출 방식과 실 매개 변수의 참조를 형식 매개 변수에 전달하는 참조 호출 방식으로 인수를 함수에 전달할 수 있음 많은 양의 데이터로 구성되는 구조체나 객체를 인수로 전달하는 경우 값 호출을 사용하는 것에 비해 참조 호출을 사용하는 것이 효율적임 일반적으로 사용되는 디폴트 값이 있는 인수는 디폴트 인수로 지정할 수 있음 동일한 개념이지만 처리 대상에 맞게 동작하는 여러 개의 함수를 만들 때 이들을 같은 이름의 함수로 다중 정의할 수 있음 매우 빈번히 호출되며 빠른 실행이 요구되는 함수를 inline함수로 선언하면 성능을 높이는 데 도움이 됨" }, { "title": "[C++ 프로그래밍] 3강 - C++ 언어의 기초", "url": "/posts/knou-cpp-3/", "categories": "Language, CPP", "tags": "knou, cpp", "date": "2025-06-08 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 이병래 교수님의 'C++ 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 흐름 제어 구문, 구조체 및 클래스, 배열과 포인터, 동적 메모리 할당, 참조 등 C++ 프로그램의 기본적인 구문에 대하여 소개함 클래스 선언문에 대해서 C언어의 구조체와 비교하는 수준에서 학습함 포인터 및 동적 메모리 할당에 대한 내용은 이해가 쉽지 않으며, 문법적으로는 잘 이해하고 있다 해도 실제 활용 과정에서 에러를 유발하기 쉬우므로 많은 실습을 통해 깊이 있는 학습을 하는 것이 필요함학습 목표 흐름 제어 구문을 이용하여 구현하고자 하는 논리에 맞게 문장의 흐름 제어를 할 수 있음 구조체와 클래스의 차이점을 설명할 수 있음 배열을 이용하여 여러 개의 데이터 집합에 대해 반복적 처리를 할 수 있음 메모리를 필요한 시기에 필요한 만큼 동적으로 할당하거나 반환할 수 있음 동적으로 할당된 메모리 공간을 포인터를 이용하여 액세스할 수 있음 l-value 참조를 활용할 수 있음주요 용어 구조체 여러 가지 자료형의 데이터 집합을 저장할 수 있는 새로운 자료형을 정의한 것 클래스(class) 객체 지향 프로그래밍에서 표현하고자 하는 대상(객체)의 데이터(속성)와 함께 그 대상이 할 수 있는 동작을 나타내는 함수(행위)들을 묶어서 선언한 것 배열(array) 동일한 자료형의 값을 여러 개 저장할 수 있는 연속적으로 할당된 공간을 묶어 하나의 이름을 갖는 변수로 만든 것 포인터(pointer) 어떠한 대상이 위치한 곳을 가리키는(주소를 저장하는) 변수 동적 메모리 할당 프로그램 동작 중에 기억 공간의 필요성 및 소요 량을 결정하여 필요한 공간을 할당하는 것 참조(reference) 프로그램에서 어떤 데이터를 간접적으로 액세스할 수 있도록 그 데이터를 가리키는 값(주소) 강의록흐름 제어 구문기본적인 흐름 제어 구조 순차 구조 문장이 나열 된 순서에 따라 차례로 실행하는 구조 조건 제어 구조 지정 된 조건에 따라 실행 흐름을 제어하는 구조 if문, switch문 반복 제어 구조 정해진 범위의 문장을 반복적으로 실행하게 하는 구조 for문, while문, do while문 조건문 - if if문 사용 형식 if (조건) 문장1; // 조건이 참일 때 실행할 문장 else 문장2; // 조건이 거짓일 때 실행할 문장 ex) 변수 a와 b에 저장 된 값 중 큰 값을 출력하기 if (a &gt; b) cout &lt;&lt; a &lt;&lt; endl; else cout &lt;&lt; b &lt;&lt; endl; 조건문 - switch switch문 사용 형식 switch (정수형_수식) { case 값1 : 문장1; // 정수형_수식 == 값1 일 때 실행할 문장들 나열 break; // switch문을 빠져 나가게 함 case 값2 : 문장2; // 정수형_수식 == 값2 일 때 실행할 문장들 나열 break; // switch문을 빠져 나가게 함 default: // 정수형_수식의 값과 일치하는 case 값이 없을 때 문장n; // 실행할 문장들을 나열 } switch문 사용 예 ex) int형 변수 score의 값에 따라 A ~ F의 학점 부여하기 switch (score / 10) { case 10: // score가 100인 경우 case 9: grade = 'A'; // score가 90~99인 경우 break; case 8: grade = 'B'; // score가 80~89인 경우 break; case 7: grade = 'C'; // score가 70~79인 경우 break; case 6: grade = 'D'; // score가 60~69인 경우 break; default: grade = 'F'; // score가 59 이하인 경우 } 반복문 - for문 루프 for문 사용 형식 for ( 초기화_문장 ; 반복조건 ; 증감_문장 ) 반복할_문장; ex) 10개의 정수 값을 입력하여 합계 구하기 int val, total = 0; for (int i = 0 ; i &lt; 10 ; i++) { cin &gt;&gt; val; total += val; } 범위 기반 for루프 for (원소선언 : 데이터집합) 반복할_문장; ex) 배열 안의 모든 값을 합산 하기 int arr[5] = {2, 3, 9, 4, 7}; int sum = 0; for (int a : arr) sum += a; cout &lt;&lt; \"합계 = \" &lt;&lt; sum &lt;&lt; endl; 반복문 - while루프 while문 사용 형식 while (반복조건) 반복할_문장; ex) for루프를 while루프로 표현 하기 int val, total = 0; for (int i = 0 ; i &lt; 10 ; i++) { cin &gt;&gt; val; total += val; } int val, total = 0; { int i=0; while (i &lt; 10) { cin &gt;&gt; val; total += val; i++; } } 반복문 - do ~ while루프 do ~ while문 사용 형식 do 반복할_문장; while (반복조건 ); 구조체와 클래스구조체 구조체 여러 가지 자료형 데이터 집합을 저장할 수 있는 새로운 자료형을 정의한 것 구조체 선언문 형식 struct StructName { Type1 item1; Type2 item2; }; 구조체의 예 2차원 좌표 struct C2dType { double x, y; }; 원 struct CircleType { C2dType center; double radius; }; 구조체 데이터를 처리하는 함수 C 언어에서는 구조체와는 별개의 함수로 정의함 ex) 원의 면적 구하기 double circleArea(CircleType c) { return c.radius * c.radius * PI; } int main() { CircleType c1 = { {0, 0}, 10}; cout &lt;&lt; \" 원의 면적 : \" &lt;&lt; circleArea(c1) &lt;&lt; endl; } 클래스 클래스 표현하고자 하는 대상(객체)의 데이터(속성)와 함께 그 대상이 할 수 있는 동작을 나타내는 함수(행위)들을 묶어서 선언한 것 ex) 원 클래스 행위 init: 원의 초기화   area: 원의 면적을 계산   chkOverlap: 다른 원과 중첩 여부 검사   display: 원의 정보 디스플레이 속성 center: 중심 좌표   radius: 반경 class CircleClass { // 원 클래스 C2dType center; // 중심 좌표 double radius; // 반경 public: // 중심 (cx, cy), 반경 r로 원을 초기화 void init(double cx, double cy, double r) { center.x = cx; center.y = cy; radius = r; } // 원의 면적 계산 double area() const { return radius * radius * PI; } bool chkOverlap(const CircleClass&amp; c) const { double dx = center.x - c.center.x; double dy = center.y - c.center.y; double dCntr = sqrt(dx*dx + dy*dy); return dCntr &lt; radius + c.radius; } void display() const { } }; int main() { CircleClass c1, c2; c1.init(0, 0, 10); // 중심(0, 0), 반경 10으로 초기화 c2.init(30, 10, 5); // 중심(30, 10), 반경 5로 초기화 cout &lt;&lt; \"원1\" &lt;&lt; endl; c1.display(); cout &lt;&lt; \" 원1의 면적 : \" &lt;&lt; c1.area() &lt;&lt; endl; cout &lt;&lt; \"원2\" &lt;&lt; endl; c2.display(); cout &lt;&lt; \" 원2의 면적 : \" &lt;&lt; c2.area() &lt;&lt; endl &lt;&lt; endl; } 구조체와 클래스의 비교배열배열 동일한 자료형의 값을 여러 개 저장할 수 있는 연속적으로 할당 된 공간을 묶어 하나의 이름을 갖는 변수로 만든 것 각각의 원소는 0번부터 시작하여 차례로 부여 된 번호(첨자, 인덱스)를 이용하여 액세스 함 배열의 차원 배열의 첨자 개수 1차원 배열 1차원 배열의 선언 1차원 배열의 사용 float fArray[4]; int i = 0; fArray[i] = 10.0f; cin &gt;&gt; fArray[1] &gt;&gt; fArray[2] &gt;&gt; fArray[3]; cout &lt;&lt; fArray[1] * fArray[2]; 다차원 배열 2차원 배열 1차원 배열이 원소인 배열 int Arr2D[4][3]; 배열의 활용 배열의 초기화 int a[5] = { 1, 2, 3, 4, 5 }; // '='는 생략할 수 있음 int b[5] = { 1, 2, 3 }; // b[3]와 b[4]는 0으로 초기화됨 int c[] = { 1, 2, 3, 4, 5 }; // 배열의 크기는 5임 int d[2][4] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } }; // 2차원 배열의 초기화 여러 개의 데이터 중 최댓 값 구하기 MaxValue.cpp int main() { int max; int data[10] = { 10, 23, 5, 9, 22, 48, 12, 10, 55, 31 }; max = data[0]; // data의 0번 값을 max로 가정함 cout &lt;&lt; \"데이터 : \" &lt;&lt; data[0]; // 0번 데이터 출력 for (int i = 1; i &lt; 10; i++) { // 나머지 9개의 데이터 비교 cout &lt;&lt; \" \" &lt;&lt; data[i]; // i번 데이터 출력 if (max &lt; data[i]) max = data[i]; // i번 데이터 비교 } cout &lt;&lt; \"\\n\\n배열의 최댓값 : \" &lt;&lt; max &lt;&lt; endl; return 0; } 포인터와 동적 메모리 할당포인터의 활용 포인터 어떠한 대상이 위치한 곳을 가리키는(주소를 저장하는) 변수 가리키는 대상 포인터에 지정 된 자료형에 해당 되는 변수, 동적으로 할당 된 메모리, 함수 등 포인터 선언 형식 TypeName* ptrVar; TypeName 가리킬 값의 자료형 ptrVar 포인터 변수의 이름 int* iPtr; 포인터의 사용 포인터가 유효한 대상을 가리키게 한 후 사용해야 함 ptrVar = &amp;var; // ptrVar이 var을 가리키게 함 *ptrVar = value; // ptrVar을 이용하여 var을 액세스 &amp; 주소 계산 연산자 *ptrVar 포인터 ptrVar가 가리키는 곳 int a; int* iPtr = &amp;a; *iPtr = 10; 포인터의 사용 예 SimplePt.cpp #include &lt;iostream&gt; using namespace std; int main() { int a = 10; int* ptr; ptr = &amp;a; // ptr에 a의 주소를 넣는다. cout &lt;&lt; \"ptr이 가리키는 값 : \" &lt;&lt; *ptr &lt;&lt; endl; // 출력되는 값 : 10 *ptr = 20; cout &lt;&lt; \"변수 a의 값 : \" &lt;&lt; a &lt;&lt; endl; // 출력되는 값 : 20 return 0; } 동적 메모리 할당 동적 메모리 할당이란? 프로그램 동작 중에 기억 공간의 필요성 및 소요 량을 결정하여 필요한 공간을 할당하는 것 기억 공간의 생성 시점 new연산자의 실행 시점 기억 공간의 소멸 시점 delete연산자의 실행 시점 포인터 변수가 할당 된 기억 공간을 가리키게 함 메모리 할당 연산자 ptrVar = new TypeName; ptrVar = new TypeName[n]; 메모리 반납 연산자 delete ptrVar; delete [] ptrVar; 단일 데이터 공간의 할당 및 반환 int* intPtr; intPtr = new int; *intPtr = 10; int* intPtr; intPtr = new int; *intPtr = 10; delete intPtr; intPtr = nullptr; // 아무 것도 가리키지 않는 포인터 배열 데이터 공간의 할당 및 반환 int* intPtr; intPtr = new int[4]; *intPtr = 10; *(intPtr+1) = 20; intPtr[2] = 30; int* intPtr; intPtr = new int[4]; *intPtr = 10; *(intPtr+1) = 20; intPtr[2] = 30; delete [] intPtr; intPtr = nullptr; 참조l-value 참조 참조(reference) 어떠한 대상을 가리키는 값 포인터와 유사함 참조 변수는 참조 대상의 별명처럼 사용할 수 있음 I-value 참조 실체가 있는 대상(I-value)에 대한 참조 l-value 참조 변수의 선언 형식 TypeName&amp; refVar = varName; TypeName 참조 대상의 자료형 refVar 참조 변수의 이름 varName 참조 대상 l-value 참조 변수의 사용 예 const참조 참조 변수가 참조하는 대상의 값을 바꿀 수 없음 int x { 10 }; const int&amp; xRef = x; cout &lt;&lt; xRef &lt;&lt; endl; // x의 값을 읽어 출력함 xRef += 10; // 오류: const 참조로 값을 수정할 수 없음 참조가 포인터와 다른 점 참조 변수를 이용하여 값을 읽거나 저장할 때 참조 대상 변수를 사용하는 형식과 동일함 참조 변수는 초기화를 통해 반드시 어떤 대상을 참조해야 함 초기화 되지 않은 상태로 인해 무엇을 참조하고 있는지 알 수 없는 상황은 발생하지 않음 참조 변수는 초기화를 통해 지정 된 참조 대상을 바꿀 수 없어 참조의 유효 기간 동안 하나의 대상만 참조할 수 있음 r-value 참조 r-value 참조 사용한 후에는 그 값을 더 이상 가지고 있을 필요가 없는 대상을 참조 r-value 참조의 용도 객체의 값을 다른 객체로 이동 연습 문제 위 지문에서 배열의 항목에 cin으로 부터 입력된 값을 넣으려고 한다. 공란에 넣을 내용은? int arr[10]; for ( // _______ : arr) cin &gt;&gt; a; a. int&amp; a 범위 기반 for루프에서 arr의 각 원소를 나타내는 선수를 선언함 이때 arr의 값을 입력을 통해 변경해야 하므로 참조형으로 선언함 C++ 에서 클래스와 구조체의 차이점을 바르게 설명한 것은? a. 클래스의 항목들은 공개 여부를 지정하지 않은 경우 공개되지 않는 것이 기본이나, 구조체의 항목들은 공개되는 것이 기본이다. 구조체는 내부 데이터 항목들을 외부에서 자유롭게 사용하도록 공개하는 것이 디폴트임 클래스의 경우는 내부의 구현을 감추는 것이 디폴트임 10개의 int형 값을 저장하는 공간을 동적 할당하는 명령을 바르게 사용한 것은? a. int *iPtr = new int[10]; new 명령으로 할당 받을 자료형 이름을 쓰고 그 뒤에 [크기]의 형식으로 할당 크기를 지정함 위 지문에서 int형 포인터 iPtr의 선언이 올바르게 사용된 것은? a. int a; int *iPtr = &amp;a; 포인터는 동일한 자료형의 데이터를 가리키도록 해야 함 어떠한 변수를 가리키도록 하려면 변수의 주소를 계산하는 &amp;연산자를 사용함 다음 중 l-value 참조 ref를 선언하는 문장으로 올바른 것은? 단, a는 int형 변수이다. a. int&amp; ref = a; l-value 참조는 &amp; 기호를 이용하여 선언함 이때 참조 대상을 지정하여 초기화해야 함 l-value 참조의 대상은 l-value여야 하며, 참조 대상과 자료형이 같아야 함 auto&amp; ref = 10;에서는 참조 대상이 int형 리터럴이므로 const참조로 선언해야 참조할 수 있음 정리 하기 if문 및 switch문을 이용하여 조건 제어 구조를 만들 수 있으며, for, while, do while문을 이용하여 반복 제어 구조를 작성할 수 있음 클래스를 이용하여 표현 대상이 어떤 일을 할 수 있는가(행위)와 이를 위해 어떤 데이터를 저장하는가(속성)를 선언함 배열을 이용하여 동일한 자료형의 값을 여러 개 연속적 저장 공간에 저장하고 첨자를 지정하여 개별 원소를 액세스할 수 있는 변수를 만들 수 있음 포인터를 이용하여 값이 저장되어 있는 곳이나 함수를 가리키게 하여 간접적으로 액세스할 수 있음 new연산자를 이용하여 메모리를 동적으로 할당하여 사용할 수 있으며, delete연산자를 이용하여 사용이 끝난 메모리를 반납할 수 있음 참조형 변수를 이용하여 변수 등을 참조할 수 있으며, 초기화에 의해 지정된 참조 대상을 교체할 수 없음" }, { "title": "[C++ 프로그래밍] 2강 - C++ 언어의 기초", "url": "/posts/knou-cpp-2/", "categories": "Language, CPP", "tags": "knou, cpp", "date": "2025-06-07 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 이병래 교수님의 'C++ 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 C++ 언어는 C 언어를 바탕으로 하여 객체 지향 프로그래밍을 위한 구문을 제공함 그러므로 대부분의 문법이 C와 동일하지만, 조금 다른 부분이나 추가된 문법이 있음 C++ 언어의 기본적인 구문들에 대하여 개괄적으로 정리해 봄 C++ 언어의 단어(키워드, 식별자), 자료형, 변수와 상수, 연산자, 형 변환 등에 대해 다룸학습 목표 C++의 문법에 맞게 식별자를 만들 수 있음 기본 자료형의 값을 표현하고, 변수를 만들어 저장하는 표현을 활용할 수 있음 C++ 언어의 연산자를 사용하여 수식을 작성할 수 있음 자료형 사이의 형 변환을 할 수 있음주요 용어 키워드(keyword) C++ 언어에서 미리 용도를 정해 놓은 단어 변수 프로그램이 실행되는 동안 기억하고 있어야 하는 값들을 저장하기 위해 자료형과 이름이 지정된 메모리 영역 사용 영역(scope) 이름이 유효성을 갖는 영역 지역 변수 프로그램의 소속 블록 안에서만 사용될 수 있는 변수 형 변환 값의 자료형을 다른 자료형으로 변환하는 것으로, 자료형의 변환은 묵시적 또는 명시적으로 지정 가능 강의록키워드와 식별자키워드 키워드(keyword) C++ 언어에서 미리 용도를 정해 놓은 단어 반드시 정해진 용도로만 사용해야 함 키워드의 예 #include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; \"나의 첫 번째 C++ 프로그램\" &lt;&lt; endl; return 0; } using namespace int return 식별자 식별자(identifier) 여러 가지 대상을 구분하기 위해 만든 이름 변수나 함수, 클래스 등의 이름 식별자를 만드는 규칙 첫 자는 비 숫자 문자를 사용함(C++11부터 다국어 문자 포함) 비 숫자 문자 영문 대,소문자와 _(MS C++에서는 $ 포함) 이후의 문자는 비 숫자 문자와 숫자를 사용함(특수 문자 사용 불가) 길이 제한 없음 키워드는 식별자로 사용 불가 _문자로 시작하는 이름 사용하지 않는 것이 바람직함 적절한 식별자 myname my_name Snake case myName Camel case MyName Pascal case a3 VALUE Int initial_value 합계 C++11 이후 $price MS C++ 사용할 수 없는 식별자의 예 4days my name my#name int initial-value min:value 기본 자료형 및 상수와 변수C++의 자료형 기본 자료형 C++ 에서 기본적으로 제공하는 하나의 값을 지정하는 자료형 정수 자료형 char int short long bool 실수 자료형 float double long double 복합 자료형 여러 개의 데이터를 모아서 사용할 수 있는 자료형 배열, 구조체(struct), 클래스(class), 열거형(enum), 공용체(union) 포인터, 참조 C++의 기본 자료형 정수형 자료형(integral types) 고정 소수점(fixed-point) 방식의 숫자 표현 오버플로(overflow)가 발생하지 않도록 주의해야 함 문자를 표현하는 자료형 signed/unsigned char 정수를 표현하는 자료형 signed/unsigned signed 부호 있음 양수, 음수 둘 다 표현 가능 unsigned 부호 없음 양수만 표현 가능 int, short, long, long long int≤ short≤ long≤ long long int32bit short16bit long32bit 참/거짓을 표현하는 자료형 bool true(참) false(거짓) 다국어 표현을 위한 자료형 wchar_t char16_t char32_t 실수 자료형 부동 소수 점(floating-point) 방식의 숫자 표현 부동 소수점 소수점의 위치가 움직일 수 있음 부동 소수점 방식의 숫자 표현 123 = 12.310^1 = 1.2310^2 float (4byte) 부호 1비트, 지수 부 8비트, 가수 부 23 비트로 구성 1.17549×10^-38 ~ 3.40282×10^38 범위의 값을 표현 numeric_limits&lt;float&gt;::min() numeric_limits&lt;float&gt;::max() &lt;climits&gt;헤더 파일 include 시 float에 대해 가장 작은 값, 큰 값 확인 가능 double (8byte) 부호 1비트, 지수 부 11비트, 가수 부 52비트로 구성 2.22507 * 10⁻ ³⁰⁸ ~ 1.79769 * 10³⁰⁸ 범위의 값을 표현함 numeric_limits&lt;double&gt;::min() numeric_limits&lt;double&gt;::max() 상수의 표현 - 리터럴(iteral) 정수형 리터럴의 표현 숫자를 표현하는 문자와 부호 만으로 표현됨 숫자를 표현하는 문자 0 ~ 9 까지의 숫자 10 ~ 15에 해당되는 16진수를 표현하기 위한 문자 a ~ f와 A ~ F 접두사를 이용한 진법의 표현 표현 의미 159 10진수 int형 상수 0b10011111 2진수 int형 상수 0237 8진수 int형 상수 0x9f 16진수 int형 상수 접미사를 이용한 정수 리터럴의 자료형 지정 표현 자료형 123 int형 123u unsigned int형 123L long 형 123ul unsigned long 형 123ll long long 형 문자 리터럴의 표현 표현 자료형 ‘A’ 문자 ‘A’ (ASCII 코드에 해당되는 정수 65와 동일) ‘\\101’ ‘A’와 동일함(65의 8진수 표현) ‘\\x41’ ‘A’와 동일함(65의 16진수 표현) 작은 따옴표(‘ ‘) 안에 문자를 표기하는 방법 8진수나 16진수 문자 코드로 표기하는 방법 실수 형 리터럴의 표현 표현 자료형 1200., 1200.0, 12e2, 1.2e+3 double형 값 1200 1200.0f, 12e2f float형 값 1200 소수점이 있거나 10의 거듭 제곱을 표현하기 위한 지수 기호인 e가 있으면 실수형 리터럴임 변수 변수 프로그램이 실행되는 동안 기억하고 있어야 하는 값들을 저장하는 메모리 영역 변수에는 자료형과 이름이 지정되어야 함 모든 변수는 사용하기 전에 미리 선언해야 함 int korScore, mathScore; cin &gt;&gt; korScore &gt;&gt; mathScore; float avrScore = (korScore + mathScore) / 2.0f; int 자료형 korScore, mathScore; 변수의 이름 float avrScore 사용하기 전에 선언하면 됨 변수의 초기화 int total = 0; int total(0); int x(131070.5); // x ← 131070 : 오차 발생 short y(x); // x ← -2 : 오버플로 발생 int total{0}; short a{total}; // 오류: 축소 변환 float b{total}; // 오류: 축소 변환 자료형 추론 변수를 초기화할 때 초기화하는 값의 자료형으로 변수의 자료형을 추론 auto i(10); // int i(10); 과 동일함 변수의 사용 영역(scope) 변수가 유효성을 갖는 영역 s1.cpp int a; // 선언된 이후 프로그램의 전체 영역에서 사용 가능 - 비 지역 변수(non-local variable) static int b{10}; // 선언된 이후 소속 파일의 전체 영역에서 사용 가능 - 비 지역 변수(non-local variable) int f() { int c{20}, d{30}; // 선언된 이후 소속 블록의 전체 영역에서 사용 가능 - 지역 변수(local variable) { int d{40}; // 선언된 이후 소속 블록의 전체 영역에서 사용 가능 - 지역 변수(local variable), 이름 가리기 int e{50}; // 선언된 이후 소속 블록의 전체 영역에서 사용 가능 - 지역 변수(local variable) } } s2.cpp extern int a; // 다른 소스 파일에서 존재하는 변수 사용 = s1.cpp 의 a 변수 static int b{50}; // 해당 소스 파일에서만 사용 가능 s1.cpp b 변수 != s2.cpp b 변수 int g() { } const와 constexpr const한정어 변수의 값을 수정할 수 없게 함 초기화를 통해서만 값을 정할 수 있음 const double PI {3.14159}; // 원주율 정의 #define PI 3.14159 // 매크로 상수 정의 - 단순 치환 constexpr한정어 그 값을 컴파일할 때 평가한다는 의미 실행 중 값을 평가하는 것에 비해 효율적으로 동작할 수 있게 함 int a; std::cin &gt;&gt; a; const int b = 20; const int C1 = a; // cin을 통해 입력된 a의 값으로 초기화 constexpr int C2 = a + 10; // 오류: 컴파일 시에 a의 값을 알 수 없음 constexpr int C3 = b + 100; // b + 100을 컴파일 시에 계산할 수 있음 constexpr int C4 = C1 * 2; // 오류: 컴파일 시에 C1의 값을 알 수 없음 모든 인수가 constexpr인 경우 컴파일할 때 값을 구할 수 있게 함 constexpr int fac(int n) { return n &gt; 1 ? n * fac(n - 1) : 1; }; void f(int x) { constexpr int a = fac(4); // 컴파일할 때 계산 int b = fac(x); // 실행 중 계산 }; 변수의 유효 기간 변수의 유효 기간(lifetime) 변수가 언제 만들어져서 언제 없어지는가를 나타냄 자동 변수 생성 시점 함수(블록)가 시작될 때 소멸 시점 함수(블록)가 종료될 때 정적 변수 생성 시점 프로그램이 시작될 때 소멸 시점 프로그램이 종료될 때 int x; // 전역 변수 - 정적 유효 기간 int f() { int y{10}; // 지역 변수 - 자동 유효 기간 static int z{0}; // 정적 지역 변수 - 정적 유효 기간 } 변수와 상수 사용 CircleArea.cpp #include &lt;iostream&gt; using namespace std; int main( ) { const double PI {3.14159}; double radius; cout &lt;&lt; \"원의 반경을 입력하시오 : \"; cin &gt;&gt; radius; double area = radius * radius * PI; cout &lt;&lt; \"원의 면적 = \" &lt;&lt; area &lt;&lt; endl; return 0; } 연산자산술 연산자 2항 연산자 사칙 연산자 +, -, *, / 수식 수식의 값 5 + 3 8 3 / 2 1 3.0 / 2.0 1.5 나머지 연산자 % 수식 수식의 값 5 % 3 2 -5 % 3 -2 5 % -3 2 -5 % -3 -2 단항 연산자 증, 감 연산자 ++, -- 수식(a = 10일 때) a의 값 b의 값 b = ++a; 11 11 b = a++; 11 10 b = --a; 9 9 b = a--; 9 10 부호 연산자 +, - 대입 연산자 대입 연산자(=) 수식의 값 저장 된 결과 연산자의 결합 방향 우 → 좌 수식(a는 double형, b는 int형) 실행 결과 a = 0; a ← 0 a = b = 0; b ← 0, a ← 0 a = b = 1.5; b ← 1, a ← 1 복합 대입 연산자 이항 연산자와 대입 연산자를 결합 +=, -=, *=, /=, %=, &lt;&lt;=, &gt;&gt;=등 수식 실행 결과 a += b; a = a + b;와 동일 관계 연산자 관계 연산자 &gt;, &lt;, &gt;=, &lt;=, ==, ≠ 수식(a = 10, b = -5) 수식의 값 a &gt; b true a == 5 false 논리 연산자 논리 합 ||, 논리 곱 &amp;&amp;, 부정 ! 수식(a = 10, b = -5) 수식의 값 a &gt; 0 &amp;&amp; b &gt; 0 false a &gt; 0 || b &gt; 0 true a &lt; 0 &amp;&amp; --b &lt; 0 false, b는 -5 !(a &gt; 0) false 비트 단위 연산자 비트 단위 논리 연산자 논리 합 |, 논리 곱 &amp;, 배타적 논리 합 ^, 부정 ~ 수식(x = 0x35(0011 0101), y = 0xf0(1111 0000)) 수식의 값 x | y 0xf5 (1111 0101) x &amp; y 0x30 (0011 0000) x ^ y 0xc5 (1100 0101) ~x 0xca (1100 1010) 비트 이동 연산자 좌측 이동 (&lt;&lt;) unsigned char x = 0b00011101; // 29 unsigned char y = x &lt;&lt; 2; 우측 피 연산자에 지정된 비트 수만큼 좌측 피 연산자를 좌측으로 이동 우측의 비는 비트에는 0이 채워짐 왼쪽으로 두 비트 이동 시 2의 제곱을 곱한 값과 같은 결과를 가짐 우측 이동 (&gt;&gt;) char x = 0b10010100; // -108 char y = x &gt;&gt; 2; 우측 피 연산자에 지정된 비트 수만큼 좌측 피 연산자를 우측으로 이동 signed 형에 대해서는 부호를 유지할 수 있도록 부호 비트가 좌측의 비는 비트에 채움(구현에 따라 다름) 오른쪽으로 두 비트 이동 시 2의 제곱을 나눈 값과 같은 결과를 가짐 조건 연산자 유일한 3항 연산자 수식 ( a = 10, b = 20, c = 30) 수식의 값 a &gt; 0 ? b : c 20 조건 ? 값1 : 값2 조건이 true이면 수식의 값은 값1, false이면 값2 자료형의 변환묵시적 형 변환 묵시적 형 변환 개요 두 값 사이의 연산에서는 우선 순위가 낮은 자료형의 값이 순위가 높은 자료형의 값과 같은 형으로 변환됨 여러 개의 연산으로 구성된 수식에서 묵시적 형 변환은 연산자 단위로 이루어짐 대입 연산자(=)는 값을 저장할 변수의 자료형으로 묵시적 형 변환을 함 오차나 오버플로가 발생할 수 있으므로 주의해야 함 묵시적 형 변환의 예 명시적 형 변환 형 변환 연산자 static_cast 연관 된 자료형 간의 형 변환을 처리하며, 변환 처리는 컴파일 단계에서 정해짐 dynamic_cast 기초 클래스와 파생 클래스 간의 포인터 또는 참조 형 변환이 프로그램 실행 중에 일어나도록 지시함 reinterpret_cast 관련이 없는 자료형 사이의 변환을 처리하는 연산자로, 포인터를 다른 자료형의 포인터나 정수 자료형으로, 또는 그 역으로 변환 const_cast const지정을 일시 해제함 형 변환 연산자 사용 형식 연습 문제 다음 중 부동 소수 점 표현 방식의 수는? a. 123e4 e는 부동 소수 점 수의 지수 부 값을 나타내기 위한 기호로 사용되므로 123.0×10^4을 나타내는 부동 소수 점 수 123 10진수 0x24 16진수 0123 8진수 정수(고정 소수 점) 위 지문에서 문장의 결과 a에 저장 되는 값은? int x = 5, y = 2; double a, z=10.0; a = z + x / y; a. 12.0 x와 y는 int형이므로 x / y는 정수 연산이 이루어지며, 그 결과는 2이고 이 값을 z의 10.0과 더하므로 결과는 12.0임 위 지문의 프로그램에서 (가)와 (나)의 의미에 대한 설명으로 옳은 것은? constexpr int f(int x) { return x * x; } void g(int a) { constexpr int b = f(10); // (가) const int c = f(a); // (나) // (다) } a. (가)는 f(10)의 값을 컴파일할 때 계산한다. constexpr함수는 모든 인수가 constexpr인 경우 컴파일할 때 값을 구할 수 있게 함 위 지문에서 변수 x, y가 모두 unsigned char 형이다. x의 하위 4비트는 변하지 않고 상위 4비트만 모두 0으로 만들려고 한다. y에는 어떠한 값을 가지고 있어야 하는가? x &amp;= y; a. 0x0f y의 어떤 비트가 0이면, AND 결과에서 그 자리(x의 해당 비트)는 무조건 0이 됨 y의 어떤 비트가 1이면, 원래 x 값이 전달됨 위 수식은 x = x &amp; y;와 같음 &amp;는 비트 단위 논리 곱 연산자임 어느 비트의 값이 a일 때 a &amp; 0은 a의 값에 관계없이 0임 반면 a &amp; 1은 a가 0이면 0, 1이면 1임 즉, a &amp; 1은 a와 같음 그러므로 x의 값에서 0으로 지우고 싶은 비트는 0, 그대로 두고 싶은 비트는 1이 y에 들어 있다면 x의 원하는 비트를 0으로 지울 수 있음 하위 4비트는 변하지 않고 상위 4비트만 0으로 만들려고 하므로 y는 2진수 00001111, 즉 16진수 0x0f를 저장하고 있으면 됨 다음의 변수 선언문 중 오류가 있는 것은? a. int d{1.5}; 1.5가 double이므로 int형 변수를 초기화하려면 축소 형 변환이 필요하여 오류임 변수 선언문 중 옳은 것은? int a = 100; 필요하다면 묵시적 형 변환을 통해 변수가 초기화 됨 float b(20.0); 필요하다면 묵시적 형 변환을 통해 변수가 초기화 int c = {200}; 초깃 값으로 사용된 수식에 대해 축소 형 변환이 일어나면 안 됨 위 지문 중 소스 파일에서 변수의 값을 수정하지 않았을 경우 (가) 영역에서 사용할 수 있는 변수와 그 값을 모두 올바르게 나열한 것은? int a; static int b{10}; int f() { int c{20}, d{30}; { int d{40}; int e{50}; } // ······ // (가) } a. a:0, b:10, c:20, d:30 (가)를 포함하는 블록에 선언된 c와 d, 함수 f()의 앞에 선언된 a와 정적 변수 b를 모두 사용할 수 있으며, 함수 f()에 내포된 블록에 선언된 d와 e는 그 블록 안에서만 존재하며, (가)에서는 사용할 수 없음 정리 하기 C++에서 사용하는 단어는 반드시 정해진 용도로 사용하도록 지정된 키워드와 프로그램 내에서 여러 가지 대상을 구분하기 위해 만드는 식별자가 있음 문자, 정수, 참/거짓, 실수를 표현하는 기본 자료형과 복합 자료형을 사용할 수 있음 값을 저장하기 위해 사용하는 변수는 사용하기 전에 자료형과 이름을 미리 선언해야 함 블록 안에 선언된 변수는 소속된 블록에서만 사용할 수 있는 지역 변수임 const한정어는 변수의 값을 변경할 수 없게 하며, constexpr한정어는 변수나 함수의 값을 컴파일할 때 평가할 수 있게 할 수 있게 함 지역 변수는 자동 유효 기간, 전역 변수 및 정적 지역 변수는 정적 유효 기간을 갖음 연산자는 산술, 논리, 관계, 비트 단위 논리, 대입 등의 처리를 하는 데 사용 됨 서로 다른 자료형이 연산에 사용될 경우 우선순위가 높은 자료형으로, 대입 연산의 경우 값을 저장할 변수의 자료형으로 묵시적 형 변환이 일어남 형 변환 연산자를 이용하여 명시적으로 자료형을 변환할 수 있음" }, { "title": "[C++ 프로그래밍] 1강 - C++ 언어의 소개", "url": "/posts/knou-cpp-1/", "categories": "Language, CPP", "tags": "knou, cpp", "date": "2025-06-04 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 이병래 교수님의 'C++ 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 C++ 프로그래밍 언어의 기본적인 형식에 대하여 학습 프로그램을 구성하는 소스 파일의 종류와 선행 처리, 명칭 공간, main 함수 등 기초적인 C++ 프로그램을 작성하는 방법 알 수 있게 됨학습 목표d C++ 프로그램을 구성하는 소스 파일의 용도 설명할 수 있음 선행 처리, 문장, 함수 등 C++ 언어의 기본 요소들로 구성된 최소한의 프로그램을 작성할 수 있음 통합 개발 환경을 통해 프로그램을 작성하고 빌드하여 실행 프로그램을 만들 수 있음주요 용어 소스 파일 프로그래밍 언어의 문법에 따라 작성된 프로그램을 저장하고 있는 파일 헤더 파일 여러 소스 파일에 공통적으로 선언되는 내용을 담고 있는 파일로 그 헤더 파일의 내용이 필요한 소스 프로그램 파일에 삽입 된 후 컴파일 됨 빌드(build) 프로그램의 소스 파일을 실행 가능한 프로그램 파일로 변환하는 것을 의미함 컴파일이 필요한 소스 파일들을 컴파일하고, 그 결과와 라이브러리 등을 링크하는 처리가 이루어짐 통합 개발 환경(integrated development environment, IDE) 컴퓨터 프로그램을 만드는데 필요한 소스 파일 편집기, 컴파일러, 링커, 디버깅 도구 등 소프트웨어 개발에 필요한 도구를 모아 놓은 소프트웨어임 선행 처리기 지시어(preprocessor directives) C++ 프로그램을 컴파일하기 전에 소스 프로그램을 가공하여 컴파일러가 실제로 번역할 소스 프로그램을 만드는 선행 처리를 지시하는 명령어 스트림(stream) 시간에 따라 순서대로 입력되거나 출력 되는 일련의 데이터 백색 공백 문자(whitespace character) 컴퓨터에서 수평 또는 수직 방향의 공간을 표현하는 문자로 공백 문자, 탭, 새줄 문자 등이 이에 해당 됨 명칭 공간(name space) 특정한 명칭들이 인식 되는 프로그램의 부분 다른 영역에 선언된 명칭과 무관하게 명칭 공간 내에서 자유롭게 명칭을 선언하여 사용할 수 있게 함 강의록C++ 언어의 개요C++언어 1979년 Bell 연구소의 Bjarne Stroustrup이 C 언어를 확장하여 만든 프로그래밍 언어 C with Classes 주요 확장 내용 객체 지향 프로그래밍 클래스, 상속, 다형성, 동적 바인딩 등 일반화 프로그래밍 템플릿 예외 처리 C++ 언어의 표준 국제 표준화 기구(ISO)의 C++ 표준화 연혁 1983년부터 C++라는 이름을 사용함 C++ 프로그램의 작성 및 빌드C++ 프로그램의 소스 파일 소스 프로그램 파일 처리하고자 하는 작업을 수행하는 C++ 프로그램 명령어들을 담고 있는 파일 파일의 확장자 .cpp .cxx .C 헤더 파일 클래스, 함수의 원형, 매크로, 전역 변수, 상수 등 여러 소스 파일에 공통적으로 선언되는 내용을 담고 있는 파일 단독으로 컴파일 되지 않고, #include라는 선행 처리기 지시어에 의해 소스 프로그램 파일에 삽입 되어 함께 컴파일 됨 확장자 .h .hpp C++ 프로그램의 빌드 프로젝트 빌드 과정 소스 파일(.cpp) -컴파일(번역)→ 목적 파일(.obj) 목적 파일(.obj) +(링크)+ 라이브러리 = 실제 동작 가능한 실행 프로그램 파일(.exe) 필요한 도구 통합 개발 환경(IDE) 소스 프로그램 및 GUI 등의 편집기 컴파일러 링커 디버깅 도구 C++ 프로그래밍 첫걸음C++ 소스 프로그램 FirstStep.cpp #include &lt;iostream&gt; int main() { // 표준 출력 스트림으로 문장을 출력함 -&gt; 주석 std::cout &lt;&lt; \"나의 첫 번째 C++ 프로그램\" &lt;&lt; std::endl; return 0; } 주석 C++에서 주석(comment)을 작성하는 방법 /*와 */사이에 문장을 작성 /* a와 b의 값 중에서 \t 더 큰 값을 출력한다. */ if (a &gt; b) std::cout &lt;&lt; a &lt;&lt; std::endl; else std::cout &lt;&lt; b &lt;&lt; std::endl; //를 기입하면 그 행의 나머지는 주석임 // a와 b의 값 중에서 // 더 큰 값을 출력한다. if (a &gt; b) std::cout &lt;&lt; a &lt;&lt; std::endl; else std::cout &lt;&lt; b &lt;&lt; std::endl; 선행 처리 선행 처리의 지시 #include &lt;iostream&gt; // 선행 처리기 지시어 int main() { // 표준 출력 스트림으로 문장을 출력함 std::cout &lt;&lt; \"나의 첫 번째 C++ 프로그램\" &lt;&lt; std::endl; return 0; } #include &lt;iostream&gt; 선행 처리기 지시어 선행 처리 C++ 프로그램을 컴파일하기 전에 소스 프로그램을 가공하여 컴파일러가 실제로 번역할 소스 프로그램을 만드는 것 선행 처리기 지시어(preprocessor directives)로 처리를 지시함 선행 처리기 지시어는 #로 시작함 선행 처리기 지시어 문장은 한 행에 한 개의 문장 작성함 대표적인 선행 처리 헤더 파일 삽입 #include #include &lt;iostream&gt; /* \"\" → 내가 만든 헤더 파일을 include 할 때 &lt;&gt; → 표준 라이브러리에서 제공하는 헤더 파일을 include 할 때 */ int main() { // 표준 출력 스트림으로 문장을 출력함 std::cout &lt;&lt; \"나의 첫 번째 C++ 프로그램\" &lt;&lt; std::endl; return 0; } 매크로 선언 및 해제 #define #undef 조건부 컴파일 #if #ifdef #ifndef 문장 C++ 프로그램의 문장 하나의 문장은 단어와 연산자, 숫자, 문자, 문자열, 문장 부호, 빈칸 등을 정해진 문법에 따라 나열하여 작성함 문장의 끝에는 세미 콜론(;)을 기입해 다음 문장과 구분함 std::cin &gt;&gt; a; aSquare = a * a; 블록(block) 한 개 이상의 문장을 중괄호({}) 안에 나열하여 묶어 놓은 것 여러 개의 문장을 하나의 문장처럼 취급하거나 함수의 몸체 구성하기 위해 사용 됨 if (a &gt; b) { auto tmp = a; a = b; b = tmp; } 함수 함수의 구성 #include &lt;iostream&gt; int main() // 머리부 // 몸체 블록 { // 표준 출력 스트림으로 문장을 출력함 std::cout &lt;&lt; \"나의 첫 번째 C++ 프로그램\" &lt;&lt; std::endl; return 0; } main() 프로그램 시작 점 입 출력 스트림 std::out객체 표준 출력 스트림 객체 데이터를 문자열로 변환하여 출력함 출력 연산자(삽입 연산자) &lt;&lt; std::cout &lt;&lt; \"나의 첫 번째 C++ 프로그램\"; // \"나의 첫 번째 C++ 프로그램\" int a = 10; std::cout &lt;&lt; \"a의 값은 \"; std::cout &lt;&lt; a &lt;&lt; \"입니다.\" &lt;&lt; std::endl; // \"a의 값은 10입니다.\" std::cin객체 표준 입력 스트림 객체 문자열을 입력 변수의 자료형의 값으로 변환하여 입력 입력 연산자(추출 연산자) &gt;&gt; 백색 공백 문자(빈칸, 탭, 새줄 문자)는 구분 문자로 취급 int a; char str[100]; std::cin &gt;&gt; a &gt;&gt; str; std::cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; \", str = \" &lt;&lt; str &lt;&lt; std::endl; 사용자 입력 10 KNOU Computer Sci 입력 결과 a = 10, str = KNOU 명칭 공간 명칭 공간 특정한 명칭들이 인식 되는 프로그램의 부분 다른 영역의 명칭 선언과 무관하게 명칭 공간 내에서 자유롭게 명칭을 선언하여 사용 가능 명칭 공간의 정의 namespace myNSpc { // 명칭 공간의 이름 : myNSpc int count; // 명칭을 선언하는 문장 나열 } 명칭 공간 외부에서는 소속 명칭 공간을 지정해 사용해야 함 myNSpc::count = 0; 동일한 명칭이라도 서로 다른 명칭 공간에서 정의되었다면 별개의 것으로 구분 여러 프로그래머가 작성한 프로그램을 결합해 완성된 프로그램 만들 경우 각자 필요한 명칭을 독립적으로 만들어 사용 가능 전역 명칭 공간 특정 명칭 공간에 속하지 않는 기본 명칭 공간 std 명칭 공간 표준 C++ 라이브러리의 명칭들이 정의되어 있는 명칭 공간 명칭 공간 사용 #include &lt;iostream&gt; namespace NameSpace1 { int a = 10; } namespace NameSpace2 { int a = 20; } int a = 30; namespace NameSpace1 { int b = 50; } int main() { int a = 40; std::cout &lt;&lt; NameSpace1::a &lt;&lt; std::endl; std::cout &lt;&lt; NameSpace2::a &lt;&lt; std::endl; std::cout &lt;&lt; ::a &lt;&lt; std::endl; std::cout &lt;&lt; a &lt;&lt; std::endl; std::cout &lt;&lt; NameSpace1::b &lt;&lt; std::endl; return 0; } /* 10 20 30 40 50 */ using이용한 명칭 공간 사용 특정 명칭 공간이나 명칭 공간 내의 특정 이름을 자주 사용하는 경우 명칭 공간 지정을 간소화 할 수 있음 std::cout→ cout using namespace std; using std::cout; using std::endl; 명칭 공간 사용 #include &lt;iostream&gt; using namespace std; namespace NameSpace1 { int a = 10; } namespace NameSpace2 { int a = 20; } int a = 30; namespace NameSpace1 { int b = 50; } int main() { int a = 40; cout &lt;&lt; NameSpace1::a &lt;&lt; endl; cout &lt;&lt; NameSpace2::a &lt;&lt; endl; cout &lt;&lt; ::a &lt;&lt; endl; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; NameSpace1::b &lt;&lt; endl; return 0; } FirstStep.cpp #include &lt;iostream&gt; using namespace std; int main() { // 표준 출력 스트림으로 문장을 출력함 cout &lt;&lt; \"나의 첫 번째 C++ 프로그램\" &lt;&lt; endl; return 0; } 실습 가이드Visual Studio Community 설치 Visual Studio 홈페이지 접속 → Community 2022 선택 → 다운로드 C++를 사용한 데스크톱 개발 체크 → 설치 → 로그인 새프로젝트 만들기 → 빈 프로젝트 프로젝트 구성 작성 → 만들기 프로젝트 이름 작성 프로젝트 저장 폴더 지정 솔루션(프로젝트를 담는 그릇) 이름 작성 생성된 솔루션, 프로젝트 확인 프로젝트 마우스 우클릭 → 추가 → 새항목 C++ 파일 선택 → 소스 파일명 입력 → 추가 C++ 프로그램의 작성 및 빌드 소스 프로그램 입력 파일명 옆 *표시 수정된 파일이라는 뜻 상단 창 → 빌드 → FirstSetp 빌드 콘솔 창 로그 확인 프로젝트 빌드 성공 프로그램 실행 상단 창 → 디버깅 → 디버깅 시작/디버깅 하지 않고 시작 명령창 확인해 프로그램 실행 확인 연습 문제 헤더 파일에 대한 올바른 설명은? a. 선행 처리기 지시어 #include에 의해 소스 프로그램 파일에 삽입된다. 헤더 파일은 클래스, 함수의 원형, 매크로, 전역 변수, 상수 등 여러 소스 파일에 공통적으로 선언되는 내용을 담고 있는 파일임 헤더 파일은 단독으로 컴파일 되지 않고, #include명령으로 지시 되는 위치에 선행 처리기에 의해 소스 프로그램에 삽입되어 함께 컴파일 됨 일반적으로 사용되는 파일 이름의 확장자는 .h임 다음 중 C++ 프로그램을 실행 가능한 프로그램으로 변환하는 것과 관련한 설명으로 올바른 것은? a. 통합 개발 환경(IDE)은 소스 프로그램의 편집기, 컴파일러, 링커, 디버깅 도구 등 소프트웨어 개발에 필요한 도구를 통합 제공하는 프로그램이다. C++ 문법에 따라 작성한 프로그램을 소스 코드라고 하며, 컴파일러는 이를 목적 코드로 변환하는 역할을 함 프로그래머가 작성한 프로그램은 링커(linker)를 이용하여 프로그램에서 사용한 라이브러리의 함수 등과 연결하는 링크 과정을 거쳐 실행 파일이 됨 프로그램 개발에 필요한 이러한 도구들을 모아 통합 환경으로 제공하는 프로그램을 통합 개발 환경(IDE)이라고 함 위 지문 중 프로그램에서 (다)의 x에 10을 저장하기 위해 빈칸에 넣을 내용은? #include &lt;iostream&gt; namespace A{int x;} // 가 namespace B{int x;} // 나 int x; // 다 int main() { int x; // 라 // __________ = 10; } a. ::x main()함수 내의 지역변수 x가 아닌 전역 명칭 공간을 지정하기 위해서는 ::을 첨부한다. 정리 하기 C++ 언어는 C 언어에 객체 지향 프로그래밍, 일반화 프로그래밍, 예외 처리 등의 기능을 추가하여 확장된 프로그래밍 언어임 C++ 프로그램은 .cpp라는 확장자를 갖는 소스 프로그램 파일과 .h라는 확장자를 갖는 헤더 파일이라는 두 가지 종류의 소스 파일에 작성함 선행 처리기 지시어를 이용하여 소스 파일의 컴파일에 앞서 헤더 파일의 삽입, 매크로 선언, 조건부 컴파일 등의 선행 처리를 함 C++ 프로그램은 함수로 구성되며, 콘솔에서 동작하는 응용 프로그램의 경우 일반적으로 main()이라는 함수부터 프로그램 실행이 시작됨 명칭 공간 이용 시 프로그램을 구성하는 영역 별로 다른 영역과의 충돌 우려 없이 자유롭게 명칭 선언해 사용 가능" }, { "title": "[데이터 정보 처리 입문] 15강 - 파이썬을 활용한 자료 분석 2", "url": "/posts/knou-dip-15/", "categories": "Data Science, Data Analysis", "tags": "knou, data information processing", "date": "2025-05-30 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김성수, 이기재 교수님의 '데이터 정보 처리 입문' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 파이썬은 객체 지향 프로그래밍 언어로 문법이 쉽고, 확장성이 좋아 데이터 과학 분야에서 R과 더불어 널리 이용되고있는 프로그램 언어임 파이썬을 이용하여 데이터를 읽고, 처리하는 방법을 알아보고, 기술 통계량을 구하는 법, 히스토그램 등 기본적인 통계 그래프를 그리는 방법을 알아봄학습 목표 파이썬을 이용하여 데이터를 읽을 수 잇음 파이썬을 이용하여 기술 통계 량을 구할 수 있음 파이썬을 이용하여 통계 그래프를 그릴 수 있음강의록자료 읽기자료 파일 (nex8-1.csv, nex8-1.xlsx) 자료 읽기 기술 통계량 및 빈도표 그래프 그리기&lt;Py 9-3&gt; 텍스트 자료 읽기import pandas as pd # pandas 라이브러리를 pd라는 이름으로 불러옴nex8 = pd.read_csv(\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/dataintro/nex8-1.csv\", header=0) # CSV 파일을 읽어 DataFrame으로 저장 (첫 번째 행을 헤더로 사용)nex8.head() # DataFrame의 첫 5행을 출력#   id  sex  age  edu    salary# 0  1   m   21   high     150# 1  2   f   22   middle   100# 2  3   m   33   high     200# 4  5   m   28   high     170nex8.head(3) # DataFrame의 첫 3행을 출력#   id  sex  age  edu    salary# 0  1   m   21   high     150# 1  2   f   22   middle   100# 2  3   m   33   high     200nex8.tail(3) # DataFrame의 마지막 3행을 출력#   id   sex  age   edu   salary# 7  8   m    32    univ    220# 8  9   f    44    middle  370# 9 10   m    55    univ    410type(nex8) # nex8 객체의 타입을 확인# pandas.core.frame.DataFrame nex8.shape # DataFrame의 행과 열의 개수를 확인 (10행, 5열)# (10, 5)&lt;Py 9-4&gt; 엑셀 파일 읽기import pandas as pd # pandas 라이브러리를 pd라는 이름으로 불러옴nex8_2 = pd.read_excel(\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/dataintro/nex8-1.xlsx\", header=0) # 엑셀 파일을 읽어 DataFrame으로 저장 (첫 번째 행을 헤더로 사용)nex8_2.head(3) # DataFrame의 첫 3행을 출력#   id sex  age    edu salary# 0  1   m   21   high    150# 1  2   f   22 middle    100# 2  3   m  33   high    200 변수 선택 nex8[\"age\"] # age 열 선택 nex8.age # age 열 선택 cols = ['sex', 'age', 'edu', 'salary'] # 선택할 여러 열의 이름을 리스트로 저장 nex8[cols] # 리스트에 지정 된 여러 열 선택 nex8.iloc[:, 1:] # 모든 행과 두 번째 열부터 끝까지의 모든 열 선택 (첫 번째 열 제외) nex8 = nex8.iloc[:, 1:] # 첫 번째 열을 제외한 결과를 다시 nex8에 저장 기술 통계량 및 빈도 표&lt;Py 9-5&gt; 기술 통계량 구하기import pandas as pd # pandas 라이브러리를 pd라는 이름으로 불러옴nex8 = pd.read_csv(\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/dataintro/nex8-1.csv\", header=0) # CSV 파일을 읽어 DataFrame으로 저장 (첫 번째 행을 헤더로 사용)nex8.head(2) # DataFrame의 첫 2행을 출력#   id sex  age     edu  salary# 0  1   m   21    high     150# 1  2   f   22  middle     100nex8 = nex8.iloc[:,1:] # 첫 번째 id 열을 제외nex8.head(2) # 변경된 DataFrame의 첫 2행을 출력 (id 열 없음)#    sex  age     edu  salary# 0  m   21    high     150# 1  f   22  middle     100nex8[\"salary\"].mean() # salary 열의 평균 계산# Out[15]: 243.0nex8[\"salary\"].std() # salary 열의 표준편차 계산# Out[16]: 98.21178929006209nex8.salary.median() # salary 열의 중앙값 계산# Out[17]: 220.0nex8.salary.quantile(0.75) # salary 열의 3사분위수 (75%) 계산# Out[18]: 297.5nex8.describe() # 숫자형 열들의 기술통계량 요약 (개수, 평균, 표준편차, 최소값, 사분위수, 최대값)# Out[19]:#              age      salary# count  10.000000   10.000000# mean   34.800000  243.000000# std    10.347302   98.211789# min    21.000000  100.000000# 25%    29.000000  177.500000# 50%    33.000000  220.000000# 75%    40.500000  297.500000# max    55.000000  410.000000참고 : &lt;Py 9-5&gt; 기술 통계량 구하기 – 범주형 변수로 바꾸기ex8 = pd.read_csv(\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/dataintro/nex8-1.csv\", header=0) # ex8-1.csv 파일을 읽어 DataFrame으로 저장 (첫 번째 행을 헤더로 사용)ex8.head(3) # DataFrame의 첫 3행을 출력#    id sex age edu salary# 0   1   1  21   2    150 # 1   2   2  22   1    100# 2   3   1  33   2    200ex8.describe() # 숫자형 열들의 기술통계량 요약 (범주형 변환 전)# Out[20]#              sex        age        edu      salary# count  10.000000  10.000000  10.000000   10.000000# mean    1.400000  34.800000   2.200000  243.000000# std     0.516398  10.347302   0.788811   98.211789# min     1.000000  21.000000   1.000000  100.000000# 25%     1.000000  29.000000   2.000000  177.500000# 50%     1.000000  33.000000   2.000000  220.000000# 75%     2.000000  40.500000   3.000000  297.500000# max     2.000000  55.000000   3.000000  410.000000# ? sex, edu : 범주형 변수로 바꾸기ex8[\"sex\"] = ex8[\"sex\"].astype(\"category\") # sex 열을 범주형(category) 데이터 타입으로 변경ex8[\"edu\"] = ex8[\"edu\"].astype(\"category\") # edu 열을 범주형(category) 데이터 타입으로 변경ex8.describe() # 기술통계량 요약 (범주형으로 변환된 sex, edu는 기본적으로 포함 안 됨)# Out[31]: #              age      salary# count  10.000000   10.000000# mean   34.800000  243.000000# std    10.347302   98.211789# min    21.000000  100.000000# 25%    29.000000  177.500000# 50%    33.000000  220.000000# 75%    40.500000  297.500000# max    55.000000  410.000000&lt;Py 9-6&gt; 그룹 별 기술 통계량 구하기import pandas as pd # pandas 라이브러리를 pd라는 이름으로 불러옴nex8 = pd.read_csv(\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/dataintro/nex8-1.csv\", header=0) # CSV 파일을 읽어 DataFrame으로 저장nex8 = nex8.iloc[:,1:] # 첫 번째 'id' 열을 제외group_stat_by_sex = nex8.groupby(\"sex\")[\"salary\"].describe() # 'sex' 열을 기준으로 그룹화한 후, 각 그룹의 'salary'에 대한 기술통계량 계산group_stat_by_sex # 결과 출력# Out[62]:#      count        mean         std    min     25%    50%     75%    max# sex# f      4.0  245.000000  114.455231  100.0  190.00  255.0  310.00  370.0# m      6.0  241.666667   97.450842  150.0  177.50  210.0  280.00  410.0group_stat_by_sex[\"mean\"] # 그룹별 기술통계량 중 'mean'(평균) 값만 선택하여 출력# Out[95]:# sex# f    245.000000# m    241.666667group_stat_by_sex[\"std\"] # 그룹별 기술통계량 중 'std'(표준편차) 값만 선택하여 출력# Out[96]:# sex# f    114.455231# m     97.450842group_stat_by_sex.loc[\"m\"] # 'sex'가 'm'인 그룹의 기술통계량 출력group_stat_by_sex.loc[\"f\"] # 'sex'가 'f'인 그룹의 기술통계량 출력# Out[98]# count      4.000000# mean     245.000000# std      114.455231# min      100.000000# 25%      190.000000# 50%      255.000000# 75%      310.000000# max      370.000000# Name: f, dtype: float64&lt;Py 9-7&gt; 빈도 표 및 분할 표 구하기import pandas as pd # pandas 라이브러리를 pd라는 이름으로 불러옴nex8 = pd.read_csv(\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/dataintro/nex8-1.csv\", header=0) # CSV 파일을 읽어 DataFrame으로 저장sex_freq = pd.crosstab(index=nex8[\"sex\"], columns=\"count\") # 'sex' 열의 빈도표 생성sex_freq # 결과 출력# Out[100]:# col_0  count# sex# f          4# m          6edu_freq = pd.crosstab(index=nex8[\"edu\"], columns=\"count\") # 'edu' 열의 빈도표 생성edu_freq # 결과 출력# Out[102]:# col_0   count# edu# high        4# middle      2# univ        4sex_edu_table = pd.crosstab(index=nex8[\"sex\"], columns=nex8[\"edu\"]) # 'sex'와 'edu' 열 간의 분할표(교차표) 생성sex_edu_table # 결과 출력# Out[104]:# edu   high  middle  univ# sex# f        1       2     1# m        3       0     3from scipy.stats import chi2_contingency # scipy.stats 모듈에서 카이제곱 검정 함수 불러옴chi2_contingency(sex_edu_table) # 분할표에 대해 카이제곱 독립성 검정 수행 (통계량, p-value, 자유도, 기대빈도 반환)# Out[106]:# (3.7499999999999996,       # 카이제곱 통계량#  0.1533549668449285,       # p-value#  2,                        # 자유도#  array([[1.6, 0.8, 1.6],   # 기대빈도#         [2.4, 1.2, 2.4]]))&lt;Py 9-8&gt; 막대 그림, 원 그림, 겹친 막대 그림import pandas as pd # pandas 라이브러리를 pd라는 이름으로 불러옴nex8 = pd.read_csv(\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/dataintro/nex8-1.csv\", header=0) # CSV 파일을 읽어 DataFrame으로 저장nex8 = nex8.iloc[:, 1:] # 첫 번째 'id' 컬럼 제외sex_freq = pd.crosstab(index=nex8[\"sex\"], columns=\"count\") # 'sex' 열의 빈도표 생성edu_freq = pd.crosstab (index=nex8[\"edu\"], columns=\"count\") # 'edu' 열의 빈도표 생성import matplotlib.pyplot as plt # matplotlib.pyplot 라이브러리를 plt라는 이름으로 불러옴 (시각화용)plt.bar(sex_freq.index, sex_freq[\"count\"]) # 'sex' 빈도에 대한 막대그래프 생성plt.bar(edu_freq.index, edu_freq[\"count\"]) # 'edu' 빈도에 대한 막대그래프 생성plt.pie(edu_freq[\"count\"], labels=edu_freq.index) # 'edu' 빈도에 대한 원그래프 생성 (각 항목의 레이블 지정)sex_edu_table = pd.crosstab(index=nex8[\"sex\"], columns=nex8[\"edu\"]) # 'sex'와 'edu'의 분할표 생성sex_edu_table.plot.bar(stacked=True) # 분할표를 이용해 겹친 막대그래프 생성&lt;Py 9-9&gt; 히스토그램, 줄기-잎 그림, 상자 그림import pandas as pd # pandas 라이브러리를 pd라는 이름으로 불러옴nex8 = pd.read_csv(\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/dataintro/nex8-1.csv\", header=0) # CSV 파일을 읽어 DataFrame으로 저장nex8 = nex8.iloc[:,1:] # 첫 번째 'id' 컬럼 제외import matplotlib.pyplot as plt # matplotlib.pyplot 라이브러리를 plt라는 이름으로 불러옴plt.hist(nex8[\"salary\"], bins=4) # 'salary' 열에 대한 히스토그램 생성 (구간(bin) 개수는 4개)# Out[113]:# (array([3., 3., 2., 2.]), # 각 구간의 빈도수#  array([100. , 177.5, 255. , 332.5, 410. ]), # 각 구간의 경계값#  &lt;BarContainer object of 4 artists&gt;)# pip install stemgraphic (in DOS) # stemgraphic 라이브러리 설치 명령어import stemgraphic # stemgraphic 라이브러리 불러옴 (줄기-잎 그림용)stemgraphic.stem_graphic(nex8.salary, scale=100) # 'salary' 열에 대한 줄기-잎 그림 생성 (scale은 줄기의 단위를 조절)import seaborn as sns # seaborn 라이브러리를 sns라는 이름으로 불러옴 (시각화용)sns.boxplot(x=\"sex\", y=\"salary\", data=nex8) # 'sex'별 'salary'에 대한 상자 그림 생성# [그래프 출력됨: 성별에 따른 급여 상자그림]&lt;Py 9-10&gt; 산점도 그리기import pandas as pd # pandas 라이브러리를 pd라는 이름으로 불러옴nex8 = pd.read_csv(\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/dataintro/nex8-1.csv\", header=0) # CSV 파일을 읽어 DataFrame으로 저장nex8 = nex8.iloc[:,1:] # 첫 번째 'id' 컬럼 제외import matplotlib.pyplot as plt # matplotlib.pyplot 라이브러리를 plt라는 이름으로 불러옴plt.scatter(nex8.age, nex8.salary) # 'age'와 'salary' 간의 산점도 생성import numpy as np # numpy 라이브러리를 np라는 이름으로 불러옴 (배열/수치 연산용)colors = np.where(nex8[\"sex\"]=='m','r','b') # 'sex' 열의 값이 'm'이면 'r'(빨강), 아니면 'b'(파랑)으로 색상 지정colors # 생성된 색상 배열 확인# Out[122]: array(['r', 'b', 'r', 'b', 'r', 'r', 'b', 'r', 'b', 'r'], dtype='&lt;U1')plt.scatter(nex8.age, nex8.salary, c=colors) # 'age'와 'salary' 산점도에 성별에 따른 색상 적용&lt;Py 9-10&gt; 산점도 그리기 – 범례 추가import matplotlib.pyplot as plt # matplotlib.pyplot 라이브러리를 plt라는 이름으로 불러옴import numpy as np # numpy 라이브러리를 np라는 이름으로 불러옴colors = np.where(nex8[\"sex\"]=='m','r','b') # 'sex' 열의 값이 'm'이면 'r', 아니면 'b'로 색상 지정colors # 생성된 색상 배열 확인# Out[122]: array(['r', 'b', 'r', 'b', 'r', 'r', 'b', 'r', 'b', 'r'], dtype='&lt;U1')plt.scatter(nex8.age, nex8.salary, c=colors) # 이전에 실행한 색상 구분 산점도 mage = nex8.age[nex8.sex == 'm'] # 성별이 'm'인 데이터의 'age' 선택fage = nex8.age[nex8.sex == 'f'] # 성별이 'f'인 데이터의 'age' 선택msalary = nex8.salary[nex8.sex == 'm'] # 성별이 'm'인 데이터의 'salary' 선택fsalary = nex8.salary[nex8.sex == 'f'] # 성별이 'f'인 데이터의 'salary' 선택plt.figure() # 새로운 그림(figure) 영역 생성 (이전 그래프와 분리)plt.scatter(mage, msalary, marker = \"x\", color=\"r\", label='Male') # 남성 데이터 산점도 (마커 'x', 색상 빨강, 레이블 'Male')plt.scatter(fage, fsalary, marker = \"o\", color=\"b\", label='Female') # 여성 데이터 산점도 (마커 'o', 색상 파랑, 레이블 'Female')plt.legend() # 범례 표시plt.show() # 그래프 출력연습 문제 파이썬에서 csv 텍스트 파일을 읽기 위한 명령 ( )는 ?  import pandas as pd nex8 = ( )(\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/dataintro/nex8-1.csv\", header=0) a. pd.read_csv 다음 출력 결과와 같이 데이터 객체 nex8의 각 변수의 기술 통계량 을 구하고자 한다. ( ) 명령은 ? nex8.head(3) # Out: # id sex age edu salary # # 0 1 1 21 2 150 # # 1 2 2 22 1 100 # # 2 3 1 33 2 200 # ( ) # Out: # sex age edu salary # count 10.000000 10.000000 10.000000 10.000000 # mean 1.400000 34.800000 2.200000 243.000000 # std 0.516398 10.347302 0.788811 98.211789 # min 1.000000 21.000000 1.000000 100.000000 # 25% 1.000000 29.000000 2.000000 177.500000 # 50% 1.000000 33.000000 2.000000 220.000000 # 75% 2.000000 40.500000 3.000000 297.500000 # max 2.000000 55.000000 3.000000 410.000000 a. nex8.describe() 파이썬에서 엑셀 파일을 읽기 위한 명령 ( )는 ?  import pandas as pd nex8 = # ( )(\"c:/data/dataintro/nex8-1.xlsx, header=0) a. pd.read_excel 파이썬에서 nex8.head( ) 의 결과가 다음과 같다. 여기서 변수 id를 제거하고 나머지 변수를 가져오기 위한 명령 ( )은 ? nex8.head(2) # Out: # id sex age edu salary # 0 1 1 21 2 150 # 1 2 2 22 1 100 nex8 = ( ) nex8.head(2) # Out: # sex age edu salary # 0 1 21 2 150 # 1 2 22 1 100 a. nex8.iloc[:, 1:] 변수 edu 의 막대 그림을 그리고자 한다. ( ) 안의 명령은 ?  nex8.head(3) # Out: # id sex age edu salary # 0 1 1 21 2 150 # 1 2 2 22 1 100 # 2 3 1 33 2 200 edu_freq = pd.crosstab(index=nex8[\"edu\"], columns=\"count\") import matplotlib.pyplot as plt # ( )(edu_freq.index, edu_freq[\"count\"] ) a. plt.bar " }, { "title": "[유비쿼터스 컴퓨팅 개론] 15강 - 인공 지능", "url": "/posts/knou-uqc-15/", "categories": "Computer Science, CS Theory", "tags": "knou, ubiquitous computing", "date": "2025-05-29 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정광식 교수님의 '유비쿼터스 컴퓨팅 개론' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 현대적인 의미의 컴퓨터가 등장한 이후 1950년대에 이미 인공 지능이란 용어가 사용 되었음 하지만 당시에는 컴퓨팅 인프라도 부족했고, 인공 지능을 위한 대용량 데이터 뿐만 아니라 이 데이터를 효과적으로 학습할 수 있는 알고리즘도 없었음 이후 인공 지능 암흑기를 거친 후, 여러 실증 연구에서 성과가 보이기 시작함 인공 지능 연구는 패턴 인식, 예측, 강화 학습 등 우수한 연구 성과를 기반으로 현재까지 활발하게 진행되고 있음 인공 지능은 인간처럼 생각하고 행동할 수 있는 기계를 만드는 기술을 의미함 이는 일반 프로그래밍과 달리 컴퓨터가 입력 데이터를 이용하여 스스로 알고리즘을 찾아내는 것으로, 여러 산업 영역에서 인공 지능 기술을 적용하면서 많은 성과를 내고 있음 이러한 인공 지능의 동작 원리를 이해하고, 향후 발전 방향에 대하여 살펴봄학습 목표 인공 지능의 장점과 단점, 향후 전망에 대해 설명할 수 있음 인공 지능의 정의와 역사를 살펴보고, 그 과정에서 어떤 사건들이 있었는지 이해할 수 있음강의록인공 지능, 머신 러닝, 딥 러닝인공 지능의 역사 2016년 3월, 국내 바둑 기사 이세돌과 알파고의 대국이 개최되었고, 결과는 알파고의 4대 1 완승이었음 그 이후 인공 지능을 갖춘 다양한 서비스가 우리의 삶 속에 제공되기 시작하였음 인공 신경 망 인공 신경 망은 인간의 뇌에 있는 뉴런 구조를 흉내 낸 모델로 인공 지능에서 활용하는 기술 중 하나임 즉, 뇌에 있는 뉴런은 여러 계층으로 나열되어 있고, 인접한 계층의 뉴런들이 서로 연결되어 있음 외부의 입력은 입력 층으로 전달되고, 각 뉴런은 입력 신호들에 대하여 내부에 저장된 가중치(weight)를 이용하여 적절한 출력을 계산하여 다음 계층으로 보내게 됨 1940년대 중반 현대적인 컴퓨터가 등장했고, 1956년 존 매카시가 인공 지능이란 용어를 처음 사용하였음 앨런 튜링(Alan Turing)이 처음 제안한 튜링 테스트(Turing Test)는 컴퓨터의 지능을 평가하는 지표가 되었음 튜링 테스트는 기계가 수행한 행동이 인간과 동등하거나 구별할 수 없을 정도인지를 테스트하는 것임 신경 외과 의사 워렌 매컬록(Warren McCullonch)과 논리 학자 월터피츠(Walter Pitts)가 인간의 뇌 구조와 유사하게 인공 신경을 그물 망으로 연결하여 간단한 기능을 구현할 수 있음을 증명하였음 추론 문제에서 인공 지능의 한계가 드러나면서 1차 암흑기가 도래하였음 당시에는 컴퓨팅 인프라도 부족했고, 인공 지능을 위한 대용량 데이터뿐만 아니라 데이터를 효과적으로 학습할 수 있는 알고리즘도 없었음 1980년대에 이르러서 전문가 시스템(Expert System)과 딥 러닝 기술이 제안 되면서 인공 지능 연구가 되살아났음 전문가 시스템은 특정 분야(예를 들면, 의료나 제조업, 설계 등)의 전문 지식을 컴퓨터가 이해할 수 있도록 표현하여 일반인도 이를 이용할 수 있도록 하였음 제프리 힌튼(Geoffrey Hinton)과 데이비드 루멜하트(David Rumelhart)는 역전파(Backpropagation) 개념을 이용하여 학습 방법을 대중화하였음 고가의 전문가 시스템은 일부 영역을 제외하면 범용화 할 수 없다는 점에서 부정적으로 평가 받기 시작하였음 이로 인해 인공지능 연구는 2차 암흑기에 들어섰고, 관련 연구는 대부분 슈퍼 컴퓨터를 활용한 시뮬레이션으로 전환하게 됨 2차 암흑기 시기에도 기존에 수학적으로만 증명된 심층 신경 망을 실질적으로 구현할 수 있는 컴퓨터 성능과 알고리즘 개선은 여러 연구자들에 의해서 계속적으로 이루어져 왔음 컴퓨팅 하드웨어 성능이 향상되면서 인공 지능 관련 연구에 필수적인 컴퓨팅 파워가 제공되기 시작하였음 1997년 IBM의 딥블루(Deep Blue)가 인간 체스 챔피언을 이겼음 2006년에 힌튼 교수는 심층 신경 망(딥러닝)을 제안하여 인공 지능의 실증 연구가 가능할 수 있었음 인공 지능 연구는 패턴 인식, 예측, 강화 학습 등의 우수한 연구 성과를 기반으로 현재까지 활발하게 진행되고 있음인공지능의 정의 인간처럼 생각하고 행동할 수 있는 기계를 만드는 기술 인간이 학습을 통해 지식을 배워가듯이 기계가 유사하게 많은 데이터로부터 학습하면서 지식을 쌓고 행동할 수 있는 컴퓨터 시스템을 개발하는 것 컴퓨터 관련 이론뿐만 아니라 통계학, 의학, 철학, 심리학, 윤리학 등 다양한 학문 연구 결과를 활용함 IT 관점에서 인공 지능은 주어진 문제를 해결할 수 있는 능력을 갖춘 시스템을 구현하는 것임 문제의 정의에 따라 강 인공 지능과 약 인공 지능으로 구분할 수 있음 약 인공 지능 스팸 메일을 걸러내거나 바둑을 두고 인간과 대화가 가능한 기술 개발 등 특정한 주제에 한정된 문제를 해결할 수 있는 기술임 강 인공 지능 인간의 지성 자체를 인공적으로 구현한 기술임 질문 인간이 하는 여러 가지 일을 각각 구현한 후 이를 합치면 강 인공 지능이 가능할까? 답 현재로서는 인간의 지성 자체를 올바르게 정의할 수 없을 뿐만 아니라, 뇌 과학 자체도 완벽하지 않기 때문에 강 인공 지능은 미래 공상 과학 영화에서만 가능한 것으로 간주하고 있다 일반적인 프로그래밍 (a): 프로그래머가 주어진 문제를 이해한 후 그와 동일하게 기계가 동작할 수 있도록 알고리즘 구현 및 개발 적절한 입력(Data) 프로그램의 수행 및 결과(Output) 생산 하지만 해결해야 할 문제 자체가 간단하지 않다면, 그 알고리즘을 개발하는 것도 용이하지 않음 예를 들면, 사람마다 필기하는 방식이 모두 동일하지 않은데, 모든 종류의 필기를 인식할 수 있는 일반화된 알고리즘을 개발하는 것은 용이하지 않음 이에 따라 여러 사용자의 필기 데이터(Data)를 이용하여 컴퓨터가 스스로 여러 사용자들의 필기를 인식할 수 있는 알고리즘(Program)을 찾아내도록 하는 것이 기계 학습 개발 방식 이미지 속에서 개와 고양이를 구분하는 응용 이를 위해 개와 고양이 사진을 상당히 많은 양을 확보한 다음, 이 사진들을 컴퓨터가 반복해서 학습하면서 가장 잘 구분할 수 있는 프로그램(혹은 알고리즘)을 찾도록 하는 것임 머신 러닝에서 주어진 문제에서 데이터를 기반으로 컴퓨터가 학습하면서 성능을 높일 수 있도록 스스로 만들어 낸 알고리즘을 모델(Model)이라고 함 딥 러닝 머신 러닝의 한 종류 인공 신경 망(Artificial Neural Network)의 은닉층(hidden layer)을 여러 계층 쌓아서 만든 깊은 신경 망(Deep Neural Network) 구조를 가짐 뇌의 신경 망 구조와 유사한 방식으로 동작하도록 계층적인 인공 신경 망을 기반으로 설계되었음 인공 지능, 머신 러닝, 딥 러닝은 사람처럼 동작하는 기계를 만드는 동일한 목적을 가지고 있음 인공 지능 큰 의미에서 인간처럼 동작할 수 있도록 컴퓨터 시스템을 구현하기 위한 방식 머신 러닝 인간처럼 동작하기 위해 컴퓨터가 사람처럼 학습하여 스스로 규칙을 만들어낼 수 있도록 함 딥 러닝 머신 러닝을 구현하는 방식 중 하나로 인공 신경 망 구조를 활용하였음 일반적인 인공 지능, 머신 러닝, 딥 러닝의 관계 머신 러닝 머신 러닝(Machine Learning, 기계 학습) 인공 지능 기술 중 하나이며, 관련 분야의 데이터를 바탕으로 지식을 자동으로 습득하여 스스로 성능을 향상 시키는 기술 대상과 관련된 데이터 분석 데이터 학습 학습한 것을 적용해 입력이 주어지면 적절한 결정을 수행하는 알고리즘 개발 머신 러닝의 분류개요 최근의 기술적 성과와 다양한 응용의 개발은 주로 머신 러닝과 딥 러닝에 기반함 머신 러닝과 딥 러닝은 데이터를 이용하여 기계가 스스로 일정한 규칙을 찾도록 함 2012년 구글과 앤드류 응(Andrew Ng) 교수는 딥 러닝을 활용하여 1,000만 개의 유튜브 영상에서 고양이를 74.8%의 정확도로 식별하였고, 이 과제가 성공하면서 머신 러닝 및 딥 러닝의 가능성이 크게 주목 받게 되었음 특정 문제에 대하여 머신 러닝을 활용하기 위해서는 주제와 관련된 대용량 데이터, 이를 학습할 수 있는 알고리즘, 그리고 데이터와 알고리즘을 처리할 수 있는 컴퓨팅 자원이 필요함 최근에는 클라우드 시스템이 대중화되고 빅 데이터 처리 기술이 성숙하면서 컴퓨팅 인프라가 충분하게 제공될 수 있게 되었음 머신 러닝이 해결하고자 하는 문제는 학습 종류에 따라 지도 학습, 비지도 학습, 강화 학습으로 구분하며, 그 외에 반 지도 학습도 있음 지도 학습과 비 지도 학습은 학습 데이터마다 관련된 정보인 레이블 유무에 따라 구분함 강화 학습은 컴퓨터가 주어진 상황에 대해 적절한 행동을 수행한 후 적절한 보상을 수행하는 방식임지도 학습 모든 학습 데이터(x)에 적당한 레이블(y)을 부여한 후, 기계가 입력 집합 x를 모델에 넣어 결과에 해당하는 y값과 비교함으로써 모델의 성능을 높이는 학습을 진행하게 됨 레이블은 각 학습 데이터에 대한 정답으로 이해할 수 있음 학습 데이터로 수집한 이미지에 이미지의 내용에 해당하는 ‘개’, ‘고양이’ 등을 레이블로 지정해 둔 후, 학습을 진행하면서 이미지가 무엇을 표현하는지 구분할 수 있도록 함 머신 러닝을 수행하기 위해 수집 된 데이터 중 일부는 학습에 사용하고, 나머지는 테스트에 사용함 학습을 진행한다는 것은 레이블 된 학습 데이터를 머신 러닝 알고리즘에 전달하여 예측을 수행하고, 그 예측이 정확한지 레이블과 비교하면서 정확도를 높여 나가는 과정 이 과정에서 내부 가중치를 조절하기 위해 비용 함수, 활성화 함수 등 다양한 개념이 적용됨 지도 학습은 학습하는 목적에 따라 분류와 회귀 모델로 구분함 분류 학습 데이터 집합을 지정 된 항목 중 하나로 선별하는 문제이며, 분류 문제에서 레이블은 이산적이고 순서가 없음 이미지 집합이 주어졌다면, 학습된 결과는 {cat, dog, mug, hat} 중 하나로 분류되는 문제가 될 수 있음 메일에서 스팸 메일을 필터링 하기 위해 지도 학습을 사용하는 경우 먼저 수집 된 수많은 이메일 각각에 ‘정상 메일’과 ‘스팸 메일’이라는 레이블을 부여함 각 메일에 대하여 학습을 수행함 새롭게 들어온 메일을 ‘정상 메일’과 ‘스팸 메일’으로 구분함 스팸 메일 필터도 분류 문제가 됨 회귀 모델 주어진 데이터의 속성 값을 기준으로 연속된 값 또는 분류된 값 중 N개의 값 중 하나를 예측하는 문제이며, 출력 되는 값이 분명하게 예측하는 것이 아니라, 연속된 값들 중 하나로 출력하는 것임 특정 지역에서 동네 별 범죄율, 세금, 집의 크기, 방의 개수와 같은 데이터를 집합 및 그 집 가격에 해당하는 레이블을 사용하여, 새로운 집의 가격을 예측하는 문제임 여기서 동네별 범죄율, 세금, 집의 크기, 방의 개수와 같은 변수를 예측 변수 혹은 특성이라고 하고, 집의 가격을 결과라고 함 학생들의 수학 과목을 공부한 시간(x)과 성적(y)과의 관계를 이용하여 모델을 만드는 경우 공부한 시간에 해당하는 독립 변수가 주어졌을 때, 그에 해당하는 성적이란 종속 변수 값을 분석하여 예측하는 모델을 생성할 수 있음 이때 성적은 0부터 100점 사이의 임의의 실수 값이 되므로 회귀 분석의 예가 됨 비 지도 학습 비 지도 학습은 주어진 데이터에 대한 어떤 지식이나 레이블도 없는 데이터를 다룸 레이블이 없는 데이터를 학습하는 목적은 해당 데이터에 있는 알려지지 않은 특징이나 구조를 스스로 파악하여 일정한 규칙성을 찾아내는 것임 지도 학습의 데이터는 학습 과정에서 주어진 입력에 대한 정답에 해당하는 레이블을 가지고 있음 비 지도 학습은 결과에 대한 어떤 가정도 없이 학습을 수행하고, 그 결과로부터 유의미한 지식을 얻고자 함 비 지도 학습의 주요 응용에는 군집화와 차원 축소가 있음 군집화 주어진 입력 데이터를 의미 있는 N개의 클러스터로 구분하는 데이터 분석 기법 각 클러스터 내에 포함된 데이터들은 다른 클러스터의 데이터와는 다른 어떤 공통된 특징을 가지고 있음 예를 들면, 마케팅 회사에서 관리하는 고객 데이터를 고객의 나이(x)와 고객의 홈페이지 방문 횟수(y)와의 유사도를 기반으로 세 개의 그룹으로 군집화 할 수 있음 비 지도 학습의 차원 축소 다 차원 데이터의 집합에서 일부 속성을 제거하여 새로운 차원의 데이터 집합을 생성하는 작업임 대개 하나의 데이터는 여러 특성으로 구성되어 있으며, 차원은 특성의 개수를 의미함 일반적으로 차원이 클 경우, 데이터 간의 거리가 기하급수적으로 커지기 때문에 모델의 예측 정확도가 떨어지게 됨 일반적으로 차원 축소는 피처 선택과 피처 추출로 구분함 피처 선택 특정 피처에 강하게 연관된 다른 피처를 제거하는 것 피처 추출 기존 피처를 중요한 피처 위주로 저 차원으로 압축해서 추출하는 것임 반 지도 학습 반 지도 학습은 전체 데이터 중에서 일부만 레이블을 가지고 있을 때 적용함 대부분의 반 지도 학습은 지도 학습 알고리즘과 비 지도 학습의 조합으로 이루어짐 레이블이 없는 데이터에 대해 일부 레이블 있는 데이터로 보충해서 학습을 시키는 방식임강화 학습 사람들은 경험으로부터 배운다는 말을 구현한 것이 강화 학습임 지도 학습과 비 지도 학습은 현재 상태를 특별히 가정하지 않고, 단지 주어진 데이터를 이용하여 학습을 수행하면서 특정 문제에 대한 모델을 생성해 나가는 방식임 강화 학습 행동을 수행할 에이전트가 현재 상태를 기반으로 하여 행동을 선택함 가능한 행동 중에서 가장 큰 보상을 받을 수 있는 행동이 무엇인지 스스로 학습하도록 함 현재 상황에 따라 보상을 크게 받을 수 있도록 시행 착오를 하면서 학습을 진행함 바둑의 경우, 현재 바둑판에 놓인 백돌과 흑돌이 현재 상태가 되며, 그에 따라 다음에 둘 수 있는 위치들의 집합이 선택 가능한 행동임 대국 도중에는 그 선택 가능한 행동 중에서 승리하기 위해 가장 좋은 수가 무엇인지 알기 힘듦 대국이 끝나면 각각의 수에 대해 피드백을 받아, 이겼을 때에는 양의 보상을 받고 졌을 때에는 음의 보상을 받도록 함 강화 학습의 학습 방식 강화학습에서는 에이전트에게 무엇을 하라고 명령을 내리지 않고, 단지 강화 학습의 목표가 무엇인지 지정해 둠 이후 여러 차례 시행착오를 통해 얻은 결과를 바탕으로 에이전트는 지속적으로 보상을 받으면서 성능이 향상됨 강화 학습 모델 현재 상태 Sₜ에서 수행할 행동 Aₜ를 결정해야 하는데 이를 정책이라고 함 강화 학습의 목적이 보상을 최대로 할 수 있도록 정책을 학습해야 하는데, 이는 가치 함수로 표현하고 가치 함수는 현재 상태를 입력으로 주었을 때 출력 되는 리턴 값에 대한 기댓 값으로 표현하며, 벨만(Bellman) 방정식으로 표현할 수 있음 바둑에서는 여러 차례 대국을 진행하면서 가치 함수를 높일 수 있도록 에이전트의 정책이 개선되는 것임인공 지능의 미래개요 2016년 세계 경제 포럼(WEF)에서 처음 언급된 4차 산업 혁명은 향상 된 정보 통신(IT) 기술을 타 산업에 융합하여 혁신 시키고자 하는 차세대 산업 혁명임 이를 위한 핵심 기술에는 빅 데이터, 인공지능, 사물 인터넷, 로봇, 3차원 프린팅, 나노 기술 등이 있음 지난 10여 년간 인공 지능 관련 여러 기반 기술이 성숙해지고, 대용량의 데이터를 수집하여 처리할 수 있는 알고리즘 및 컴퓨팅 인프라가 충분히 지원되면서, 보안, 자율 주행 자동차, 금융, 마케팅, 물류, 엔터테인먼트, 의료 등 다양한 분야에 적용되고 있음인공 지능 기술의 특징 인공 지능은 사람을 흉내 내는 것을 목표로 하지만, 일부 영역에서는 이미 사람보다 우수한 성능을 보이고 있음 머신 러닝이나 딥 러닝처럼 입력 데이터로 학습하면서 생성해 낸 알고리즘은 결국 방대한 데이터를 처리하여 나온 결과이며, 이러한 방대한 데이터 처리 역시 우수한 컴퓨팅 인프라를 활용하고 있음 특정 분야와 관련된 방대한 데이터를 수집하고 이를 처리한 후, 적절한 모델에 적용할 수 있다면 인공 지능은 상당히 많은 영역에서 사람들의 행동 양식에 영향을 줄 것으로 기대됨 일단 특정 응용에서 인공 지능의 초기 모델이 생성 된 후에도 지속적으로 데이터가 추가된다면 기계 스스로 계속 학습하면서 성능이 더 좋아질 수 있다는 것도 중요한 장점이 될 수 있음 다만, 얼마 전 이슈가 된 초 거대 언어 모델(LLM)처럼 이전과 비교할 수 없을 정도의 양을 가진 데이터를 학습하기 위해서는 엄청난 컴퓨팅 파워가 필요함 자본, 기술, 인프라를 갖춘 대기업을 중심으로 선도적인 기술 및 서비스 개발이 이루어질 수 있음을 시사함인공 지능의 부정적인 미래 여러 산업 영역과 관련된 데이터와 올바른 모델만 있다면 사람처럼 동작할 수 있는 인공 지능 기계가 등장할 수 있으며, 결국 그 자리에서 일하던 인간의 필요성이 사라질 수 있다는 의미이기도 함 대표적으로 단순 반복 업무인 고객 응대, 애프터 서비스(AS), 정보 요청(FAQ)은 챗 봇으로 대체될 수 있음 뿐만 아니라 전문직으로 여겨졌던 은행 및 보험 업무, 회계사, 공무원의 행정 업무, 법률 서비스 등도 인공지능에 의해 일자리가 위협 받는 직업으로 예측됨 2011년 IBM이 개발한 왓슨은 퀴즈 대회에서 인간 챔피언을 이기고 우승했음 왓슨은 왓슨헬스 그룹을 설립한 후 50만 편의 논문을 통해 여러 항암 유전자를 찾아냄 그 외에도 헬스케어, 법률, 광고, 요리 등에서도 활약하고 있음 학습에 사용된 원천 데이터에 포함된 개인 정보 보호 이슈, 개인의 잊혀질 권리, 콘텐츠의 원 저작자와 저작권 문제 등은 아직 해결되지 않은 주요 쟁점임 초 거대 언어 모델과 ChatGPT 자연어 처리는 컴퓨터가 음성이나 문자 형태인 사람의 언어를 이해하고, 생성 및 조작할 수 있는 기술임 ChatGPT는 OpenAI가 개발한 프로토 타입 대화형 인공지능 챗봇(Chat Bot)임 GPT는 Generative Pre-trained Transformer의 약자로, Transformer 아키텍처를 기반으로 구축된 신경 망 기반 언어 예측 모델임 즉, 사람이 자연어로 질의한 질문을 분석하고 언어에 대한 이해를 바탕으로 가능한 최상의 응답을 예측하여 생성할 수 있음 2018년 개발된 GPT-1은 1억 1,700만 개의 파라미터를 가지고 있지만, GPT-3은 1,750억 개, GPT-4는 수십조 개의 파라미터를 가진 것으로 예상 됨 이처럼 엄청난 파라미터를 가진 초거대 언어 모델을 만드는 이유는 일단 완성되면 다양한 목적에 맞게 수정될 수 있기 때문임 이를 위해 다양한 목적에 적용할 수 있도록 먼저 일반적인 지식을 학습 시키는 사전 학습과 사전 학습 결과를 목적에 맞게 특수 화 시키는 전이 학습이 활용 정리 하기 인공 지능은 큰 의미에서 인간처럼 동작할 수 있도록 컴퓨터 시스템을 구현하기 위한 방식들을 의미함 머신 러닝은 인간처럼 동작하기 위해 컴퓨터가 사람처럼 학습하여 스스로 규칙을 만들어 낼 수 있도록 함 딥 러닝은 머신 러닝을 구현하는 방식 중 하나로 인공 신경 망 구조를 활용함연습 문제 모든 학습 데이터(x)에 적당한 레이블(y)을 부여한 후, 기계가 입력 집합 x를 모델에 넣어 결과에 해당하는 y값과 비교함으로써 모델의 성능을 높이는 학습 방식은 무엇인가? a. 지도 학습(Supervised Learning) 위 지문은 무엇에 대한 설명인가? 인공신경망(Artificial Neural Network)에서 은닉층(hidden layer)을 여러 계층 쌓아서 만든 깊은 신경망(Deep Neural Network)이며, 뇌의 신경망 구조와 유사한 방식으로 동작하도록 계층적인 인공신경망을 기반으로 설계된다 a. 딥 러닝 출력 되는 값이 분류 문제처럼 N개의 값 중 하나를 예측하는 것이 아니라, 연속된 값 중 하나를 출력하는 것은 무엇인가? a. 회귀 모델 정리 하기 인공 신경망 인간의 뇌에 있는 뉴런 구조를 흉내 낸 모델로 인공 지능에서 활용하는 기술 중 하나임 즉, 뇌에 있는 뉴런은 여러 계층으로 나열되어 있고, 인접한 계층의 뉴런들이 서로 연결되어 있음 외부의 입력은 입력 층으로 전달되고, 각 뉴런은 입력 신호들에 대하여 내부에 저장된 가중치(weight)를 이용하여 적절한 출력을 계산하여 다음 계층으로 보내게 됨 머신 러닝(Machine Learning, 기계 학습) 인공 지능 기술 중 하나이며, 관련 분야의 데이터를 바탕으로 지식을 자동으로 습득하여 스스로 성능을 향상 시키는 기술임 딥러닝 머신 러닝의 한 종류이며, 인공 신경 망(Artificial Neural Network)의 은닉 층(hidden layer)을 여러 계층 쌓아서 만든 깊은 신경 망(Deep Neural Network) 구조를 가짐 강화 학습 컴퓨터가 주어진 상황에 대해 적절한 행동을 수행한 후 적절한 보상을 수행하는 방식임 지도 학습 모든 학습 데이터(x)에 적당한 레이블(y)을 부여한 후에 기계가 입력 집합 x를 모델에 넣어 결과에 해당하는 y값과 비교함으로써 모델의 성능을 높이는 학습을 진행함 비 지도 학습 주어진 데이터에 대한 어떤 지식이나 레이블도 없는 데이터를 다룸 강화 학습 행동을 수행할 에이전트가 현재 상태를 기반으로 하여 행동을 선택하고, 가능한 행동 중에서 가장 큰 보상을 받을 수 있는 행동이 무엇인지 스스로 학습하도록 함 " }, { "title": "[데이터베이스 시스템] 15강 - 회복 시스템", "url": "/posts/knou-dbs-15/", "categories": "Database", "tags": "knou, database", "date": "2025-05-28 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '데이터베이스 시스템' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 DBMS는 대량의 데이터를 여러 사용자가 동시에 접근하고 공유할 수 있도록 지원하는 시스템으로, 장애 상황에서도 중단 없는 서비스를 제공해야 함 그러나 트랜잭션 수행 중의 논리적 오류, 디스크 손상과 같은 하드웨어적 결함, 또는 시스템 소프트웨어의 예외 상황 등 다양한 원인으로 인해 데이터의 일관성이 손상되거나 시스템이 정상적으로 동작하지 않을 수 있음 이러한 상황에서도 DBMS는 데이터베이스를 일관되고 안정된 상태로 복원할 수 있어야 하며, 이를 위해 회복 시스템(recovery system)을 갖추고 있음 회복 시스템의 개념과 필요성을 이해하고, 장애 발생 시 데이터베이스를 정상 상태로 복원하기 위해 사용되는 주요 기술들을 학습함 특히 트랜잭션의 원자성을 보장하기 위한 로그 기반 회복 기술, 주기적인 저장 시점을 기록하는 체크포인트 기법, 그리고 백업과 복구 전략에 대해 구체적으로 살펴봄주요 용어 버퍼 블록 디스크로부터 읽어들여져 주 기억 장치에 임시적으로 있는 블럭 로그 레코드 데이터베이스가 수행하는 모든 수정 작업을 기록한 데이터 WAL 데이터베이스 수정 전, 로그 레코드를 생성하여 기록하여 변경 기록에 대한 로그를 안정하게 저장하는 기법 체크 포인트 회복 작업에 소모되는 비용 감소를 위해 주기적으로 모든 수정 작업을 중단하고 메인 메모리 상의 수정 된 모든 버퍼 블럭을 디스크에 반영 시키는 기법 강의록회복 시스템의 개념회복의 역할 예상치 못한 HW 고장 및 SW 오류가 발생 사용자의 작업에 대한 안정적 디스크 반영 여부 보장이 불가능 오류 발생 이전의 일관된 상태로 데이터베이스를 복원 시키는 기법이 요구 고장 원인 검출, DBMS의 안전성 및 신뢰성을 보장 데이터베이스는 데이터 복원 절차 내재화 정상 운영 데이터베이스에서 장애 발생 시 훼손된 데이터베이스가 됨 회복 데이터를 수집하여 (회복 데이터) 훼손된 데이터베이스를 복원 시스템 실패(system failure)의 유형 트랜잭션 실패 논리적 잘못된 데이터 입력, 부재, 버퍼 오버플로, 자원 초과 이용 시스템적 운용 시스템의 교착 상태 발생 시스템 장애 시스템의 하드웨어 고장, 소프트웨어의 오류 주 기억 장치와 같은 휘발성 저장장치의 내용 손실 디스크 실패 비 휘발성 디스크 저장 장치의 손상 및 고장으로 인한 데이터 손실 디스크 영구 저장을 하는 가장 중요한 장치 회복 데이터의 구성 백업 데이터베이스의 일부 또는 전체를 주기적으로 별도의 저장 장치에 복제하는 방식 로그 데이터 변경 이전과 이후의 값을 별도의 파일에 누적 기록하는 방식 백업(backup) 정상 운영 데이터베이스 → 복제된 데이터베이스 (전체/일부 복제) 로그(log) 정상 운영 데이터베이스 → 수정 사항 기록 데이터 저장 구조 전체 데이터는 디스크와 같은 비 휘발성 저장장치에 저장되며, 일부의 데이터만 주 기억 장치에 상주 데이터베이스는 데이터를 블록(block) 단위로 전송하고 블록 단위로 기억 장소를 분할 트랜잭션은 디스크로부터 주 기억 장치로 데이터를 가져오며, 변경된 데이터는 다시 디스크에 반영 가져오기, 내보내기 연산은 블록 단위로 실행 물리적 블록 디스크 상의 블록 버퍼 블록 주 기억 장치에 임시적으로 상주하는 블록 데이터베이스 연산 처리 과정 메인 메모리와 디스크 사이의 연산 Input(X) 물리적 블록 X를 메인 메모리에 적재 Output(X) 버퍼 블록 X를 디스크에 저장 Read와 Write 연산 처리 과정 Read(X)의 처리 과정 버퍼 블록 X가 메인 메모리에 없을 경우 Input(X)를 수행 버퍼 블록 X의 값을 변수 x에 할당 Write(X)의 처리 과정 버퍼 블록 X가 메인 메모리에 없을 경우 Input(X)를 수행 변수 x의 값을 버퍼 블록 X에 할당 로그 기반 회복로그 기반 회복의 개념 데이터베이스가 수행한 모든 수정 작업을 기록한 여러 종류의 로그를 사용하여 회복하는 시스템 로그 레코드의 종류 &lt;Tᵢ,Xⱼ,V₁,V₂&gt; Tᵢ가 데이터 항목 변경 연산을 수행하여 Xⱼ의 값을 V₁에서 V₂로 변경 &lt;Tᵢ,start&gt; Tᵢ가 시작 &lt;Tᵢ,commit&gt; Tᵢ가 커밋 &lt;Tᵢ,abort&gt; Tᵢ가 취소 데이터 항목 변경 WAL (Write-Ahead Log) 트랜잭션은 데이터베이스 수정 전, 로그 레코드를 생성하여 기록 트랜잭션(애플리케이션)에서 Write(X) 요청이 오면, 로그 디스크에 &lt;Tᵢ,Xⱼ,V₁,V₂&gt; 로그를 먼저 기록하고, 그 다음 메인 메모리에서 X를 변경한 후, 운영 DB의 Output(X)로 X를 반영 데이터 항목 변경 로그 디스크 변경 과정 저장용 운영 DB 영구적으로 디스크 저장 데이터는 안바뀌고, 로그만 바뀐 것도 오류 로그 레코드의 수정 기록을 보고 DB에 반영하면 됨 회복을 위한 연산 회복 기법은 로그에 대해 두 연산을 사용 Redo(Tᵢ) Tᵢ에 의하여 수정된 새로운 값으로 데이터베이스의 데이터 항목을 수정 디스크 상 반영 X 메모리에서만 반영 O Undo(Tᵢ) Tᵢ에 의해 수정된 모든 데이터 항목을 이전 값으로 복귀, 완료 후 &lt;Tᵢ,abort&gt; 기록 트랜잭션이 잘 수행(commit) 또는 잘못 되었다(abort) 요청이 없는 상태 시스템 장애 발생 시 로그에 &lt;Tᵢ,start&gt;가 있지만 &lt;Tᵢ,commit&gt; 또는 &lt;Tᵢ,abort&gt;를 포함하는 경우 Tᵢ를 Redo 로그에 &lt;Tᵢ,start&gt;가 있지만 &lt;Tᵢ,commit&gt; 또는 &lt;Tᵢ,abort&gt;를 포함하지 않는 경우 Tᵢ를 Undo 데이터베이스 변경과 커밋 데이터베이스 변경 시 복구 알고리즘의 고려 사항 트랜잭션의 일부 변경 사항이 버퍼 블록에만 반영되고 물리 블록에 기록되지 않은 상태에서 트랜잭션이 커밋 되는 상황 트랜잭션이 동작 상태에서 데이터베이스를 수정했으나 수정 후에 발생한 실패로 취소가 필요한 상황 트랜잭션 커밋 상황 &lt;Tᵢ,commit&gt; 로그 레코드가 안정된 저장 장치에 기록 완료 시 트랜잭션 커밋으로 간주 &lt;Tᵢ,commit&gt; 로그 레코드가 기록되기 전에 장애가 발생하면 롤백 회복의 유형 회복은 트랜잭션에 의해 요청된 갱신 작업이 디스크에 반영되는 시점에 따라 구분 갱신 작업이 디스크에 반영 되는 시점 DBMS가 적용할 수 있는 두가지 정책 즉시 갱신 회복 지연 갱신 회복 지연 갱신 회복 (deferred update restore) 부분 커밋까지 디스크 반영을 지연 시키고 로그에만 기록 실패 시, 별도의 회복 작업 필요 없이 로그만 수정 트랜잭션에 의해 데이터 변경이 발생할 때마다 메인 메모리에서 디스크로 반영 최대한 메인 메모리에서만 수정하고 디스크에는 나중에 반영 디스크에 아직 반영 안 된 상태 로그 레코드에만 있음 회복 시 디스크의 값을 되돌릴 필요 X 즉시 갱신 회복 (immediate update restore) 갱신 요청을 곧바로 디스크에 반영 실패 시, 디스크에 반영된 갱신 내용을 로그를 바탕으로 회복 메인 메모리에서 수정을 진행하다가 특정 시점이 되었을 때 DB에 반영 디스크에 바로 반영이 됨 다시 이전 값으로 되돌리는 작업이 필요 은행 시스템의 트랜잭션 예 초기값 A=30,000, B=10,000, C=50,000 T1은 A에서 5000을 빼고, B에 5000을 더하며, T2는 C에서 1000을 빼는 작업 로그와 데이터베이스 상태시스템 장애 발생 상황체크포인트의 필요 로그 기반 회복 시스템의 한계 로그의 크기는 시간이 지남에 따라 계속 증가하므로 대용량 로그의 탐색 비용이 매우 커짐 Redo를 해야하는 트랜잭션 중 대부분은 이미 데이터베이스에 반영 반영된 트랜잭션의 재실행은 시스템 자원의 낭비 체크포인트 기법 현재 시점에 메인 메모리의 버퍼 블록에 존재하는 모든 로그 레코드를 안정 저장장치로 기록 수정 된 모든 버퍼 블록을 디스크에 반영 로그 레코드 &lt;checkpoint ListT&gt;를 안정된 저장 장치에 기록 ListT는 체크포인트 시점에 실행 중인 트랜잭션 목록 checkpoint ListT 지금 실행 중인 것은 나중에 오류 생겼을 때 볼 것 체크포인트를 이용한 회복 체크포인트 기법을 이용한 회복 과정 로그의 마지막부터 역방향으로 탐색하여 &lt;checkpoint ListT&gt; 레코드를 찾음 ListT에 존재하는 &lt;checkpoint ListT&gt; 이후에 실행된 트랜잭션에 대해서만 Redo와 Undo 연산 수행 로그에 &lt;Tᵢ,commit&gt; 또는 &lt;Tᵢ,abort&gt;가 없는 ListT안의 모든 트랜잭션을 Undo 트랜잭션의 작업이 최종 완료 되지 않음 이전 값으로 다시 덮어씀 로그에 &lt;Tᵢ,commit&gt; 또는 &lt;Tᵢ,abort&gt;가 있는 ListT안의 모든 트랜잭션을 Redo 커밋된 트랜잭션에 한해,장애 발생 시 로그를 참조하여 변경 사항을 디스크에 재실행 회복 알고리즘트랜잭션 Tᵢ의 롤백 알고리즘 특정 트랜잭션 Tᵢ가 자체적인 오류, 명시적인 철회(Abort) 요청 등으로 인해 정상적으로 완료되지 못했을 때, 해당 트랜잭션이 데이터베이스에 적용한 모든 변경 사항을 취소(Undo)하는 과정 1단계 로그를 역방향으로 탐색 트랜잭션 Tᵢ와 관련 된 로그 레코드 찾음 2단계 Tᵢ의 로그 레코드 &lt;Tᵢ,Xⱼ,V₁,V₂&gt;에 대하여 트랜잭션 Tᵢ가 데이터 항목 Xⱼ의 값을 V₁에서 V₂로 변경했다는 의미 데이터 항목 Xⱼ에 V₁ 기록 이전 값으로 되돌림 로그 레코드 &lt;Tᵢ,Xⱼ,V₁&gt;을 로그에 기록 Undo 작업 수행한 로그를 추가 기록 3단계 &lt;Tᵢ,start&gt;를 찾은 이후 역방향 탐색을 중단 로그 레코드 &lt;Tᵢ,abort&gt;를 로그에 기록 시스템 장애 후 회복 알고리즘 시스템 장애 이후, 재 시작 시 Redo와 Undo 단계를 수행 장애 직전까지 커밋(Commit)된 트랜잭션의 변경 사항은 모두 디스크에 반영(Redo)하고, 커밋 되지 않은 트랜잭션의 변경 사항은 모두 취소(Undo)하는 것이 목표 Redo 단계 최근의 체크 포인트에서부터 순 방향 로그 탐색 롤백 대상할 트랜잭션의 Undo 리스트인 ListofUndo를 ListT로 초기화 체크포인트 시점에 진행 중이었던 트랜잭션(ListT)들은 장애 시점까지 커밋 되었는 지 확인이 필요하므로 일단 Undo 대상 후보로 간주 &lt;Tᵢ,Xⱼ,V₁,V₂&gt;, &lt;Tᵢ,Xⱼ,V₁&gt; 형태의 모든 레코드를 재 실행 로그를 읽으면서 나오는 모든 데이터 변경 작업(일반 업데이트 레코드 및 보상 로그 레코드)을 그대로 재실행 장애 직전 메모리 상태를 그대로 재현 &lt;Tᵢ,start&gt; 발견 시, Tᵢ를 ListofUndo에 추가 새로운 트랜잭션이 시작되면, 이 트랜잭션도 커밋되지 않고 종료되었을 수 있으므로 ListofUndo에 추가 &lt;Tᵢ,abort&gt;, &lt;Tᵢ,commit&gt; 발견 시 Tᵢ를 Undo 리스트에서 제거 트랜잭션 Tᵢ가 커밋되었거나 이미 철회(abort)된 것이 확인되면, 더 이상 Undo할 필요가 없으므로 시스템 장애 후 회복 알고리즘 (Undo 단계) Undo 단계 (역방향 로그 탐색) ListofUndo의 트랜잭션의 로그 레코드를 찾으면 트랜잭션 롤백 알고리즘 1단계 수행 ListofUndo의 트랜잭션 Tᵢ에 대해 &lt;Tᵢ,start&gt;를 만나면 로그에 &lt;Tᵢ,abort&gt;를 기록하고 ListofUndo에서 제거 ListofUndo에 트랜잭션이 존재하지 않는 상태가 되면 Undo 단계를 종료 로그를 통한 회복 작업 과정 Redo 단계 (체크포인트부터 순방향 탐색) 회복 관리자가 시스템을 재시작 &lt;checkpoint {T₀, T₁}&gt; 발견 ListofUndo = {T₀, T₁}로 초기화함 &lt;T₁, C, 1000, 900&gt; 발견 Redo 데이터 C의 값을 900으로 변경함 &lt;T₁, commit&gt; 발견 T₁은 커밋 된 트랜잭션임 ListofUndo에서 T₁을 제거함 ListofUndo = {T₀} &lt;T₂, start&gt; 발견 ListofUndo에 T₂를 추가함 ListofUndo = {T₀, T₂} &lt;T₂, A, 300, 500&gt; 발견 Redo 데이터 A의 값을 500으로 변경함 &lt;T₀, B, 10000&gt; 발견 Redo 데이터 B의 값을 10000으로 변경함 만약 T₀가 장애 발생 전에 이미 롤백 중이어서 이 레코드가 보상 로그 레코드였다면, 이 Redo는 그 롤백 작업을 재실행하여 B를 10000으로 만드는 것을 보장함 &lt;T₀, abort&gt; 발견 T₀는 철회된 트랜잭션임 ListofUndo에서 T₀를 제거함 ListofUndo = {T₂} 로그의 끝에 도달 (장애 발생 지점) Redo 단계가 종료 됨 현재 ListofUndo = {T₂} 즉, T₂는 장애 발생 시점까지 완료되지 않은 패자 트랜잭션임 Undo 단계 (로그 끝에서 역방향 탐색) ListofUndo = {T₂}인 상태로 Undo 단계를 시작함 로그를 역방향으로 탐색하며 T2와 관련된 작업을 찾음 &lt;T₀, abort&gt; T₀는 ListofUndo에 없으므로 무시 &lt;T₀, B, 10000&gt; T₀는 ListofUndo에 없으므로 무시 &lt;T₂, A, 300, 500&gt; T₂의 로그 레코드 발견 트랜잭션 롤백 알고리즘에 따라 Xᵢ(A)의 값을 V₁(300)으로 되돌림 A = 300 보상 로그 레코드 &lt;T₂, A, 300&gt;을 로그에 기록함 &lt;T₂, start&gt; T₂의 시작 레코드 발견 T₂의 모든 변경이 취소되었으므로, 로그에 &lt;T₂, abort&gt;를 기록함 ListofUndo에서 T₂를 제거함 ListofUndo = {} ListofUndo가 비었으므로 Undo 단계 및 전체 회복 과정이 종료 됨 연습 문제 다음과 같은 스토리지 구조와 상태에서 트랜잭션에 의해 Write(X)를 실행하기 위한 첫 번째 단계로 올바른 것은? (단, 데이터 항목 x는 블록 X에 존재한다고 가정한다) a. Input(X)를 수행한다. Write(A)를 수행하기 위해서 DBMS는 데이터 항목 A가 존재하는 블록이 현재 메모리 상에 존재하는지 확인한 후, 존재하지 않을 경우 Input(X)를 수행하여 메모리 상으로 읽어들어들임 이 후 X내의 A에 xi값을 할당하고 마지막으로 Output(X)를 수행함 Write 연산을 수행할 때 마다 데이터베이스가 변경되기 전에 로그 레코드를 우선 로그에 추가하는 방식을 무엇이라고 하는가? a. Write Ahead Log 로그는 데이터베이스 회복을 위한 데이터로 어떠한 연산이 수행된 이후에 로그가 기록되지 않은 상태에서 데이터베이스 오류가 발생할 경우, 회복할 수가 없기 때문에 로그 레코드를 먼저 기록한 후, Write 연산을 수행함 이를 Write Ahead Log, WAL이라고 함 다음 중 체크포인트에 의해 발생하는 작업이라고 할 수 없는 것은? a. 트랜잭션의 명령을 분석하여 Undo할 트랜잭션과 Redo할 트랜잭션을 구분함 체크포인트는 로그를 이용한 회복 작업에 필요한 비용 감소를 위해 주기적으로 수정된 버퍼를 디스크에 반영하고 로그 레코드 를 기록하는 것을 말함 체크 포인트에 의해 발생하는 작업 현재 메인 메모리에 존재하는 모든 로그 레코들르 안정 저장 장치에 기록함 수정 된 모든 버퍼 블록을 디스크에 반영함 로그 레코드 를 안정 저장 장치에 기록함 정리 하기 데이터 회복이란 데이터베이스 운영 도중에 발생하는 예기치 못한 실패나 고장이 발생한 경우, 데이터베이스를 실패 및 고장 발생 이전의 일관적인 상태로 되돌리는 작업을 의미함 실패 유형에는 논리적 오류나 버퍼 오버플로 등의 요인에 의한 트랜잭션 실패, 하드웨어 고장 등으로 인한 시스템 장애, 디스크 손상으로 인한 디스크 실패가 있음 디스크와 주기억 장치 사이에 블럭 단위로 데이터가 이동 되며, 디스크 상의 블록은 물리적 블럭, 주기억 장치 상의 블럭은 버퍼 블록이라고 함 데이터베이스 응용에서의 데이터 조작은 버퍼 블럭에서 이루어지며, 트랜잭션 완료나 버퍼의 여유 공간이 없을 때 버퍼 블럭이 디스크에 기록 됨 데이터베이스 회복을 위해 가장 많이 사용 되는 로그 기반 회복 기법은 데이터베이스 시스템이 기록한 모든 수정 작업에 대한 기록을 유사 시 데이터베이스를 이전 상태로 복구하는 데에 사용하는 기법임 데이터베이스 회복 시 각각의 트랜잭션은 Redo나 Undo 됨 문제 없이 진행되어야 했을 트랜잭션의 경우 Redo 되며, 완료되지 못한 상황에서 예기치 않게 종료 되어 데이터베이스의 일관성을 해칠 위험이 있는 트랜잭션의 경우 Undo 됨 장기간 데이터베이스 운용으로 시스템 장애 발생 시 재 실행해야 할 로그의 양이 방대해지기 때문에 체크 포인트를 실행하여 최근의 실행 된 체크 포인트 이후의 로그만으로도 데이터베이스를 회복할 수 있는 방법을 제공함 체크 포인트를 생성하는 작업은 메모리에 존재하는 모든 로그 레코드를 안정 저장 장치로 기록한 후, 수정 된 모든 버퍼 블럭을 디스크에 반영함 이후 현재 실행 중인 트랜잭션의 리스트를 표시한 레코드를 안정 저장 장치에 기록함 회복 과정은 오류가 발생하기 전까지 트랜잭션의 실행 상태에 따라 Redo 또는 Undo 작업으로 분류 됨 정상적으로 완료 된 트랜잭션에 대해서는 Redo를 실행하며, 불완전하게 실행 된 트랜잭션은 로그를 역순으로 읽어 트랜잭션 실행 전까지 되돌림 체크 포인트를 사용하는 시스템에 대해서는 마지막 체크 포인트를 확인하고 그 이후의 로그에 대해서만 정상적으로 반영 되었는지 확인하여 Redo 또는 Undo 하면 무결성 데이터베이스를 유지할 수 있음체크 포인트 다음의 검사점(checkpoint)이 있는 로그에서 시스템 고장이 발생하는 경우 재수행(redo)을 해야하는 트랜잭션만을 모두 고른 것은? a. T₃, T₉ 마지막으로 체크 포인트가 일어난 이후, 실패가 일어나기 이전에 커밋 된 트랜잭션에 대해서는 진행을 다시 해야 함 즉시 갱신 전략을 이용하는 회복 시스템에서 다음과 같은 로그 기록을 사용하여 복구 과정을 수행한 내용 중 옳지 않은 것은? a. 트랜잭션 T₃는 undo 를 수행하여 C값으로 30을 저장한다. 커밋이 된 작업이기 때문에 이 작업을 다시 수행 해야 하는 redo 작업을 해야 하고 45가 되었는지 확인해야 함 즉시 갱신 전략을 이용하는 회복 시스템에서 다음과 같은 로그 기록을 사용하여 복구 과정을 수행한 내용 중 옳은 것 트랜잭션 T₁은 복구 작업을 수행할 필요가 없음 트랜잭션 T₂는 undo를 수행하여 B값으로 20을 저장함 트랜잭션 T₅는 undo를 수행하여 D값으로 20을 저장함 " }, { "title": "[운영 체제] 15강 - 운영 체제 사례", "url": "/posts/knou-os-15/", "categories": "OS, Operating System", "tags": "knou, os", "date": "2025-05-27 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김진욱 교수님의 '운영 체제' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 현대 컴퓨터에서 모바일 장치부터 슈퍼 컴퓨터까지 다양한 이질적인 환경에서 운영 체제가 동작함 지금까지 운영 체제의 전반에 대해 공부했는데 실제 우리가 사용하고 있는 운영 체제는 각각 해당하는 내용을 어떻게 반영했는지 실제 사례를 통해 공부함 리눅스와, 윈도우, 그리고 안드로이드에 대해 살펴봄학습 목표 리눅스의 특징을 설명할 수 있음 임베디드 리눅스의 차이점을 설명할 수 있음 윈도우의 특징을 설명할 수 있음 안드로이드의 특징을 설명할 수 있음강의록Linux리눅스의 개요 1991년 Linus Torvalds가 MINIX에 기반하여 개발 MINIX 마이크로 커널 구조의 아주 작은 수업용 운영체제 소스 공개 개발자 뿐 아니라 일반인 및 기업용으로 사용 가능한 운영체제 인텔 CPU뿐 아니라 ARM 등 다양한 CPU를 지원 실습용 컴퓨터부터 슈퍼 컴퓨터까지 널리 사용됨리눅스의 장점 무료로 사용 가능 UNIX와 완벽하게 호환 가능 높은 안정성 낮은 성능의 하드웨어에서 동작 가능 개인용 컴퓨터에서 서버 기능 수행 가능리눅스의 단점 교육, 유지 보수 문제 보안 문제가 상대적으로 심각할 수 있음 떨어지는 보급률 특정 하드웨어가 지원되지 않을 수 있음 최근에 좋아지고 있음 리눅스 커널 일체형 커널 소스가 공개되어 있기 때문에 필요 없는 부분은 제거 가능 멀티 태스킹, 멀티 유저 시스템 멀티 코어, 멀티 프로세서 지원 여러 가지 하드웨어 지원 리눅스의 대부분은 C 언어로 작성되어 있어 다양한 플랫폼에 손쉽게 이식 됨 UNIX 표준인 POSIX 표준 지원 프로세스 간 통신 지원 세마포어, 메시지 큐, 공유 메모리 등 다양한 파일 시스템 지원 ext4, FAT, NTFS, HPFS 등 모듈 필요한 서비스를 모듈로 만들어, 커널을 교체하거나 시스템을 재시동하지 않고 기능 추가 가능 파일 형태의 주변 장치 접근임베디드 시스템 미리 정해진 특정한 기능을 수행하기 위해 하드웨어와 소프트웨어를 결합하여 설계된 컴퓨터 시스템 한 가지 일을 잘하도록 설계된 시스템 ex) 세탁기 여러 센서를 이용하여 물의 양, 세탁물에 대한 정보 등 측정 효율적인 세탁을 위해 임베디드 시스템의 제어를 통해 동작 보통 실시간 시스템에 이용됨실시간 시스템 시스템의 상황과 무관하게 정해진 마감 시간 내에 주어진 이벤트에 반응해야 함 실시간 운영체제(RTOS)는 빠르게 주어지는 마감 시간 내에 작업을 처리하는 데 중점을 둠 두 가지로 구분 경성 실시간 시스템 (Hard real-time system) 반드시 마감 시간 내 작업을 완수해야 함 ex) 항공기 전자 제어 시스템, 심박동기 등 연성 실시간 시스템 (Soft real-time system) 마감 시간 내 작업을 완수하면 좋지만 못해도 실패는 아님 기준에 따라 어떤 작업을 완수할 것인가 결정해야 함 ex) 멀티미디어 재생 임베디드 리눅스 임베디드 시스템을 위해 개발 된 리눅스 필요한 요건 소용량 메모리를 감안하여 운영체제의 크기를 최소화하여 필요한 부분만 남겨야 함 저성능 CPU를 감안하여 성능이 최적화되어야 함 리눅스는 원래 범용 컴퓨터 시스템을 위한 운영체제이므로 실시간 시스템의 요구 사항에 대응할 수 있어야 함 장점 무료로 사용 가능하며, 운영체제를 응용에 적합하게 수정 가능 많은 사용자와 개발자로부터 검증 받았으며, 많은 검증된 코드를 바로 사용 가능 운영체제의 최신 동향 반영 리눅스에 익숙한 개발자는 빠르게 적응 가능 단점 경성 실시간 시스템에 적절하지 못하고 요구되는 H/W 사양 높음 Windows윈도우의 역사 PC에서 GUI를 제공하는 것을 목적으로 1985년에 처음 발표 Windows NT POSIX 표준 및 Windows 3.0의 API를 지원하는 Win32 추가 서버용 운영체제로 보안과 신뢰성 강화 Windows 95 이전과 달리 윈도우 안에 MS-DOS 포함 Windows XP Windows NT 구조에 Windows 95/98의 사용자 편의성 결합 윈도우 커널 마이크로 커널을 확장한 형태 커널 모드에서는 마이크로 커널 위에 여러 서비스가 동작 I/O 관리자, Win32 윈도우 관리자 GDI, 보안 참조 모니터, LPC 기능, 가상 메모리 관리자, 객체 관리자, 프로세스 관리자 등 사용자 모드에서는 OS/2, POSIX, Win32에 대응되는 하위 시스템이 동작 NT API가 커널 모드와 사용자 모드를 연결 윈도우 커널 I/O 관리자 Win32 윈도우 관리자와 그래픽 장치 인터페이스(GDI) 사용자의 입력과 화면 출력을 제어 Win32 하위 시스템이지만 성능 향상을 위해 커널 모드에서 동작 보안 참조 모니터 자원의 접근 가능 여부 점검 LPC(Local Procedure Call facility) 기능 같은 기계에서 동작하는 프로세스 사이의 정보 교환 객체 관리자 다른 서비스가 자원을 접근하려면 거쳐야 하는 자원 관리 서비스 모든 자원은 객체로 간주 프로세스 관리자Android모바일 운영체제 모바일 환경의 요구 조건 배터리로 동작하기 때문에 전력 소모량을 줄여야 함 대부분 무선 네트워크로 인터넷에 연결됨 터치 스크린 등 입 출력 장치가 일반적인 PC 환경과 다름 저 수준 운영체제와 고 수준 사용자 인터페이스가 결합된 형태 대표적인 모바일 운영 체제 안드로이드 iOS 안드로이드 개요 2008년 처음 발표 스마트폰에서 가장 널리 사용 되고 있음 셋톱 박스, 스마트 TV, 자동차 등 사용 범위가 넓어지고 있음안드로이드의 특징 기본적으로 소스는 공개되어 있지만, 회사에서 따라 디바이스 드라이버 등이 비공개 되는 경우가 늘고 있음 ARM, x86 CPU 지원 다른 CPU 지원도 이론적으로는 가능 리눅스에 기반한 일체형 커널 구조 C, C++로 구현 된 운영 체제에 Java로 개발 된 응용 프로그램 동작 iOS에 비해 다양한 하드웨어를 지원하기에 파편화 문제 존재 파편화 문제 특정 H/W에서만 동작하는 S/W 존재 가능 안드로이드 런타임 (ART) 응용 프로그램을 처음 설치할 때 중간 코드를 실제 기계 코드로 번역하고, 이후 실행할 때 번역된 코드를 실행해 성능을 높임 (AOT - Ahead-Of-Time 컴파일) 설치 시 코드를 번역하는 과정이 포함되기 때문에 설치에 시간이 더 걸림 정리 하기 리눅스 커널은 일체형 구조이며, 커널 소스는 공개 되어 자유롭게 수정할 수 있음 임베디드 시스템은 미리 정해진 특정한 기능을 수행하기 위해 하드웨어와 소프트웨어를 결합하여 설계 된 컴퓨터 시스템임 실시간 운영체제는 주어진 마감 시간 내에 필요한 결과를 얻기 위한 실시간 시스템을 위한 운영 체제임 실시간 시스템은 마감 시간을 얼마나 엄격하게 지켜야 하느냐에 따라 경성 실시간 시스템과 연성 실시간 시스템으로 나뉨 리눅스는 임베디드 시스템에서 활발히 사용되고 있음 Windows 95부터 본격적인 GUI를 갖춘 운영 체제의 형태를 갖춤 Windows XP 이후는 Windows NT의 구조인 수정 된 마이크로 커널에 기반한 운영 체제임 Windows NT의 커널, I/O 관리자, Win32 윈도우 관리자와 GDI, 객체 관리자, 장치 드라이버 등은 커널 모드에서 동작함 Android는 iOS와 함께 대표적인 모바일 운영 체제로, 리눅스에 기반한 일체형 커널 구조임" }, { "title": "[파이썬 프로그래밍 기초] 15강 - 체크 포인트", "url": "/posts/knou-python-15/", "categories": "Language, Python", "tags": "knou, python", "date": "2025-05-25 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '파이썬 프로그래밍 기초' 강의를 개인 공부 목적으로 메모하였습니다. 강의록 유사한 유형의 문제를 해결할 수 있도록 특정 작업을 수행하는 명령문의 집합을 단일 식별자로 구성한 개념은? a. 함수 인터프리터 소스 코드를 바이트 코드 또는 실행 파일로 바꾸는 역할 파일 데이터를 임시적으로 저장하고 있는 개념 명령 블럭 특정 목적을 수행하는 코드의 집합 line 클래스의 인스턴스 m의 멤버 __len을 10으로 수정하기 위한 올바른 표현은? class line: def __init__(self, length): self.__len = length def get_length(self): return self.__len def set_length(self, length): self.__len = length a. m.set_length(10) __로 시작하는 private 데이터 필드는 외부에서 접근 불가 setter 또는 변경자라 불리는 메소드 통해 수정해 주어야 함 math 모듈 사용을 위한 빈 칸의 올바른 표현은? # 빈 칸 a, b = 10, 20 area = 1/2 * a * b * sin(radians(60)) print(area) a. from math import sin, radians 모듈을 사용하려면 프로그램 내부에 선언이 필요 특정 목적 또는 분야에서 사용되는 함수, 상수, 클래스 등을 모아 놓은 파일은? a. 모듈 프레임워크 어떤 개발하는 과정에서 일종의 토대를 만들어 놓고 약간 살을 덧붙임으로 개발을 빠르게 개발할 수 있는 방법 제공 특정한 배열 순서나 규칙적인 의미가 없는, 임의의 수는? a. 난수 난수 다룰 수 있는 랜덤 모듈이 있음 대규모 소프트웨어 개발에 자원을 투입하여 초기에 예상한 결과물 구현을 목적으로 소프트웨어 전체 개발 과정을 하나의 프로세스로 정의한 것은? a. 소프트웨어 개발 라이프사이클 SDLC 매개 변수 값의 합을 반환하는 summation 함수에 대해 빈칸에 알맞은 표현은? def summation(*numbers): # 가변 매개 변수 -&gt; 리스트 형태로 들어옴 sum = 0 # ________________ sum = sum + i return sum a. for i in numbers 딕셔너리의 구성 요소와 용어가 올바르게 짝 지어진 것은? a. 2 - 항목(item) 1 - 키(key) 2 - 항목(item) 3 - 값(value) 4 - 딕셔너리(dictionary) 리스트와 유사한 시퀀스 타입 동일한 형태의 유형이 나열되는 형태의 데이터 타입 각각의 항목이 키와 값이라고 하는 두 개의 pair로 구성 됨 검색의 용도로 사용 가능 매개 변수로 전달된 숫자를 역순으로 출력하는 함수이다. 빈칸에 알맞은 연산자는? def reverse_digit(number): while number != 0: digit = number % 10 # 10으로 나눈 나머지 -&gt; 일의 자리 값 가져옴 number = number # ____ # 10으로 나눔 -&gt; 일의 자리 숫자를 떼어냄 print(digit, end=\"\") a. // 정수 나눗셈 정수만 남기는 형태의 나눗셈 객체와 객체 사이의 상호작용으로 프로그램을 구성하는 프로그래밍 패러다임은? a. 객체 지향 프로그래밍 명령형 프로그래밍과 구조적 프로그래밍을 그대로 사용하면서도 코드의 재활용률을 높이고 객체 사이사이의 상호 작용 관점을 제공 아래는 ‘Khan.txt’ 파일을 읽고 처리하는 프로그램이다. 다음 물음에 따라 답하시오. khan_fp = open(\"Khan.txt\", \"r\") # 읽기 모드로 파일을 읽어옴khan_mottos = # ___(가)___ for motto in khan_mottos: print(motto.strip()) # 공백 제거 후 출력 # ___(나)___ 파일 전체의 내용이 리스트로 저장되도록 (가)에 들어갈 알맞은 표현은? 멤버 설명 open() : file obj 파일과 연결되어 있는 파일 객체 생성 read() 특정 개수의 문자를 반환 readline() 한 라인의 문자열을 반환 readlines() : list 전체 라인의 문자열을 리스트로 반환 write(s: str): 파일에 문자열을 작성 close() 파일 닫기 및 파일 객체 삭제 a. khan_fp.readlines() 파일 처리 후 프로그램이 종료되기 전 파일에 대한 마무리 작업으로 (나)에 들어갈 올바른 표현은? a. a. khan_fp.close() 파일에 대한 라이프사이클 생성 처리 · 사용 닫기 파일 포인터를 얻어 사용하고 나면 꼭 닫아주어야 오류가 적음 함수의 처리 결과 반환 시 사용하는 키워드는? a. return break 반복문이 중간에 중단 될 수 있도록 만들어주는 키워드 continue 현재의 반복만 중단하고 다음 반복으로 넘어감 다음은 EDP 구동 구조이다. 이벤트 루프의 역할에 대한 올바른 설명은? a. 이벤트 생성 여부 확인 및 전달 EDP Event driven programming 이벤트에 의해서 동작하는 프로그램 GUI 프로그래밍에 기본적으로 사용 되는 구조 이벤트 발생 장치 이벤트 유형에 따른 이벤트 생성 이벤트 큐 이벤트가 발생 되면 이벤트 저장함 이벤트 핸들러 이벤트 발생에 따른 코드 실행 소프트웨어 개발 라이프 사이클에서 요구 반영, 예상 결과 유사 검증 및 오류 파악이 진행되는 단계는? a. 테스트 다음 클래스의 인스턴스를 생성하는 표현은? class robot: def __init__(self, name): self.name = name self.skill = [] def create_skill(self, skill): self.skill.append(skill) def info(self): print('제 이름은', self.name, '입니다!') a. r1 = robot(\"android1\") 클래스의 인스턴스를 만들려고 하면 생성자를 불러야 함 생성자의 이름은 클래스 이름과 동일 생성자의 파라미터는 __init__ 에 있는 파라미터로 결정 모든 메소드의 첫번째 파라미터는 self → 파라미터를 넘길 때는 생각하지 않음 객체 지향 프로그래밍에서 객체의 구성 요소가 아닌 것은? a. 내장 함수 객체 지향 프로그래밍 객체로써 프로그램을 구성함 객체는 데이터 필드와 메소드의 하나의 합 메소드, 초기자, 데이터 필드는 객체를 구성하는 요소 내장 함수 인터프리터에 있어 별도로 정의하지 않아도 사용할 수 있는 함수들 아래는 구구단 게임 소스 코드이다. 다음 물음에 따라 답하시오. a, b가 1~9의 임의의 정수가 되도록 (가), (나)에 공통적으로 사용되는 표현은? import randomscore = 0for i in range(10): a = # ___(가)___ b = # ___(나)___ result = int(input(str(a)+\" X \"+str(b)+\"?\")) if result == a * b : score += 20 print(\"맞았습니다.\") else: print(\"틀렸습니다.\") 멤버 설명 random() 0 ~ 1 사이의 숫자 중 난수 발생 randint(a, b) a부터 b 사이의 숫자 중 난수 발생 randrange(a, b, c) a부터 b 사이의 c의 간격으로 나열된 숫자 중 난수 발생 choice(sequence) 주어진 항목을 랜덤하게 반환 sample(sequence) 랜덤하게 여러 개의 원소를 선택 shuffle(sequence) 시퀀스의 순서를 랜덤하게 섞음 a. random.randint(1, 9) 아래는 2차원 리스트 board에 포함된 모든 항목을 출력하는 함수이다. 다음 물음에 답하시오. 행마다 원소의 값이 새로운 라인에서 출력되도록 (가)에 print()가 삽입될 때, print() 앞의 들여쓰기 칸 수는? (단, 들여쓰기 단위는 3칸이라고 가정한다.) def show_board(): for row in board: for item in row: print(item, end=\" \") # ___(가)___ a. 6 행이 바뀔 때 마다 print 문이 실행 되어야 함 아래는 파일에 포함된 단어의 출현 횟수를 세는 프로그램이다. 다음 물음에 따라 답하시오. h_fp = open(\"hamlet_by_Shakespeare.txt\", \"r\")wdict = dict() for line in h_fp.readlines(): # 파일에 포함 된 리스트를 모두 읽어 한줄 한줄 가져옴 for word in line.strip().split(): # 공백이 있을 때마다 하나씩 끊음 word = word.strip(\" ,?[.\\\\\";\").lower() # 불필요한 문자 삭제 if # ___(가)___ is not None: count = # ___(나)___ else : count = 0 # ___(다)___ = count + 1 h_fp.close() wdict 딕셔너리에 word에 대한 항목 생성 여부를 확인하기 위한 표현으로 (가)에 들어갈 올바른 것은? | 멤버 | 설명 | | ——————- | ——————————– | | keys() : tuple | 포함된 모든 키를 반환 | | values() : tuple | 포함된 모든 값을 반환 | | items() : tuple | (키, 값) 형태의 튜플로 모든 항목을 반환 | | clear() : None | 모든 항목을 삭제 | | get(key) : value | 키에 해당하는 값을 반환 | | pop(key) : value | 키에 해당하는 값을 반환하고 항목을 삭제 | | popitem() : tuple | 무작위로 한 (키, 값)을 반환하고 선택된 항목을 삭제 | a. wdict.get(word) word를 넘겨주어 해당 되는 출현 횟수의 값이 넘어옴 wdict에서 word 항목의 값을 가져오거나 저장하기 위해 (나)와 (다)에 공통으로 들어갈 올바른 표현은? a. wdict[word] key 에 대한 값을 가지고 오거나 키에 대한 항목 값을 세팅할 때 사용 아래는 3 X 3 2차원 리스트 board 의 대각선 항목이 모두 X 기호로 채워져 있는지 검사하는 함수이다. 다음 물음에 따라 답하시오. 아래와 같은 방향에 위치한 항목이 X로 채워졌을 때 True가 반환 되도록 각각 들어갈 (가)와 (나)의 표현은? def is_diagonal(board): # board를 매개 변수로 추가 (일반적인 경우) win = True for i in range(3): if board # [(가)][(나)] != \"X\": win = False break if win == True: return win return False a. i, 3 - 1 - i 한 행 검사할 때마다 행의 값은 0에서 1씩 증가, 열의 값은 2에서 1씩 감소 행 0, 열 2 행 1, 열 1 행 2, 열 0 연습 문제 다음과 같은 형식으로 실수를 출력할 때, 숫자 앞에 삽입 된 공백(스페이스)의 개수는? (숫자의 입력) format(3.141592, \"&gt;20.3f\") a. 15 3.141592를 소수점 3자리까지 실수로 표시하면 → 3.142 ___________________3.142 언더바 15개 &gt; 오른쪽 정렬 20 전체 출력 폭(width)이 20칸 .3f 소수점 이하 3자리까지의 실수로 표시 private 데이터 필드에 값을 설정하는 메소드를 접근자(accessor)라고 함 a. X 접근자(Accessor) 데이터 필드의 값을 읽어오는 메소드 getter 설정자(Mutator) 데이터 필드의 값을 설정하는 메소드 setter 다음은 객체의 생성 과정을 도식화 한 것이다. 빈칸에 알맞은 것은? Cone(20, 30) # 생성자 호출 -&gt; 20, 50이 인자로 전달 됨 a. 초기자 호출 객체 생성 시 내부적으로 __init__(초기화 함수)가 호출 됨 class Cone: def __init__(self, a, b): # 인자로 받은 값을 객체의 속성에 할당(초기화) 함 self.a = a self.b = b cone = Cone(20, 30) " }, { "title": "[Java 프로그래밍] 15강 - 라이브러리와 모듈", "url": "/posts/knou-java-15/", "categories": "Language, Java", "tags": "knou, java", "date": "2025-05-23 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김희천 교수님의 'Java 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 라이브러리는 자주 사용 되는 공통의 Java 클래스를 묶어 .jar파일 형태로 압축한 것임 모듈 개념은 Java 9부터 도입 된 것으로 라이브러리의 발전 된 형태이며 패키지 별로 접근성을 제어할 수 있음 개발 환경에서 라이브러리 또는 모듈을 제공하는 방법과 이것을 사용하는 방법을 학습함학습 목표 라이브러리로 사용 될 클래스를 개발하여 배포할 수 있음 .jar형태의 라이브러리를 활용하는 프로그램을 작성할 수 있음 모듈 프로젝트를 만들고, module-info.java 파일에 모듈을 정의할 수 있음 모듈을 개발하여 제공하거나, 제공 된 모듈을 사용하여 프로그래밍 할 수 있음 Java 표준 모듈을 설명할 수 있음강의록라이브러리라이브러리 여러 프로그램에서 공통으로 사용될 수 있는 클래스와 인터페이스의 모음 여러 .class파일을 묶어 압축한 .jar파일의 형태 이때 유사한 클래스와 인터페이스는 묶어서 패키지로 구성됨 라이브러리 만들기 자바 프로젝트 생성 프로젝트 이름은 my_lib module-info.java 파일은 만들지 않음 pack_a패키지에 Member클래스 작성 pack_b패키지에 Student클래스 작성 my_lib프로젝트에 .jar파일을 저장할 dist 폴더 생성 .jar 파일 만들기 Export… → JAR file .class파일이 포함됨 파일은 my_lib/dist/my_lib.jar 라이브러리 사용 하기 자바 프로젝트 생성 프로젝트 이름은 UseMyLibExample module-info.java 파일은 만들지 않음 LibraryExample패키지에 Main 클래스와 main()메소드 작성 라이브러리 추가 하기 프로젝트의 팝업 메뉴에서 Build Path → Configure Build Path… → Java Build Path → Libraries 탭 → Classpath 선택 → Add External JARs… 버튼 클릭 이전에 만든 my_lib.jar 파일을 선택하고 Apply and Close Add External JARs…은 외부에서 받은 .jar를 포함 시킬 때 사용 Add JARs…은 작업 공간에 있는 .jar를 포함 시킬 때 사용 main()메소드에서 라이브러리의 public클래스 사용하기 import구문을 사용할 수 있음 모듈모듈 자바 라이브러리의 업그레이드 버전 Java 9부터 모듈 시스템을 도입 패키지가 클래스의 묶음이라면, 모듈은 패키지의 묶음 모듈은 특별한 기능을 담당하는 프로그램으로, 관련 패키지를 묶어 모듈 단위로 캡슐화 했으며, 다른 모듈을 사용할 수 있으며, 일부 패키지를 공개 패키지로 노출 패키지 단위의 접근 제한을 설정할 수 있음 기본적으로 모듈 내의 패키지는 외부(다른 모듈)에 공개 되지 않음 자바 프로젝트에서 module-info.java 파일에 모듈에 대한 정보를 기술모듈 정의 module-info.java 파일에 모듈의 이름과 모듈 간의 관계를 기술함 자바 모듈 프로젝트의 src 폴더에 위치함 배포 과정에서는 .jar 파일에서 루트 폴더에 위치함 module descriptor 파일이라고 함 모듈의 이름, 모듈이 requires하는 다른 모듈(의존성), 모듈이 exports하는 패키지(공개 API)를 명시 module my_mod_a { requires my_mod_b; } module my_mod_b { exports package_a; exports package_b; } 모듈을 제공하는 프로젝트 모듈을 제공하는 자바 프로젝트 생성 프로젝트 이름은 my_mod_a 프로젝트 생성 시 module-info.java 파일을 생성 나중에 만들려면 프로젝트 팝업 메뉴에서 configure 실행 pack_a패키지에 Member클래스 작성 pack_b패키지에 Student클래스 작성 프로젝트 이름은 my_mod_b 프로젝트 생성 시 module-info.java 파일을 생성 pack_c패키지에 Triangle클래스 작성 pack_d패키지에 Circle클래스 작성 모듈을 사용하는 프로젝트 모듈을 사용하는 자바 프로젝트 생성 프로젝트 이름은 MyProject 프로젝트 생성 시 module-info.java 파일을 생성 TestModule패키지에 Main 클래스와 main() 메소드 작성 프로젝트의 팝업 메뉴에서 Build Path → Configure Build Path… 선택 → Projects 탭 → Modulepath 선택 → Add… 버튼 클릭 모듈을 사용하려면 Classpath가 아닌 Modulepath에 추가해야 함 사용할 모듈 프로젝트로 my_mod_a와 my_mod_b를 선택하고 Apply 모듈을 만들고 정의하기 모듈 프로젝트에서 module-info.java 파일을 작성 기본적으로 모듈의 이름은 프로젝트 이름과 같음 my_mod_a모듈 module my_mod_a { \texports pack_a; \texports pack_b; } my_mod_b모듈 module my_mod_b { \texports pack_c; \texports pack_d; } MyProject모듈 module MyProject { \trequires my_mod_a; \trequires my_mod_b; } exports 패키지 프로젝트의 패키지를 다른 모듈에서 사용할 수 있게 외부에 제공함을 의미 기본적으로 public클래스도 모듈 외부에 공개되지 않기 때문에 공개하려면 exports 해야 함 requires 모듈 프로젝트에서 해당 모듈이 제공한 패키지를 사용(의존)하겠다는 의미 이러한 선언이 있어야 import 가능함 모듈 사용하기 main()메소드에서 외부 모듈이 제공한 패키지 사용하기 모듈 간의 의존 관계 requires와 exports requires키워드는 해당 모듈(A)이 다른 모듈(B)에 의존함을 선언 아래는 모듈 A가 모듈 B가 제공(exports)하는 패키지를 사용한다는 의미 module A { requires B; } 모듈 간 의존 관계 requires transitive 모듈이 다른 모듈에 의존함을 표현하며, 현 모듈을 사용하는 모든 모듈에 의존성을 전파함. 즉, 자동으로 의존 관계가 추가 됨 MyProject에서 pack_c와 pack_d를 사용할 수 있음 module A { requires transitive B; } 모듈 간 의존 관계의 전이 Java 표준 모듈Java 표준 모듈 Java 9부터 모듈 개념이 도입됨 자바 표준 라이브러리가 모듈화 됨 java.xxx모듈을 표준 모듈 또는 플랫폼 모듈이라 함 java.base 모듈 자바 플랫폼에서 가장 기본이 되는 모듈 어떤 모듈에도 not dependent, 다른 모듈은 java.base에 dependent java.base모듈을 사용하기 위해, requires 키워드로 사용 선언을 하지 않아도 됨 java.lang, java.math, java.net, java.io, java.nio, java.util등의 패키지를 포함 java.lang은 import 하지 않아도 됨 표준 모듈의 사용 module-info.java 파일 자바 프로젝트에서 이 파일을 사용하고, java.base모듈 내에 없는 패키지를 사용해야 한다면, requires키워드를 사용하여 명시적 선언을 해야 함 프로그래밍에서 java.sql패키지를 import하여 사용하는 경우 java.sql패키지는 java.sql모듈에서 exports 하고 있음 따라서 프로젝트에서 java.sql모듈을 requires 해야 함 학습 정리 자주 사용 되는 클래스와 인터페이스를 컴파일 된 형태로 제공한 것을 라이브러리라고 함 Java의 라이브러리는 .class파일을 묶어서 만든 .jar파일의 형태임 모듈은 라이브러리의 업그레이드 버전으로 패키지 단위에서 접근성을 설정할 수 있음 라이브러리를 사용하려면 해당 .jar파일을 Classpath에 추가하고, 모듈을 사용하려면 Modulepath에 추가함 모듈 프로젝트에서 module-info.java 파일에 export 패키지;또는 requires 모듈;형식으로 모듈 간 의존 관계를 설정할 수 있음 JDK의 표준 라이브러리는 모두 모듈화 되었으며, java.base는 자바 표준 모듈 중 가장 기본 모듈임연습 문제 .jar파일 형식으로 배포 된 라이브러리를 사용하고자 할 때, 이러한 .jar파일을 어떤 환경 변수에 추가해야 하는가? a. Classpath Java의 표준 모듈 중 requires키워드로 사용 선언을 하지 않아도 사용 가능한 모듈은 무엇인가? a. java.base java.sql모듈에서 제공하는 java.sql패키지가 있으며, 여기에 포함 된 클래스(또는 인터페이스)를 사용하는 모듈 프로젝트가 있을 때, module-info.java 파일에서 아래 밑줄 부분에 들어가야 할 내용은? module com.mymodule.app { \t\t\t\t// _____________ } a. requires java.sql; " }, { "title": "[데이터 정보 처리 입문] 14강 - 파이썬을 활용한 자료 분석", "url": "/posts/knou-dip-14/", "categories": "Data Science, Data Analysis", "tags": "knou, data information processing", "date": "2025-05-22 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김성수, 이기재 교수님의 '데이터 정보 처리 입문' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 파이썬은 객체 지향 프로그래밍 언어로 문법이 쉽고, 확장성이 좋아 데이터 과학 분야와 R과 더불어 널리 이용되고 있는 프로그램 언어임 파이썬을 설치하는 방법, 파이썬 프로그래밍에 대하여 공부함학습 목표 파이썬을 설치하는 방법을 이해할 수 있음 Spyder 및 Jupyter Notebook을 사용할 줄 암 파이썬 언어를 사용할 수 있음강의록파이썬 소개Python(파이썬) 소개 Platform independent Windows, Unix, MacOS, … Easy to install, learn &amp; use Easy syntax, …. Easily extensible with library packages 개발자 Guido van Rossum (1956.1.31~) 네덜란드 Python 설치Anaconda (아나콘다) www.anaconda.comPath 설정하기 Windows 시스템 → 제어판 → 시스템 및 보안 → 시스템 → 고급 시스템 설정 → 환경 변수 → 시스템 변수에서 Path 편집 → 새로 만들기 추가 경로 C:\\ProgramData\\anaconda3\\ C:\\ProgramData\\anaconda3\\Scripts C:\\ProgramData\\anaconda3\\Library\\bin pip: Python 패키지를 설치하고 관리하는 프로그램 패키지 설치하기 pip install mglearn pip install graphviz pip install pydot pip install pydotplus pip install tensorflow Spyder 실행print(\"Hello Python !\")3**2파이썬 프로그래밍x = 4y = 4 * x + 7print(y)2**10 # 102417 // 4 # 417 % 4 # 1import numpy as npx = np.arange(-10, 11)print(x)y = 4 * x + 7print(y)x[2]x[0:5]x1 = x[x&lt;0]print(x1)y = 4 * x1 + 7 print(y)Jupyter notebook 실행 window 앱 검색 Jupyter Notebook cmd 창에서 anaconda 설치 경로에서 jupyter notebook 명령어 입력 jupyter notebook New - Python 3 선택 Markdown 선택 → 설명문 입력 → 실행 Code 선택 후 코드 입력 → 실행 print(\"Hello, World!\") Run python using Google Colabfrom google.colab import filesupload = files.upload()import pandas as pdimport iodf = pd.read_csv(io.BytesIO(uploaded['filghts.csv']))df.describe()파이썬 프로그래밍산술 연산1 - 2 # 뺄셈4 * 5 # 곱셈7 / 5 # 나눗셈3 ** 2 # 거듭 제곱자료형type(10) # inttype(2.710) # floattype(\"hello\") # str변수x = 10print(x)y = 3.14x * ytype(x * y) # float리스트a = [1,2,3,4,5]print(a) # [1,2,3,4,5]len(a) # 5a[0] # 1a[4] # 5a[4] = 99print(a) # [1,2,3,4,99]a[0:2] # [1,2]a[1:] # [2,3,4,99]a[:3] # [1,2,3]a[:-1] # [1,2,3,4]a[:-2] # [1,2,3]Dictionary : key 와 value 를 한 쌍으로 저장me = {'height': 180, 'weight': 70}me['height'] # 180me['weight'] # 70me['age'] = 30 # 새 원소 추가print(me) # {'height': 180, 'weight': 70, 'age': 30} 참고 : desc0.py import pandas as pd import numpy as np #Create a Dictionary of series D = ({ 'Name' : pd.Series(['Tom','James','Ricky','Vin','Steve','Smith','Jack','Lee','David','Gasper','Betina','Andres']), 'Age' : pd.Series([25,26,25,23,30,29,23,34,40,30,51,46]), 'Rating' : pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])}) #Create a DataFrame Df = pd.DataFrame(D) print(Df) Df.head() runfile(\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/desc0.py\") boolhungry = Truesleepy = Falsetype(hungry) # boolnot hungry # Falsehungry and sleepy # Falsehungry or sleepy # Trueifhungry = Trueif hungry: print(\"I'm hungry\")# I'm hungryhungry = Falseif hungry: print(\"I'm hungry\")else: print(\"I'm not hungry\") print(\"I'm sleepy\")# I'm not hungry# I'm sleepyfor : 반복문for i in [1,2,3]: print(i)# 1# 2# 3name = ['a', 'b', 'c', 'd', 'e']for i in name: print(i)# a# b# c# d# efor : 반복문 - 계속sum = 0for i in range(10) : sum = sum + iprint(sum)# 45# Note that range(10) is not the value of 0 to 10, but the values 0 to 9함수def hello(): print(\"Hello World !\") print(\"Welcome to Python class !\")hello()# Hello World !# Welcome to Python class !def hello2(object): print(\"Hello \" + object + \" !\")hello2(\"Jang\")# Hello Jang !클래스class Man: def __init__(self, name): self.name = name print(\"Initialized !\") def hello(self): print(\"Hello \" + self.name + \" !\") def goodbye(self): print(\"Good-bye \" + self.name + \" !\")m = Man(\"David\")# Initialized !m.hello()# Hello David !m.goodbye()# Good-bye David !클래스 - 계속 1class Person: def __init__(self, name, age): self.name = name self.age = age def disp(self): print(self.name) print(self.age)p1 = Person('홍길동', 22)p2 = Person('철수', 35)p1.disp()# 홍길동# 22p2.disp()# 철수# 35클래스 - 계속 2class Person2: def __init__(self): self.name = input('Name:') self.age = int(input('Age:')) def disp(self): print('Name =',self.name) print('Age =',self.age)customer = []for i in range(5): customer.append(Person2()) # &gt;&gt;&gt; customer[0].disp() # Name:AAA # Age:12 # &gt;&gt;&gt; customer[1].disp() # Name:BBB # Age:25 # ...Numpy 가져오기import numpy as npx = np.array([1.0, 2.0, 3.0])print(x) # [1. 2. 3.]type(x) # numpy.ndarrayy = x/3print(y) # [0.33333333 0.66666667 1.]x = np.array([1.0, 2.0, 3.0])y = np.array([2.0, 4.0, 6.0])x + y # array([3., 6., 9.])x - y # array([-1., -2., 0.])x * y # array([ 2., 8., 36.])x / y # array([0.5, 0.5, 1. ])Numpy - N차원 배열import numpy as npA = np.array([[5,7], [9,11]])print(A)# [[ 5 7]# [ 9 11]]A[0] # array([5, 7])A[1] # array([ 9, 11])A[0,0] # 5 - A[0][0]A[1,0] # 9 - A[1][0]B = np.array([[3,0], [0,6]])A + B# array([[ 8, 7], [ 9, 17]])A * B# array([[15, 0], [ 0, 66]])Broadcast : 형상이 다른 배열 계산import numpy as npA = np.array([[1,2], [3,4]])B = np.array([10,20])C = 10A * B# array([[10, 40], [30, 80]])A * C# array([[10, 20], [30, 40]])원소 접근 : 원소의 인덱스는 0부터 시작X = np.array([[51,55], [14,19], [0,4]])print(X)# [[51 55]# [14 19]# [ 0 4]]X[0] # array([51, 55])X[0][1] # array([55])X[0,1] # 55Y = X.flatten()print(Y)# [51 55 14 19 0 4]for row in X: print(row)# [51 55]# [14 19]# [0 4]Y &gt; 15# array([True, True, False, True, False, False])Y[Y &gt; 15]# array([51, 55, 19])matplotlibimport matplotlib.pyplot as pltimport numpy as npx = np.arange(0, 6, 0.1)y = np.sin(x)plt.plot(x,y)plt.show()import matplotlib.pyplot as pltimport numpy as npx = np.arange(0, 6, 0.1)y1 = np.sin(x)y2 = np.cos(x)plt.plot(x, y1, label='sin')plt.plot(x, y2, linestyle='--', label='cos')plt.xlabel('x-axis')plt.ylabel('y-axis')plt.title('sin &amp; cos')plt.legend()plt.show()연습 문제 파이썬에서 딕셔너리로 선언하고자 한다. 적합한 것은? me = {‘height’ : 180, ‘weight’: 70 } 다음 파이썬 프로그래밍에서 a[4]의 결과는? a = [1,2,3,4,5] a[4] a. 5 파이썬을 설치하기 위한 아나콘다 사이트는? a. www.anaconda.com Python 패키지를 설치하고 관리하는 프로그램이다. Dos 창에서 (        ) 안에 맞는 명령은? C:\\anaconda3&gt;( ) install tensorflow a. pip 다음과 같이 파이썬 함수 문을 작성하였다. hello2(“Jeong”) 의 결과는? def hello2(object): print(\"Hello \" + object + \" !\") hello2(\"Jeong\") a. Hello Jeong ! " }, { "title": "[유비쿼터스 컴퓨팅 개론] 14강 - 빅 데이터", "url": "/posts/knou-uqc-14/", "categories": "Computer Science, CS Theory", "tags": "knou, ubiquitous computing", "date": "2025-05-21 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정광식 교수님의 '유비쿼터스 컴퓨팅 개론' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 빅 데이터는 세 가지 특징인 볼륨, 속도, 다양성을 가지고 있음 이를 활용하기 위해 빅 데이터 수집, 적재, 처리, 분석 과정을 거치게 되며, 각 단계 별로 여러 세부 기술이 필요함 현재 다방면에서 정형/비정형 데이터를 수집, 저장하고 분석함으로써 의미있는 결과를 도출할 수 있는 빅데이터 시스템이 널리 활용되고 있음 빅 데이터의 특징, 주요 세부 기술, 응용 분야에 대해 살펴 봄학습 목표 빅 데이터의 특징을 이해하고, 이를 활용할 수 있는 기술을 살펴 봄 빅 데이터의 주요한 응용 분야를 살펴보고, 향후 어떻게 발전해 나갈 것인지 생각 해 봄강의록빅 데이터빅 데이터의 정의 빅 데이터 (Big Data) 대용량의 정형 · 비정형 데이터 집합 빅데이터를 분석하여 의미 있는 결과를 도출하기 위해 사용됨 국가 정보화 전략 위원회의 정의 대용량 데이터를 활용, 분석하여 가치 있는 정보를 추출하고, 생성된 지식을 바탕으로 능동적으로 대응하거나 변화를 예측하기 위한 정보화 기술 1970년대 관계형 데이터베이스가 널리 활용되면서 많은 데이터를 저장하는 데이터 센터의 중요성이 부각되었음 대용량 데이터 분석의 필요성에 의해 데이터 마이닝 기술도 활용되었음 빅 데이터라는 용어는 1990년대부터 사용됨 2000년대 중반 페이스북이나 유튜브를 포함한 온라인 서비스가 널리 보급되면서 대용량 데이터가 발생하기 시작하였음 예를 들면, 뉴욕 증권 거래소를 하루에 1 테라 바이트 (TB=10¹²) 크기의 거래 데이터가 발생하며, 페이스북에는 30 페타 바이트 (PB=10¹⁵) 크기의 사진 데이터가 저장되어 있음 최근에는 전 세계에서 하루 생성되는 데이터의 크기가 약 2.5 엑사 바이트 (EB=10¹⁸)로 추정 됨 대용량의 데이터를 수집, 저장 및 처리하기 위해서는 이전과는 다른 기술이 필요함 2000년대 중후반 아파치 하둡이나 스파크가 개발되어 빅 데이터를 분산 처리할 수 있게 되었음 클라우드 시스템도 대중화되어 널리 활용되고 있음 NoSQL처럼 빅 데이터를 표현하고 처리할 수 있는 기반 기술도 함께 발전하고 있음빅 데이터의 특징 일반적으로 데이터는 구조나 색인 여부에 따라 구분 됨 정형 데이터 반 정형 데이터 비 정형 데이터 정형 데이터 정형(Structured) 데이터란 저장 될 데이터에 대하여 미리 정해진 규칙을 정의한 후, 그에 따라 저장된 데이터임 마이크로소프트의 엑셀이나 관계형 데이터베이스의 테이블이 그 예에 해당함 각 데이터는 행과 열로 표현됨 열은 각각의 속성을 정의하고, 각 행은 해당 속성의 구체적인 값을 의미함 대개 정형 데이터의 개수가 많다고 해서 빅 데이터라고 하지 않음 비정형 데이터 정형 데이터가 아닌 데이터는 비 정형(Unstructured) 데이터이며, 텍스트, 이미지, 오디오, 비디오와 같은 형태임 비 정형 데이터에도 일부 정형 데이터가 포함될 수 있음 예를 들면, 사진 이미지에는 촬영 날짜나 시간 등의 정형 데이터가 포함될 수 있지만, 기본적으로 이미지 자체는 비 정형 데이터임 비 정형 데이터는 대개 NoSQL(Not Only SQL) 데이터베이스를 활용하여 처리함 반 정형 데이터 반 정형 데이터는 약한 정형 데이터를 의미함 HTML, XML, JSON과 같은 포맷을 가짐 일반적인 데이터베이스는 아니지만 일부 스키마를 가지고 있음을 의미함 예를 들어, 전자 메일의 경우, 발신자, 수신인, 제목, 내용, 날짜와 같은 구조화된 정형 데이터도 가지고 있고, 본문에 해당하는 텍스트나 첨부 파일은 비 정형 데이터에 해당함 반 정형 데이터는 정형과 비 정형 데이터의 특징을 모두 가지고 있음 빅 데이터는 정형 데이터뿐만 아니라 비 정형, 반 정형 데이터를 모두 다루고 있음 데이터 양이 크다고 빅 데이터라고 하지 않음 빅 데이터는 볼륨(Volume), 속도(Velocity), 다양성(Variety)의 공통된 특징(3V)을 가지고 있음 볼륨(Volume) 빅 데이터라는 이름에서 알 수 있듯이, 빅 데이터에서 다루는 데이터의 양은 매우 큼 데이터를 효율적으로 관리하고 분석하기 위한 알고리즘이 필요함 속도(Velocity) 관계형 데이터베이스에서는 데이터를 수작업으로 입력한 후 이를 처리함 빅 데이터 기술을 활용하면 실시간으로 데이터를 수집하고, 빠르게 처리할 수 있음 다양성(Variety) 빅 데이터는 정형, 비 정형, 반 정형 데이터를 모두 고려하고 있음 빅 데이터 구조가 복잡하고 다루는 범위가 넓어 기존 데이터베이스 시스템을 이용해서 처리하기에는 곤란함 최근에는 3V에 더해 새로운 특징 2V(정확성, 가치)를 추가하여 함께 고려하기도 함 정확성(Veracity) 데이터 크기가 커짐에 따라 일정한 패턴을 찾기 곤란해질 수 있음 빅 데이터를 분석하기에 앞서 수집한 데이터가 정확하고 가치가 있는 것인지 판단해야 함 예를 들어, SNS로부터 수집한 데이터로부터 잘못되었거나 출처가 부정확한 데이터, 비윤리적 데이터 등은 배제해야 함 가치(Value) 빅 데이터를 분석함으로써 기업이나 조직의 현실 문제 해결에 도움이 될 수 있는 가치를 얻을 수 있어야 함 빅데이터 수집 소스는 가장 대표적인 곳이 페이스북, 인스타그램, 유튜브와 같은 SNS임 SNS에는 게시글, 댓글과 같은 텍스트 뿐만 아니라, 음악, 이미지, 동영상과 같은 다양한 원천 데이터가 있음 최근에는 여러 산업에서 데이터의 중요성이 부각되고 있으며, 그 중 하나가 거래 데이터임 여러 유통, 물류, 금융 관련 업체에서 생성되는 거래 데이터는 정형 데이터 뿐만 아니라 비 정형/반 정형 데이터를 포함하고 있음 CCTV, IoT, 제조업과 같이 새로운 산업이나 제품에 의해 빅 데이터가 생성되기도 함 IoT 산업의 경우, 전 세계 다양한 분야에서 활용되는 센서들이 수집한 데이터를 인터넷을 거쳐 서버에 저장함 IDC(Internet Data Center)에 따르면 2025년까지 전 세계 약 250억 개 이상의 IoT 장치가 디지털 데이터를 생성할 것으로 예상됨빅 데이터 관련 기술빅 데이터 분석 수집된 빅 데이터의 분석 사례 국내 대표적인 플랫폼 기업인 카카오는 여러 종류의 온라인 서비스(카카오톡, 카카오페이, 카카오TV 등)를 제공하면서 사용자 별로 다양한 데이터를 수집함 수집 된 데이터를 분석함으로써, 사용자의 선호도를 파악할 수 있고, 그에 따라 사용자 맞춤형 광고를 제작하거나 서비스를 개인화하여 사용자 경험을 개선함 빅 데이터를 올바르게 활용한다면, 사업 내의 개선 사항을 발굴하거나 인사이트를 제공할 수 있음 조직이 빅 데이터를 활용하기 위한 4단계 과정 빅 데이터 수집 빅 데이터 저장 빅 데이터 처리 빅 데이터 분석 빅 데이터 분석 - 빅 데이터 수집 빅 데이터는 대용량의 정형, 비 정형 데이터 집합이며, 여러 데이터 소스로부터 수집 되어야 함 외부로부터 수집 된 데이터를 처리하기 위해 대용량 파일 수집과 실시간 스트림 수집 방식을 이용함 빅 데이터의 특징인 볼륨, 다양성, 속도를 만족 시키기 위해 분산 처리가 가능한 방식을 제공해야 함빅 데이터 분석 - 빅 데이터 적재 빅 데이터 적재 수집한 빅 데이터를 분산 저장 장치에 영구 또는 임시로 저장하는 기술 수집 된 빅 데이터는 이전 정형 데이터를 주로 다루는 관계형 데이터베이스와 다른 방식으로 저장되어야 함 빅 데이터 분산 저장소는 HDFS(Hadoop Distributed File System)이나 NoSQL을 활용함 HDFS는 대용량 파일 적재에 주로 활용하지만, 실시간 발생되는 대용량 데이터 적재를 위해서는 NoSQL을 사용함빅 데이터 분석 - 빅 데이터 처리 대용량 저장소에 저장된 빅 데이터를 분석할 수 있도록 데이터를 정형화 및 정규화 해야 함 빅 데이터를 분석하여 의미 있는 결론을 도출하기 위해서는 수집 된 데이터를 올바르게 이해해야 함 적재 된 빅 데이터를 지속적으로 탐색하고 탐색 된 결과를 정기적으로 구조화해야 함 빅 데이터 분석 - 빅 데이터 분석 수집 된 빅 데이터로부터 새로운 경향이나 패턴을 찾고, 올바르게 해석하여 통찰력을 확보해야 함 과거의 흔적(데이터)으로부터 주어진 문제에 대한 원인을 찾고, 이에 대한 개선 방향을 제시하려는 목적을 가짐 빅 데이터 분석을 위해 이전 통계학이나 데이터 마이닝(Data Mining) 기법 뿐만 아니라 최근의 인공지능 기술을 활용할 수 있음대용량 데이터 저장 기술 - 개요 빅 데이터는 처리해야 할 데이터 용량이 매우 크므로 일반적인 데이터 적재 기법을 활용한다면 원하는 성능을 얻을 수 없음 수집한 데이터의 특징에 따라 처리 방식과 저장 방식의 차이가 남 데이터는 발생 주기에 따라 배치 처리 가능한 데이터와 실시간 데이터 스트림으로 구분할 수 있음 배치 처리 가능한 데이터의 경우, 대용량 파일 전체를 영구 저장 장치에 저장한 후 분산 처리함 실시간 로그 분석과 같이 각 데이터의 크기는 작지만 대량으로 발생하는 메시지 성 데이터는 실시간으로 분석할 수 있어야 함대용량 데이터 저장 기술 - 하둡 하둡(Hadoop) 여러 서버를 연결하여 대용량 빅 데이터를 분산 처리할 수 있도록 지원하는 자바 기반의 오픈 소스 프레임워크 하둡은 하둡 분산 파일 시스템(HDFS)과 프로그래밍 컴포넌트인 맵리듀스(MapReduce)를 제공함 하둡 분산 파일 시스템 수집 된 대용량 데이터 블록을 여러 개의 작고 균일한 블록으로 나누어 여러 서버에 분산 저장함 여러 서버에 분산 및 중복 저장을 할 수 있어서 일부 서버에 오류가 발생해도 다른 서버에서 복구할 수 있으며, 높은 데이터 안정성을 얻을 수 있음 마스터/슬레이브 구조의 HDFS NameNode가 마스터 노드 역할을 하고, 여러 DataNode가 슬레이브 역할을 수행함 마스터 노드는 각 데이터 노드에 저장된 파티션들과 관련된 정보를 관리함 여러 데이터 노드는 사용자들의 요청에 따라 자신이 저장하고 관리하는 파티션에 대해 실제 읽기 및 쓰기 작업을 담당함 대상이 된 빅 데이터가 지속적으로 대규모로 수집 되는 경우, 수집 된 데이터를 더 작은 집합 또는 파티션으로 세분화함 저장 된 데이터를 분산 처리하기 위해서는 MapReduce 개념을 사용하며, 혼자서 할 일을 여러 명이 나누어서 동시에 수행한 후 최종적으로 합치는 작업 개념임 각 데이터 노드는 자신이 가진 데이터에 적절한 작업을 수행한 후(Map), 최종적으로 이를 하나로 합치는 작업(Reduce)을 수행함 단순하면서도 사용이 편리하고, 특정한 데이터 모델이나 스키마에 의존하지 않아 유연하며, 높은 확장성을 가지고 있음 맵리듀스 개념 대용량 데이터 저장 기술 - 스파크 아파치 스파크(Spark)는 오픈 소스 기반의 범용적인 목적으로 활용 가능한 분산 클러스터 컴퓨팅 프레임워크이며, MapReduce 형태의 클러스터 컴퓨팅 패러다임의 한계를 극복하기 위해 등장함 스파크가 자체 네이티브 파일 시스템을 가지고 있지 않으므로 데이터를 처리하기 전에 RAM에 복사하고, 작업을 완료한 후 RAM에 다시 쓰는 방식으로 동작하기 때문에 실시간 데이터 처리에 유용함대용량 데이터 저장 기술 - 하둡과 스파크 하둡은 분산 저장 공간에 저장 된 데이터를 읽어 들여 Map을 통해 흩어져 있는 데이터를 연관성 있는 데이터끼리 묶은 후에, Reduce 과정에서 중복된 데이터를 제거하고 원하는 데이터로 가공하여 디스크에 저장함 스파크는 인 메모리 엔진을 통해 초기 MapReduce 방식의 처리 성능을 크게 향상 시켰으며, 빅 데이터 처리 플랫폼으로서 실시간으로 수집 되는 데이터 처리를 실시간으로 빠르게 처리할 수 있음 하둡은 주로 디스크 사용량이 많고 MapReduce 패러다임을 사용하는 작업에 사용됨 스파크는 유연하지만 대체로 더 많은 비용이 드는 인 메모리 처리 구조가 필요한 작업에 사용됨빅 데이터 응용 분야 및 해결 과제응용 분야 비용 절감, 새로운 수익 원 창출, 문제 해결을 위해 빅 데이터를 활용함 구체적인 활용 분야 새로운 제품 및 서비스 개발 유지 보수 비용 절감 고객 경험 리스크 관리 인공지능 데이터 처리 새로운 제품 및 서비스 개발 기존 고객들의 구매 후기, SNS 데이터, 최근 관련 동향 등과 같은 빅 데이터를 분석하면, 새로운 트렌드를 이해할 수 있고 이는 신제품 개발에 적극 활용될 수 있음 유지 보수 최근 IoT 기반 응용이 널리 활용되면서, 공장 설비에 부착된 센서가 수집한 빅 데이터를 분석하면 유지 보수 비용을 크게 줄일 수 있음 비용 절감 기업 활동 전반에 빅 데이터 분석을 수행하면 조직이나 세부 업무에서 비효율적인 부분을 발견할 수 있고, 신속하고 효과적인 업무 프로세스를 제안할 수 있음 고객을 만족 시킬 수 있는 제품 및 서비스 개발을 통해 경쟁력을 강화할 수 있음 고객 경험 자사 제품의 구매 고객을 밀착 관찰하고, 그로부터 획득한 고객의 정서 및 반응 등을 분석할 수 있다면 고객 맞춤형 경험을 제공할 수 있음 리스크 관리 코로나19와 같은 이전에 경험하지 못한 위기 상황에 대비하기 위해 기업들은 닥칠 수 있는 리스크를 미리 파악하고 이에 대비할 필요성이 생겼음 인공 지능 데이터 처리 최근 인공 지능 활용 가능 분야가 확대되면서 빅 데이터 시스템은 인공지능 시스템이 필요로 하는 대용량 학습 데이터 저장/전 처리/탐색/가공을 수행하는 역할도 담당함 응용 분야 - 제조업 일반적인 제조 공장은 기획 및 설계, 생산, 유통 및 판매 단계를 거치면서 이율을 취함 각 단계 별로 자동화된 여러 도구를 설치하여 활용하고 있음 별개로 동작하는 각 단계에서 생성되는 데이터는 미리 정해진 규칙 없이 생성되어 개별적으로 관리되고 있음 이렇게 수집한 여러 데이터를 통합하여 저장한 후, 빅데이터 분석을 수행함으로써 제조 프로세스의 비효율성을 제거할 수 있음 불량품을 줄이고 생산성을 향상 시킬 수 있을 뿐만 아니라 시장의 수요 변화에 능동적으로 대응하여 재고 관리를 효율적으로 진행할 수 있음 제조 공장에서 구체적으로 빅 데이터를 활용할 수 있는 경우 생산 설비 고장 시간 최소화 생산 설비로부터 센서가 수집한 데이터를 효과적으로 시각화하여 공장 생산 라인 별 설비의 운전 상황, 문제가 발생한 설비의 원인 파악, 해결 방법 제시, 설비 문제의 조기 발견을 가능하게 함 실적 관리 각 라인 별로 설정한 목표치와 생산 실적의 차이를 분석하여 그 원인을 파악하고, 적절한 대응 방안을 제시 함 생산 제품 추적 제품 생산 과정에서 적절한 장비 (ex) 바코드 스캐너나 무선 센서 장비)로부터 생성되는 데이터를 분석하면, 원자재부터 각 생산 라인 별 재료 소비량, 불량 률, 재고 관리, 출하, 배송의 전 과정에 대한 추적이 가능함 빅 데이터와 전통적인 데이터베이스의 차이 우리가 알고 있는 일반적인 데이터베이스는 대상 데이터를 일정한 규격(스키마)에 맞춰 저장한 후, 트랜잭션 시스템(DBMS)을 통해 정확한 처리를 목적으로 함 여러 사람들을 위해 통합된 데이터를 저장하고 운영하는 공용 데이터 창고 역할과 항상 최근의 정확한 데이터를 동적으로 유지하는 역할을 수행함 빅 데이터는 과거에 발생한 대규모 데이터를 수집 · 저장한 후, 이를 분석하여 주어진 목적에 부합하는 인사이트를 찾거나 원인 분석, 미래 예측을 수행하려는 것이 목적임 다양한 종류의 데이터를 대상으로 하고, 대규모 데이터를 효율적으로 처리하는 것이 중요하며, 분석 과정에서 일부 데이터가 누락되거나 중복되더라도 크게 문제가 되지 않음 빅 데이터가 해결해야 할 문제점 현재 빅 데이터 분석 시스템에는 다양한 기술이 개발되어 적용되고 있지만, 생성되는 데이터 양은 더 커지고 있으므로, 이에 대응할 수 있는 효과적인 기술이 필요함 현재 전 세계에서 생성되는 데이터의 크기는 엑사 바이트 (10¹⁸) 수준으로 증가 되고 있음 최근 초 거대 데이터 모델(LLM)처럼 대용량 데이터를 기반으로 하는 응용도 많아지고 있음 대용량 데이터를 저장하고 효율적으로 처리할 수 있는 기반 기술 개발도 함께 진행되어야 함 빅 데이터도 다양한 경로로 수집한 데이터를 활용하는 시스템이므로 이전 정보 처리 시스템과 같이 보안 기술이 중요함 시스템 내에 저장된 데이터 보안은 조직이 관리하는 데이터 및 정보 보호를 위한 정책과 세부 기술을 의미함 최근 중요성이 커지고 있는 개인 정보 보호는 각 개인을 식별할 수 있는 고유한 정보(이름, 주민등록번호, 유 · 무선 전화번호, 인터넷 계정 정보, 주소, 직업, SNS 관련 정보, 의료 정보, 위치 정보) 등을 수집해서는 안 된다는 원칙이 있음 빅 데이터 분석의 주요 목적 중 하나가 개인 맞춤 서비스 제공이며, 이를 위해서는 개인정보를 활용하는 것이 필수적임 수집 된 데이터 중에서 개인 식별 정보는 비 식별화(de-identification)한 후 저장하도록 함 비 식별화 된 개인 정보는 빅 데이터 분석에 사용되더라도 각 개인을 식별할 수 없으므로 사생활 정보를 보호할 수 있음 개인 정보 비 식별화 개인 정보를 비 식별화 했더라도 여러 정보 소스로부터 획득한 정보를 조합하면 특정 인을 유추할 수 있음 ex) 주민등록번호를 이용하여 생년월일/남녀 정보 식별 재 식별화(re-identification)라고 함 CCTV 영상으로부터 특정 인의 이동 경로와 같이 동의하지 않은 개인 정보 수집 문제도 발생할 수 있음 정리 하기 대용량의 정형/비 정형 데이터 집합을 빅 데이터라고 하며, 이를 수집 · 저장· 분석하여 의미 있는 결과를 도출하기 위해 사용함 빅 데이터는 대개 3V(볼륨, 속도, 다양성) 혹은 5V(3V + 정확성, 가치)의 특징을 지님연습 문제 저장될 데이터에 대하여 미리 정해진 규칙(혹은 스키마)을 정의한 후, 그에 따라 저장된 데이터는 무엇인가? a. 정형 데이터 위 지문은 무엇에 대한 설명인가? 빅데이터 적재 기술은 수집한 데이터를 분산 저장장치에 영구 또는 임시로 저장하는 기술이다. 수집된 빅데이터는 이전 정형 데이터를 주로 다루는 관계형 데이터베이스와는 다른 방식으로 저장되어야 한다. 이를 위해 빅데이터 분산 저장소는 대개 HDFS(Hadoop Distributed File System)이나 NoSQL을 활용한다. HDFS는 대용량 파일 적재에 주로 활용하지만, 실시간 발생하는 대용량 데이터 적재를 위해서는 NoSQL을 사용한다. a. 빅 데이터 적재 여러 서버를 연결하여 대용량 빅 데이터를 분산 처리할 수 있도록 지원하는 자바(Java) 기반의 오픈소스 프레임워크는 무엇인가? a. 하둡(Hadoop) 정리 하기 대용량의 정형/비정형 데이터 집합을 빅 데이터라고 하며, 이를 **수집 · 저장 · 분석하여 의미 있는 결과를 도출하기 위해 사용함 빅 데이터는 대개 3V(볼륨, 속도, 다양성) 혹은 5V(3V + 정확성, 가치)의 특징을 지님 빅 데이터를 활용하기 위해 빅 데이터 수집 → 빅 데이터 적재 → 빅 데이터 처리 → 빅 데이터 분석 과정을 수행하며, 각 단계 별로 여러 세부 기술이 필요함 향후 빅 데이터는 여러 산업에서 비용 절감, 문제 해결, 트렌드 분석 등의 목적으로 활용될 것으로 예상되며, 그에 따라 해결해야 할 기술적인 요소도 많아지고 있음" }, { "title": "[운영 체제] 14강 - 운영 체제 보안", "url": "/posts/knou-os-14/", "categories": "OS, Operating System", "tags": "knou, os", "date": "2025-05-20 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김진욱 교수님의 '운영 체제' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 현대 사회에서 컴퓨터는 거의 모든 분야에서 활용 되어 이전에 생각하기 어려운 수준으로 인간의 생활을 편리하게 만들어 주고 있음 반면, 컴퓨터의 이용이 보급 됨에 따라 불법적인 방법을 통해 컴퓨터 시스템에 침투하여 이익을 보려는 해킹이 기술적인 문제 뿐만 아니라 사회적인 문제가 되고 있음 이에 대응하는 보안이 학문적으로나 경제적으로나 중요성이 커지고 있음 운영 체제 관점에서 보호와 보안에 대한 개념을 알아보고, 운영 체제에서 보안에 대해 할 수 있는 일에 대해 살펴봄학습 목표 보호와 보안의 개념을 설명할 수 있음 운영 체제에서 보안이 달성하고자 하는 목표를 설명할 수 있음 운영 체제에 대한 침해 유형을 설명할 수 있음 운영 체제 수준에서의 보안 기법과 보안 모델을 설명할 수 있음 안전한 운영 체제에 대해 설명할 수 있음강의록보안의 개요보호와 보안 컴퓨터 시스템에서의 보호 컴퓨터 시스템 내부 자원 각각의 영역을 보장해 주는 것 각 프로세스가 사용하는 자원이 다른 프로세스에 영향을 받지 않도록 하는 것 컴퓨터 시스템에서의 보안 인증, 암호화 등을 통해 합법적인 처리만 이루어지도록 보장 시스템이 정상적으로 동작함으로써 저장된 자료가 결함이 없도록 하며 시스템을 신뢰할 수 있게 하는 것 보호와 보안의 목적 악의적인 사용자가 시스템 자원 접근 제한을 의도적으로 위반하는 것 방지 잠재적 오류를 미리 검출하여 시스템의 신뢰도를 높임 시스템 자원을 권한이 없는 사용자가 잘못 사용하는 것을 막음 권한이 있는 사용자와 권한이 없는 사용자 구별 시스템 프로세스와 사용자 프로세스가 권한을 가진 자원만 접근하도록 접근 제어 규정보호 영역 한 프로세스가 접근할 수 있는 자원 각 영역은 자원의 집합과 그 자원에 대해 프로세스가 할 수 있는 연산을 정의 하나의 영역은 접근 권한의 집합 접근 권한 프로세스가 객체(자원)에 대한 연산을 수행할 수 있는 능력 &lt;객체 이름, 권한 집합&gt; 영역 사이에서 공유 운영 체제 보안 운영 체제가 관리하는 자원이 공격에 의해 불법적으로 이용되는 것을 막는 정책과 기법 직접 또는 네트워크를 통해 접속하는 다수의 사용자가 모든 자원을 안정적으로 이용할 수 있도록 함 저장된 정보가 소실되거나 유출되지 않도록 함 적절한 접근 제어 설정, 정보의 암호화, 시스템 접속 및 자원 사용에 대한 기록 등 활용운영체제 보안의 기본 목표 기밀성 주체가 자원을 합법적으로 사용할 수 없다면 사용되어서는 안 됨 무결성 객체에 저장된 정보는 항상 정확함 가용성 주체가 자원을 사용하는 데 문제가 없다면 반드시 사용할 수 있어야 함 정보 침해 운영 체제 보안의 기본 목표가 달성 되지 못하고 정보가 불법적으로 읽히거나 다른 값이 덮어 쓰이는 것 정보 침해가 발생하는 경우 소프트웨어 오류나 오작동을 통해 보호 영역이 지켜지지 못하는 경우 공격자가 의도적으로 다른 사용자의 권한을 도용하는 경우 정보 침해 형태 가로 채기 공격자가 허락 받지 않은 컴퓨터 자원 접근 (기밀성 공격) 흐름 차단 시스템의 일부를 파괴하거나 사용할 수 없게 함 (가용성 공격) 변조 공격자가 기존에 있던 데이터의 내용을 바꿈 (무결성 공격) 위조 공격자가 기존에 없던 불법적인 정보 삽입 (무결성 공격) 정보 침해 유형 트로이 목마 숨겨진 기능이 있는 프로그램을 사용자가 실행하게 만들어 사용자의 권한을 이용하여 시스템에 침투 트랩 도어 정상적인 인증 절차나 암호화를 피해 갈 수 있는 비밀 통로 백도어 비밀 채널 데이터를 주고받을 수 없는 프로세스 사이에 정상적이지 않은 방법으로 정보를 주고받음 웜 자기 자신을 복사하여 다른 컴퓨터에 전파 바이러스 다른 프로그램을 감염 시켜 전파 보안 정책 및 보안 메커니즘보안 정책과 보안 메커니즘 보안 정책 보안을 어떠한 관점에서 무엇을 행할 것인지 결정하는 것 권한 부여, 접근 제어, 최소 권한, 감사 등 보안 메커니즘 보안을 어떠한 방법으로 할 것인지 결정하는 것 암호, 인증, 보안 등급 관리 등 보안 정책 권한 부여(authorization) 어떤 주체가 어떤 객체를 어떻게 액세스할 수 있는지 결정하는 것 모든 주체와 객체는 식별 및 인증이 가능해야 함 식별(identification) 신분을 알아내는 것 인증(authentication) 정말 그 주체와 객체가 맞는지 확인하는 것 주체의 객체에 대한 접근 제어 및 보안 등급 부여를 가능하게 함 임의적 접근 제어 (DAC, Discretionary Access Control) 관리자 또는 자원 소유자가 보안 관리자의 개입 없이 주체에 자원의 접근 권한을 부여할 수 있음 자원의 보호보다 자원의 공유가 중요할 때 적합 장점 유연하게 자원을 공유할 수 있음 단점 관리가 쉽지 않음 누가 권한을 가지고 있는지 판단 어려움 강제적 접근 제어 (MAC, Mandatory Access Control) 주체에는 허가 등급, 객체에는 비밀 등급이 주어짐 접근 요청이 올 때마다 허가 등급과 비밀 등급을 비교하여 허가 여부를 결정 보안 관리자가 시스템 전체에 대한 보안 정책을 구현하고 강제 각 사용자는 이 정책을 넘어서는 행동을 할 수 없음 장점 관리가 확실함 단점 자원의 공유가 어려움 역할 기반 접근 제어 (RBAC, Role-Based Access Control): 역할 개념을 사용하여 권한을 관리 주체는 역할이 주어졌을 때, 그리고 그 역할에 권한이 주어졌을 때만 권한 사용 가능 최소 권한 사용자는 임무를 수행하기 위해 필요한 최소한의 권한을 받아야 함 임무가 끝나면 이 권한을 반환해야 함 감사(auditing) 발생한 이벤트는 해당 내용 정보가 기록되어야 하고 변조 되지 않고 보존되어야 함 감사 과정을 통해 로그 파일을 조사하여 발생한 이벤트를 추적하고 침해 사고 등이 발생했는지 여부를 확인하고 감시해야 함 보안 메커니즘 주체 및 객체의 레이블 부여 메커니즘 유일한 식별자를 부여하여 서로 구별이 가능하게 함 보안 등급을 부여하여 허락되지 않은 접근을 막음 강제적 접근 제어를 구현하는 데 필요 안전한 암호 메커니즘 비밀 키 암호 알고리즘과 공개 키 암호 알고리즘 서로 다른 특징으로 사용되는 분야가 다름 안전한 인증 메커니즘 패스워드 가장 간단한 방법 수정이나 탈취를 막기 위해 암호화하여 저장 다요소 인증 사용자 인증에 둘 이상의 방법 요구 임의적 접근 제어를 위한 메커니즘 UNIX 파일 소유자가 각 파일마다 자신, 자신이 속한 그룹, 나머지에 대해 읽기, 쓰기, 실행 권한을 부여 가능 접근 제어 리스트(ACL) 이용 보안 등급 관리 메커니즘 사용자에게 다양한 종류의 보안 등급 부여 체계적이고 안전한 방법으로 관리되어야 함 기록 파일 관리 메커니즘 로그를 수정하지 못하게 접근 제어와 암호화를 통해 안전하게 보관 운영자 권한의 분산 메커니즘 시스템 관리자의 권한을 세분화하여 목적에 따라 해당 역할을 담당하는 운영자에게 부여 하드웨어 보호를 위한 방법 사용자 프로세스가 불법적인 명령을 수행하거나 허락되지 않은 메모리에 접근하는 등 오류가 발생 프로세서 상태 변경 트랩 또는 인터럽트를 이용 이중 모드 연산 모드 비트를 이용하여 사용자 모드와 커널 모드 구분 사용자 모드 자신에게 허용된 권한만 행사 가능 대부분의 경우 프로세스는 사용자 모드에서 수행 커널 모드 특권 명령 수행 가능 특권 명령 시스템의 상태를 바꾸어 보안에 위험을 줄 수 있는 명령 사용자 모드에서 특권 명령이 호출되면 트랩 발생 메모리 보호 각 프로세스가 가지는 주소 공간은 서로 분리 2개의 레지스터 이용 기준 레지스터 프로세스가 접근할 수 있는 물리적 주소의 최솟 값 한계 레지스터 프로세스가 접근할 수 있는 주소 범위의 길이 운영 체제가 사용하는 메모리 영역을 사용자 프로세스가 접근하려는 경우 트랩 발생 CPU 보호 무한 루프에 빠진 프로세스가 CPU를 독점하는 것을 막음 타이머 주기적으로 인터럽트를 발생 시키는 장치 프로세스가 자신에게 할당된 시간을 다 쓰면 대기하고 있는 다른 프로세스로 제어를 옮김 입출력 보호 한 프로세스의 입출력에 다른 프로세스가 영향을 미치면 안됨 입출력은 커널 모드에서 동작 암호화 비밀 키 암호 시스템 비밀 키를 아는 사람만 암호화와 복호화 가능 공개 키 암호 시스템에 비해 속도가 빠름 키 공유 문제 공개 키 암호 시스템 암호화 키(공개 키)와 복호화 키(개인 키)가 다름 전자 서명에 응용 비밀 키 공유에 활용 운영체제 보안 모델참조 모니터 주체가 객체를 접근하는 과정에 대해 접근 제어 수행 주체와 객체 사이에서 단순 접근의 허용 여부만 결정 접근 허용 여부를 결정하고, 이를 강제함 접근한 객체에 포함 된 기밀 정보를 유포하는 것은 막지 못함정보 흐름 모델 정보의 유형에 따라 정보가 흐르는 방향을 제어하는 모델 모든 허가 된 정보 흐름은 허용하고 모든 허가 받지 않은 정보 흐름은 방지 벨-라파듈라 모델 (BLP; Bell-LaPadula) 상위 보안 수준에서 하위 보안 수준으로 정보가 흐르는 것을 방지하는 것이 주된 목적 기밀성 유지에 초점 무결성이 깨질 수 있음 비바 모델 (Biba) 하위 보안 수준에서 상위 보안 수준으로 정보가 흐르는 것을 방지하는 것이 주된 목적 무결성을 보장하기 위한 모델 권한이 없는 주체가 데이터를 수정하는 것을 막음 권한이 없는 주체가 수정한 데이터를 사용하지 못하게 막음 보안 커널보안 커널 기존의 운영 체제 커널에 보안 기능을 통합 시킨 것 자주 수행되고 중요한 일을 커널에 둠 보안 커널을 사용한 운영 체제는 보안 기능 요소를 갖추어야 함 사용자에 대한 식별 및 인증, 접근 제어, 객체 보호, 침입 탐지 등 시스템 호출을 통해 보안 경계를 통과 TCB의 하드웨어, 펌웨어, 소프트웨어 요소 TCB(Trusted Computing Base) 컴퓨터 시스템의 보안을 구성하는 핵심 요소들의 집합 정상적으로 동작하지 않을 경우 시스템 보안에 문제가 생길 수 있는 하드웨어, 펌웨어, 소프트웨어, 물리적 설치 장소, 보안 정책 등의 집합 참조 모니터를 구현한 형태 운영 체제의 기본적인 작업에 대한 보안성 및 무결성을 감시 정리 하기 운영 체제 보안에서 달성하려는 기본 목표는 기밀성, 가용성, 무결성임 정보 침해 위협 요소로는 가로 채기, 흐름 차단, 변조, 위조 등이 있음 임의적 접근 제어에서는 각 사용자가 자신이 보유하고 있는 자원에 대한 접근 권한을 자신의 자율적 판단에 따라 부여하고 자신이 가진 접근 권한을 다른 사용자에게 전달할 수 있음 강제적 접근 제어는 각 객체의 비밀 등급, 개별 사용자의 허가 등급에 따른 중앙의 규칙에 따라 제어가 이루어짐 역할 기반 접근 제어에서는 사용자의 역할의 멤버가 됨으로써 권한을 배정 받음 비밀 키 암호 시스템은 암호 시스템의 보안이 암호화와 복호화에 사용되는 키를 아는 사람만 정보를 공유할 수 있다는 사실을 이용함 공개 키 암호 시스템에서는 암호화와 복호화에 사용하는 키가 다르며, 암호화에 사용되는 키는 공개 되고 복호화에 사용되는 키는 공개 되지 않음 참조 모니터는 주체와 객체의 접근 권한을 정의한 데이터 베이스를 참조하여 보안 정책을 수행함 벨 - 라파듈라 모델에서는 기밀성에 중점을 두어, 상위 보안 수준의 정보가 하위 보안 수준으로 흐르는 것을 막음 비바 모델에서는 무결성에 중점을 두어, 하위 보안 수준의 정보가 상위 보안 수준으로 흐르는 것을 막음" }, { "title": "[파이썬 프로그래밍 기초] 14강 - 실전 프로그래밍", "url": "/posts/knou-python-14/", "categories": "Language, Python", "tags": "knou, python", "date": "2025-05-19 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '파이썬 프로그래밍 기초' 강의를 개인 공부 목적으로 메모하였습니다. 학습 목표 2차원 리스트의 구조를 이해할 수 있음 2차원 리스트의 생성 및 순회 구조를 설명할 수 있음 게임 루프를 생성할 수 있음주요 용어 2차원 리스트 1차원 리스트의 행 인덱스와 내포된 1차원 리스트의 열 인덱스로 구성된 리스트 강의록2차원 리스트리스트 순서화 된 값의 집합체를 저장할 수 있는 데이터 타입 단일 식별자로 연속된 저장 공간 접근 수단 제공 반복 구조에서 많이 사용 1차원 리스트 2차원 리스트 리스트에 리스트가 내포된 즉, 리스트의 리스트 값들이 서로 매칭 되어 일렬로 세울 수 없는 경우 2차원 리스트 구조2차원 리스트 접근 2차원 리스트의 요소는 리스트이름[행인덱스][열인덱스] 형식으로 접근 두 개의 접근 연산자를 사용해 개별적인 값에 접근 distance[0] → 첫 번째 행 리스트 distance[0][0] → 첫 번째 행의 첫 번째 열 값 distance[4] → 다섯 번째 행 리스트 distance[7][7] → 여덟 번째 행의 여덟 번째 열 값 2차원 리스트 생성 구문 형식 리스트 내부에 리스트가 정의 2차원 리스트 생성 시 원소가 결정된 상황에 사용 2차원 리스트 동적 생성 random 모듈을 이용하여 동적으로 2차원 리스트 생성 가능 import random as rd # 행의 개수 nRows, 열의 개수 nColumns distance = [] for i in range(nRows): row = [] for j in range(nColumns): row.append(rd.randint(0, 99)) distance.append(row) print(distance) 2차원 리스트 순회 각 차원 순차적으로 순회하기 위한 2개의 반복 구조가 중첩되어 사용 해당 차원의 개수에 맞게 끔 for 문이 중첩 됨 출발 도시 변수와 도착 도시 변수를 사용하여 순회 # 출발도시(departure) 순회 for dep in distance: # dep 출발 도시 변수 # 도착도시(destination) 순회 for des in dep: # des 도착 도시 변수 print(des, end = \" \") # 각 도시 간 거리를 출력 print() # 한 행의 출력이 끝나면 줄 바꿈 틱택토 게임 구현게임 설계 2차원 리스트를 사용하여 게임 판을 생성하고 각각의 칸을 빈칸으로 초기화 빈칸에 대한 지정한 기호(*)를 사용 게임판에 빈칸이 남아있는지 확인 게임 판 전체를 확인하고 True/False 반환 둘 중 한 플레이어가 승리했는지 확인 8가지의 승리 상황에 따른 가능성을 확인 각각의 행, 열과 두 개의 대각선 방향을 확인 게임 판의 현재 상태를 출력 게임 시작 무작위로 선공할 플레이어를 선택 게임 루프를 기동 게임 판의 현재 상태를 출력하고 다음 플레이어가 빈칸을 선택 플레이어가 선택할 빈칸의 위치(행과 열 번호)를 입력 받음 플레이어가 선택한 위치에 기호를 표시하고 게임 판을 업데이트 현재 플레이어가 승리했는지 확인 게임 판에 빈칸이 남아있는지 확인 게임 판이 가득찬 경우, 무승부 메시지를 출력하고 게임 루프를 종료 승리 상황인 경우, 승리한 플레이어에 대한 메시지를 출력하고 게임 루프를 종료 사용자일 경우 사용자 입력을 통해 행과 열 번호를 입력 받음 컴퓨터일 경우 무작위로 행과 열 번호를 선택 게임이 종료 될 때까지 게임 루프를 반복 class Tic_Tac_Toe: # 게임판 생성 def __init__(self): # 게임판 초기화 def create_board(self): # 첫 플레이어 선택 def select_first_player(self): # 기호 표시 def mark_spot(self, row, col, player): # 승리 상태 확인 def is_win(self, player): #잔여 빈칸 여부 확인 def is_board_full(self): # 플레이어 변경 def next_player(self, player): # 현재 게임판 상태 출력 def show_board(self): # 게임 시작 def start(self): # 게임 생성 #게임 시작 게임 구현import randomclass Tic_Tac_Toe: # 게임판 생성 def __init__(self): self.board = [] # 클래스 전역에서 사용하기 위해 self 붙임 # 게임판 초기화 def create_board(self): for i in range(3): row = [] # 하나의 행 생성 for j in range(3): row.append('*') # *로 채운 3개의 칸 만들기 self.board.append(row) # self.board 판에 row 넣음\t\t\t\t # 첫 플레이어 선택 def select_first_player(self): if random.randint(0, 1) == 0: # 0, 1 포함해 값 랜덤하게 뽑고 0이 나오면 return 'X' # 컴퓨터(X)가 플레이어 else: return 'O' # 사용자(O)가 플레이어 # 기호 표시 def mark_spot(self, row, col, player): self.board[row][col] = player # 승리 상태 확인 def is_win(self, player): n = len(self.board) # board가 가리키는 리스트의 원소의 개수 추출 # 행 확인 for i in range(n): win = True # 승리 상황이라 일단 가정하고 반복할 때마다 각 행에 대해서 다른게 있는지 체크 for j in range(n): if self.board[i][j] != player: # 세칸이 모두 player의 말과 다르다는 것은 승리 상황이 아니라는 의미 win = False break # 반복 중단 if win == True: return win # 승리 상황일 경우 True를 반환 # 열 확인 for i in range(n): win = True # 승리 상황이라 일단 가정하고 반복할 때마다 각 행에 대해서 다른게 있는지 체크 for j in range(n): if self.board[j][i] != player: # 열부터 확인할 때에는 i와 j의 위치 바꿈 win = False break # 반복 중단 if win == True: # 할당 연산자 =와 비교 연산자 == 사용에 유의 return win # 승리 상황일 경우 True를 반환 # 오른쪽 대각선 확인 win = True # 승리 상황이라 일단 가정하고 반복할 때마다 각 행에 대해서 다른게 있는지 체크 for i in range(n): if self.board[i][i] != player: win = False break if win == True: return win # 왼쪽 대각선 확인 win = True # 승리 상황이라 일단 가정하고 반복할 때마다 각 행에 대해서 다른게 있는지 체크 for i in range(n): if self.board[i][n - i - 1] != player: win = False break if win == True: return win return False # 행, 열, 대각선 확인 후에도 승리 상황이 아닌 경우는 False 반환 # 잔여 빈칸 여부 확인 def is_board_full(self): for row in self.board: for item in row: if item == '*': return False return True # 플레이어 변경 def next_player(self, player): if player == 'O': return 'X' else: return 'O' # return 'X' if player == 'O' else 'O' # 현재 게임판 상태 출력 def show_board(self): for row in self.board: for item in row: print(item, end = \" \") # 출력할 때 줄바꿈 되지 않게 print() # 게임 시작 def start(self): # 새 게임 판 생성 self.create_board() self.show_board() # 첫 플레이어 선택 player = self.select_first_player() # 게임 루프 시작(이벤트가 발생할 때까지 기다림 반복) while True: # 다음 플레이어 안내\t if player == 'X': print(\"컴퓨터 차례입니다.\") else: print(\"사용자 차례입니다.\") # 현재 게임 판 상태 출력 self.show_board() # 사용자 입력 대기, 컴퓨터일 경우 랜덤 위치 반환 if player == 'X': while True: row, col = random.randint(1, 3), random.randint(1, 3) # 사용자와 동일한 입력 상황을 맞추기 위해 (1, 3)으로 표기 if self.board[row - 1][col - 1] == '*': # 무작위로 입력 받은 게임판의 좌표 값이 빈칸('*')이면 반복을 중단 break print(\"컴퓨터가 행 \" + str(row) + \", 열\" + str(col) + \"을/를 선택했습니다.\") print() else: row, col = list(map(int, input(\"선택할 빈칸의 위치를 입력하세요: \").split())) # 공백 기준으로 문자 분리 print(\"사용자가 행 \" + str(row) + \", 열\" + str(col) + \"을/를 선택했습니다.\") print() # row, col 입력 값이 0, 0인 경우 게임 종료 if row == 0 and col ==0: print(\"게임을 종료합니다.\") break # 입력 된 위치 표시 self.mark_spot(row - 1, col - 1, player) self.show_board() # 현재 플레이어가 이겼는지 확인 if self.is_win(player) == True: # 승리 상황 메소드 값이 True인지 확인하고 if player == 'X': # 승리자에 맞는 메시지 출 print(\"컴퓨터가 이겼습니다. 다시 도전하세요\") else: print(\"사용자가 이겼습니다. 축하합니다.\") break # 상황 종료 # 게임판 가득참 확인, 빈칸 여부 확인 if self.is_board_full() == True: print(\"무승부 입니다. 다시 도전하세요.\") break # 플레이어 변경 확인 player = self.next_player(player) # 최종 게임판 출력 print() self.show_board()# 게임 생성TTT = Tic_Tac_Toe()#게임 시작TTT.start() 게임 판 생성 메소드 board는 리스트 []를 통해 리스트 생성 range(0, 3) 범위는 0, 1, 2를 의미 첫 플레이어 선택 단계 무작위로 둘 중에 하나를 선택 ex) 0이면 컴퓨터, 1이면 사용자 randint(0, 3) 범위는 0, 1, 2, 3 기호 표시 메소드 게임 판 상의 행, 열 값에 Player의 말 표시 []를 통해 리스트 생성 잔여 빈칸 여부 확인 메소드 한 칸씩 확인한 후, 빈칸을 의미하는 *가 있으면 False 반환 플레이어 변경 단계 현재 player가 O이면 X를 반환하고 X이면 O를 반환 현재 게임 판 상태 출력 메소드 for 문을 활용해 게임 판 상태를 출력 map 함수 리스트 각각의 요소에 함수를 적용해주는 역할 input으로 입력 받은 위칫 값(리스트 형태)에 (정수로 바꾸는 함수인) int 함수 적용 마무리로 어떤 형태로 만들어 주어야 하는지 명시해야 함 게임 생성 단계 Tic_Tac_Toe 객체를 생성 게임 시작 단계 생성 된 객체가 start() 메소드 호출 연습 문제 다음 함수에서 0 또는 1의 난수 값이 생성되어 0, X가 반환될 수 있도록 random 모듈의 설명을 참조하여 빈칸에 들어갈 수 있는 표현을 작성하면? import random def select_first_player(self): if ______ == 0: return 'X' else: return 'O' 멤버 설명 random() 0 ~ 1 사이의 숫자 중 난수 발생 randint(a, b) a부터 b 사이의 숫자 중 난수 발생 randrange(a, b, c) a부터 b 사이의 c의 간격으로 나열된 숫자 중 난수 발생 choice(sequence) 주어진 항목을 랜덤하게 반환 sample(sequence) 랜덤하게 여러 개의 원소를 선택 shuffle(sequence) 시퀀스의 순서를 랜덤하게 섞음 a. random.randint(0, 1) 다음 2차원 리스트에서 파란색 원소에 접근하기 위한 표현은? a. distance[2][3] 다음은 dist라는 이름의 0으로 초기화된 3 X 3 크기의 2차원 리스트 생성하는 코드이다. 빈칸에 공통으로 들어갈 표현은? dist = ______ for i in range(3): row = ______ for j in range(3): row.append(0) dist.append(row) a. [] 또는 list() 학습 정리 단일 식별자로 순서화 된 값의 집합체를 저장할 수 있는 데이터 타입을 리스트라고 함 2차원 리스트는 행 인덱스라는 1차원 리스트를 가리키고 있으며 행 인덱스의 각 원소가 열 인덱스라는 또 다른 1차원 리스트를 포함하는 구조임 2차원 리스트의 순회는 각 차원을 순차적으로 순회하기 위한 2개의 반복 구조가 중첩된 구조로 이루어짐" }, { "title": "[Java 프로그래밍] 14강 - JDBC 프로그래밍", "url": "/posts/knou-java-14/", "categories": "Language, Java", "tags": "knou, java", "date": "2025-05-18 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김희천 교수님의 'Java 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 Java 프로그램에서 데이터베이스 프로그래밍을 위해 JDBC API를 사용함 JDBC API를 사용하려면 DBMS 별로 존재하는 JDBC 드라이버가 필요함 JDBC 기술을 사용하여 DBMS에 연결하고 각종 SQL 구문을 실행하며 결과를 받아 처리하는 방법을 학습함학습 목표 JDBC 기능을 설명하고 드라이버를 설치할 수 있음 MariaDB를 설치하고 사용할 수 있음 Java 프로그램에서 MariaDB에 연결하여 데이터베이스를 사용할 수 있음 데이터베이스 프로그래밍에 사용되는 여러 인터페이스를 설명할 수 있음강의록JDBC와 MariaDB데이터베이스 기초 데이터베이스 데이터를 모아 놓은 집합 장소 DBMS 데이터베이스 관리 시스템 데이터베이스의 효과적 관리를 위한 응용 소프트웨어 관계형 DBMS에서는 데이터를 테이블 형태로 저장함 DBMS는 여러 데이터베이스들로 구성됨 하나의 데이터베이스는 여러 테이블들로 구성됨 하나의 테이블은 여러 레코드(행)들로 구성됨 하나의 레코드는 여러 필드(열)들로 구성됨 각 필드에 데이터를 저장하며, 레코드를 식별하는 키 필드가 존재함 관계형 데이터베이스 테이블 관계형 데이터베이스에서 데이터 구조화를 위한 기본 자료 구조 테이블은 고유한 이름을 가짐 테이블은 행(레코드 또는 엔터티)과 열(속성 또는 필드)로 구성됨 ID 제목 작성자 작성날짜 조회수 내용 1 시작 홍길동 2024/05/11 1252 첫 번째 글의 내용 2 과정 이순신 2024/05/12 197 두 번째 글의 내용 3 마무리 김유신 2024/05/13 94 세 번째 글의 내용 스키마 테이블의 이름과 구조를 정의 테이블의 구조란 테이블을 구성하는 속성(필드, 열)들에 대한 정보 필드 이름 데이터 타입 길이 ID INT - 제목 VARCHAR 100 작성자 VARCHAR 20 작성날짜 DATE - 조회수 INT - 내용 VARCHAR 500 DBMS 설치 MariaDB를 설치하기로 함 https://www.mariadb.org/download/ 에 접속 MariaDB Server 설치 프로그램을 다운로드 mariadb-11.7.*-winx64.msi을 실행시킴 설치 과정에서 root 계정의 암호를 정하고 기억해야 함 기본적으로 C:\\Program Files\\MariaDB 11.7에 설치됨 기본 포트는 3306 https://dev.mysql.com/doc/index-other.html 에 접속하여 샘플 데이터베이스로 world database를 다운로드하여 설치 world-db.zip 파일에서 world.sql을 이용하여 설치 MariaDB 사용 MariaDB 서버 프로그램이 실행 중인지 확인 데몬을 실행하려면 시작 메뉴의 Windows 관리 도구에서 서비스 실행 또는 윈도우 시작 버튼을 클릭하고, 찾기에서 서비스를 타이핑함 서비스 목록에서 MariaDB 서비스의 상태 확인 MySQL Client (MariaDB 11.7 (x64)) 프로그램을 실행 시작 메뉴 → MariaDB 11.7 (x64) → MySQL Client (MariaDB 11.7 (x64)) 또는 명령 프롬프트 창에서 mysql -u root -p를 실행 먼저 C:\\Program Files\\MariaDB 11.7\\bin 경로를 Path에 추가해야 함 샘플 데이터베이스 설치 https://dev.mysql.com/doc/index-other.html 에 접속하여 샘플 데이터베이스 world database를 다운로드하여 설치 world-db.zip 파일에서 world.sql을 이용하여 설치 Enter password: ******* source c:/db/world.sql show databases; use world; show tables; MariaDB 서버에 연결하기JDBC JDBC(Java DataBase Connectivity) API Java 프로그램에서 관계형 DBMS와 연동하여 데이터를 사용하고 관리할 수 있게 하는 Java API 표준 규격 데이터베이스에 연결하고, 데이터베이스에 대해 질의, 갱신, 삽입, 삭제를 요청하고, 결과를 받기 위한 프로그래밍 방법을 제공 JDK의 일부로 포함되어 있음(java.sql 패키지) MariaDB JDBC 드라이버 JDBC 드라이버 JDBC API는 DBMS 제조사가 제공하는 JDBC 드라이버를 통해 구현됨 사용하려는 DBMS의 JDBC 드라이버를 다운로드 받아 설치해야 함 JDBC API를 사용한 데이터베이스 연동 프로그램을 실행할 수 있음 MariaDB JDBC 드라이버 MariaDB용 JDBC API를 구현한 소프트웨어 .jar파일 형식으로 제공됨 Java 프로그램에서 MariaDB와 연동하는 경우, Java 8+ Connector가 필요함 https://mariadb.com/downloads/connectors/ 에 접속 mariadb-java-client-3.5.3.jar 파일을 다운로드함 MariaDB 연결 프로그램 만들기 이클립스 설정 자바 프로젝트 생성 프로젝트 이름을 지정 ex) JDBCExample module-info.java 파일을 만들지 말 것 드라이버 파일울 Classpath에 추가 프로젝트 설정에서 Project → Properties → Java Build Path → Libraries → Classpath → Add External JARs…를 이용하여 mariadb-java-client-3.3.3.jar를 추가함 또는 마우스 오른쪽 버튼으로 Build Path → Configure Build Path… → Java Build Path → Libraries → Classpath → Add External JARs…를 이용 MariaDB 접속 프로그램 예 // MariaDB 데이터베이스 연결 정보 설정 String url = \"jdbc:mariadb://localhost:3306/world\"; // DB URL String user = \"root\"; // DB 계정 사용자 이름 String pass = \"root\"; // DB 계정 비밀번호 // try-with-resources를 사용하여 데이터베이스 연결, 쿼리 실행, 결과 처리 try (Connection conn = DriverManager.getConnection(url, user, pass); // DB 연결 생성 Statement stmt = conn.createStatement(); // 쿼리를 실행할 객체 생성 ResultSet rs = stmt.executeQuery(\"SELECT * FROM city limit 0, 50\")) { // 쿼리 실행 // 결과 출력 시, 헤더(컬럼 제목) 형식 지정 및 출력 System.out.println(String.format(\"%-10s\", \"ID\") + String.format(\"%-35s\", \"Name\") + String.format(\"%-15s\", \"CountryCode\") + String.format(\"%-20s\", \"District\") + String.format(\"%-11s\", \"Population\")); // ResultSet으로 조회된 결과를 반복하여 한 행씩 출력 while (rs.next()) { // 각 컬럼 값을 읽어서 정렬된 형식으로 출력 System.out.print(String.format(\"%-10d\", rs.getInt(\"ID\"))); // ID 컬럼 System.out.print(String.format(\"%-35s\", rs.getString(\"Name\"))); // Name 컬럼 System.out.print(String.format(\"%-15s\", rs.getString(\"CountryCode\")));// CountryCode 컬럼 System.out.print(String.format(\"%-20s\", rs.getString(\"District\"))); // District 컬럼 System.out.println(String.format(\"%-11d\", rs.getInt(\"Population\"))); // Population 컬럼 } } // ID Name CountryCode District Population // 1 Kabul AFG Kabol 1780000 // 2 Qandahar AFG Qandahar 237500 // 3 Herat AFG Herat 186800 MariaDB 연동 프로그래밍MariaDB 연동 프로그래밍 순서 JDBC 패키지를 import import java.sql.*; JDBC 드라이버를 동적으로 로드 Class.forName(\"org.mariadb.jdbc.Driver\");호출 최신 JDBC 버전에서는 생략해도 됨 MariaDB 서버 프로그램과 연결 설정 DriverManager.getConnection(url, user, pass)호출 SQL 구문의 실행과 결과 처리 Connection, Statement, ResultSet 객체 사용 연결 해제 사용 중인 데이터베이스 자원을 반납 finally블록에서 rs.close();stmt.close();conn.close();실행 try-with-resource구문을 사용하면 이 부분이 자동 처리됨 MariaDB 서버에 연결하기 방법 DriverManager.getConnection**(url, user, pass)메소드는 URL, 사용자 아이디, 비밀번호를 이용하여 MariaDB 서버에 접속을 시도 성공하면 Connection 유형의 객체를 리턴 String url = \"jdbc:mariadb://localhost:3306/world\"; String user = \"root\"; String pass = \"mariadb\"; try(Connection conn = DriverManager.getConnection(url, user, pass); Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(\"SELECT * FROM city limit 0, 50\")) { } Statement객체 SQL 구문을 실행하고 결과를 반환해 주는 객체 Connection객체의 createStatement()메소드를 통해 생성됨 주요 메소드 메소드 설명 boolean execut(String sql) SQL 구문을 실행하며, select구문을 실행하는 경우 true를 리턴하고 이어서 getResultSet()를 호출할 수 있음, update/insert/delete구문의 경우 false를 리턴하며 getUpdateCount()를 호출할 수 있음 ResultSet getResultSet() SQL 구문(execute로 실행)을 실행한 결과를 리턴 int getUpdateCoun() SQL 구문(execute로 실행)의 실행으로 영향을 받은 행의 개수를 리턴 ResultSet executeQuery(String sql) select구문 실행할 때 사용되며, 실행 결과를 나타내는 테이블인 ResultSet객체를 리턴 int executeUpdate(String sql) update, insert, delete구문 실행할 때 사용하며, 영향 받은 행의 개수를 리턴 Statement객체로 select구문 실행하기 Statement객체를 생성하고 executeQuery()또는 execute()를 호출 쿼리 결과를 읽을 때는 ResultSet객체에서 읽음 try(Connection conn = DriverManager.getConnection(url, user, pass); Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(\"SELECT * FROM city limit 0, 50\")) { while(rs.next()) { System.out.print(String.format(\"%-10d\", rs.getInt(\"ID\"))); System.out.print(String.format(\"%-35s\", rs.getString(\"Name\"))); } } try(Connection conn = DriverManager.getConnection(url, user, pass); Statement stmt = conn.createStatement()) { ResultSet rs = null; if(stmt.execute(\"SELECT * FROM city limit 0, 50\")) rs = stmt.getResultSet(); while(rs.next()) { } } ResultSet객체 select구문의 실행 결과를 나타내는 테이블 Statement객체의 getResultSet(), executeQuery()메소드가 리턴한 객체 테이블에서 한 행을 가리키는 커서를 가짐 select구문을 실행하여 ResultSet객체가 생성되면 커서가 만들어지고, select구문의 실행 결과를 가리킴 커서는 행을 가리키는 포인터, 기본적으로 위에서 아래로 진행 커서의 초기 값은 첫 행의 직전 행을 가리킴 ResultSet의 메소드 주요 메소드 메소드 설명 boolean next() 커서를 다음 행으로 이동 시킴 boolean previous() 커서를 이전 행으로 이동 시킴 Statement getStatement() 현재 ResultSet을 생성 시킨 Statement객체를 리턴 String getString(int index), String getString(String columnName) ResultSet객체에서 해당 열의 문자열을 리턴, 첫 번째 필드의 인덱스는 1 int getInt(int index), int getInt(String columnName) ResultSet객체에서 해당 열의 int 값을 리턴 Statement객체로 insert, update, delete구문 실행하기 Statement객체를 생성하고 executeUpdate()를 호출 영향을 받은 행의 개수가 리턴 됨 try (Connection conn = DriverManager.getConnection(url, user, pass); Statement stmt = conn.createStatement()) { int resultCount = stmt.executeUpdate(\"insert into 테이블이름 values ...\"); System.out.println(resultCount + \"개의 행이 삽입되었습니다.\"); resultCount = stmt.executeUpdate(\"update 테이블이름 set ...\"); System.out.println(resultCount + \"개의 행이 변경되었습니다.\"); resultCount = stmt.executeUpdate(\"delete from 테이블이름 where ...\"); System.out.println(resultCount + \"개의 행이 삭제되었습니다.\"); } if(!stmt.execute(\"delete from 테이블이름 where ...\")) System.out.println(stmt.getUpdateCount() + \" 개의 행 삭제\"); DatabaseMetaData객체, PreparedStatement객체, ResultSetMetaData객체DatabaseMetaData객체 드라이버나 데이터베이스의 정보를 제공하는 메소드를 가진 인터페이스 Connection객체의 getMetaData()메소드로 객체를 생성 주요 메소드 메소드 설명 String getDriverName() JDBC 드라이버 이름을 리턴 String getURL() 연결에 사용된 DBMS URL을 리턴 String getUserName() 연결에 사용된 데이터베이스 사용자 DatabaseMetaData사용 예 DBMS 정보 알아내기 import java.sql.*; public class Main { public static void main(String[] args) { String url = \"jdbc:mariadb://localhost:3306/world\"; String user = \"root\"; String pass = \"mariadb\"; try { Class.forName(\"org.mariadb.jdbc.Driver\"); } catch (Exception ex) { System.out.println(ex); } try (Connection conn = DriverManager.getConnection(url, user, pass)) { System.out.println(conn.getMetaData().getDriverName()); System.out.println(conn.getMetaData().getDriverVersion()); System.out.println(conn.getMetaData().getURL()); System.out.println(conn.getMetaData().getUserName()); } catch (Exception ex) { System.out.println(ex); } } } MariaDB Connector/J 3.5.3 jdbc:mariadb://localhost/world?user=root&amp;password=*** root DBMS와 Java의 자료형 변환 DBMS 테이블에서 필드의 자료형과 Java의 자료형, 그리고 JDBC 메소드 간의 관계 DBMS 자료형 Java 자료형 ResultSet메소드 PreparedStatement메소드 CHAR String getString() setString() VARCHAR String getString() setString() INTEGER int getInt() setInt() DATE java.sql.Date getDate() setDate() PreparedStatement객체 Precompiled된 SQL 문을 표현 객체는 Connection객체의 prepareStatement(String sql)메소드를 통해 생성됨 객체를 생성할 때 SQL 구문이 주어짐 (Statement객체의 경우 실행할 때 제공) 같은 SQL 문을 여러 번 반복 실행할 때 효율적임 SQL문에 매개 변수(?)를 사용하고, 실행 전에 값을 지정할 수 있음 Connection conn = DriverManager.getConnection(url, user, pass); String query = \"SELECT * FROM 테이블이름 WHERE 필드1=? and 필드2&gt; ?\"; PreparedStatement ps = conn.prepareStatement(query); ps.setString(1, \"필드값\"); ps.setInt(2, 숫자); ResultSet rs = ps.executeQuery(); PreparedStatement의 메소드 주요 메소드 SQL 구문을 실행하는 PreparedStatement객체가 가지고 있으므로, SQL 구문을 실행하는 메소드에는 인자가 없음 메소드 설명 boolean execute() 객체가 가진 SQL 구문을 실행함 ResultSet executeQuery() SQL 쿼리 문을 실행하고 ResultSet객체를 리턴 int executeUpdate() insert, update또는 delete문을 실행 void setInt(int parameterIndex, int x) SQL 구문의 매개변수(?)에 int 값을 지정, SQL 구문에서 첫 번째 ?의 인덱스는 1임 void setString(int parameterIndex, String x) SQL 구문의 매개변수(?)에 문자열 값을 지정 PreparedStatement의 사용 예 PreparedStatement객체 사용하기 String query = \"SELECT * FROM city WHERE population &gt; ?\"; try (Connection conn = DriverManager.getConnection(url, user, pass); PreparedStatement ps = conn.prepareStatement(query); ResultSet rs = getPS(ps, 1, 9000000).executeQuery()) { System.out.println(String.format(\"%-10s\", \"ID\") + String.format(\"%-35s\", \"Name\") + String.format(\"%-15s\", \"CountryCode\") + String.format(\"%-20s\", \"District\") + String.format(\"%-11s\", \"Population\")); while (rs.next()) { System.out.print(String.format(\"%-10d\", rs.getInt(\"ID\"))); System.out.print(String.format(\"%-35s\", rs.getString(\"Name\"))); System.out.print(String.format(\"%-15s\", rs.getString(\"CountryCode\"))); System.out.print(String.format(\"%-20s\", rs.getString(\"District\"))); System.out.println(String.format(\"%-11d\", rs.getInt(\"Population\"))); } } ID Name CountryCode District Population 206 São Paulo BRA São Paulo 9968485 939 Jakarta IDN Jakarta Raya 9604900 1024 Mumbai (Bombay) IND Maharashtra 10500000 ResultSetMetaData객체 ResultSet객체에서 테이블의 이름, 열의 이름과 타입 정보를 얻을 때 사용하는 객체 ResultSet의 getMetaData()메소드로 생성함 주요 메소드 메소드 설명 String getColumnName(int index) index 위치의 컬럼 이름을 리턴 int getColumnCount() ResultSet의 컬럼 개수를 리턴 int getColumnType(int index) index 위치의 컬럼 자료형을 리턴 String getTableName(int index) index 위치의 컬럼을 포함하는 테이블의 이름을 리턴 ResultSetMetaData사용 예 ResultSetMetaData객체 import java.sql.*; try (Connection conn = DriverManager.getConnection(url, user, pass); Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(\"SELECT * FROM city limit 0, 50\")) { ResultSetMetaData rsmd = rs.getMetaData(); // ResultSet 메타데이터 가져오기 int colCount = rsmd.getColumnCount(); // 컬럼 이름 출력 for (int i = 1; i &lt;= colCount; i++) { System.out.print(rsmd.getColumnName(i) + (i &lt; colCount ? \", \" : \"\")); } System.out.println(); // 결과 출력 while (rs.next()) { for (int i = 1; i &lt;= colCount; i++) { switch (rsmd.getColumnType(i)) { case Types.INTEGER: System.out.print(rs.getInt(i) + (i &lt; colCount ? \", \" : \"\")); break; case Types.VARCHAR: // VARCHAR 타입 처리 case Types.CHAR: // CHAR 타입 처리 System.out.print(rs.getString(i) + (i &lt; colCount ? \", \" : \"\")); break; default: // 기본적으로 문자열로 처리 System.out.print(rs.getString(i) + (i &lt; colCount ? \", \" : \"\")); break; } } System.out.println(); } } ID, Name, CountryCode, District, Population 1, Kabul, AFG, Kabol, 1780000 2, Qandahar, AFG, Qandahar, 237500 3, Herat, AFG, Herat, 186800 4, Mazar-e-Sharif, AFG, Balkh, 127800 5, Amsterdam, NLD, Noord-Holland, 731200 6, Rotterdam, NLD, Zuid-Holland, 593321 7, Haag, NLD, Zuid-Holland, 440900 8, Utrecht, NLD, Utrecht, 234323 9, Eindhoven, NLD, Noord-Brabant, 201843 10, Tilburg, NLD, Noord-Brabant, 193238 11, Groningen, NLD, Groningen, 172701 12, Breda, NLD, Noord-Brabant, 160398 13, Apeldoorn, NLD, Gelderland, 153491 14, Nijmegen, NLD, Gelderland, 152463 15, Enschede, NLD, Overijssel, 149544 16, Haarlem, NLD, Noord-Holland, 148772 17, Almere, NLD, Flevoland, 142465 18, Arnhem, NLD, Gelderland, 138020 19, Zaanstad, NLD, Noord-Holland, 135621 20, ´s-Hertogenbosch, NLD, Noord-Brabant, 129170 21, Amersfoort, NLD, Utrecht, 126270 22, Maastricht, NLD, Limburg, 122087 23, Dordrecht, NLD, Zuid-Holland, 119811 24, Leiden, NLD, Zuid-Holland, 117196 25, Haarlemmermeer, NLD, Noord-Holland, 110722 26, Zoetermeer, NLD, Zuid-Holland, 110214 27, Emmen, NLD, Drenthe, 105853 28, Zwolle, NLD, Overijssel, 105819 29, Ede, NLD, Gelderland, 101574 30, Delft, NLD, Zuid-Holland, 95268 31, Heerlen, NLD, Limburg, 95052 32, Alkmaar, NLD, Noord-Holland, 92713 33, Willemstad, ANT, Curaçao, 2345 34, Tirana, ALB, Tirana, 270000 35, Alger, DZA, Alger, 2168000 36, Oran, DZA, Oran, 609823 37, Constantine, DZA, Constantine, 443727 38, Annaba, DZA, Annaba, 222518 39, Batna, DZA, Batna, 183377 40, Sétif, DZA, Sétif, 179055 41, Sidi Bel Abbès, DZA, Sidi Bel Abbès, 153106 42, Skikda, DZA, Skikda, 128747 43, Biskra, DZA, Biskra, 128281 44, Blida (el-Boulaida), DZA, Blida, 127284 45, Béjaïa, DZA, Béjaïa, 117162 46, Mostaganem, DZA, Mostaganem, 115212 47, Tébessa, DZA, Tébessa, 112007 48, Tlemcen (Tilimsen), DZA, Tlemcen, 110242 49, Béchar, DZA, Béchar, 107311 50, Tiaret, DZA, Tiaret, 100118 학습 정리 MariaDB는 MySQL과 호환되는 오픈 소스 관계형 데이터베이스 관리 시스템임 JDBC는 Java 프로그램에서 관계형 데이터베이스와 연동할 수 있게 하는 표준 API임 JDBC 프로그래밍을 위해서는 MariaDB용 JDBC 드라이버로 .jar파일을 다운로드 받아 Classpath에 추가해야 함 DBMS와 연결을 설정할 때는 java.sql.Connection객체를 사용함 SQL 구문을 실행할 때 Statement인터페이스의 execute(), executeQuery(), executeUpdate()를 사용할 수 있음 select구문을 실행할 때 executeQuery()를 호출하며, 검색 결과가 ResulteSet객체로 리턴 됨 같은 SQL 문을 여러 번 실행할 때는 PreparedStatement객체를 사용하는 것이 효율적이며, SQL 문에 매개변수를 사용하고 실행 전에 값을 지정할 수 있음연습 문제 JDBC 프로그래밍에 사용되는 클래스나 인터페이스가 아닌 것은? a. Runnable JDBC 프로그래밍에 사용 되는 클래스나 인터페이스는? Connection DriverManager Statement PreparedStatement객체에 대한 설명으로 잘못된 것은? a. PreparedStatement는 Statement의 부모 인터페이스임 PreparedStatement객체에 대한 설명으로 옳은 것은? 객체를 생성할 때 SQL 구문을 지정해야 함 같은 SQL 구문을 여러 번 실행할 때 효율적으로 활용될 수 있음 매개 변수를 가지는 SQL 구문을 지정할 수 있음 Statement객체를 이용하여 executeQuery()를 호출하면 select구문을 실행할 수 있다. 이때 질의를 만족하는 레코드들이 테이블 형태로 리턴되는데 이것의 데이터 타입은 무엇인가? a. ResultSet " }, { "title": "[데이터베이스 시스템] 14강 - 동시성 제어", "url": "/posts/knou-dbs-14/", "categories": "Database", "tags": "knou, database", "date": "2025-05-18 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '데이터베이스 시스템' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 여러 사용자의 데이터베이스 요청을 동시에 실행하는 것은 시스템의 처리 율과 자원 활용도를 높이고, 개별 요청의 응답 시간을 단축 시켜 전체적인 사용자 만족도를 향상 시키기 위한 중요한 방법임 그러나 트랜잭션 간의 병행 실행은 자칫하면 데이터의 일관성을 훼손하거나 무결성 제약을 위반할 위험이 있음 이를 방지하기 위해 DBMS는 직렬성(serializability) 이론을 기반으로, 트랜잭션 간의 실행 순서를 제어함으로써 동시에 수행 되는 연산이 하나씩 순차적으로 수행 된 것과 동일한 효과를 내도록 보장함 트랜잭션의 동시 실행에서 발생할 수 있는 문제점을 이론적으로 분석할 수 있는 기반 개념을 학습하고, 이를 해결하기 위한 동시성 제어 기법을 살펴 봄 대표적인 제어 방식인 락 기반 규약과 타임 스탬프 기반 규약의 구조와 작동원리를 중심으로, 병행성을 최대화하면서도 데이터베이스의 무결성을 안전하게 유지할 수 있는 방법에 대해 학습함주요 용어 양립성 함수 락의 종류에 따라 동시에 수락 될 수 있는지 판단하는 함수 2단계 락킹 규약 요청 단계에서 트랜잭션은 락을 추가 요청할 수 있으며, 반납 단계부터는 락을 반납 해야 하는 방식으로 직렬성을 보장하는 규약 토마스 기록 규칙 타임스탬프 기반 규약의 규칙으로 오래 된 쓰기를 무시하는 규칙 교착 상태 특정 트랜잭션 집합 내에 속하는 모든 트랜잭션이 집합 내의 다른 트랜잭션을 기다리고 있는 상태 강의록락 기반 규약동시성 제어의 개념 트랜잭션 직렬화와 회복화는 스케줄이 데이터 일관성에 영향을 미치는 여부를 판별하고 일관성이 유지되는 상태로 실행/복원 시키기 위해 정의한 개념 일관성을 훼손시키는 트랜잭션에 대해 동시성 제어를 통해 일관성 유지에 개입 트랜잭션 간 연산의 순서를 제어 어떠한 데이터 읽기, 쓰기 연산에도 무결성을 유지 동시에 실행되는 트랜잭션 수를 증가 동시성 제어 규약의 종류 락 기반 규약 타임스탬프 기반 규약 검증 기반 규약 락 기반 규약의 개념 직렬 가능성을 보장하기 위해 락(lock: 잠금)을 사용하여 데이터 항목에 연산 적용 전 트랜잭션이 락을 획득하고 연산 후 반납하도록 하는 규약 락의 종류 공유 락(shared lock: S) 트랜잭션 T가 LS(Q) 명령으로 데이터 항목 Q에 공유 락을 획득하면 T는 Q를 읽을 수 있지만 쓰기 연산은 할 수는 없는 락 읽기는 함께 작업 가능 배타 락(exclusive lock: X) 트랜잭션 T가 LX(Q) 명령으로 데이터 항목 Q에 대한 배타 락을 획득하면, T가 Q를 읽기/쓰기 연산을 할 수 있는 락 락 양립성 트랜잭션은 연산하고자 하는 데이터에 대한 락을 획득한 후 연산 진행 가능 여러 트랜잭션이 같은 데이터 항목 Q에 동시에 락을 걸 수 있는지 여부 같이 락을 공유할 수 있는 지를 판단 락 양립성 함수 | | 공유 락(S) | 배타 락(X) | | — | — | — | | 공유 락(S) | 가능 | 불가능 | | 배타 락(X) | 불가능 | 불가능 | 공유 락은 다른 공유 락과 양립 가능(읽기만 가능) 배타 락과 다른 락과 양립 불가능 배타 락의 요청은 공유 락이 반납 될 때까지 대기 락의 반납은 UN() 명령 사용 예제 트랜잭션 어떤 트랜잭션이 A에 대한 락을 가지고 있다면 선점한 트랜잭션이 락을 해제할 때까지 중지 상태동시 실행 스케줄 T₁₀ 이 락을 일찍 반납하여 비일관적인 사태에서 데이터 접근이 가능해져 T₁₁이 정확하지 않은 결과 값을 출력 락 반납이 지연 된 트랜잭션락 반납 지연의 문제 T₁₂, T₁₃에 대한 부분 스케줄 T₁₂가 B에 대한 배타 락을 반환 할 때까지 T₁₃은 대기 이미 T₁₂가 락을 가지고 있으므로 대기 T₁₃이 A에 대한 공유 락을 반환 할 때까지 T₁₂는 대기 A에 대한 공유 락 선점 T₁₂, T₁₃가 서로를 계속 기다리는 상태 락 반납을 지연한 것이 교착 상태의 원인 교착 상태(deadlock) 연관 된 트랜잭션 모두가 대기 상태로 전환 되어 정상적인 실행이 불가능한 상태 일부 트랜잭션이 반드시 롤백 2 단계 락킹 규약 (2PL) 트랜잭션은 락을 요청 · 반납하는 두 단계로 구성 확장 단계 락 획득은 가능, 반납은 불가 단계 축소 단계 락 반납은 가능, 새로운 락 획득은 불가 단계 적절한 시기에 락 반납 교착 상태 감소 직렬성을 보장하나 교착 상태 완전한 예방은 불가 이후 더 엄격한 2단계 락킹 규약 생성 타임스탬프 기반 규약타임스탬프 기반 규약의 개념 각 트랜잭션 Tᵢ 실행의 순서를 판단하기 위해 타임스탬프 TS(Tᵢ)를 부여 트랜잭션에도 데이터 항목에도 타임스탬프가 부여 됨 마지막에는 최종 실행 된 값이 남아있어야 함 락 기반 규약에 비해 잦은 롤백이 발생 데이터 항목에 대한 타임스탬프 할당 W-TS(Q) Write(Q)를 성공적으로 실행한 트랜잭션 중 가장 큰 타임스탬프 가장 마지막으로 실행, 요청 된 트랜잭션의 타임스탬프 R-TS(Q) Read(Q)를 성공적으로 실행한 트랜잭션 중 가장 큰 타임스탬프 가장 마지막으로 실행 된 트랜잭션의 타임스탬프 타임스탬프 할당 방법 시스템 클럭 값 논리적 계수기 Tᵢ가 Read(Q)를 수행할 때 TS(Tᵢ) &lt; W - TS(Q)이면 Read 연산이 거부 되고 Tᵢ는 롤백 W-TS(Q) 여러 트랜잭션 중 가장 마지막에 실행 요청 된 트랜잭션의 타임스탬프 TS(Tᵢ) ≥ W - TS(Q)이면 Read 연산이 수행되고 R-TS(Q)는 기존 R-TS(Q)와 TS(Tᵢ) 중 최대 값으로 설정Tᵢ가 Write(Q)를 수행할 때 TS(Tᵢ) &lt; R-TS(Q) 또는 TS(Tᵢ) &lt; W-TS(Q)이면 Write 연산이 거부되고 Tᵢ는 롤백 그렇지 않으면 Write 연산을 수행하고 W-TS(Q)는 TS(Tᵢ)로 설정타임스탬프 기반 규약의 적용 TS(T₁₄) &lt; TS(T₁₅) 토마스 기록 규칙 TS(Tᵢ) &lt; R-TS(Q)이면 Write 연산이 거부되고 Tᵢ는 롤백 TS(Tᵢ) &lt; W-TS(Q)이면 Write 연산은 거부 (무시) Tᵢ는 롤백하지 않음 그렇지 않으면 Write 연산을 수행하고 W−TS(Q)는 TS(Tᵢ)로 설정 교착 상태교착 상태(deadlock)의 개념 특정 트랜잭션 집합 내에 속하는 모든 트랜잭션이 집합 내의 다른 트랜잭션을 기다리고 있는 상태 두 트랜잭션 중 하나를 반드시 롤백 교착 상태 처리 방법 교착 상태 발생이 비교적 높은 시스템의 경우 → 미연에 방지 교착 상태 방지 규약 사용 모든 데이터 항목에 대해 락을 설정하는 기법 타임스탬프를 이용한 선점유 기법 교착 상태 발생이 비교적 높지 않은 시스템의 경우 교착 상태 탐지와 회복 기법 사용 대기 그래프 희생자 선정 교착 상태 방지 규약 타임스탬프를 이용 Tⱼ가 락을 소유한 데이터 항목을 Tᵢ가 요청하는 상황 wait-die 기법 (비선점유 기반) TS(Tᵢ) &lt; TS(Tⱼ)일 때 Tᵢ가 기다리고 그렇지 않으면 Tᵢ를 롤백 wound-wait 기법 (선점유 기반) TS(Tⱼ) &lt; TS(Tᵢ)일 때, Tᵢ가 기다리고 그렇지 않으면 Tⱼ를 롤백하고 락을 이양 교착 상태 탐지와 회복 교착 상태 발생이 비교적 높지 않은 시스템의 경우 주기적으로 교착 상태를 탐지하고 발생 시 회복 절차를 수행 탐지 및 회복 절차 트랜잭션이 할당된 데이터 항목과 현재 요청되고 있는 데이터 항목에 대한 정보를 유지 교착 상태가 발생 여부를 판별하기 위해 시스템의 상태를 검사하는 알고리즘을 주기적으로 수행 교착 상태가 검출되면 시스템은 교착 상태로부터 회복을 위한 절차를 수행 교착 상태 탐지 대기 그래프(wait-for graph)를 이용하여 확인 가능 정점 V는 시스템 내의 트랜잭션으로 구성되며 간선 E는 트랜잭션의 순서쌍 (Tᵢ, Tⱼ)으로 이루어짐 Tᵢ가 요청한 데이터의 락을 Tⱼ가 소유하고 있으며, Tᵢ는 Tⱼ가 락을 반납하기 대기하는 상태 대기 그래프에 사이클이 있다면 교착 상태가 발생 교착 상태 탐지-대기 그래프 이용 교착 상태 아님 T₁₅ 실행이 완료 되어 T₁₅가 데이터 항목 반납 → T₁₃ 실행 → T₁₄ 실행 → T₁₂ 실행 T₁₂ T₁₃이 소유하고 있는 데이터 항목의 락을 요청해서 대기 중 T₁₄ T₁₃이 소유하고 있는 데이터 항목의 락을 요청해서 대기 중 T₁₃ T₁₅가 소유하고 있는 데이터 항목의 락을 요청해서 대기 중 교착 상태 T₁₃, T₁₄, T₁₅가 서로 기다리는 교착 상태 교착 상태의 회복 희생자 선정 롤백 비용이 가장 적은 트랜잭션을 선택 연산을 수행한 시간과 남은 작업을 마치기 위한 시간 사용한 데이터와 나머지 트랜잭션 실행에 필요한 추가적인 데이터의 양 롤백에 포함되는 트랜잭션의 개수 희생자 롤백 어느 시점까지 롤백 할 것인지 결정 전체 롤백 VS 교착 상태를 해결하는 지점 모든 트랜잭션의 상태에 대한 정보를 부가적으로 유지 무한정 기다림(starvation) 해결 동일 트랜잭션이 계속 희생자로 선정되지 않도록 희생자 선정 시 롤백 횟수를 고려 롤백 횟수를 카운트 연습 문제 타임스탬프 순서 규약에서 타임스탬프를 할당하는 방법인 것은? a. 시스템 시계 타임스탬프 순서 기법이란 로킹 규약으로 서로 상충되는 트랜잭션의 직렬성 순서를 결정하기 위해 트랜잭션에 부여 된 타임 스탬프 값을 이용하는 기법을 말함 타임스탬프 순서 기법을 구현하는데 시스템 시계(system clock)와 논리적 계수기가 보편적으로 이용 됨 교착 상태 방지 기법으로, 오래 된 트랜잭션이 최근의 트랜잭션을 기다리는 대신 강제 복귀시킨다는 선점(preemptive) 기법인 것은? a. wound-wait 기법 교착 상태 방지 기법에는 크게 wound-wait 기법과 wait-die 기법이 있음 이 중 wound-wait 기법은 선 점유 기법을 기반으로 타임스탬프가 작은 트랜잭션(오래 된 트랜잭션)이 큰 트랜잭션을 복귀 시키는 방법으로 교착 상태를 방지함 교착 상태의 회복에서 ‘교착 상태의 트랜잭션 집합이 주어지면 교착 상태를 해결하기 위하여 복귀 시킬 트랜잭션을 결정하여야 한다.’라고 할 때, 이 대상을 무엇이라 하는가? a. 희생자 교착 상태 회복을 위해서는 교착 상태에 관여하고 있는 트랜잭션 중 일부를 복귀 시켜야 하는데 복귀로 선택 된 트랜잭션을 희생자(victim)이라고 함 정리 하기 동시성 제어는 다수의 트랜잭션이 동시에 동일한 데이터에 대해 읽기 연산을 수행하거나 갱신 연산을 수행하려고 할 때, 데이터의 무결성을 유지하면서도 동시에 실행될 수 있는 트랜잭션의 수를 제어하는 기법임 대표적인 동시성 제어 기법에는 락 기반 규약, 타임스탬프 규약, 검증 기반 규약(protocol) 등이 있음 락(lock)이란 한 트랜잭션이 데이터 항목에 접근하는 동안에는 다른 트랜잭션이 그 데이터 항목에 접근하는 것을 제어하는 기법임 락킹 기법에는 공유 락(shared lock)과 배타 락(exclusive lock)이 있음 공유 락은 양립 가능하지만 배타 락은 다른 공유, 배타 락과 양립될 수 없음 2단계 락킹 규약(two–phase locking protocol)은 각 트랜잭션이 락을 요청하는 단계와 언락을 요청하는 두 단계로 구성되어 있음 트랜잭션은 요청 단계에서부터 시작되며 필요에 따라서 락을 요청할 수 있음 만약 트랜잭션이 하나의 락을 반납하게 되면 그때부터 트랜잭션은 반납 단계로 되며 더 이상 락 요청을 할 수 없음 타임스탬프 순서(timestamp ordering) 기법은 트랜잭션 충돌을 위해 직렬 가능한 순서를 정하는 데 가장 많이 사용하는 방법으로, 시스템의 각 트랜잭션마다 고유한 타임스탬프를 부여함 타임스탬프가 직렬 가능성을 보장하므로, TS(T₁)＜TS(T₂)라면 시스템은 T₁을 처리한 후 T₂를 처리하여 직렬 스케줄과 동등하도록 보장함체크 포인트 5개 트랜잭션의 충돌 직렬 가능 스케줄에 대한 우선순위 그래프이다. 이에 대한 설명으로 옳은 것만을 모두 고르면? ㄱ. 동등한 직렬 스케줄은 6개이다. ㄴ. 모든 동등한 직렬 스케줄은 T1에서 시작하고 T5에서 종료한다. ㄷ. T2와 T3은 동시에 수행할 수 있지만, T5는 T4가 수행된 후에 수행해야 한다. ㄹ. T2와 T5는 같은 데이터 항목에 대한 write 연산이 없다. a. ㄱ, ㄹ 우선 순위 그래프 분석 T₂는 T₁이 끝나기 만을 기다림 T₁보다 T₂가 먼저 실행될 수 없음 T₄는 T₂와 T₁이 끝나기 만을 기다림 T₅는 T₃가 끝나기 만을 기다림 T₃는 T₁이 끝나기 만을 기다림 동등한 직렬 스케줄 T₁ → T₃ → T₅ → T₂ → T₄ T₁ → T₂ → T₄ → T₃ → T₅ T₁ → T₂ → T₃ → T₄ → T₅ T₁ → T₂ → T₃ → T₅ → T₄ T₁ → T₃ → T₂ → T₅ → T₄ T₁ → T₃ → T₂ → T₄ → T₅ 다음 스케줄에 대해 타임스탬프 순서 기법을 적용하였을 때 설명이 올바른 것은? (TS(Ti)는 트랜잭션 Ti의 타임스탬프이고, read_TS(x)는 read(x) 연산을 성공적으로 수행한 트랜잭션의 타임스탬프 중 가장 큰 것이고, write_TS(x)는 write(x) 연산을 성공적으로 수행한 트랜잭션들의 타임스탬프 중 가장 큰 것이다. read_TS(x)와 write_TS(x)의 초기 값을 모두 10이라고 가정한다.) 2시: T1 read(x) 3시: T2 write(x) 4시: T1 write(x) a. 토마스 기록 규칙을 적용하면, T1의 write(x)는 무시된다. TS(T1) &lt; TS(T2) " }, { "title": "[데이터 정보 처리 입문] 13강 - R을 활용한 자료 분석 2", "url": "/posts/knou-dip-13/", "categories": "Data Science, Data Analysis", "tags": "knou, data information processing", "date": "2025-05-16 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김성수, 이기재 교수님의 '데이터 정보 처리 입문' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 R을 이용하여 데이터를 읽고, 처리하는 방법을 알아보고, 기술 통계 량을 구하는 법, 히스토그램 등 기본적인 통계 그래프를 그리는 방법을 공부함 Function문, 정규 분포, 이산형 및 연속형 그래프 등에 대해 알아봄학습 목표 Function문 사용법을 설명할 수 있음 정규 분포를 이해할 수 있음 이산형 그래프를 그릴 수 있음 연속형 그래프를 그릴 수 있음강의록Function문Function문 자주 쓰이는 계산 등은 Function문으로 작성하는 것이 좋음 제곱 값을 반환하는 함수: sq_value &lt;- (function(x) { x*x }) sq_value(4) power 값을 반환하는 함수 fpower &lt;- function(x,n) {x^n} fpower(3, 2) fpower(4, 1/2) 여러 개의 power 값을 동시에 반환하는 함수 : powerfun.r power_value &lt;- function(x, n1, n2, n3=5) { n1_val = x^n1 n2_val = x^n2 n3_val = x^n3 value = list(v1=n1_val, v2=n2_val, v3=n3_val) return(value) } source(\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/powerfun.R\") # 작성된 프로그램을 r에서 배치로 수행하는 방법 power_value(2, 1/2, 2, 3) power_value(2, 1/2, 2) 정규분포정규분포 (normal distribution) 정규분포 그리기 # -3부터 3까지의 구간에서 표준 정규분포(평균 0, 표준편차 1)의 확률밀도함수 그래프를 그림 plot( function(x) dnorm(x), # x값에 대해 표준 정규분포의 밀도 값을 계산하는 함수 -3, # x축의 최소값 3, # x축의 최대값 main = \"정규분포\" # 그래프 제목을 정규분포로 설정 ) Pr(X ≤ x) 구하기 pnorm(0) # 표준 정규분포에서 0 이하일 확률을 구하는 함수 pnorm(1) # 표준 정규분포에서 1 이하일 확률을 구하는 함수 pnorm(2) # 표준 정규분포에서 2 이하일 확률을 구하는 함수 pnorm(3) # 표준 정규분포에서 3 이하일 확률을 구하는 함수 정규 분포 난수(random number) 생성 정규 분포를 따르는 난수 생성 rnorm 함수 이용 평균이 0, 표준 편차가 1인 정규 분포를 따르는 난수 20개 생성 rnorm(20) # 표준 정규분포에서 난수 20개 생성 평균이 -5이고, 표준 편차가 2.5인 정규분포를 따르는 난수 100개 생성 rnorm(100, -5, 2.5) # 평균이 -5, 표준편차가 2.5인 정규분포에서 난수 100개 생성 난수 생성 후 평균, 표준 편차 확인 및 히스토그램 그리기 ran_norm = rnorm(100) # 표준 정규분포에서 난수 100개를 생성하여 ran_norm에 저장 mean(ran_norm) # ran_norm 값들의 평균값 계산 sd(ran_norm) # ran_norm 값들의 표준편차 계산 hist(ran_norm) # ran_norm 값들에 대한 히스토그램(분포도) 생성 이산형 그래프 그리기예제 1 세 그룹(C1, C2, C3)이 다섯 자선단체(T1,…,T5)에 기부하는 다음 가상 자료를 이용하여 막대 그림, 원 그림을 그려보자 막대 그림 그리기 데이터 읽기 percData &lt;- read.table(\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/dataintro/perc.txt\", header=T) # perc.txt 파일을 데이터프레임으로 불러오기, 첫 행을 변수명으로 사용 percData &lt;- as.matrix(percData) # 데이터프레임을 행렬로 변환 var_name &lt;- colnames(percData) # 열(변수)이름을 var_name 변수에 저장 case_name &lt;- rownames(percData) # 행(케이스)이름을 case_name 변수에 저장 막대 그림 그리기 # barplot barplot(percData, names=var_name) # percData 행렬을 막대그래프로 그림. x축 이름은 var_name 사용 legend(locator(1), case_name) # 그래프에서 클릭한 위치에 범례 추가, 범례 이름은 case_name title(\"Barplot\") # 그래프 제목을 \"Barplot\"으로 설정 원 그림 그리기 원 그림 그리기 # Piechart pie(percData[,1], labels=case_name) # percData의 첫 번째 열의 값을 케이스별로 파이차트로 그림, 라벨은 case_name 사용 title(\"Pie Chart of Company 1\") # 그래프 제목을 \"Pie Chart of Company 1\"으로 설정 예제 2 한 설문조사에서 다음 6개 문항에 대하여 표본 추출 된 40명을 대상으로 조사한 자료이다. R을 이용하여 교육 정도에 대한 수직형 막대 그림을 그려라. 또 각각의 성별(남자, 여자)에 대하여 교육 정도에 대한 수직형 막대그림을 그려라. 막대 그림 그리기ex8_2 = read.csv(\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/dataintro/ex8-2.csv\") # ex8-2.csv 파일을 읽어와 ex8_2 데이터프레임에 저장colnames(ex8_2) # 데이터프레임의 열(변수)이름을 확인edu_tb = table(ex8_2$edu) # ex8_2 데이터프레임의 edu' 변수의 각 값에 대한 빈도표(도수분포표)를 생성하여 edu_tb에 저장edu_tb # 생성된 도수분포표를 확인rownames(edu_tb) = c(\"무학\", \"초졸\", \"중졸\", \"고졸\", \"대졸\") # 각 도수에 해당하는 교육단계별 이름을 부여edu_tb # 이름이 부여된 도수분포표를 다시 확인barplot(edu_tb) # 교육단계별 빈도를 막대그래프로 시각화성별 구분 막대 그림 그리기EduSex = list(ex8_2$sex, ex8_2$edu) # sex와 edu 데이터를 리스트로 묶음EduSex_tb = table(EduSex) # 두 범주형 변수(sex, edu)로 교차표(도수분포표)를 생성EduSex_tb # 생성된 교차표 확인colnames(EduSex_tb) = c(\"무학\", \"초졸\", \"중졸\", \"고졸\", \"대졸\") # 열이름을 한글로 지정rownames(EduSex_tb) = c(\"남성\", \"여성\") # 행이름을 한글로 지정EduSex_tb # 한글 라벨이 적용된 교차표 확인barplot(EduSex_tb) # sex와 edu에 대한 누적 막대그래프를 그림성별 구분 원 그림 그리기# Piechartpar(mfrow=c(1,2)) # 그래프 영역 분할pie(EduSex_tb[1,]) # 남성 교육 정도 원그림title(\"Education of Male\")pie(EduSex_tb[2,]) # 여성 교육 정도 원그림title(\"Education of Female\")연속형 그래프 그리기상자 그림 percData의 세 회사(C1, C2, C3) 상자 그림 그리기 percData &lt;- read.table(\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/dataintro/perc.txt\", header=T) percData &lt;- as.matrix(percData) var_name &lt;- colnames(percData) case_name &lt;- rownames(percData) boxplot(percData[,1], percData[,2], percData[,3], names=var_name) # percData의 세 열에 대해 상자 그림을 그림. 각 boxplot의 이름은 var_name 사용 title(\"Box Plot\") # 그래프 제목을 Box Plot으로 설정 줄기-잎 그림 및 히스토그램 자유도가 5인 t-분포를 따르는 난수 50개를 만들어 히스토그램 및 줄기-잎 그림 그리기 my_sample &lt;- rt(50, 5) # 자유도 5인 t-분포에서 임의로 50개의 샘플을 생성하여 my_sample에 저장 hist(my_sample) # 생성된 샘플(my_sample)에 대한 히스토그램을 그림 -&gt; 데이터의 분포를 시각적으로 확인 stem(my_sample) # 생성된 샘플(my_sample)에 대한 줄기-잎 그림을 출력 -&gt; 데이터의 분포와 개별 값들을 세밀하게 확인 시계 열 그림 R 시스템에 내장된 데이터 co2를 이용한 시계열 그림 그리기 co2 # 내장된 월별 대기 중 CO2 농도(time series 데이터) 출력 plot(co2) # co2 데이터를 시계열(time series) 그래프로 그림 lines(smooth(co2), col=\"BLUE\") # co2 데이터에 스무딩 처리를 한 선을 파란색으로 그래프 위에 추가 smooth() 함수 이동 평균 등의 방식으로 데이터를 부드럽게 처리 lines() 원본 데이터 위에 스무딩된 선을 덧그림 함수 그리기 수학 함수 그래프 그리기 x = seq(-30, 30, 0.1) # -30부터 30까지 0.1 간격으로 x값을 생성 y = 2*(x-3)^3 + (x-2)^2 + 4*x - 3 # y = 2(x-3)^3 + (x-2)^2 + 4x - 3 함수를 x의 값에 따라 계산 plot(x, y, type=\"l\") # (x, y) 좌표를 선(line) 그래프로 그림 abline(h=0, v=0, lty=2) # y=0(수평축), x=0(수직축)을 점선(linetype=2)으로 추가 히스토그램 그리기 예제2 자료에서 변수 age 히스토그램 그리기 ex8_2 = read.csv(\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/dataintro/ex8-2.csv\") # 지정한 경로의 CSV 파일에서 데이터를 읽어와 ex8_2라는 데이터프레임에 저장함 ageHist = hist(ex8_2$age, col=\"BLUE\") # ex8_2 데이터의 age 변수로 파란색 히스토그램 그리고 결과 객체를 ageHist에 저장 names(ageHist) # 히스토그램 객체(ageHist)의 구성 요소 이름을 확인 ageHist$breaks # 히스토그램의 구간(계급)의 경계값(벡터) 확인 ageHist$counts # 각 구간(계급)별 데이터 개수(도수) 확인 ageHist$mids # 각 구간(계급)의 중앙값 확인 그룹별 줄기-잎 그림 그리기 예제2 자료에서 남녀(sex)별로 변수 age 줄기-잎 그림 그리기 stem(ex8_2$age[ex8_2$sex==1]) # 성별이 1인 사람들의 나이에 대한 줄기-잎 그림 출력 stem(ex8_2$age[ex8_2$sex==2]) # 성별이 2인 사람들의 나이에 대한 줄기-잎 그림 출력 library(aplpack) # stem.leaf.backback 함수를 사용하기 위해 aplpack 패키지 로드 m_age = ex8_2$age[ex8_2$sex==1] # 남성(male)의 나이 데이터 벡터 생성 f_age = ex8_2$age[ex8_2$sex==2] # 여성(female)의 나이 데이터 벡터 생성 stem.leaf.backback(m_age, f_age) # 남성과 여성의 나이 분포를 비교하는 back-to-back(양방향) 줄기-잎 그림 출력 그룹별 상자 그림 그리기 그룹별 상자 그림 그리기 boxplot(age ~ sex, data=ex8_2) # # ex8_2 데이터에서 sex에 따라 age의 분포를 상자 그림으로 그림 각 상자는 해당 sex 그룹의 age 분포(최소값, 1사분위수, 중앙값, 3사분위수, 최대값 등)를 시각적으로 나타냄 그룹 구분 산점도 그리기 예제2 자료에서 남녀(sex)별로 구분한 (나이, 월수입) 산점도 그리기 plot(ex8_2$age, ex8_2$salary, type=\"n\") # 빈 그래프 영역 생성 points(ex8_2$age[ex8_2$sex==1], ex8_2$salary[ex8_2$sex==1], pch=\"M\", col=4) # 남성 데이터 점 추가 points(ex8_2$age[ex8_2$sex==2], ex8_2$salary[ex8_2$sex==2], pch=\"F\", col=2) # 여성 데이터 점 추가 legend(\"bottomright\", legend=c(\"Male\",\"Female\"), pch=c(\"M\",\"F\"),col=c(\"BLUE\",\"RED\")) # 범례 추가 plot(ex8_2$age, ex8_2$salary, type=\"n\") # 전체 데이터에서 age를 x축, salary을 y축으로 사용하여 좌표 평면만 생성함 (type=\"n\"은 점이나 선을 그리지 않고 빈 그래프만 만듦) points(ex8_2$age[ex8_2$sex==1], ex8_2$salary[ex8_2$sex==1], pch=19, col=4) # sex가 1인 사람들의 age와 salary 데이터를 파란색(col=4) 원형 점(pch=19)으로 그래프에 그림 points(ex8_2$age[ex8_2$sex==2], ex8_2$salary[ex8_2$sex==2], pch=17, col=2) # sex가 2인 사람들의 age와 salary 데이터를 빨간색(col=2) 삼각형 점(pch=17)으로 그래프에 그림 legend(\"bottomright\", legend=c(\"Male\",\"Female\"), pch=c(19,17), col=c(4,2)) # 그래프 오른쪽 하단에 범례를 추가하여 파란색 원(pch=19, col=4)이 Male, 빨간색 삼각형(pch=17, col=2)이 Female을 의미함을 표시 R 알기R 기여자 S language 개발 John Chambers, Richard Becker, Allan Wilks 등 Bell Laboratories (formerly AT&amp;T, now Lucent Technologies Reference Richard A. Becker, John M. Chambers, and Allan R. Wilks. The NewS Language. Chapman &amp; Hall, London, 1988. R 초기 개발자 Robert Gentleman and Ross Ihaka Statistics Department of the University of Auckland R 매뉴얼 An Introduction to R R BooksR Commanderlibrary(Rcmdr)R Studio R Studio 사용자가 친숙하게 R을 쉽게 사용할 수 있도록 개발된 통합 환경 시스템 다운로드 www.rstudio.com 연습 문제 다음 R 명령 수행 결과는? sq.value &lt;- (function(x) { x*x }) sq.value(2) a. 4 다음 R 명령 수행 결과는? power.value &lt;- function(x,n1,n2,n3=5) { n1.val = x^n1 n2.val = x^n2 n3.val = x^n3 value = list(v1=n1.val, v2=n2.val, v3=n3.val) return(value) } aval = powr.value(2, 1/2, 2) aval$v1 a. 1.414 다음 R 명령 수행 결과는? power.value &lt;- function(x,n1,n2,n3=5) { n1.val = x^n1 n2.val = x^n2 n3.val = x^n3 value = list(v1=n1.val, v2=n2.val, v3=n3.val) return(value) } aval = powr.value(2, 1/2, 2) aval$v3 a. 32 상자 그림을 그리는 명령은? a. boxplot(ex.data) " }, { "title": "[유비쿼터스 컴퓨팅 개론] 13강 - 스마트 자동차", "url": "/posts/knou-uqc-13/", "categories": "Computer Science, CS Theory", "tags": "knou, ubiquitous computing", "date": "2025-05-15 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정광식 교수님의 '유비쿼터스 컴퓨팅 개론' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 각 자동차 제조사는 인포테인먼트, 자율 주행, 첨단 운전자 보조 시스템(ADAS) 드응 특정 기능을 차량에 접ㅈ목하고 있으며, 궁극적인 스마트 자동차는 이런 모든 기능을 갖춘 형태로 발전하고 있음 음석 인식 기술도 애플의 시리(Siri)처럼 대화형 방식으로 발전함에 따라 운전자와 자동차가 더욱 자연스럽게 상호 소통이 가능하게 됨 자율 주행은 첨단 운전자 보조 시스템의 발전을 통해 안정성을 높여 가고 있음 자동차-IT 기술 융합의 주요 경향은 연결성, 운전자의 안정성 및 편의성 향상, 친환경, 자율 주행, 차량용 앱과 자체 앱스토어, 자동차 운영 체제 기술 등으로 요약할 수 있음 스마트 자동차의 개념과 주요 기술에 대해 살펴 봄학습 목표 고도의 안전과 편의를 제공하는 스마트 자동차의 개념을 이해 함 운전자의 안전성과 편의성을 위한 기술과 조작성과 접근성을 높이는 자율 주행 기술을 이해함강의록스마트 자동차스마트 자동차의 정의 스마트 자동차(Smart Car)의 사전적 의미 첨단 컴퓨터 · 통신 · 측정 기능 등을 이용하여 자동으로 운행할 수 있는 차량 기계 중심의 자동차에 전기, 전자, 정보통신, 제어 기술을 적용하여 높은 수준의 안전과 편의 기능을 제공할 수 있는 자동차 자동차의 내 · 외부 상황을 실시간으로 인식하여 도로 위의 위험에 대처할 수 있는 안전성과 탑승자의 만족을 극대화하는 편의 기능을 갖춘 인간 친화적인 이동수단스마트 자동차의 개념 차량에서 외부 통신을 기반으로 차량 내 정보를 통합 관리하고 운전자에게 필요한 정보를 제공하거나, 오락, 영화 등 다양한 콘텐츠를 즐길 수 있음 스마트폰과 같은 모바일 기기와 이동통신 기술을 이용하여 텔레매틱스(Telematics)나 인포테인먼트(Infotainment)로 필요에 따라 고객의 편의를 높일 수 있음 지리 정보 데이터베이스에 축적된 경로 정보뿐만 아니라 해당 지역의 역사나 특산품, 호텔이나 식당과 같은 주변 정보, 운전자 개인의 성향을 고려한 맞춤형 부가 정보도 제공할 수 있음 주변 상황을 인지하는 차량용 센서와 차량 · 사물 통신(V2X: Vehicle to Everything Communication) 등을 활용하여 운전자에게 실시간 경로 정보와 교통 상황을 알려 줄 수도 있음 사고 위험을 줄이기 위해 신호등이나 도로 인프라와 상호 통신하면서 능동적인 안전 운전을 지원함 자동차 내부 상태 정보나 도로 상황 정보를 사전에 인식하여 차량 결함, 충돌, 돌발 상황과 같은 위험 요소로부터 사고 발생 확률을 줄여 탑승자의 안전을 향상 시킬 수 있음 스마트 자동차 개념도 자동차 내에 다양한 센서, 디스플레이 장치, 통신 모듈 등이 추가되면서 자동차는 새로운 IT 플랫폼으로 부상하고 있음 다양한 콘텐츠를 소비하는 새로운 스마트 기기로서 스마트 자동차의 역할도 점차 커지고 있음 스마트 자동차의 궁극적인 목표: 자율 주행이 가능한 무인 자동차 다양한 첨단 기술이 적용된 전장 부품과 소프트웨어는 자율 주행을 실현하기 위한 핵심 기술임스마트 자동차 전형 스마트 자동차 통신을 통한 연결성을 강조한 커넥티드 카와 운전자의 조작 없이 스스로 주행하는 무인 자동차의 특성을 모두 갖춘 자동차를 의미함 커넥티드 카 자동차 내부의 각종 기기와 외부의 시스템이 무선 통신을 통해 연결 되어 차량 자체를 정보 기기처럼 활용할 수 있는 자동차를 말함 스마트 자동차의 유사 용어 커넥티드 카 (Connected Car) 자동차에 통신 기능을 탑재하여 외부 인프라와 연동(예: 클라우드)하고 운행 정보를 주변의 차량(V2V: Vehicle to Vehicle communication) 및 도로 인프라(V2I: Vehicle to Infrastructure communication)와 공유하여 사고 예방 및 안전 운전을 도모하고 편의성을 향상 시킨 차 ex) 스마트폰과 자동차 연결 자율 주행차 (Self-driving Car, Autonomous Car) 사람이 탑승한 상태에서 사람의 개입(제어) 없이 자동차 스스로 목적지까지 주행할 수 있는 자동차 스마트 자동차 (Smart Car) 전기 · 전자 · 통신 기술을 융합해 고도의 안전·편의를 제공하는 자동차로, 통신망에 상시 연결된 커넥티드 카를 의미(협의의 의미) 커넥티드 카뿐만 아니라 자율 주행 자동차의 의미까지 포함(광의의 의미) 무인 자동차 (Unmanned Vehicle, Driverless Car) 사람이 탑승하지 않았거나 운전석에서 운전하지 않은 상태에서 특정 목적을 달성하는 차량 자동차의 자동화 단계 미국의 도로 교통 안전국(NHTSA)의 자율 주행 자동차에 대한 5단계의 자동화 정의자동차의 자동화 단계 - 자율 주행 자동차의 자동화 5단계 자동화 단계 정의 개요 레벨 0 비자동화 (No Automation) 자율 주행 시스템의 작동 없이 오로지 운전자에 의해 통제되는 자동차     브레이크, 속도 조절, 조향 등 안전에 민감한 기능을 운전자가 항상 제어하고 교통 모니터링 및 안전 조작도 책임 레벨 1 특정 기능 자동화 (Function-specific Automation) 특정 기능을 지원하는 자동화 시스템이 1개 이상 탑재된 자동차로 현재 운행되는 대다수 차량     일부 기능을 제외하면, 정상적인 주행 혹은 사고나 충돌 임박 상황에서 자동차 제어권을 운전자가 소유     ex) 적응형 순항 제어 장치, 전자식 차체 자세 제어 장치, 자동 긴급 제동 시스템 레벨 2 조합 기능 자동화 (Combined Function Automation) 대부분의 상황에서 운전자가 자동차를 운전하지만, 2개 이상의 자동화 시스템이 탑재되어 차량을 통제하는 수준의 자동차     특정 주행 환경에서 2개 이상의 제어 기능이 조화롭게 작동 (단, 운전자가 여전히 모니터링 및 안전에 책임을 지고 자동차 제어권을 소유)     ex) 적응형 순항 제어 장치 및 차선 중앙 유지[Lane Centering], 핸들 및 페달 미제어 레벨 3 제한된 자율 주행 (Limited Self-Driving Automation) 본격적인 자율 주행 시스템을 갖춘 자동차     특정 교통 환경에서 자동차가 모든 안전 기능을 제어     자동차가 모니터링 권한을 갖되 운전자 제어가 필요한 경우 경고 신호 제공     운전자는 간헐적으로 제어     ex) 구글 웨이모, 메르세데스-벤츠 S클래스, 현대자동차 제네시스 G90, 혼다 레전드 등 레벨 4 완전 자율 주행 (Full Self-Driving Automation) 완벽한 자율 주행이 가능한 차량으로 운전자 없이도 스스로 움직이는 자동차     자동차가 모든 안전 기능을 제어하고 상태 모니터링 가능     운전자는 목적지나 기능 설정만 함     안전운행에 대한 책임은 자율주행 시스템에 있음 자동차의 자동화 단계 - 자율 주행 자동차에 대한 총 5단계 현재 대부분의 자동차 업체는 레벨 2의 자동화 기능을 제공하고 있음 주차 보조, 차선 이탈 방지 시스템 등의 기능을 제공하고 있음 구글 웨이모는 운전자가 항상 존재한다는 점에서 레벨 3라 할 수 있음 레벨 4는 자동차 자동화의 궁극적 목표인 완전 자율 주행 단계임자동차의 자동화 단계 2023년에 레벨 3의 차량 양산 시스템이 구축되어 본격적으로 생산되고, 2025년에는 레벨 4의 자동차도 볼 수 있을 것으로 예상 됨 완전 자율 주행하는 스마트 자동차의 도입은 운전 미숙, 과속, 음주 운전 등 운전자의 과실에 의해 발생하는 교통사고를 감소 시키고 관련 비용을 절감 시킬 수 있음 운전이 어려운 고령자, 장애인, 면허 미소지자 등에게 차량 이동성을 지원함 일반인들에게는 운전 부담을 줄여 운전자 스트레스를 감소 시킴으로써 생산성을 향상 시킬 수 있음 원활한 교통 흐름을 통한 연료 효율성 향상과 이로 인한 오염 물질 배출을 감소 시킬 수 있음스마트 자동차의 주요 기술개요 스마트 자동차 관련 기술은 크게 운전자의 안전성을 위한 기술과 편의성을 위한 기술, 조작성과 접근성을 높이는 자율 주행 기술로 나눌 수 있음 안전성 기술 차량 결함, 사고 예방 및 회피, 충돌 등의 위험 상황으로부터 운전자 및 탑승자를 보호하고 교통사고로 인한 피해를 경감하는 기술 편의성 기술 자동차에 흥미를 부여하고 운전자 편의를 극대화하여, 자동차를 가정, 사무실에 이은 제 3의 주거 공간으로 활용하는 기술 자율 주행 기술 차량에 설치된 센서, 카메라 등으로 교통 신호, 차선, 장애물 등에 대한 정보를 수집하고 이를 이용하여 차량에 내장된 컴퓨터가 주변 상황에 맞게 차량을 스스로 운행하는 기술 스마트 자동차 관련 주요 기술 자동차 센서 기술 자동차 안전 기술 자율 주행 시스템 기술 자동차 편의 기술 자동차 센서 기술의 발전 배경 야노 경제 연구소 (Yano Research Institute) 2015년에는 자동차 1대당 약 200개의 센서가 사용되었는데, 2020년에는 약 300개로 늘어났으며, 센서의 개수는 지속적으로 증가하고 있음 소비자의 경제력이 향상되면서 비용이 다소 증가하더라도 자동차의 품질, 신뢰성, 편의성 및 안전성에 대한 요구가 증대되어 왔음 센서 및 전기/전자, 정보 통신, 소프트웨어 기술의 발전으로 고성능 저비용 시스템 개발이 가능해졌음 환경 오염 방지를 위한 자동차 배기 가스 감축, 연료 경제성 제고 및 안전 등에 대한 법적인 규제가 강화되고 있음자동차 센서 스마트 자동차 구동을 위한 부품과 센서 스마트 자동차에 적용되는 센서는 동력 제어, 안전 제어, 편의 제어, 정보통신 기술 연동 목적으로 구분할 수 있음 초기에는 자동차 엔진 제어를 위해 센서가 주로 사용되기 시작함 이후에는 차체 제어를 위한 브레이크 잠김 방지 시스템(ABS), 전자식 주행 안정 프로그램(ESP) 센서 에어백과 공조 제어, 조명 제어 등으로 센서의 활용이 늘어났음 압력 센서와 회전 및 위치 파악을 위한 자기 센서도 많이 사용되고 있음 충돌 방지 목적으로 전후방 물체를 인식하기 위한 초음파 센서, 카메라 기반 센서, 레이더 센서, 레이저 레이더 센서 등도 사용이 증가하고 있음 스마트 자동차용 센서는 미세 전기 기계 시스템 기술의 발전을 견인하고 있음 압력 센서, 가속도 센서, 각속도 센서 등은 자동차의 안정성과 편의성 향상에 중요한 역할을 하고 있음자동차 안전 기술 자동차 안전 기술은 자동차가 도로, 기상 여건, 장애물 등의 주변 상황을 인식하면서 자동차를 능동적으로 제어하여 안전도를 높이는 기술을 의미 동작은 단계 순서로 이루어짐 외부 주행 환경 인식 주행 상황 판단 운전자 경보/표시 차량 제어 안전 기술 작동 영역 교통사고 발생 전 예방을 위한 능동적 안전성 사고 후 피해를 줄이고 확대를 방지하는 수동적 안전성 능동적 안전성 주행 시 운전을 지원함 위험 상황이 발생하면 미리 사고를 예방함 충돌 직전까지 사고를 회피하도록 지원함 다양한 차량 통신(V2V, V2I, V2N) 기술을 함께 활용한다면 교통사고 확률을 더 감소 시킬 수 있음 차량 내에서 수집한 정보 뿐만 아니라 외부에서 운행하는 다른 자동차와 도로 인프라가 수집한 정보도 함께 활용할 수 있기 때문임 스마트 자동차 안전 제품군의 분류 분류 정의 대표적인 스마트 안전 시스템 운전 지원 차량의 일반적인 주행 상황에서 편리한 운전 조작으로 안전 운전을 지원하는 주행 지원 기술 적응형 순항 제어 장치, 차선 유지 보조 시스템, 주차 보조 시스템, 차량용 전방 표시 장치, 인공지능 전조등 시스템, 야간 시야 시스템, 어라운드뷰 모니터링 시스템 등 사고 예방 위험 상황과 운전자 상태를 감지하여 사고 발생 가능성이 있는 경우, 경고하여 사고를 미연에 방지하는 기술 타이어 압력 모니터링 시스템, 차선 이탈 경보 시스템, 전방 차량 충돌 경고 장치, 사각 지대 경고 장치 등 사고 회피 차량 상태의 위험 상황과 운전자 상태를 감지하여 사고 발생 가능성이 있는 경우, 사고를 회피시키는 차량 제어 기술 브레이크 잠김 방지 시스템, 전자식 자세 제어 장치, 차량 자세 제어 장치 등 구동 제어 장치 사고 피해 경감 사고 발생이 불가피한 경우, 사고 피해를 최소화 또는 경감할 수 있는 안전 기술 액티브 헤드레스트, 능동 안전벨트(Pre-safe Seatbelt), 스마트 에어백 등 자율 주행 시스템 기술 스마트 자동차의 자율 주행 기술 운전자의 조작 없이 자동차 스스로 주행 환경을 인식하면서 목표 지점까지 운행하여 운전자의 부주의로 인한 교통사고를 미연에 방지하고 편리한 운전 환경을 제공함 (반)자율 주행 시스템 개별 능동 안전 시스템을 통합하여 자동차 스스로 자율 주행이 가능함 자동 대리 주차, 전용 도로 자율 또는 군집 주행 등 일종의 자율 주행 기술임 자율 주행 자동차는 크게 센서, 프로세서, 알고리즘, 구동기 등으로 구성됨 자율 주행 센서를 통해 차량 주변의 환경에 대한 데이터를 수집한 후, 프로세서가 미리 정의된 알고리즘을 통해 데이터 처리 결과를 해석하여 주행에 관한 의사 결정을 내린 후 구동기를 통해 실행함 일련의 과정 중 중요한 것은 센서를 통해 수집 된 대량의 데이터를 바탕으로 조향, 속도, 운행에 관한 의사 결정을 내리는 소프트웨어 알고리즘임 자율 주행 기술은 스스로 인식할 수 있는 범위 내에서 수집한 데이터를 기반으로 독자적인 판단을 하지만, 시야 한계 너머에서 일어나는 도로 교통 정보를 사전에 파악하여 이를 활용하는 방향으로 발전하고 있음자동차 편의 기술 자동차 전장화의 진전과 모바일 기술의 발달로 자동차가 이동 통신, 무선 인터넷, GPS 등 외부 통신 인프라와 연결되어 정보 검색, 내비게이션, 텔레매틱스, 인포테인먼트 등 다양한 서비스를 이용할 수 있는 정보 통신 자동차로 탈바꿈하면서 탑승자의 편의성이 증대되고 있음 텔레매틱스 텔레커뮤니케이션과 인포매틱스의 합성어 유무선 통신으로 자동차 안의 단말기를 통해 자동차와 운전자에게 다양한 종류의 정보 서비스를 제공해 주는 기술 자동차에 위치 측정 시스템(GPS)과 지리 정보 시스템을 장착하여 운전자와 탑승자에게 교통 정보 제공, 응급 상황 대처, 원격 차량 진단, 인터넷 이용 등 각종 모바일 서비스 제공 카오디오, TV 모니터, 내비게이션, 핸즈프리 휴대 전화 기능이 모두 통합되고, 음성 인식, 문자 음성 변환(TTS: Text-To-Speech) 등의 기능을 위한 마이크와 스피커, 액정 디스플레이, 키보드, 터치스크린 등의 특별한 입출력 장치가 설치됨 플래시 메모리나 개인용 디지털 단말기, 노트북 컴퓨터 등을 이용하여 외부와 데이터 전송 가능 자동차에 내장되거나 스마트폰과 연동되어 인터넷에 접속하여 각종 정보를 주고받거나, 클라우드에 저장된 정보 또는 클라우드가 수집한 개인 맞춤형 정보의 제공 가능 자동차 관리 서비스 회사의 서버가 자동차의 주요 부품의 상태를 원격 모니터링하거나, 교통사고가 발생했을 때 자동으로 응급 신호를 보내는 등의 서비스 제공 인터넷과 클라우드를 통해 정보 연결성과 데이터 접근성으로 개인 정보 뿐만 아니라 자동차 제어 시스템에도 접근할 수 있어 보안과 안전 측면의 고려 필요 차량용 인포테인먼트 자동차 안에 설치된 여러 정보 기술 기기들이 정보와 재미, 즉 인포테인먼트 서비스를 제공하는 것 자동차 내비게이션에서 맛집과 같은 정보 제공이나 오락 기능의 제공 고객의 차량 구매에서 인포테인먼트 기능이 중요한 기준이 되고 있음 안전 부문과 달리 논란의 소지가 적고 제품 수명 주기가 짧아 교체 수요가 많은 것도 특징임 교통 정보와 위치 정보를 분석해 내비게이션 서비스를 제공하는 증강 현실 내비게이션 서비스와 차량 위치에 따라 주변 정보를 실시간으로 감지하여 맞춤형 정보를 제공하는 인포모티브(Informotive) 서비스도 인포테인먼트 서비스 중 하나임 탑재된 태블릿 PC나 스마트폰을 통해 영화, 음악, 게임 등을 이용하는 엔터테인먼트가 가능함 교차로 위반 통제, 전자 지불, 원격 자동차 진단 및 자가 수리 등도 가능함 자동차에 다양한 소프트웨어가 설치되고 사용됨에 따라 애플의 ‘앱 스토어’와 같은 개방형 생태계가 자동차 산업에도 도입되고 있음 스마트 자동차의 핵심 기능인 지능화뿐만 아니라 부가적인 스마트 기능도 시현되어 새로운 가치 창출이 가능해지고 있음 정리 하기 스마트 자동차는 첨단 컴퓨터 · 통신 · 측정 기술 등을 이용하여 자동으로 운행할 수 있는 차량이다. 스마트 자동차 관련 기술은 크게 운전자의 안전성과 편의성을 위한 기술과 조작성 및 접근성을 높이는 자율 주행 기술로 나눌 수 있다.연습 문제 일부 기능을 제외하면 정상적인 주행 혹은 사고나 충돌 임박 상황에서 자동차 제어권을 운전자가 소유하는 자동차의 자동화 단계는 무엇인가? a. 특정 기능 자동화 차량 상태의 위험 상황과 운전자 상태를 감지하여 사고 발생 가능성이 있는 경우, 사고를 회피 시키는 차량 제어 기술은 무엇인가? a. 사고 회피 차량과 주변 인프라 망이 유무선 통신에 의해 접속 되는 단말과 서버 간에 이루어지는 무선 통신 차량에 인터넷 프로토콜(IP) 기반의 교통 정보 및 안전 운행 정보를 내려 받을 수 있는 서비스는 무엇인가? a. 차량 인프라 간 통신(V2I; Vehicle to Infrastructure communication) 정리 하기 스마트 자동차(Smart Car) 첨단 컴퓨터 · 통신 · 측정 기술 등을 이용하여 자동으로 운행할 수 있는 챠랑임 즉, 자동차의 내 외부 상황을 실시간 인식하여 도로 위의 위험에 대처할 수 있는 안정성과 탑승자의 만족을 극대화시키는 편의 기능을 갖춘 인간 친화적인 자동차임 안정성 기술 차량 결함, 사고 예방 및 회피, 충돌 등 위험 상황으로부터 운전자 및 탑승자를 보호하고 교통사고로 인한 피해를 경감하는 기술 편의성 기술은 자동차에 흥미를 부여하고 운전자 편의를 극대화하여 자동차를 가정, 사무실에 이은 제3의 주거 공간으로 활용하는 기술임 자율 주행 기술 운전자의 조작 없이 자동차 스스로 주행 환경을 인식하면서 목표 지점까지 운행하여, 운전자의 부주의로 인한 교통 사고를 미연에 방지하고 편리한 운전 환경을 제공 함 " }, { "title": "[데이터베이스 시스템] 13강 - 트랜잭션", "url": "/posts/knou-dbs-13/", "categories": "Database", "tags": "knou, database", "date": "2025-05-14 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '데이터베이스 시스템' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 DBMS의 핵심 기능 중 하나는 여러 사용자가 동시에 데이터를 공유하더라도 데이터의 일관성과 무결성이 손상되지 않도록 보장하는 것임 데이터에 대한 동시 접근이 이루어질 경우, 적절한 제어가 없다면 불일치나 손실과 같은 문제가 발생할 수 있으며, 이는 시스템 전체의 신뢰성을 저하시킬 수 있음 이러한 문제를 해결하기 위해 DBMS는 트랜잭션(transaction)이라는 단위 작업 개념을 도입하여, 데이터베이스 연산이 원자적으로 수행되고 데이터가 일관 된 상태를 유지할 수 있도록 지원함 트랜잭션의 기본 개념과 트랜잭션 수행의 4가지 핵심 속성인 ACID 특성을 중심으로 살펴 봄 은행 계좌 이체와 같은 사례를 통해 트랜잭션의 처리 과정을 구체적으로 이해하고, 트랜잭션 간의 충돌을 방지하기 위한 직렬성 개념과 시스템 장애 발생 시 일관 된 상태로 복구하기 위한 회복 메커니즘의 기초에 대해 학습함주요 용어 ACID 특성 트랜잭션이 안전하게 수행되는 것을 보장하기 위해 만족 되어야 하는 트랜잭션의 특성으로 원자성, 일관성, 고립성 및 지속성이 있음 동시성 제어 다중 사용자 환경을 지원하는 데이터베이스 시스템에서 데이터의 일관성을 유지하면서 동시에 실행 될 수 있도록 트랜잭션을 제어하는 기능 직렬 스케줄 하나의 트랜잭션에 대해 트랜잭션에 포함 된 모든 연산이 연속적으로 실행 되는 스케줄 병렬 스케줄 하나의 트랜잭션이 완료되기 전에 다른 트랜잭션이 실행 되는 스케줄 강의록트랜잭션의 이해데이터 동시 접근의 문제 동일 데이터에 다수 사용자의 접근 허용 시 일관성이 훼손 동시 처리 요청을 받았지만 상황 고려 없이 개별적인 작업에만 치중해 발생한 문제 일관성과 무결성을 지키기 위해 DBMS는 작업 처리 순서를 일부 조정해야 함 트랜잭션의 개념 트랜잭션의 정의 데이터베이스를 조작하기 위한 하나의 논리적 단위를 이루는 일련의 데이터베이스 연산의 집합 ex) 예금 인출 작업 단위 예금 1000원 인출 일련의 연산 Read(A), A=A-1000, Write(A) ex) 출금의 순서 계좌의 기존 잔고 읽기(read) 일정 금액 차감 데이터베이스를 사용하여 처리하는 작업을 하나의 묶음으로 인식하여 묶음 단위로 실행된 것과 동일한 결과가 도출되도록 정의한 개념데이터 읽기와 쓰기 데이터베이스의 두 연산 Read(X) 데이터베이스에서 데이터 X를 읽고, 트랜잭션이 실행되는 메모리의 변수 X에 값을 저장하는 연산 Write(X) 트랜잭션이 실행되는 메모리에 있는 변수 X의 값을 데이터베이스에 저장하는 연산 ex) 계좌 A에서 B로 1,000원을 이체하는 트랜잭션 트랜잭션의 특징 다수의 연산으로 구성된 트랜잭션이 사용자에게 단일 작업처럼 다뤄지도록 ACID 특징을 준수해야 함 ACID 특성 원자성 (Atomicity) 하나의 트랜잭션에 포함 된 모든 연산은 완전히 수행되거나 전혀 수행되지 않음 일관성 (Consistency) 특정 트랜잭션이 수행되기 전과 후에 데이터베이스가 일관 된 상태를 유지 고립성 (Isolation) 특정 트랜잭션이 데이터베이스를 갱신하는 동안 다른 트랜잭션에 의해 방해 받지 않음 지속성 (Durability) 완료 된 트랜잭션의 결과는 어떠한 시스템의 장애에도 데이터베이스에 반영되어야 함 ACID 특성 유지 원자성 6개 연산이 모두 성공하거나, 하나라도 실패하면 모두 취소되어야 함 Write(A) 후 시스템이 다운되면, 이체는 없었던 것처럼 처리되어야 함 일관성 이체 전 A와 B의 총액이 20000원이었다면, 이체 후에도 A와 B의 총액은 20000원으로 유지되어야 함 중간 단계에서 A:=A-1000만 수행되고 시스템이 멈추면 일시적으로 총액이 19000원이 될 수 있으나, 트랜잭션이 원자성에 의해 완전히 성공하거나 완전히 실패함으로써 최종적으로 일관성을 보장함 고립성 Write(A)는 수행되었지만 Write(B)는 아직 수행되지 않은 상태를 다른 트랜잭션이 관찰할 수 없어야 함 다른 트랜잭션이 이체 중간에 A의 잔액을 조회하면 이체 전 또는 이체 후의 값 중 하나를 보아야 함 지속성 Write(A)와 Write(B) 연산이 성공적으로 수행되어 트랜잭션이 커밋된 후에는, A 잔고 9000원, B 잔고 21000원이라는 상태가 어떤 상황에서도 보존됨 트랜잭션 실행 연산자 트랜잭션 실행의 연산 커밋(commit) 트랜잭션 연산에 의해 갱신 된 데이터 롤백(rollback) 트랜잭션이 중단되기 이전까지 수행한 연산에 의해 갱신 된 모든 데이터 항목의 값을 무효화하여 일관성을 확보 트랜잭션의 5가지 상태 변화 트랜잭션의 상태 동작 트랜잭션이 시작을 준비 또는 실행 중인 상태 부분 커밋 마지막 연산을 실행한 직후의 상태 커밋 모든 실행이 성공적으로 완료 된 후의 상태 실패 실행이 정상적으로 진행될 수 없는 상태 중단 실행 실패로 롤백 되고 시작 이전의 상태로 환원 된 상태 5가지 상태 변화를 통해 ACID 특성을 유지 트랜잭션의 동시성동시성 고려 DBMS는 다수의 사용자가 데이터베이스를 공용으로 사용하기 위한 목적으로 도입 여러 사용자들이 조직의 업무를 효율적으로 하기 위해 만들어놓은 DBMS 시스템 성능을 극대화한 활용은 거의 불가능 시스템 유휴 자원들이 많음 자원 활용률을 높이기 위해 여러 작업을 동시에 해 줄 필요가 있음 다중 사용자 환경에서 트랜잭션의 동시 실행으로 데이터 갱신 시, 일관성 훼손 문제가 발생 일관성을 훼손시키지 않는 선에서 여러 트랜잭션을 동시에 실행하는 것은 자원 활용율과 고객 만족도 관점에서 이점 트랜잭션 동시 실행의 이점 트랜잭션 처리율과 자원 이용률을 향상 트랜잭션의 대기 시간을 감소 동시성 제어(concurrency control) 다수의 트랜잭션이 성공적으로 동시에 실행되어도 일관성을 유지할 수 있도록 지원하는 기법 트랜잭션이 동시에 실행 된다면 각각의 연산을 어떤 순서로 처리할지 결정해야 함 스케줄의 개념 예제 트랜잭션 A와 B에 각각 10,000과 20,000원 잔액 T₁ 1000원을 계좌 A에서 B로 이체 T₂ 계좌 A의 잔고에서 20%를 B로 이체 스케줄(schedule) 다수의 트랜잭션에 포함 된 연산의 실행 순서를 명시한 것 직렬 스케줄 T₁과 T₂가 순차적으로 실행 되는 경우 직렬 스케줄 각 트랜잭션에 속한 모든 연산이 순차적으로 실행 되는 스케줄 병렬 스케줄 T₀과 T₁의 비순차적 실행 되는 스케줄 병렬 스케줄 하나의 트랜잭션이 완료 되기 전에 다른 트랜잭션이 실행 되는 스케줄 병렬 스케줄의 순서로 연산을 수행할 경우 일관성 훼손 문제가 발생할 가능성 내포트랜잭션의 직렬화 직렬 가능 스케줄 복수 개의 트랜잭션이 동시에 수행 된 결과가 직렬 스케줄의 결과와 동일한 스케줄 직렬로 실행 된 것과 다름이 없는 스케줄 동시에 실행되었으나 일관성 문제 없음 직렬 가능 스케줄 트랜잭션 간 연산 순서를 교환하여 트랜잭션을 직렬 스케줄과 동등하게 변환이 가능한 스케줄 사용 된 Read와 Write 연산 교환 시 상황에 따라 실행 결과에 일관성이 훼손 되는 현상(충돌)이 발생 연산 순서의 교환(단, Iᵢ는 Tᵢ의 연산) Iᵢ = Read(Q) Iⱼ=Read(Q) Iᵢ = Read(Q) Iⱼ=Write(Q) Iᵢ = Write(Q) Iⱼ=Read(Q) Iᵢ = Write(Q) Iⱼ=Write(Q) 어느 한 곳에 쓰기 연산이 있으면 순서를 바꾸지 못함 충돌 동등 특정 스케줄 S에서 충돌이 일어나지 않은 연산의 순서를 바꿔 스케줄 S’으로 변환이 가능한 상태 스케줄 S와 스케줄 S’은 충돌 관점에서 동등 충돌 직렬성 순서 교환이 가능한 연산을 교환하여 직렬 스케줄의 연산과 동등하게 변환이 가능한 스케줄 Tⱼ가 Write(A)를 실행하고 Tⱼ가 Write(B)를 실행하려고 함 서로 다른 항목을 쓰는 것은 연산의 순서를 바꾸어도 문제가 발생하지 않음 서로 다른 데이터 항목은 어떤 작업이라도 순서를 바꿔도 괜찮음 무결성, 일관 훼손 여부를 파악 충돌 직렬적 트랜잭션의 회복회복의 개념 트랜잭션 실패 시, 원자성을 보장하기 위해 실행 된 모든 연산을 실행 이전 상태로 복원하는 기법 스케줄에 포함 된 트랜잭션의 수가 매우 많으면 원상복구가 쉽지 않음 회복 불가능한 스케줄 T₆가 T₅가 기록한 A를 읽고 커밋한 상태 T₆는 T₅에 종속적(dependent) 커밋한 T₅는 롤백 불가능 회복 가능한 스케줄 Tᵢ와 Tⱼ에 대해, Tᵢ가 기록한 데이터를 Tⱼ가 읽을 떄, Tᵢ의 커밋이 Tⱼ보다 먼저 나타나는 스케줄 연쇄적 롤백 유발 가능 T₇의 롤백으로 인하여 연쇄적으로 다른 트랜잭션도 롤백 되는 현상 비연쇄적 스케줄 대량의 회복 연산이 발생하는 연쇄적 롤백을 방지하기 위해 연쇄적이지 않은 연산 순서로 구성 된 스케줄 Tᵢ가 기록한 데이터를 읽을 때 Tᵢ의 커밋이 Tⱼ의 읽기 연산보다 먼저 나타나는 스케줄 연습 문제 아래 그림과 같이 시스템 오류 이후, 트랜잭션 T1에 대해 실행 결과가 데이터베이스에 반영이 되었는지를 확인하고, 반영이 되어있지 않았다면, T1을 재실행한다. 이는 트랜잭션의 어떤 특성을 만족 시키기 위한 것인가? a. 지속성 한 번 정상적으로 실행이 완료 된 트랜잭션의 결과는 데이터베이스의 어떠한 소프트웨어적, 하드웨어적 오류에도 반드시 데이터베이스에 반영되어야 함 이러한 트랜잭션의 특성을 지속성(durability)라고 함 다음 중 트랜잭션을 동시에 실행시키는 이유에 대한 설명으로 옳지 않은 것은? a. 데이터베이스의 일관성이 향상된다. 서로 다른 두 트랜잭션이 같은 데이터 항목에 대하여 연산을 수행할 경우 데이터베이스의 일관성이 보장되지 않을 수 있음 따라서 트랜잭션을 동시 수행하기 위해서는 추가적인 고려 사항이 필요함 다음은 무엇에 대한 설명인가? 모든 트랜잭션 순서쌍 Ti와 Tj에 대해, Ti가 기록한 데이터 항목을 Tj가 읽는다면, Ti의 커밋이 Tj의 커밋보다 먼저 나타나는 스케줄 a. 회복 가능한 스케줄(recoverable schedule) 정리 하기 트랜잭션은 데이터베이스를 조작하기 위한 하나의 논리적 작업 단위를 이루는 일련의 연산들의 집합으로, 트랜잭션이 실행 중에 멈추거나 중단되지 않는 최소 작업 단위임 트랜잭션은 ACID 특성이라고 하는 원자성, 일관성, 고립성, 지속성이라는 특성을 갖고 있으며 DBMS는 트랜잭션의 ACID 특성을 만족시키기 위해 지속적으로 명령의 실행과 데이터의 상태를 모니터링함 데이터베이스에 접근 연산을 수행하는 트랜잭션은 트랜잭션 내부에 포함되는 연산의 실행 가능성 여부에 따라 동작, 부분 커밋, 실패, 중단, 커밋 등 다섯 가지 상태 중 하나에 있게 됨 다수의 사용자가 접근하는 데이터베이스에서 동시에 동일한 데이터에 접근할 가능성이 있으며 이러한 상황에서 데이터베이스의 무결성을 보장하고, 트랜잭션의 일관성을 유지하기 위해서는 동시성 제어를 통해 다중 사용자 환경에서 데이터에 대한 접근과 갱신을 통제할 필요가 있음 트랜잭션의 동시 실행 가능 여부를 판단하기 위해서는 해당 트랜잭션으로 작성되는 스케줄 내부에서 트랜잭션 간 연산 순서를 교환하여 트랜잭션을 직렬 스케줄과 동등하게 변환이 가능해야 함 트랜잭션의 원자성을 위해 트랜잭션이 시작 된 이후 중간에 실패하는 경우 트랜잭션이 시작되기 전까지의 상태로 회복시켜야 함 이를 트랜잭션의 회복화라고 함 한 트랜잭션이 수정한 데이터를 다른 트랜잭션이 읽을 경우 데이터를 수정한 트랜잭션의 커밋이 데이터 읽기보다 먼저 실행되는 스케줄을 회복 가능 스케줄이라고 함체크 포인트 트랜잭션의 상태 중 트랜잭션의 수행이 실패하여 Rollback 연산을 실행한 상태는? a. 철회(abort) 데이터베이스 트랜잭션이 올바르게 수행된다는 것을 보장하기 위해 지원해야 하는 트랜잭션 성질에 대한 설명으로 옳지 않은 것은? a. 트랜잭션이 실행되는 동안의 값은 다른 트랜잭션이 접근할 수 있어야 한다. 고립성 확보되지 않아 일관성 훼손 됨 데이터베이스 트랜잭션이 올바르게 수행된다는 것을 보장하기 위해 지원해야 하는 트랜잭션의 성질에 대한 설명으로 옳은 것 각 트랜잭션의 모든 연산이 정상적으로 수행 완료되거나, 아니면 어떠한 연산도 수행되지 않은 원래 상태가 되어야 함 원자성 트랜잭션이 실행되는 동안의 값은 다른 트랜잭션이 접근할 수 없어야 함 고립성 트랜잭션이 성공적으로 끝난 뒤에는, 시스템에 오류가 발생하더라도 트랜잭션에 의해 변경 된 데이터베이스 내용은 계속 유지되어야 함 지속성 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변화 함 일관성 " }, { "title": "[운영 체제] 13강 - 분산 운영 체제", "url": "/posts/knou-os-13/", "categories": "OS, Operating System", "tags": "knou, os", "date": "2025-05-13 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김진욱 교수님의 '운영 체제' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 분산 시스템은 크기나 성능이 다를 수 있는 여러 대의 컴퓨터가 네트워크로 연결되어 이루어지는 시스템임 분산 시스템은 높은 성능과 신뢰성을 제공하기에 컴퓨터가 풀어야 할 문제가 커지고 복잡해지면서 점점 중요해지고 있음 분산 시스템의 기본적인 특징과 구성, 주요 서비스에 대해 살펴 봄학습 목표 분산 시스템의 구조와 특징을 설명할 수 있음 분산 시스템에서 파일, 메모리 등을 공유하는 방법을 설명할 수 있음 분산 시스템에서 원격 프로시저 호출을 설명할 수 있음강의록분산 운영 체제의 개요분산 시스템 크기나 성능이 다를 수 있는 여러 대의 컴퓨터가 네트워크로 연결되어 이루어지는 시스템 분산 시스템의 장점 자원 공유 각 컴퓨터의 자원을 네트워크로 연결된 컴퓨터가 공유 ex) 프린터 공유, 1,000대 컴퓨터의 각 256GB 저장 장치 등 성능 향상 여러 대의 프로세서에 작업을 분할하여 병렬적으로 동시 수행 많은 클라이언트가 동시에 작업을 요청할 때 복수의 서버가 처리 신뢰성 향상 한 대가 고장나더라도 다른 컴퓨터가 작업을 계속 수행 하드웨어나 데이터의 중복을 통한 해결 가능 통신의 편리성 단일 시스템 내부에서 동작하는 서비스와 같은 서비스 제공 ex) A 위치의 파일을 B 위치로 복사 분산 시스템의 네트워크 구성 네트워크 연결 방법 완전 연결 네트워크 각각의 노드들이 다른 노드들과 직접 다 연결 되어 있음 부분 연결 네트워크 분산 시스템 구축 시 고려 사항 망 구축 비용 사이트들을 물리적으로 연결하는 비용 통신 비용 메시지를 보내는 데 필요한 비용 신뢰성 링크나 사이트 고장 시 정상적 동작 가능 정도 네트워크 연결 방법 별 특징 비교 부분 연결 네트워크의 구성 형태 연결 방법 통신 비용 신뢰성 망 구축 비용 트리 구조 비교적 저렴 노드나 링크 고장 시 시스템이 둘 이상으로 분리 n - 1 스타형 저렴 중심 노드 고장 시 전체 네트워크 연결 끊어짐 n - 1 링형 높음 하나의 노드나 링크 고장 나도 연결 안 끊어짐 n 버스형 저렴 버스 고장 나면 전체 네트워크 연결 끊어짐 n 근거리 통신망(LAN) 빠른 속도 좁은 담당 면적 적은 비용 낮은 혼잡, 작은 지연 원거리 통신망(WAN) 느린 속도 넓은 담당 면적 많은 비용 높은 혼잡, 큰 지연 분산 운영 체제 분산 시스템을 관리하기 위한 운영 체제 투명성 제공 로컬 자원과 원격 자원의 구분을 없애 줌 원격 자원 접근에 필요한 일들을 분산 운영 체제가 대신 해 줌 분산 운영 체제에 적용할 수 있는 방법 데이터 이주 원격 데이터를 로컬로 전송해 와서 사용하는 방식 계산 이주 계산을 원격지에서 처리하고 결과를 전송 받는 방식 원격 프로시저 호출(RPC) 이용 프로세스 이주 프로세스 자체를 원격지로 이주 시키는 방식 작업 량 분산, 목적에 부합한 곳에서 프로세스 실행시켜 성능 향상 분산 파일 시스템분산 파일 시스템(DFS) Distributed File System 클라이언트가 원격 파일을 로컬 파일처럼 사용할 수 있게 해 줌 DFS의 네이밍 방식 호스트 이름과 로컬 이름을 조합 host:local_name 원격 디렉터리를 로컬 디렉터리에 마운트 mount -t nfs 10.10.10.10:/backups /var/backups 원격 파일에 대한 요청 처리 RPC를 통해 구현 네트워크 사용이 많아지면 효율성에 문제 캐시를 이용한 분산 파일 시스템 전체 시스템의 성능 높임 고려할 문제 캐시 교체 정책, 캐시 일관성 문제 등 분산 메모리분산 메모리 원격 시스템의 메모리를 효율적으로 접근할 수 있게 함 널리 사용되는 두 가지 모델 원격 메모리 분산 공유 메모리 원격 메모리 원격 메모리 API 이용&lt;(net#, host#, port#), block, offset&gt;분산 공유 메모리 (DSM) Distributed Shared Memory 물리적으로 분리 된 메모리를 하나의 주소 공간을 통해 접근할 수 있게 해 줌 장점 노드 개수가 늘어나도 잘 확장됨 실제로 메모리를 공유하기 위해 해야 할 일들을 프로그래머가 신경 쓸 필요 없음 복잡하고 큰 데이터 처리에 유리 멀티 프로세서 시스템에 비해 저렴 큰 가상 메모리 공간 제공 단점 분산 되지 않은 공유 메모리에 비해 접근 속도 느림 공유 메모리에 동시에 둘 이상이 접근할 때 보호 메커니즘 필요 성능이 떨어질 수 있음 프로그래머가 분산 공유 메모리를 직접 제어하는 것이 쉽지 않음 NUMA Non-Uniform Memory Access 각 프로세서가 로컬 메모리를 갖는 분산 공유 메모리 저장 위치에 따라 속도 차이 발생원격 프로시저 호출원격 프로시저 호출(RPC) Remote Procedure Call 프로세스가 네트워트로 연결 된 다른 컴퓨터에 있는 프로시저를 실행 시키는 것 마치 같은 컴퓨터에 있는 것처럼 이용할 수 있게 함원격 프로시저 호출의 동작 클라이언트는 같은 주소 공간에 있는 프로시저(스텁 루틴)을 호출 스텁 루틴은 매개 변수나 결과를 메시지로 만든 후 네트워크를 통해 전달 원격 프로시저 호출의 구현 고려 사항 이상적으로는 RPC 사용과 로컬 프로시저 사용이 구별되지 않아야 함 서로 다른 주소 공간에 속하기 때문에 메모리 주소를 리턴하는 참조 호출은 의미 없음 RPC 수신자는 호출이 생성된 곳과 유사한 환경에서 실행해야 함 원격 프로시저 호출의 구현 예정리 하기 분산 시스템은 네트워크를 통해 약하게 결합 된 다양한 성능의 프로세서 집합이며, 각 프로세서는 자신의 메모리와 클럭을 사용함 분산 시스템의 장점은 자원 공유, 성능 향상, 신뢰성 향상, 통신의 편리성임 분산 시스템을 관리하기 위한 운영 체제가 분산 운영 체제이며, 사용자가 원격 자원을 로컬 자원을 사용하는 것처럼 쉽게 사용할 수 있고, 둘 사이의 구별 없이 투명성을 제공함 분산 파일 시스템은 클라이언트가 원격 파일과 로컬 파일을 구별하지 않고 처리할 수 있게 함 분산 메모리는 분산 시스템에 속한 컴퓨터들이 메모리를 공유할 수 있게 함 원격 메모리는 논리적 메모리를 정의하고 공유하도록 하는 원격 메모리 API를 통해 분산 메모리를 구현함 분산 공유 메모리는 가상 메모리 기능을 확장하여, 한 주소 공간에 로컬 메모리, 보조 기억 장치, 원격 메모리를 대응 시켜 분산 메모리를 구현함 원격 프로시저 호출(RPC)을 통해 한 컴퓨터에서 동작하는 프로그램이 다른 컴퓨터에 있는 프로시저를 호출할 수 있음" }, { "title": "[Java 프로그래밍] 13강 - 멀티 스레드 프로그래밍", "url": "/posts/knou-java-13/", "categories": "Language, Java", "tags": "knou, java", "date": "2025-05-12 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김희천 교수님의 'Java 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 멀티 스레드 프로그램을 작성하는 방법과 스레드의 실행 과정을 이해함 여러 스레드가 동시에 수행될 때 스레드 간의 협업을 위해 스레드를 제어하는 메소드가 필요함 스레드 간의 상태 변화와 함께 스레드 제어 메소드를 학슴함 여러 스레드가 동일 자원에 접근할 때 반드시 필요한 동기화 방법을 살펴 봄학습 목표 멀티 스레드 프로그램의 실행 과정을 설명할 수 있음 스레드를 생성하고 시작시키는 프로그램을 작성할 수 있음 스레드의 상태 변화와 상태 제어 메소드를 설명할 수 있음 스레드를 동기화 시키는 프로그램을 작성할 수 있음강의록프로세스와 스레드프로세스와 스레드 Java 프로그램은 하나의 프로세스로 만들어져 실행됨 프로세스는 프로그램의 통상적 실행 단위 프로세스는 자원을 확보하고 있는 실행 중인 프로그램 지금까지는 프로세스에서 하나의 스레드가 생성되고, main()메소드가 호출되어 실행됨(단일 스레드) 스레드는 프로세스 내에 존재하는 소규모 실행 흐름 하나의 프로세스 내에 여러 스레드가 동시에 실행될 수 있음 스레드는 경량 프로세스 멀티 스레드 하나의 프로세스 내에서 동시 실행을 위해 존재하는 여러 스레드 Java 프로그램은 하나의 스레드(main스레드)로 시작됨 main스레드에서 자식 스레드를 만들고 시작 시킬 수 있음 그러면 여러 스레드가 동시에 독립적으로 실행되고 종료됨 스레드의 생성Thread클래스 스레드의 생성과 관리를 위한 메소드를 제공 스레드 생성을 위해 Thread클래스의 객체가 필요함 주요 생성자 생성자 설명 Thread() 새로운 스레드를 생성하며, 이름이 Thread-n으로 자동으로 주어짐 Thread(String name) 새로운 스레드를 생성하며, 스레드의 이름을 name으로 지정 Thread(Runnable target) 새로운 스레드를 생성하며, 스레드의 이름이 자동으로 주어짐, 스레드가 실행될 때 target 객체의 run()메소드가 실행됨 Thread(Runnable target, String name) 스레드의 이름을 name으로 지정하며, 나머지는 위와 같음 주요 메소드 메소드 설명 static Thread currentThread() 현재 실행 중인 스레드 객체의 참조 값을 리턴 String getName() this스레드의 이름을 리턴 void setName(String name) this 스레드의 이름을 name으로 변경 int getPriority() this스레드의 우선 순위를 리턴 void setPriority(int newPriority) this스레드의 우선 순위를 newPriority로 변경 void start() run()을 호출하여 this스레드를 실행시킴 스레드의 생성과 실행 Thread유형의 객체 t를 생성 t.start()를 호출 스레드의 실행이 시작됨 이것은 run()메소드를 호출하는 것 void run()메소드에 스레드의 실행 코드가 있음 run()메소드를 정의하는 두 가지 방법이 있음 또는 Thread객체를 생성하여 실행시키는 두 가지 방법 스레드 실행 방법 1 - Thread클래스를 상속 받는 클래스 Thread클래스를 상속 받는 클래스 A를 정의 여기서 void run()메소드를 재정의 A 유형의 객체를 생성하고 start()를 호출함 class MyThread extends Thread { public void run() { for (int i = 0; i &lt; 10; i++) System.out.println(getName()); } } public class Main { public static void main(String args[]) { Thread t1 = new MyThread(); t1.start(); Thread t2 = new MyThread(); t2.start(); System.out.println(\"main\"); } } // Thread-0 // Thread-0 // Thread-1 // Thread-1 // main // Thread-1 // Thread-1 // Thread-1 // Thread-1 // Thread-1 // Thread-1 // Thread-1 // Thread-1 // Thread-0 // Thread-0 // Thread-0 // Thread-0 // Thread-0 // Thread-0 // Thread-0 // Thread-0 스레드 실행 방법 2 – Runnable인터페이스를 구현한 클래스 Runnable인터페이스를 구현한 클래스 B를 정의 여기서 void run()메소드를 구현 Thread객체를 생성할 때, B 객체 Runnable객체를 인자로 사용 start()를 호출함 class MyThread implements Runnable { public void run( ) { for (int i = 0; i &lt; 10; i++) System.out.println(Thread.currentThread().getName()); } } public class Main { public static void main(String[] args) { Thread t1 = new Thread(new MyThread(), \"thd0\"); t1.start(); Thread t2 = new Thread(new MyThread(), \"thd1\"); t2.start(); System.out.println(\"main\"); } } // main // thd0 // thd0 // thd1 // thd1 // thd1 // thd1 // thd1 // thd1 // thd0 // thd0 // thd1 // thd1 // thd1 // thd1 // thd0 // thd0 // thd0 // thd0 // thd0 // thd0 멀티 스레드의 실행 멀티 스레드 프로그램의 실행 결과는 예측할 수 없음 실행 결과가 매번 다를 수 있음 각 스레드는 정해진 순서 없이 독립적으로 실행 됨 main스레드는 다른 스레드를 시작시키나, 다른 스레드의 실행과 무관하게 실행 되고 종료 됨 스레드 제어하기스레드의 상태 생성 된 스레드가 CPU를 얻어 실행되고 최종적으로 종료될 때까지 여러 상태 변화를 겪음 메소드 설명 Startable 객체가 생성되었으나 start()의 실행 전 Runnable start()메소드가 호출되었으나 CPU 획득 전 Running CPU를 얻어 실행 중 Not Running CPU를 잃고 중단 된 상태, Blocked, Waithing, Timed_Waiting Dead run()메소드가 종료 된 상태 스레드의 상태 전이스레드의 상태 제어를 위한 메소드 void setPriority(int newPriority) 스레드의 우선 순위를 변경 높은 우선 순위를 가지는 스레드가 CPU를 얻을 확률이 높음 static void sleep(long millis) throws InterruptedException 현재 실행 중인 스레드가 정해진 시간 동안 실행을 멈추고 Not Running 상태로 들어감 다른 스레드가 이 스레드를 interrupt()메서드를 통해 깨우면 InterruptedException예외가 발생함 static void yield() 현재 실행 중인 스레드가 잠시 실행을 멈추고 Runnable 상태로 들어감 CPU를 다른 스레드에게 양보하는 것 void join() throws InterruptedException 스레드가 종료될 때까지 기다림 현재 실행 중이었던 스레드는 Not Running 상태로 들어감 void join(long millis) 최대 millis 시간 동안 기다림 기다리는 중에 다른 스레드가 이 스레드를 깨우면 InterruptedException을 받으면서 리턴 됨 void interrupt() 스레드를 인터럽트 시킴 스레드가 wait(), join(), sleep()에 의해 중단된 상태였다면 그 상태에서 깨어나 Runnable상태가 됨 스레드 상태 제어를 위한 Object클래스의 메소드 void wait() throws InterruptedException 객체를 처리 중인 스레드가 대기 상태로 감 다른 스레드가 해당 객체에 대해 notify()메서드를 호출할 때까지 기다림 void wait(long millis) throws InterruptedException 객체를 처리 중인 스레드가 정해진 시간 동안 대기 상태가 됨 다른 스레드가 해당 객체에 대해 notify()메서드를 실행시켜 주면 대기 중이라도 이 스레드가 깨어날 수 있음 이 메서드는 synchronized메서드의 내부에서만 호출 가능 void notify() wait()를 호출하여 대기 중인 스레드를 깨워 줌 이 메서드는 synchronized메서드의 내부에서만 호출 가능 스레드의 상태 제어 예 yield()로 제어하기 class MyThread implements Runnable { public void run() { for (int i = 0; i &lt; 100; i++) { String thd_name = Thread.currentThread().getName(); System.out.print(thd_name + \" \"); if (thd_name.equals(\"thd1\")) Thread.yield(); } } } public class Main { public static void main(String args[]) { Thread my_thread1 = new Thread(new MyThread(), \"thd1\"); Thread my_thread2 = new Thread(new MyThread(), \"thd2\"); my_thread1.start(); my_thread2.start(); } } // thd1 thd2 thd2 thd2 thd2 thd2 thd2 // thd1 thd2 thd2 thd2 thd2 thd2 thd2 // thd1 thd2 thd2 thd2 thd1 thd1 thd2 // thd2 thd1 thd2 thd2 thd2 thd2 thd2 // thd2 thd2 thd2 thd2 thd2 thd2 thd2 // thd2 thd2 thd1 thd2 thd2 thd2 thd2 // thd2 thd2 thd2 thd2 thd2 thd2 thd2 // thd2 thd2 thd2 thd2 thd2 thd2 thd2 // thd2 thd2 thd2 thd2 thd2 thd2 thd2 // thd2 thd2 thd2 thd2 thd2 thd2 thd2 // thd2 thd2 thd2 thd2 thd2 thd2 thd2 // ... ... // thd1 thd1 thd1 thd1 thd1 thd1 thd1 // thd1 thd1 thd1 thd1 thd1 thd1 thd1 // thd1 thd1 thd1 thd1 thd1 thd1 thd1 // thd1 thd1 thd1 thd1 thd1 thd1 thd1 // thd1 thd1 thd1 thd1 thd1 thd1 thd1 // thd1 thd1 thd1 thd1 thd1 thd1 thd1 // thd1 thd1 thd1 thd1 thd1 thd1 thd1 // thd1 thd1 thd1 thd1 thd1 thd1 thd1 // thd1 thd1 thd1 thd1 thd1 thd1 thd1 // thd1 thd1 thd1 thd1 thd2가 thd1보다 더 많이 실행되는 경향을 보임 thd1이 yield()를 호출할 때마다 CPU를 thd2에게 양보하기 때문 join()로 제어하기 class MyThread implements Runnable { public void run() { for (int i = 0; i &lt; 100; i++) { System.out.print(Thread.currentThread().getName() + \" \"); Thread.yield(); // 예제 5와 동일하게 yield 사용 } } } public class Main { public static void main(String args[]) throws InterruptedException { Thread my_thread1 = new Thread(new MyThread(), \"thd1\"); Thread my_thread2 = new Thread(new MyThread(), \"thd2\"); my_thread1.start(); my_thread2.start(); my_thread1.join(); // my_thread1이 종료될 때까지 main 스레드 대기 System.out.println(\"main thread\"); } } // thd2 thd1 thd2 thd1 thd2 thd1 thd2 // thd1 thd1 thd2 thd1 thd1 thd2 thd2 // thd1 thd1 thd2 thd2 thd1 thd1 thd2 // thd1 thd2 thd1 thd2 thd1 thd2 thd1 // thd2 thd1 thd2 thd1 thd2 thd1 thd2 // thd1 thd2 thd1 thd2 thd1 thd2 thd1 // thd2 thd1 thd2 thd1 thd2 thd1 thd2 // thd1 thd2 thd1 thd2 thd1 thd2 thd1 // thd2 thd1 thd2 thd1 thd2 thd1 thd2 // thd1 thd2 thd1 thd2 thd1 thd2 thd1 // thd2 thd1 thd2 thd1 thd2 thd1 thd2 // thd1 thd2 thd1 thd2 thd1 thd2 thd1 // thd2 thd1 thd2 thd1 thd2 thd1 thd2 // ... ... // thd2 thd1 thd2 thd1 thd2 thd1 thd2 // thd1 thd2 thd1 thd2 thd1 thd2 thd1 // thd2 thd1 thd2 thd1 thd2 thd1 thd2 // thd1 thd2 thd1 thd2 thd1 thd2 thd1 // thd2 thd1 thd2 thd1 thd2 thd1 thd2 // thd1 thd2 thd1 thd2 thd1 thd2 thd1 // thd2 thd1 thd2 thd1 thd2 thd1 thd2 // thd1 thd2 thd1 thd2 thd1 thd2 thd1 // thd2 thd1 thd2 thd1 thd2 thd1 thd2 // thd1 thd2 thd1 thd2 thd1 thd2 thd1 // thd2 thd1 thd2 thd2 main thread thd1과 thd2가 번갈아 실행되다가, thd1이 종료된 후 main thread가 출력 됨 이는 my_thread1.join()호출 때문에 main스레드가 my_thread1의 종료를 기다리기 때문 interrupt()로 제어하기 class MyThread extends Thread { Thread thdNext = null; // 다음 스레드를 저장할 변수 String szName; public MyThread(String szName) { super(szName); this.szName = szName; } public void run() { for (int i = 0; i &lt; 100; i++) { try { Thread.sleep(1000000); // 매우 긴 시간 sleep } catch (InterruptedException e) { System.out.print(getName() + \" \"); // 인터럽트 발생 시 스레드 이름 출력 if (thdNext.isAlive()) { // 다음 스레드가 살아있으면 thdNext.interrupt(); // 다음 스레드 인터럽트 } } } } public void setNextThread(Thread t) { thdNext = t; } } public class Main { public static void main(String args[]) { MyThread my_thread1 = new MyThread(\"thd1\"); MyThread my_thread2 = new MyThread(\"thd2\"); MyThread my_thread3 = new MyThread(\"thd3\"); my_thread1.setNextThread(my_thread2); // thd1 다음에 thd2 my_thread2.setNextThread(my_thread3); // thd2 다음에 thd3 my_thread3.setNextThread(my_thread1); // thd3 다음에 thd1 (순환) my_thread1.start(); my_thread2.start(); my_thread3.start(); try { my_thread1.interrupt(); // my_thread1을 인터럽트 my_thread2.join(); // my_thread2 종료 대기 my_thread3.join(); // my_thread3 종료 대기 } catch (InterruptedException e) { System.out.println(e); } System.out.println(\"main\"); } } // thd1 thd2 thd3 thd1 thd2 thd3 thd1 thd2 thd3 // thd1 thd2 thd3 thd1 thd2 thd3 thd1 thd2 thd3 // ... ... // thd1 thd2 thd3 main my_thread1.interrupt()가 호출되면 my_thread1은 sleep()상태에서 깨어나 InterruptedException을 catch 함 catch블록에서 thd1을 출력하고 thdNext가 살아있으면 my_thread2를 인터럽트 함 이 과정이 thd2, thd3로 연쇄적으로 이어지면서 각 스레드가 InterruptedException을 처리하고 종료 됨 마지막으로 my_thread2.join()과 my_thread3.join()에 의해 main스레드는 이들 스레드가 종료될 때까지 기다린 후 main을 출력하고 종료 됨 스레드 동기화스레드 간섭 여러 개의 스레드들이 하나의 공유 객체에 동시 접근하는 경우 데이터 무결성이 깨짐 스레드 간섭 예class Counter { // 카운터 값을 저장하는 변수, 초기값은 0 private int c = 0; // c 값을 1 증가 public void increment() { c++; } // c 값을 1 감소 public void decrement() { c--; } // 현재 c 값을 반환 public int value() { return c; }}class MyThread1 implements Runnable { Counter c; public MyThread1(Counter c) { this.c = c; } public void run() { for (int i = 0; i &lt; 100000; i++) { c.increment(); } }}class MyThread2 implements Runnable { Counter c; public MyThread2(Counter c) { this.c = c; } public void run() { for (int i = 0; i &lt; 100000; i++) { c.decrement(); } }}public class Main { public static void main(String args[]) throws InterruptedException { // 공유될 Counter 객체 생성 Counter c = new Counter(); // 값을 증가시키는 CounterMyThread1 스레드 생성 Thread t1 = new Thread(new CounterMyThread1(c)); // 값을 감소시키는 CounterMyThread2 스레드 생성 Thread t2 = new Thread(new CounterMyThread2(c)); // 두 스레드를 시작 t1.start(); t2.start(); // 두 스레드가 작업을 종료할 때까지 대기 t1.join(); t2.join(); // Counter 객체의 최종 값을 출력 System.out.println(c.value()); }} 동기화가 제대로 이루어지지 않은 상태에서 출력 된 값은 실행할 때마다 달라질 수 있음스레드 동기화 서로 다른 스레드들이 공유 자원을 다룰 때, 데이터 무결성을 보장하도록 하는 것 한 번에 오직 한 개의 스레드만이 해당 공유 객체에 접근하도록 동기화 함(상호 배제) 동기화 방법 상호 배제 원칙 키워드 synchronized 동기화 메서드 또는 동기화 블록을 제공 공유 자원을 수정할 때, 다른 스레드에서 같은 코드를 수행할 수 없게 함(잠금 설정) synchronized메서드 synchronized는 스레드 동기화를 위한 키워드 한번에 하나의 스레드에 의해서만 실행 가능하게 함 synchronized메서드를 실행하려면 메서드를 호출한 객체에 대한 lock을 얻어야 함 다른 스레드는 잠금이 해제되고 lock을 얻을 때까지 동일 객체의 synchronized메서드를 실행할 수 없고 대기해야 함 public synchronized void func() { } 일부 블록만 동기화하는 것도 가능함 synchronized(객체) { } 객체는 공유 자원으로 대개 this를 사용 synchronized 메서드 사용 예class Counter { private int c = 0; public synchronized void increment() { c++; } public synchronized void decrement() { c--; } public int value() { return c; }}class Counter { private int c = 0; public void increment() { synchronized(this) { c++; } } public void decrement() { synchronized(this) { c--; } } public int value() { return c; }}학습 정리 멀티 스레드 프로그래밍이란 하나의 프로세스에서 여러 스레드가 생성 되어 동시 실행되게 하는 것을 말함 스레드의 실행 코드는 스레드 생성에 사용 되는 Thread를 상속 받는 클래스나 Runnable인터페이스를 구현한 클래스에서 정의 되어 있는 public void run()메소드임 스레드는 생성 되어 소멸할 때까지 Startable, Runnable, Running, Not Running 등의 상태를 거침 Thread클래스에서 스레드의 상태를 제어하는 메소드로 start(), join(), interrupt()가 있으며, static메소드인 yield()와 sleep()도 있음 스레드 동기화는 데이터의 무결성을 유지하도록 한번에 한 스레드만이 스레드 간 공유 객체에 접근하도록 하는 것이며, synchronized메소드는 동기화를 보장함연습 문제 스레드 동기화와 관련 된 다음 설명 중 올바른 것은? a. 메소드 notify()는 현재 실행 중인 스레드를 정해진 시간 동안 중지 시킨다. 스레드 동기화의 의미를 가장 잘 설명한 것은? a. 한 순간에 한 스레드만 공유 객체에 접근할 수 있게 하는 것 밑줄 부분에 들어갈 스레드 동기화를 위한 자바 키워드는 무엇인가? 여러 스레드가 공유 객체를 사용할 때, 한 스레드가 공유 객체의 ______ 메소드를 실행 중이라면 다른 스레드가 동일 객체에 접근할 수 없다. a. synchronized " }, { "title": "[유비쿼터스 컴퓨팅 개론] 12강 - 유비쿼터스 시대의 정보 보호 필요성과 요구 사항", "url": "/posts/knou-uqc-12/", "categories": "Computer Science, CS Theory", "tags": "knou, ubiquitous computing", "date": "2025-05-11 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정광식 교수님의 '유비쿼터스 컴퓨팅 개론' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 유비쿼터스 컴퓨팅 환경에서는 다양한 정보 기기들이 생활의 곳곳에 널리 퍼져 있고, 이러한 정보 기기를 통해서 어느 곳에서나 다양한 정보에 대한 접근과 이동이 이루어지고 있음 이러한 유비쿼터스 컴퓨팅 환경에서는 모든 서비스와 정보가 통신망을 통해 제공되므로 오작동과 해킹의 우려가 많아지고, 웜·바이러스에 의한 피해도 걷잡을 수 없이 확산될 수 있음 따라서 개인이나 기업과 국가의 정보 보호를 뛰어넘어 전 세계적이고 광범위한 공간에 대한 보호가 요구 됨 우리는 유비쿼터스 환경에 적합한 정보 보호 기술의 필요성과 인간 생활을 편리하게 변화 시키고 있는 유비쿼터스 환경의 역기능 중 하나인 각종 정보 보호 침해 유형에 대해서 공부함학습 목표 유비쿼터스 환경에 적합한 정보 보호 기술의 필요성을 이해할 수 있음 유비쿼터스 환경에서 잠재적인 보안 문제가 무엇이고, 개인정보 침해 유형, 예상되는 보안 상의 위협이 무엇인지 이해할 수 있음강의록유비쿼터스 시대의 정보 보호유비쿼터스 시대의 정보 보호 필요성 유비쿼터스 컴퓨팅 시대에는 시스템 보안이나 정보 보호의 적용 범위가 기존의 유 · 무선 통신망 기반의 정보 통신 시스템보다 넓어지고 다양해져서 이전과 다른 시스템 공격 형태가 나타나게 됨 유비쿼터스 컴퓨팅 환경에서는 사람과 기계, 기계와 기계, 사물과 사물 간에 교환 되는 데이터 자체가 보호 대상이 됨 유비쿼터스 환경을 구성하는 객체들이 상호 작용할 때 발생하는 새로운 보안 문제들을 해결할 수 있는 기술이 필요함 유비쿼터스 컴퓨팅 환경은 스마트폰, 태블릿 PC, 스마트TV와 같은 가전제품, 자율형 자동차 등과 같은 다양한 단말기기 혹은 장비와 서비스 객체로 구성됨 서로 다른 운영체제나 통신 프로토콜을 갖는 단말 기기들은 각자의 독립적인 서비스 객체들을 지원 이러한 서비스 객체들은 상호 작용하는 과정에서 서로에 대한 상호 인증 작업이 이루어져야 함 유비쿼터스 환경에서 사용되는 단말기기는 종류가 매우 다양함 동작 방식이나 내부 구조 등이 차이가 나므로 일률적인 인증 기술 적용이 쉽지 않음 람-사물-단말 기기들을 모두 수용할 수 있는 새로운 인증 기술을 만들어야 함 이전 컴퓨팅 환경에서 서비스 객체에 대한 비밀성은 암호화 기술을 적용하여 보장하였고, 무결성은 해시 기법을 통해 해결할 수 있었음 유비쿼터스 환경에서의 단말 기기는 하드웨어 자원이나 처리 능력이 상대적으로 떨어지며, 또한 단말기기에 이전과 같은 높은 수준의 보안 기능을 갖추도록 하는 것도 부하가 될 수 있음 유비쿼터스 환경에 적합한 유연한 비밀성 및 무결성과 관련된 기술이 필요함 전달되는 정보의 보안 등급이 낮거나 이미 일반인들에게 공개된 정보를 취급하는 단말 기기에는 낮은 보안 수준, 안전성은 떨어지지만 간단한 암호화 기술을 제공함 반대로 개인의 생체 정보나 금융 정보와 같은 높은 비밀성을 요구하는 정보를 취급하는 단말 기기에는 하드웨어 측면에서 많은 부담이 되더라도 안정성이 높고 복잡한 암호화 기술 적용 부인 방지 서비스 메시지를 임의의 수신자에게 보냈을 때 송신자가 그 메시지의 발송에 대해 부정하거나 부인하지 못하도록 하는 서비스이며, 이와 함께 송신자에 의해서 발송되지도 않은 메시지에 대한 수신도 방지하는 서비스임 부인 방지 서비스는 일반적으로 전자 서명 기술을 통해 구현됨 다양한 센서가 이용될 수 있는 유비쿼터스 컴퓨팅 환경에서는 전자 서명 기술과 함께 위치 정보 서비스(GPS), 생체 신호 등의 다양한 개인정보와 전자 서명 기술을 융합하여 부 방지 서비스를 제공하기도 함 단말 기기의 위치 정보가 포함된 전자 서명 기술을 활용하여 개인의 식별 정보를 이용한 부인 방지 서비스는 보안성이 높음 개인정보 침해 유형 침해 유형 침해 내용 부적절한 접근 및 수집 개인이 인식할 수 없는 상황에서 개인정보에 대한 통제 권을 상실할 가능성이 큼 부적절한 분석 부적절하게 수집 된 개인정보를 분석하여 악성 공격이나 개인에 대한 통제 권이 심해짐 부적절한 모니터링 개인의 생활 패턴 및 개인 사생활 등 개인의 생활 전반에 걸친 개인정보가 노출될 가능성이 큼 부적절한 개인정보 유통 개인정보를 제 3자에게 양도하는 등 다양한 유형의 개인정보가 불법적으로 거래되거나 유통될 가능성이 큼 원하지 않는 영업 행위 개인의 특성에 맞는 상품 광고, 광고성 정보 전송을 개인의 동의 없이 무차별적으로 유통할 수 있음 부적절한 저장 한번 수집 된 정보는 파기 되지 않고, 수차례의 분석을 통해 다양한 용도와 경로로 재활용할 가능성이 큼 유비쿼터스 환경에서 통신 네트워크를 통해 다양한 정보 침해 시도가 있을 수 있고, 탈취 된 개인정보는 네트워크를 통해 빠르게 유통됨 이를 막기 위해 네트워크에 대한 새로운 사이버 공격 등 정보 보호 환경의 변화를 수용하고 온・오프라인 상에서 개인의 사생활을 보장할 수 있도록 정보 보호 관련 법 및 제도 정비가 필요함 방송 망, 정보 통신 망, 전화 망 등이 분리된 기존의 환경에서는 각각의 영역에 따라 서로 다른 정보 형태가 유통되었고, 이에 따라 정보 보호를 위한 기술이나 정보 유통 관련 기술이 상이함 정보 보호를 위한 관련 법규도 분야에 따라 달랐음 유비쿼터스 시대의 광대역 통신 네트워크(BCN)를 기반으로 하는 통합 망이 구축되었고, 동일한 기술적 표준이 만들어지면서 통합적인 정보 보호 관련 법규의 필요 유비쿼터스 시대의 정보 보호 요구 사항 유비쿼터스 장치의 절도 및 분실 유비쿼터스 장치의 절도 및 분실은 기밀성에 큰 위험이 될 수 있음 디바이스나 단말 기기를 분실하면 타인이 접근해서는 안 되는 정보가 침해 받을 수 있음 장치 소유자는 장치에 저장된 MAC 주소와 WEP 키 등 인증 정보를 사용하여 유비쿼터스 네트워크에 접근 권한을 가지고 있음 신원정보 및 위치 정보 노출 유비쿼터스 환경에서 유통되는 메시지에 대한 기밀성은 메시지 내용과 사용자 위치에 대한 비밀 유지 방법을 통해 가능함 원격 위치 추적 기술을 통해 특정 사용자의 위치 정보를 불법적으로 수집하여 악용하는 사례가 늘고 있음 무선 환경에서 이동하는 사용자에게 서비스를 제공하기 위해서는 사용자의 위치가 추적 되어야 하는데, 이 위치 정보가 제 3자에게 노출될 경우 사생활과 관련된 정보가 노출됨 유비쿼터스 환경에서 도처에 존재하는 유비쿼터스 장비와 수시로 정보 교환이 이루어지기 때문에 사용자 위치 정보 노출은 더욱 심각한 문제가 될 수 있음 불법 접근하는 비인증 접근 점 대부분의 기존 인증은 공개 키 암호 시스템을 기반으로 이루어지며, 인증 기관에 의해 발급 된 공개 키 인증서를 바탕으로 인증 받는 사용자나 유비쿼터스 단말기기의 서명을 통해 이루어짐 만약 조직 내의 보안 정책을 따르지 않는 개인적으로 설치된 접근 점(AP; Access Point)인 비인증 접근 점을 이용하여 Wifi 서비스를 이용한다면, 공격자는 접근 점 이용 권한만 획득함으로써 여러 악의적인 네트워크 활용이 가능해짐 서비스 거부(DoS: Denial of Service) 공격의 거점이 될 수 있음 IP 위장하기(IP Spoofing) 승인받은 IP인 것처럼 시스템에 접근하려는 시도 무선 신호는 건물의 벽을 통과할 수 있기 때문에 건물 외부로 전달될 수 있고, 적어도 무선 신호 범위 내에 존재하는 어느 누구나 무선 접속이 가능하기 때문에 전송되는 정보가 암호화되지 않을 경우 공격자가 중요 정보를 가로챌 수 있음 서비스 거부 공격 (Denial of Service Attack) 서비스 거부(DoS; Denial of Service) 공격은 정보 시스템의 데이터나 자원을 정당한 사용자가 적절한 대기 시간 내에 사용하는 것을 방해하는 행위를 말함 시스템에 과부하를 일으켜 정보 시스템의 사용을 방해하는 공격 방식임 유비쿼터스 네트워크 환경은 고정된 망 구조가 없으며, 수시로 망 구조가 변경되기 때문에 임시로 구성된 사용자 노드들 간의 데이터 교환을 위해서는 ‘멀티 홉 라우팅 프로토콜’에 의존하며 노드들은 인접한 노드의 패킷을 전송해 주어야 함 노드들 가운데 하나가 협력을 거부할 경우 서비스 거부 공격이 이루어질 수 있음 배터리 소진 공격 유비쿼터스 장치의 배터리를 짧은 시간 내에 방전 시켜 장치를 더 이상 사용하지 못하게 만드는 방식 공격자는 계속해서 공격 대상 장치에 데이터 전송 요청이나 연결 요청을 보내 유비쿼터스 장치가 불필요한 동작을 빈번하게 수행하도록 함으로써 배터리 낭비가 심화되게 되며, 결국에는 사용자의 다른 서비스 이용이 제약 됨 신호 방해 공격 무선 시스템에 대한 고전적인 공격 방법으로 방해 신호(jamming) 등을 이용하여 무선 통신 채널을 혼선 시키는 것임 통신 채널의 혼선은 유비쿼터스 시스템의 정상적인 서비스를 방해함 패킷 엿보기(Packet Sniffing) 통신망에 전송되는 패킷 정보를 무단으로 얻어 보는 것으로 프레임 내용 캡처하기, 위장하기, 엿보기 등과 같은 네트워크 모니터링 툴을 이용하여 네트워크 내에 돌아다니는 패킷의 내용을 분석해서 정보를 알아내려고 함 네트워크에 연결되어 있는 호스트 뿐만 아니라 외부에서 내부 네트워크로 접속하는 모든 호스트가 대상이 됨 유비쿼터스 네트워크에는 무선 공간이 많으므로 유선에서 보다 더 많은 위험에 노출됨 트로이 목마형의 백도어 침해 트로이 목마(Trojan Horse)는 정상적인 기능을 하는 시스템으로 가장하여 프로그램 내에 숨어서 의도하지 않은 기능을 수행하는 백도어(backdoor) 프로그램 코드를 말함 이는 정상적인 동작을 하는 것으로 보이거나 일상적인 프로그램 등으로 사용자를 현혹시킴으로써 특권을 획득함 전형적인 트로이 목마는 유용한 것으로 가장하여 사용자가 악성 프로그램을 실행하도록 유도함 일단 악성 프로그램이 실행되면 사용자도 모르게 백도어 프로그램이 설치되어 사용자의 합법적인 권한을 가로채어 시스템의 방어 체계를 침해하고 공격자는 접근이 허락되지 않는 정보를 획득함 유비쿼터스 환경에서 이러한 보안 위협에 대처하기 위해서는 아래 내용을 추가적으로 고려해야 함 분류 추가적으로 고려해야 할 보안 요구 사항 가용성 서비스 거부(DoS) 공격   서비스 액세스 우선 순위   요금 지불 서비스 권한 관리 사용자 식별과 검증   사용자 정보 접근 제어 익명성 익명성에 대한 사용자 선택 권한 안전한 로밍 핸드 오프 과정에서 보안 접속 유지와 보안   상황 정보(context) 정의 및 관리   분산 인증 및 실시간 패킷 과금 유비쿼터스 정보 보호 기술 동향개요 유비쿼터스 환경에서 정보 보호 기반 기술은 정부 및 국제 표준화 기구를 중심으로 주로 초 경량 암호/인증 기술, 사생활 보호 기술 개발에 주력하고 있음 유비쿼터스 환경에서는 제한적인 플랫폼에 적용할 수 있는 기술이 필요하기 때문임 RFID 보안 기술 스마트폰 보안 기술 생체인식 기술RFID 보안 기술 RFID는 전자 기술을 부착하고 무선 통신 기술을 이용하여 사물의 정보와 주변 상황 정보를 감지하는 센서 기술임 RFID 기술은 여러 분야에 적용하기 용이하고 관리하기도 편리하기 때문에 다양한 산업 분야에 적용되어 활용되고 있음 활용되는 분야의 특성 상 관리나 감시의 사각지대가 있으므로 언제든지 보안 문제가 부각될 수 있음 신용 카드나 직불 카드에서 사용되는 RFID 태그의 정보 도용, 제품의 가격 변경 해당 문제를 생각한다면 RFID 시스템에서 RFID 태그에 부여되는 정보에 대한 보안 기술은 세심하게 고려하여 결정해야 함 고기능 RFID 시스템의 경우 해킹을 피하기 위한 인증과 암호화 시스템을 탑재할 수 있지만, 그 외의 일반적인 RFID 태그는 어떤 리더의 요구에도 응답하게 되어 있음 가장 보편적인 대책은 태그와 리더가 주고받는 신호의 도청을 막는 것으로 이에 대한 구체적인 해결 방안을 살펴보면 다음과 같음 태그와 리더가 주고받는 신호의 도청을 막는 해결 방안 킬 태그(Kill Tag) 킬 태그(Kill Tag)는 MIT의 AutoID 센터에서 제안한 방법으로 RFID 태그를 설계할 때 8비트의 비밀번호를 포함함 RFID 태그가 비밀번호와 ‘Kill’ 명령을 받을 경우 RFID 태그가 비활성화되는 방식임 RFID 태그는 내부에 단락 회로가 있기 때문에 이를 끊음으로써 ‘Kill’ 명령을 실행함 ‘읽기/쓰기’로 설계된 RFID 태그의 경우 플래그 비트를 이용하여 RFID 태그를 비활성화했다가 다시 활성화할 수도 있음 패러데이 케이지(Faraday Cage) 패러데이 케이지(Faraday Cage)는 무선 주파수가 침투하지 못하도록 하는 방법으로 금 속성의 그물이나 박막(foil)을 입히는 방법임 실제로 RSA 연구소는 유로화에 RFID 시스템 도입에 대비하여 돈 봉투에 그물을 입힌 상품을 제시함 방해 전파 (Active Jamming) RFID 리더기가 제품을 읽지 못하도록 방해 전파(Active Jamming)를 발생 시키는 장치를 이용하면, 불법적으로 이용될 소지가 크고 방해 신호에 의해 다른 RFID 시스템도 손상될 수 있음 스마트폰 보안 기술 휴대성과 성능이 크게 향상되면서 스마트폰은 필수 전자 기기가 되었고, 당연히 스마트폰 내에는 다수의 개인 정보가 보관되어 있음 스마트폰용 프로그램 개발도 용이해지면서 악성 코드가 내장된 유해 프로그램도 증가하고 있으며, 특히 분실이나 도난은 언제든지 발생할 수 있음 그에 반해 모바일 기기는 상대적으로 성능이 떨어지는 하드웨어, 운영체제, 플랫폼의 제약 조건 때문에 PC 환경과 같은 강력한 보안 솔루션을 적용하기에는 제약이 있음 당연히 악성코드 전파와 같은 단말기 공격이나 해킹 등을 효과적으로 방어할 수 있는 보안 솔루션이 필요함 스마트폰 악성코드 유형은 단말기 장애 유발형, 배터리 소모형, 요금 유발형, 정보 유출형 등이 있음스마트폰 보안 기술 - 스마트폰 보안 위협 요소 시간과 장소에 구애 받지 않고 무선 인터넷을 활용할 수 있는 스마트폰이 일상생활에서 필수품이 됨에 따라 인터넷 환경도 스마트폰에 맞춰 변화되고 있음 PC 환경에서 제공하는 인터넷 서비스가 스마트폰과 같이 무선 환경으로 확대되면서 PC 환경의 보안 위협이 스마트폰 환경에서도 나타나고 있음 스마트폰의 특성으로 인한 보안 위협은 다음과 같음 개방성 (Openness) 스마트폰과 기존의 피처 폰을 구별 짓는 가장 큰 특성은 개방성(opennness)임 스마트폰의 운영체제는 외부 인터페이스(API)를 개방하였고, 응용 프로그램 개발을 지원하기 위해 소프트웨어 개발 환경을 제공해 줌 개방성은 스마트폰 응용 프로그램 개발에 큰 도움이 되지만, 역으로 악성 코드 개발도 용이하게 되었음 스마트폰용 앱을 통해 개인 정보가 악용 되고, 내부 인터페이스는 악의적인 개발자에 의해 악성 코드가 은닉 된 모바일 소프트웨어의 통로가 되었음 휴대성 스마트폰의 무선 통신 기능은 건물 바깥에서도 내부 시스템에 접속할 수 있게 되었고, 이로 인한 기밀 정보나 문서 유출이 발생할 수 있음 스마트폰에 저장 된 정보의 암호화 기술이나 분실 된 스마트폰의 정보 관리가 가능한 원격 기술이 등장하고 있음 스마트폰의 편리한 휴대성(portability)은 큰 장점이기도 하지만, PC 환경에서는 크게 고려하지 않았던 분실 · 도난 사고가 발생할 수 있음 직접적인 경제적 피해뿐만 아니라 스마트폰에 저장된 개인정보 유출 문제도 발생시킴 저성능 스마트폰의 하드웨어는 최근 크게 향상되었지만, 아직은 PC에 비해서 상대적으로 저성능임 내장된 배터리로 구동하기 때문에 전력 공급 측면에서도 큰 제약 조건이 될 수 있음 PC 환경과 같이 보안 소프트웨어가 동작할 경우 전력이나 처리 성능의 제약으로 인하여 효율성이 좋지 못함 스마트폰 보안 기술 - 스마트폰 보안 앱 기술 스마트폰 보안 앱은 모바일 백신, 개인정보 보호, 콘텐츠 필터 등의 목적이 있음 사용자의 특성과 이용 목적에 따라 적절한 앱을 설치하여 보안에 대한 안전성을 높일 필요가 있음 스마트폰 보안 앱 기술 생체 인식 기술 각 개인마다 평생 변하지 않으면서 각기 다른 신체적 · 행동적 특징을 찾아 등록, 이후 제시한 정보나 패턴을 비교 검증하여 대상을 식별하는 기술임 생체 정보의 특징은 신체적 특징과 행동적 특징을 이용하는 방법으로 나뉨 신체적 특징은 얼굴 모양, 홍채, 망막, 정맥, 손 모양, 지문, DNA 등이 있으며, 행동적 특징은 서명, 음성, 걸음걸이 등이 있음 일반적인 생체 인식 대상 출입국 관리, 범죄 수사, 군사 등의 주요 시설의 출입 통제, 재택 근무 등 정부 기관 분야에서 널리 확산·보급되고 있음 이러한 생체 인식 시스템은 기본적으로 사용자를 등록하는 과정과 사용자가 본인이 맞음을 확인 받는 인증(Verification, 1:1), 데이터베이스에서 사용자를 찾아내는 인식(Identification, 1:N)으로 구분할 수 있음 지문 인식은 개발 비용이 저렴하고 보안성이 우수하여 세계적으로 가장 많이 사용되는 생체 인식 기술임 최근에는 보다 높은 보안성을 가진 안면 인식이나 홍채 인식 기술이 향상되면서 사용이 확대되고 있으며, 향후에는 DNA · 다중 생체 인식 등과 같은 첨단 신기술로 발전할 것임 손바닥의 정맥을 활용한 인식 기술도 개발되고 있음 해외에서는 고성능 · 초경량 지문 센서, 카메라 등 생체 정보 입력 장비, 칩셋 등 하드웨어 제조 기술과 실시간 다중 검색을 위한 서버 기술 등이 상용화 단계에 이르고 있음 사용자 등록, 인증, 인식 과정 생체 데이터는 변경이 안 되므로 일단 그 정보가 유출되면 악의적인 사용을 막기 어려움 생체 인식 시스템을 기반으로 한 다양한 서비스가 제공됨에 따라 생체 인식에 대한 공격도 고도화되고 있음 여러 생체 인식 기술을 함께 사용하여 성능을 향상 시키고, 신뢰도, 수용도를 높이는 기술이 바로 다중 생체 인식(Multimodal Biometrics) 기술임 생체 인식 기술은 개인 별 차이가 있는 사용자의 고유한 생체 정보 또는 독특한 행동을 이용하는 것으로, 사용자가 기억하거나 소지할 필요가 없고 기존 보안 기법에 비해 높은 보안 성능을 제공할 수 있음 둘 이상의 생체 정보나 생체 인식 기술을 적절히 조합한 다중 생체 인식 기술이 연구되고 있으며, 단일 생체 인식 기술에 비해 여러 가지 면에서 우수성이 입증되고 있음 다중 생체 인식 기술은 유비쿼터스 환경에서 사용자가 안전하게 다양한 서비스를 받을 수 있도록 하는 생체 인식, 생체 센싱, 생체 네트워킹, 생체 면역 등으로 구분하는 바이오 분야에 속함 바이오 보안의 주요 기술 분야 정리 하기 유비쿼터스 환경을 구성하는 객체들이 상호 작용을 통해 만들어 내는 새로운 보안 문제들이 발생할 수 있음 유비쿼터스 환경에서 정보 통신 인프라 보호 기술로 RFID 보안 기술, 스마트폰 보안 기술, 생체 인식 기술이 있음연습 문제 유비쿼터스 시대의 정보 보호 요구 사항에 포함되지 않는 것은 무엇인가? a. 사용자 익명 사용에 대한 대처 유비쿼터스 시대의 정보 보호 요구 사항에 포함 되는 것 유비쿼터스 장치의 절도 및 분실에 대한 대처 신원 정보 및 위치 정보 노출에 대한 대처 IP 위장하기(IP Spoofing)에 대한 대처 메시지의 송 ‧ 수신이나 교환 후, 또는 통신이나 처리가 실행된 후에 그 사실을 사후에 증명함으로써 사실 부인을 방지하는 보안 기술은 무엇인가? a. 부인 방지(Non-repudiation) 정상적인 기능을 하는 시스템으로 가장하여 프로그램 내에 숨어서 의도하지 않은 기능을 수행하는 백도어(backdoor) 프로그램 코드는 무엇인가? a. 트로이 목마(Trojan Horse) 코드 정리 하기 유비쿼터스 컴퓨팅 환경은 스마트폰, 태블릿 PC 등과 같은 다양한 단말 기기들과 서비스 객체로 구성됨 서로 다른 운영 체제나 통신 프로토콜을 갖는 단말 기기가 독립적인 서비스 객체를 지원함 서비스 객체의 상호 작용 과정에서 상호 인증 작업이 필요함 유비쿼터스 환경의 다양한 단말 기기들은 기존의 인증 시스템을 그대로 적용하기엔 부적절함 부인 방지(Non-repudiation) 메시지의 송‧수신이나 교환 후, 또는 통신이나 처리가 실행된 후에 그 사실을 사후에 증명함으로써 사실 부인을 방지하는 보안 기술 개인 정보 침해의 유형 개인 정보의 부적절한 접근과 수집 개인 정보의 부적절한 분석 부적절한 모니터링 부적절한 개인 정보 유통 원하지 않는 영업 행위 부적절한 저장 유비쿼터스 시대의 정보 보호 요구 사항 유비쿼터스 장치의 절도 및 분실에 대한 대처 신원 정보 및 위치 정보 노출에 대한 대처 불법 접근하는 비인증 접근 점에 대한 대처 IP 위장하기(IP Spoofing)에 대한 대처 서비스 거부 공격(DoS)에 대한 대처 배터리 소진 공격에 대한 대처 패킷 엿보기(Packet Sniffing)에 대한 대처 트로이 목마형 백도어 프로그램에 대한 대처 " }, { "title": "[파이썬 프로그래밍 기초] 13강 - 실전 프로그래밍", "url": "/posts/knou-python-13/", "categories": "Language, Python", "tags": "knou, python", "date": "2025-05-11 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '파이썬 프로그래밍 기초' 강의를 개인 공부 목적으로 메모하였습니다. 학습 목표 소프트웨어 개발 라이프사이클의 진행 단계를 나열할 수 있음 배치 프로그램과 이벤트 기반 프로그램의 구조적 차이를 설명할 수 있음 소프트웨어 개발 라이프사이클을 적용할 수 있음주요 용어 소프트웨어 개발 라이프사이클 소프트웨어 개발 계획 수립부터 폐기까지 신뢰도 높은 소프트웨어 결과물 구현을 위한 체계화 된 소프트웨어 개발 체계 배치 프로세스 일괄적으로 모아 놓은 대량의 데이터를 지정한 처리 방법에 따라 처리하는 과정 또는 프로그램 이벤트 프로그램에 의해 감지되고 처리될 수 있는 동작이나 사건 강의록게임 개발 준비소프트웨어 개발 과정 대규모 소프트웨어 개발에 자원을 투입하여 초기에 예상한 결과물 구현을 목적 소프트웨어 개발 계획 수립부터 폐기까지 전체적인 흐름을 체계화하여 고품질의 소프트웨어 생산을 위한 체계 공장에서 제품을 생산하듯 소프트웨어 전체 개발 과정을 하나의 프로세스로 정의 소프트웨어 개발 라이프사이클(SDLC) 소프트웨어 개발 라이프사이클 PLANNING (계획 수립) 비용, 기간, 자원 계획 수립 ANALYSIS (분석) SW 기능/비 기능 요구 정의 및 자료 수집 DESIGN (설계) 구조, 데이터, 인터페이스, UI 정의 IMPLEMENTATION (구현) 언어 선택, 코딩 규칙 정의, 프로그램 작성 TESTING &amp; INTEGRATION (테스트 및 통합) 요구 반영, 예상 결과 유사 검증 및 오류 파악 MAINTENANCE (유지 보수) 프로그램 오류 수정, 새로운 요구 추가 사용 환경 변화 반영 프로그램의 진행 과정 일괄적으로 모아 놓은 대량의 데이터를 특정 시간에 지정한 처리 방법에 따라 처리 배치(batch) 프로세스 컴퓨터 게임의 진행 과정 컴퓨터 사용자의 행위에 따라 프로그램 내부에서 함께 반응 이벤트 기반 프로그래밍 EDP(Event Driven Programming) 실행의 흐름을 예측하는 프로그래밍 기법이 무의미한 GUI 환경에서 사용 입력 장치, 타이머, 프로그램 등으로부터 발생하는 이벤트 관점에서 생각하는 방식 이벤트(event)란 프로그램에 의해 감지되고 처리될 수 있는 동작이나 사건 컴퓨터 프로그램이 대기하고 있다가 이벤트가 들어올 때 그 이벤트에 맞게 구동 게임 이외에도 GUI 기반 프로그램에서 대다수 활용 되는 EDPEDP 프로그램 구동 구조 이벤트 발생 장치 이벤트 유형에 따른 이벤트 생성 이벤트 큐 이벤트 저장 구조 이벤트 루프 이벤트 생성 여부 확인 및 전달 get (이벤트 큐에서 가져오기) check (이벤트 저장 구조 확인) 이벤트 핸들러 이벤트 발생에 따른 실행 코드 이벤트를 처리하는 하나의 메소드 게임의 진행 과정 게임 초기화 게임 루프 (무한 반복) 이벤트 검사 이벤트 처리 게임 업데이트 화면 생성 화면 업데이트 게임 종료 (exit)게임 정의 및 설계게임 정의 틱택토(Tic Tac Toe) 두 명의 플레이어가 3×3 판에 번갈아가며 O와 X를 기록 같은 표시를 가로, 세로, 또는 대각선 상에 일직선으로 놓이도록 하는 게임 틱택토 규칙 한 플레이어가 아직 기록되지 않은 빈 칸에 자신의 기호로 표시한다. 다른 플레이어가 아직 기록되지 않은 빈 칸에 자신의 기호로 표시한다. 둘 중 한 플레이어가 가로, 세로, 또는 대각선을 자신의 기호만으로 채우면 승리한다. 게임은 한 플레이어가 승리하거나 빈 칸이 남지 않아 비길 때까지 계속된다.게임 승리 상황 전체 8가지의 승리 상황 틱택토 요구 사항 게임 시작 시 무작위로 시작할 플레이어가 선택 플레이어는 사용자와 컴퓨터이고 각각 O와 X 기호를 사용 빈 칸의 행, 열 좌표를 입력하여 기호를 표시 사용자는 사용자 입력, 컴퓨터는 랜덤 선택 승리, 무승부 또는 종료 요청이면 게임이 종료 종료 요청은 사용자가 “0 0” 입력 시 발생 게임 판을 텍스트로 출력하여 게임 진행틱택토 설계 1/4 2차원 리스트를 사용하여 게임 판을 생성하고 각각의 칸을 빈칸으로 초기화 빈칸에 대한 지정한 기호(*)를 사용 게임 판에 빈칸이 남아있는지 확인 게임 판 전체를 확인하고 True/False 반환 둘 중 한 플레이어가 승리했는지 확인 8가지의 승리 상황에 따른 가능성을 확인 각각의 행, 열과 두 개의 대각선 방향을 확인 틱택토 설계 2/4 게임 판의 현재 상태를 출력 게임을 시작 무작위로 선공할 플레이어를 선택 게임 루프를 기동(1/3) 게임판의 현재 상태를 출력하고 다음 플레이어가 빈칸을 선택 사용자 또는 컴퓨터가 다음 말의 위치를 결정해줄 때까지 계속 대기 틱택토 설계 3/4 게임 루프를 기동(2/3) 플레이어가 선택할 빈칸의 위치(행과 열 번호)를 입력 받음 사용자일 경우 사용자 입력을 통해 행과 열 번호를 입력 받음 컴퓨터일 경우 무작위로 행과 열 번호를 선택 플레이어가 선택한 위치에 기호를 표시하고 게임 판을 업데이트 틱택토 설계 4/4 게임 루프를 기동(3/3) 현재 플레이어가 승리했는지 확인 승리 상황인 경우, 승리한 플레이어에 대한 메시지를 출력하고 게임 루프를 종료 게임 판에 빈칸이 남아있는지 확인 게임 판이 가득 찬 경우, 무승부 메시지를 출력하고 게임 루프를 종료 게임이 종료될 때까지 게임 루프를 무한 반복 틱택토 게임 설계 2차원 리스트를 사용하여 게임판을 생성하고 각각의 칸을 빈칸으로 초기화 빈칸에 대한 지정한 기호(*)를 사용 게임판에 빈칸이 남아있는지 확인 게임판 전체를 확인하고 True/False 반환 둘 중 한 플레이어가 승리했는지 확인 8가지의 승리 상황에 따른 가능성을 확인 각각의 행, 열과 두 개의 대각선 방향을 확인 게임판의 현재 상태를 출력 게임 시작 무작위로 선공할 플레이어를 선택 게임 루프를 기동 게임 판의 현재 상태를 출력하고 다음 플레이어가 빈칸을 선택 플레이어가 선택할 빈칸의 위치(행과 열 번호)를 입력 받음 사용자일 경우 사용자 입력을 통해 행과 열 번호를 입력 받음 컴퓨터일 경우 무작위로 행과 열 번호를 선택 플레이어가 선택한 위치에 기호를 표시하고 게임 판을 업데이트 현재 플레이어가 승리했는지 확인 승리 상황인 경우, 승리한 플레이어에 대한 메시지를 출력하고 게임 루프를 종료 게임 판에 빈칸이 남아있는지 확인 게임 판이 가득찬 경우, 무승부 메시지를 출력하고 게임 루프를 종료 class Tic_Tac_Toe: # 게임판 생성 def __init__(self): # 게임이 실행되자마자 생성되어야 하는 부분 pass # 게임판 초기화 def create_board(self): pass # 첫 플레이어 선택 def select_first_player(self): pass # 기호 표시 def mark_spot(self, row, col, player): pass # 승리 상태 확인 def is_win(self, player): pass # 행 확인 # 열 확인 # 대각선 확인 # 잔여 빈칸 여부 확인 def is_board_full(self): pass # 플레이어 변경 def next_player(self, player): pass # 현재 게임판 상태 츌력 def show_board(self): # 지금까지 입력 된 게임 판의 상태를 보여 주는 것 pass # 게임 루프 시작 def start(self): pass # 새 게임판 생성 # 첫 플레이어 선택 # 게임 루프 시작 while True: # 다음 플레이어 안내 pass # 현재 게임판 상태 출력 # 사용자 입력 대기, 컴퓨터일 경우 랜덤 위치 반환 # row, col 입력값이 0, 0인 경우 게임 종료 # 입력된 위치 표시 # 현재 플레이어가 이겼는지 확인 # 게임판 가득참 확인 # 플레이어 변경 # 최종 게임판 출력# 게임 생성TTT = Tic_Tac_Toe()# 게임 시작TTT.start() __init__ 클래스에서 객체가 만들어질 때 자동적으로 호출, 초기화 항상 __init__으로 명명 is로 시작하는 메소드 대체로 무언가를 물을 때 자주 쓰임 결과는 주로 True / False 연습 문제 소프트웨어 개발 라이프사이클의 순서가 올바르게 나열 된 것은? a. 계획, 분석, 설계, 구현, 테스트, 유지 보수 다음의 EDP 구동 구조에서 이벤트 발생 장치에 발생 된 이벤트가 처리 되기 전까지 저장 되는 저장 구조는? a. 이벤트 큐 일괄적으로 모아 놓은 대량의 데이터를 특정 시간에 지정한 처리 방법에 따라 처리하는 프로그램은? a. 배치 프로그램 학습 정리 소프트웨어 개발 라이프사이클이란 소프트웨어 개발 계획 수립부터 폐기까지 전체적인 흐름을 체계화하여 고품질의 소프트웨어 생산을 위한 체계를 말함 소프트웨어 개발 라이프사이클은 대규모 소프트웨어 개발 시 자원을 투입하여 초기에 예상한 대로 결과물 구현을 목적으로 함 소프트웨어 개발 라이프사이클은 계획, 분석, 설계, 구현, 테스트, 유지 보수의 순서로 진행 됨 배치 프로세스란 일괄적으로 모아 놓은 대량의 데이터를 특정 시간에 지정한 처리 방법에 따라 처리하는 과정 또는 프로그램을 말함 게임은 입력 장치, 타이머, 프로그램 등으로부터 발생하는 이벤트를 처리하는 이벤트 기반 프로그램임 이벤트란 프로그램에 의해 감지되고 처리될 수 있는 동작이나 사건임 게임은 게임 초기화 후, 이벤트 검사, 이벤트 처리, 게임 업데이트, 화면 생성, 화면 업데이트 과정을 무한히 반복하는 게임 루프로 구성 됨 틱택토는 두 명의 플레이어가 3×3 판에 번갈아가며 O와 X 표시를 기록하여 같은 표시를 가로, 세로, 또는 대각선 상에 일직선으로 먼저 놓이도록 하는 게임임" }, { "title": "[운영 체제] 12강 - 저장 장치 및 파일 관리", "url": "/posts/knou-os-12/", "categories": "OS, Operating System", "tags": "knou, os", "date": "2025-05-11 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김진욱 교수님의 '운영 체제' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 입 출력 장치 중 저장 장치에 대해 더 자세히 알아봄 디스크는 컴퓨터 시스템이 동작하는 데 있어 중요한 장치로 디스크의 효율적 관리가 매우 중요함 저장 장치와 관련하여 파일 관리자는 시스템 내에 존재하는 파일을 제어하고 관리함 저장 장치의 종류를 살펴보고, 자기 디스크 장치의 특성과 디스크 스케줄링 알고리즘에 대해 살펴 봄 파일 관리자의 기본적인 개념을 살펴봄학습 목표 저장 장치의 종류를 설명할 수 있음 다양한 디스크 스케줄링 알고리즘을 설명할 수 있음 파일 관리자에 대해 이해하고 디스크 공간 할당을 설명할 수 있음강의록저장 장치의 종류순차 접근 저장 장치 데이터를 순차적으로 읽거나 쓸 수 있는 저장 장치 ex) 테이프 장치 초기 접근 시간이 굉장히 오래 걸림 대량의 데이터 백업 용으로 사용직접 접근 저장 장치 지정한 위치를 직접 찾아 데이터를 읽거나 쓸 수 있는 저장 장치 임의 접근 저장 장치 ex) 자기 디스크, 광 디스크, SSD 자기 디스크 자성을 띤 디스크의 표면에 데이터를 쓰거나 읽음 광 디스크 디스크 표면에 레이저를 쏘아 반사되는 빛의 차이를 이용하여 데이터를 읽거나 씀 ex) CD-ROM, CD-RW, DVD, 블루레이 디스크 등 나선형인 하나의 트랙으로 구성 SSD 읽고 쓰기가 가능하면서 전력 공급이 없어도 데이터가 지워지지 않는 메모리 이용 자기 디스크보다 속도가 빠르고 전력 소모가 적음 용량 대비 가격이 비싸며 수명이 짧음 디스크 스케줄링 알고리즘디스크 스케줄링 디스크 접근 요구를 효율적으로 처리하는 순서를 결정하는 작업 디스크 접근 요구 디스크에서 데이터를 읽거나 쓰는 요구 프로세스들의 요구를 디스크 큐에 두고 관리 기계적 동작이 최소화되도록 디스크 큐를 재 배열 직접 접근을 위해 헤드의 이동, 디스크의 회전 같은 기계적 움직임 필요 디스크 접근 요구 처리 시간 탐구 시간 + 회전 지연 시간 + 전송 시간 스케줄링 형태 탐구 시간 최적화 회전 지연 시간 최적화 디스크 스케줄링 알고리즘 FCFS 스케줄링 SSTF 스케줄링 SCAN 스케줄링 C-SCAN 스케줄링 LOOK 스케줄링 C-LOOK 스케줄링 SLTF 스케줄링FCFS 스케줄링 FCFS(First-Come, First-Served) 먼저 도착한 접근 요구가 먼저 서비스를 받는 방법 총 탐구 시간 1 + 5 + 15 + 20 = 41 장점 접근 요구의 도착 순서대로 실행 되므로 공평 단점 도착 순서에 따라 총 탐구 시간이 커질 수 있음 디스크 부하가 높을수록 응답 시간이 길어짐 SSTF 스케줄링 SSTF (Shortest-Seek-Time-First) 탐구 시간이 가장 짧은 접근 요구를 먼저 처리하는 방법 총 탐구 시간 1 + 5 + 5 + 20 = 31 장점 FCFS 스케줄링보다 처리 량, 평균 응답 시간 개선 일괄처리 운영체제에 적합 단점 양 끝 쪽에 위치한 트랙에 대한 접근 요구는 기아 상태 발생 가능 트랙 위치에 따라 응답 시간 편차가 큼 시 분할 운영체제에 부적합 SCAN 스케줄링 양 끝 트랙 사이를 왕복하며 진행 방향의 가장 가까운 접근 요구를 먼저 처리하는 방법 총 탐구 시간 1 + 10 + 55 + 5 = 71 장점 SSTF 스케줄링의 응답 시간 편차를 어느 정도 개선 단점 새로운 요구가 헤드 진행 방향의 바로 앞이냐 뒤냐에 따라 응답 시간 편차 발생 양 끝 트랙은 헤드가 한 번 왕복 할 때 한 번의 서비스 기회만 있음 C-SCAN 스케줄링 오로지 한쪽 방향으로만 진행 방향의 가장 가까운 접근 요구를 먼저 처리하는 방법으로 나머지는 SCAN 스케줄링과 동일 총 탐구 시간 1 + 10 + 180 + 5 = 196 장점 양 끝 트랙에 대한 접근 요구의 차별 제거 응답 시간의 편차가 매우 작음 LOOK 스케줄링 SCAN 스케줄링처럼 처리하되 진행 방향으로 더 이상 접근 요구가 없으면 방향을 바꾸는 방법 총 탐구 시간 1 + 10 + 15 + 5 = 31 C-LOOK 스케줄링 C-SCAN 스케줄링처럼 처리하되 진행 방향으로 더 이상 접근 요구가 없으면 방향을 바꾸어 가장 먼 접근 요구의 트랙까지 이동하는 방법 총 탐구 시간 1 + 10 + 20 + 5 = 36 SLTF 스케줄링 SLTF(Shortest Latency Time First) 동일 실린더의 여러 섹터에 대한 접근 요구에 대해 회전 지연 시간이 가장 짧은 것을 먼저 처리하는 방법 높은 부하 상태에서 유용 회전 지연 시간 최적화 이론적인 최적해와 거의 일치 파일 관리파일 관리자 파일을 생성, 삭제, 수정 파일에 접근하는 것을 제어 파일에 의해 사용 되는 자원을 관리파일 관리자의 요소 액세스 방식 파일에 저장되어 있는 데이터에 접근하는 방식 파일 관리 파일을 저장 · 참조 · 공유 및 안전하게 보호되도록 함 보조 기억 장치 관리 보조 기억 장치에 파일을 저장하는 데 필요한 공간 할당 파일 무결성 유지 파일의 정보가 소실되지 않도록 보장 파일 관리자의 기능 사용자가 파일을 생성, 수정 및 삭제할 수 있게 함 타인의 파일을 공동으로 사용할 수 있게 함 읽기, 쓰기, 실행 등 여러 종류의 액세스 제어 방법 제공 사용자가 각 응용에 적합한 구조로 파일을 구성할 수 있게 함 백업 및 복구 기호화 된 이름을 사용하여 파일을 참조할 수 있게 함 정보가 안전하게 보호되고 비밀이 보장되게 함파일 구조와 접근 방식 파일 구조 파일을 구성하는 레코드들이 보조 기억 장치에 배치되는 방식 접근 방식 순차 파일, 인덱스 된 순차 파일, 직접 파일 순차 파일 레코드가 물리적 순서에 따라 저장되어 있는 파일 논리적 순서와 물리적 순서가 동일 순차 접근 저장 장치에 많이 이용 인덱스 된 순차 파일 각 레코드의 키를 기준으로 한 논리적 순서대로 레코드가 저장됨 일부 주요 레코드의 실제 주소가 저장된 인덱스를 구성하여 관리하는 파일 순차 접근(키 순서)과 직접 접근(인덱스 검색) 모두 가능 보통 디스크에 이용 직접 파일 (Direct File) 각 레코드의 키를 이용하여 직접 접근 저장 장치의 물리적 주소를 통해 직접 액세스 되는 파일 논리적인 키와 물리적 주소의 사상은 프로그래머가 정의 디스크 공간 할당 연속 할당 기법 보조 기억 장치의 연속된 가용 공간에 파일 저장 공간을 할당 필요한 공간의 크기를 미리 정해야 함 장점 액세스가 효율적 디렉터리 구현이 단순 단점 외부 단편화 파일 크기 확장에 대한 대응이 비효율적 불연속 할당 기법 섹터 또는 블록 단위로 공간을 할당 포인터를 이용하여 블록들을 연결 장점 단편화 문제 해결 파일 확장 문제 해결 단점 파일 공간 분산으로 성능 저하 포인터 관리를 위한 연산 및 공간 소비 정리 하기 저장 장치는 순차 접근 저장 장치와 직접 접근 저장 장치로 나뉨 직접 접근 저장 장치인 자기 디스크의 접근 요구 처리 시간은 탐구 시간, 회전 지연 시간, 전송 시간으로 구성 됨 디스크 스케줄링은 디스크 접근 요구를 효율적으로 처리하는 순서를 결정하는 작업으로, 탐구 시간을 최소화하는 것이 가장 중요함 SSTF 스케줄링 알고리즘은 헤드 위치로부터 탐구 시간이 가장 짧은 접근 요구를 먼저 처리하는 방법임 SCAN 스케줄링 알고리즘은 양 끝 트랙 사이를 왕복하며 진행 방향의 가장 가까운 접근 요구를 먼저 처리하는 방법임 C-SCAN 스케줄링 알고리즘은 정해진 한 방향으로만 가장 가까운 접근 요구를 먼저 처리하는 방법으로, 트랙의 끝에 도달하면 반대편 트랙 끝으로 이동한 후 다시 같은 방향으로 진행하는 방법임 LOOK과 C-LOOK 스케줄링 알고리즘은 진행 방향의 앞쪽에 더 이상 접근 요구가 없으면 바로 방향을 바꾸는 방법임 이때 C-LOOK 스케줄링은 반대편 트랙 끝까지 이동하지 않고 가장 먼 접근 요구의 트랙까지만 이동함 SLTF 스케줄링 알고리즘은 회전 지연 시간 최적화를 위한 알고리즘으로, 동일 실린더에서 회전 지연 시간이 가장 짧은 접근 요구를 먼저 처리하는 방법임 파일 관리자는 파일의 생성 · 수정 · 삭제, 파일의 공유 및 액세스 제어, 백업, 정보 보호 등의 기능을 수행함" }, { "title": "[데이터 정보 처리 입문] 12강 - R을 활용한 자료 분석", "url": "/posts/knou-dip-12/", "categories": "Data Science, Data Analysis", "tags": "knou, data information processing", "date": "2025-05-11 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김성수, 이기재 교수님의 '데이터 정보 처리 입문' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 R은 자료 처리, 통계 분석, 그래 픽스 분야 등에 탁월한 기능을 가지고 있는 무료 통계 시스템임 대화형 프로그래밍 언어를 기반으로 다양한 통계 분석 함수 및 그래프 함수들을 포함하고 있음 R을 이용하여 데이터를 읽고, 처리하는 방법을 알아보고, 기술 통계량을 구하는 법, 히스토그램 등 기본적인 통계 그래프를 그리는 방법을 알아보도록 함학습 목표 R 사용법을 익힐 수 있음 데이터를 읽어 들이는 방법을 이해할 수 있음 행렬 연산 방법을 설명할 수 있음 기술 통계량을 구할 수 있음 통계 그래프를 그릴 수 있음강의록R 소개 및 다운로드R의 소개 통계 소프트웨어 시스템(statistical software system) 데이터를 효율적으로 처리하고 분석할 수 있으며, 다양한 통계적 분석과 그래프 등을 구현할 수 있는 통계 시스템 대화형 언어(interpreted language) 언어가 입력된 즉시 시행이 됨 객체 지향(object-oriented) 시스템 R은 객체를 다룰 수 있도록 구성되어 있음 데이터, 변수, 행렬 등은 모두 객체이며, 객체는 연산자 &lt;-, 또는 =에 의해 생성 됨 R의 기능 자료 처리 기능 자료의 구성, 소팅, 결합 등이 프로그램 처리로 쉽게 이루어짐 자료 분석 기능 자료를 분석하기 위해 필요한 통계 분석 함수 및 분석 결과 제공 등이 다양함 언어 기능 함수 문을 쉽게 작성할 수 있으며, C언어 및 FORTRAN 언어 등과 인터페이스(Interface)가 가능 그래픽스 기능 대화형 그래픽스에 의한 자료 분석의 기능 및 분석 결과의 그래픽스 처리 기능이 뛰어남 R 다운 받기: www.r-project.orgR 다운 받기: DownloadR 메뉴얼:자료 읽기설문지 설문 어느 집단에서 표본을 10명 추출하여 다음과 같은 4개 문항에 대하여 설문조사를 실시하였다. 일련번호 변수1 (성별) 변수2 (나이) 변수3 (교육정도) 변수4 (월수입) 1 1 21 2 150 2 2 22 1 100 3 1 33 2 200 4 2 33 3 220 5 1 28 2 170 6 1 41 3 300 7 2 39 2 290 8 1 32 3 220 9 2 44 1 370 10 1 55 3 410 귀하의 성별은? 남자 여자 귀하의 나이는? (단위: 세) 교육 정도는? 중졸 이하 고졸 대졸 이상 월 수입 (단위: 만원) 텍스트 자료 읽기: read.table, read.csv ex-8-1.txt ex-8-1.csv ex8 = read.table(\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/dataintro/ex8-1.txt\", header=T) # 텍스트 파일 불러오기 (첫 행을 열 이름으로 사용)# ex8 = read.csv(\"c:/data/dataintro/ex8-1.csv\") head(ex8) # 데이터의 처음 6행 출력 head = T true 첫 번째 케이스는 변수로 되어있음 엑셀 자료 읽기: (package: xlsx, readxl) Packages-Install → package(s) 엑셀 자료 읽기 xlsx 패키지 사용 library(xlsx) # xlsx 패키지 로드 ex8_xls = read.xlsx(\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/dataintro/ex8-1.xlsx\", 1) # ex8-1.xlsx 파일의 첫 번째 시트에서 데이터를 불러옴 head(ex8_xls, 3) # 데이터의 처음 3행 출력 readxl 패키지 사용 library(readxl) # readxl 패키지 로드 ex8 = read_excel(path=\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/dataintro/ex8-1.xlsx\") # ex8-1.xlsx 파일 의 데이터를 읽어오기 head(ex8, 3) # 데이터의 처음 3행 출력 기술 통계 량 구하기 변수 월 급여(salary)의 평균 및 표준 편차 구하기 ex8 = read.csv(\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/dataintro/ex8-1.csv\") # CSV 파일 읽기 head(ex8, 3) # 데이터의 처음 3행 출력 names(ex8) # 열 이름 출력 attach(ex8) # 데이터 프레임의 변수를 직접 참조 가능하게 만듦 mean(ex8$salary) # salary 열의 평균 계산 sd(ex8$salary) # salary 열의 표준 편차 계산 summary(ex8$salary) # salary 열에 대한 요약 통계량 출력 (최솟값, 최댓값, 중앙값 등) 그룹 별 기술 통계 량 구하기 성별과 교육 정도 별로 월 급여(salary)의 평균 및 표준 편차 구하기 tapply(ex8$salary, ex8$sex, mean) # sex에 따라 salary의 평균 계산 tapply(ex8$salary, ex8$sex, sd) # sex에 따라 salary의 표준 편차 계산 mean_Sal_Sex = tapply(ex8$salary, ex8$sex, mean) # sex에 따른 salary의 평균을 mean_Sal_Sex에 저장 rownames(mean_Sal_Sex) = c(\"남\", \"여\") # 행 이름을 \"남\"과 \"여\"로 설정 mean_Sal_Sex # 결과 출력 sd_sal_edu = tapply(ex8$salary, ex8$edu, sd) # edu에 따라 salary의 표준 편차 계산 sd_sal_edu # 결과 출력 rownames(sd_sal_edu) = c(\"중졸이하\", \"고졸\", \"대졸이상\") # 학력 수준별 이름 설정 sd_sal_edu # 결과 출력 sex_edu = list(ex8$sex, ex8$edu) # 성별(sex)과 학력(edu)을 조합한 리스트 생성 tapply(ex8$salary, sex_edu, mean) # 성별과 학력별 salary의 평균 계산 mean_sal_sex_edu = tapply(ex8$salary, sex_edu, mean) # 결과를 mean_sal_sex_edu에 저장 mean_sal_sex_edu # 결과 출력 rownames(mean_sal_sex_edu) = c(\"M\", \"F\") # 행 이름에 성별(\"M\" = 남성, \"F\" = 여성) 설정 colnames(mean_sal_sex_edu) = c(\"Middle\", \"High\", \"College-\") # 열 이름에 학력 수준 설정 mean_sal_sex_edu # 결과 출력 빈도 표 및 분할 표 구하기 성별과 교육 정도의 빈도 표 및 분할 표 table() 함수를 이용하여 빈도수를 계산 table(ex8$sex) # 성별(sex) 변수의 빈도수 계산 table(ex8$edu) # 학력(edu) 변수의 빈도수 계산 sex_edu = table(ex8$sex, ex8$edu) # 성별(sex)과 학력(edu) 변수의 교차 빈도수 계산하여 sex_edu에 저장 sex_edu # sex_edu 출력 출력 표의 행/열 이름 설정 colnames(sex_edu) = c(\"중졸이하\", \"고졸\", \"대졸이상\") rownames(sex_edu) = c(\"남\", \"녀\") sex_edu summary() 함수는 최대 빈도값, 총 빈도수, 각 조합에 대한 빈도 요약을 제공 summary(sex_edu) # 성별(sex)과 학력(edu)의 교차표(sex_edu)에 대한 요약 통계 출력 그래프 그리기막대 그림 및 원 그림 교육(edu) 변수의 막대 그림 및 원 그림 edu_freq = table(ex8$edu) # 학력(edu) 변수의 빈도를 계산하여 edu_freq에 저장 edu_freq # 결과(빈도수) 출력 rownames(edu_freq) = c(\"중졸이하\", \"고졸\", \"대졸이상\") barplot(edu_freq) # 막대 그래프 생성 title(\"교육정도 막대그림\") # 막대 그래프 제목 추가 pie(edu_freq) # 원형 그래프 생성 title(\"교육정도 원그림\") # 원형 그래프 제목 추가 # pie(edu_freq, main=\"교육정도 원그림\") # pie 함수에서 바로 main 파라미터로 제목을 설정 가능 성별 구분 막대 그림 성별 구분 교육(edu) 변수의 막대 그림sex_edu = table(ex8$sex, ex8$edu) # 성별(sex)과 교육 수준(edu)의 빈도를 교차표 형태로 계산sex_edu # 교차표 출력colnames(sex_edu) = c(\"중졸이하\", \"고졸\", \"대졸이상\") # 교차표 열 이름(학력 수준) 설정rownames(sex_edu) = c(\"남\", \"녀\") # 교차표 행 이름(성별) 설정barplot(sex_edu) # 성별 및 학력 수준에 따른 빈도 막대 그래프 생성barplot(sex_edu, main = \"성별 교육정도 막대그림\") # 그래프에 제목 추가히스토그램, 줄기-잎 그림, 상자그림 월 급여(salary) 변수의 히스토그램, 줄기-잎 그림, 성별에 따른 상자 그림 hist(ex8$salary, nclass=4) stem(ex8$salary) par(mfrow=c(1,2)) boxplot(ex8$salary~ex8$sex, main=\"상자그림\") ex8$sex = factor(ex8$sex, levels=c(1:2), labels = c(\"남\", \"여\")) boxplot(ex8$salary~ex8$sex, main=\"상자그림 2\") # 히스토그램 생성 hist(ex8$salary, nclass = 4) # ex8$salary 변수의 히스토그램 생성 (계급 개수 4로 설정) # 줄기-잎 그림 생성 stem(ex8$salary) # ex8$salary 데이터의 줄기-잎 그림 출력 # 그래프를 한 화면에 1행 2열로 배치 par(mfrow = c(1, 2)) # 그래프를 한 화면에 두 개(1행 2열) 배치하도록 설정 # 성별에 따라 급여(salary)의 분포를 나타내는 상자그림(boxplot) 생성 boxplot(ex8$salary ~ ex8$sex, main = \"상자그림\") # ex8$salary 변수를 ex8$sex(성별)에 따라 구분하여 상자그림 생성 # 성별(sex) 변수를 의미 있는 라벨로 설정 ex8$sex = factor(ex8$sex, levels = c(1:2), labels = c(\"남\", \"여\")) # 성별(sex) 데이터를 팩터로 변환하고 라벨(1 → \"남\", 2 → \"여\")을 설정 # 성별 라벨을 적용한 후 다시 상자그림 생성 boxplot(ex8$salary ~ ex8$sex, main = \"상자그림 2\") # ex8$salary 변수를 변환된 ex8$sex(성별) 기준으로 상자그림 생성 연속형 자료 그래프 : 줄기-잎 그림 줄기-잎 그림(stem-and-leaf plot) 분포의 대략적인 형태를 살펴보기 위하여 작성되는 그래프로 군집의 존재 여부, 집중도가 높은 구간, 대칭 성의 여부, 자료의 범위 및 산포, 특이 값의 존재 여부 등을 파악하는데 이용 됨 ex) 점수 자료: 54 57 55 23 51 64 90 51 52 43 15 10 82 74 54 78 37 73 52 48 41 33 52 30 41 51 18 39 46 28 53 44 46 56 28 58 29 58 67 35 25 38 61 53 23 73 69 47 41 45 77 56 89 28 54 99 10 43 35 24 21 23 67 14 53 score = scan(\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/dataintro/score.txt\") # score.txt 파일에서 데이터 읽기 stem(score) # 줄기-잎 그림 출력 ?stem # 줄기-잎 그림(stem 함수)에 대한 도움말 확인 stem(score, scale = 2) # 줄기-잎 그림 출력, scale = 2로 그림의 크기를 확장 연속 형 자료 그래프 : 상자 그림score = scan(\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/dataintro/score.txt\") # score.txt 파일에서 데이터를 읽어와 'score'에 저장stem(score) # 줄기-잎 그림 출력하여 데이터 분포 요약summary(score) # score 데이터의 기초 통계량(최소값, 최대값, 평균, 중앙값 등) 출력boxplot(score) # score 데이터의 상자그림 출력으로 데이터의 분포와 이상값(outliers) 확인산점도 그리기 (age, salary) 산점도 그리기 library(readxl) # Excel 파일을 읽어올 수 있는 readxl 패키지 로드 ex8 = read_excel(path=\"D:/01_KNOU/2025년도 1학기/데이터 정보 처리 입문/dataintro/ex8-1.xlsx\") # ex8-1.xlsx을 읽어서 ex8 데이터프레임으로 저장 head(ex8, 3) # ex8 데이터프레임의 첫 3행 출력 plot(ex8$age, ex8$salary, col = \"BLUE\", pch = 19) # 나이(age)와 급여(salary)의 산점도 출력 (파란색 점, pch=19로 채워진 점 표시) 성별로 구분한 산점도 그리기 plot(ex8$age, ex8$salary, type = \"n\") # 빈 플롯 생성 points(ex8$age[ex8$sex == 1], ex8$salary[ex8$sex == 1], pch = \"M\", col = \"BLUE\") # 남성 데이터 추가 points(ex8$age[ex8$sex == 2], ex8$salary[ex8$sex == 2], pch = \"F\", col = \"RED\") # 여성 데이터 추가 legend(\"bottomright\", legend = c(\"Male\", \"Female\"), pch = c(\"M\", \"F\"), col = c(\"BLUE\", \"RED\")) # 범례 추가 legend(locator(1), legend = c(\"Male\", \"Female\"), pch = c(\"M\", \"F\"), col = c(\"BLUE\", \"RED\")) # 마우스로 범례 위치 지정 R 연산스칼라와 벡터 연산 스칼라 연산 x = 4 # 변수 x에 값 4를 할당 y = 4 * x + 7 # y는 4*x + 7로 계산 y # y의 값을 출력 x &lt;- 4 # 변수 x에 값 4를 할당 (화살표 방식) y &lt;- 4 * x + 7 # y는 4*x + 7로 계산 y # y의 값을 출력 벡터 연산 x = c(-10:10) # -10부터 10까지의 정수를 생성하여 x에 저장 y = 4 * x + 7 # y는 x 값을 이용해 4*x + 7로 계산 y # y 값을 출력 x[3] # x의 세 번째 요소를 출력 x[1:5] # x의 1번째부터 5번째 요소를 출력 x1 = x[x &lt; 0] # x 중에서 0보다 작은 값들만 추출하여 x1에 저장 x1 # x1 값을 출력 y = 4 * x1 + 7 # x1 값을 이용해 y를 계산 (4*x1 + 7) y # 새로운 y 값을 출력 data framex = c('red', 'green', 'blue') # 색상을 나타내는 문자열 벡터 생성y = c(1, 2, 3) # 숫자 벡터 y 생성z = c(4, 5, 6) # 숫자 벡터 z 생성dframe = data.frame(x, y, z) # x, y, z 벡터를 결합해 데이터프레임 생성dframe # 데이터프레임 출력dframe[1, 1] # 데이터프레임의 1행 1열 값 출력dframe[1, 2] # 데이터프레임의 1행 2열 값 출력names(dframe) # 데이터프레임의 열 이름(컬럼 이름) 출력dframe$y # 데이터프레임의 y 열(벡터 형태) 출력dframe[, 2] # 데이터프레임의 2번째 열 출력 (y와 동일)seq 함수: 일련의 값을 갖는 객체를 생성x_seq = seq(-pi, pi, 1) # -π에서 π까지 1 간격으로 시퀀스 생성x_seq # x_seq 출력round(x_seq, 4) # x_seq 값을 소수점 4자리까지 반올림하여 출력x1_seq = seq(-pi, pi, length = 10) # -π에서 π까지 10개 값으로 균등 분할한 시퀀스 생성x1_seq # x1_seq 출력행렬 연산 행렬 생성 x = c(1:12) # 1부터 12까지의 숫자를 가진 벡터 생성 x = matrix(x, ncol = 4, byrow = T) # 벡터 x를 4개의 열로 가지는 행렬로 변환, 행 단위로 채움 x # 행렬 x 출력 모든 원소 값이 동일한 상수인 행렬 x = matrix(1, nrow = 4, ncol = 3) # 값 1로 채워진 4x3 행렬 생성 x # 행렬 x 출력 서브 행렬 추출 x = c(1:12) # 1에서 12까지의 숫자를 가진 벡터 생성 x = matrix(x, ncol = 4, byrow = T) # 4개의 열로 구성된 행렬 생성 (행 단위로 채움) x # 행렬 x 출력 x[, c(1:3)] # x의 1~3열만 선택해 출력 x[c(1:3), -2] # x의 1~3행에서 두 번째 열을 제외하고 선택해 출력 행렬 연산 함수 ncol(x) 열의 수 nrow(x) 행의 수 t(x) 전치 행렬 cbind(...) 열을 더할 때 이용되는 함수 rbind(...) 행을 더할 때 이용되는 함수 diag(x) 대각 행렬 apply(x,m,fun) 행 또는 열에 함수 적용 x %*% y 두 행렬의 곱 solve(x) 역행렬 행렬의 곱 및 apply 함수 예 x = c(1, 2, 3, 5, 6, 7) # 벡터 x 생성 x = matrix(x, ncol = 3, byrow = T) # 3개의 열로 구성된 행렬로 변환 (행 우선 방식) x # 행렬 x 출력 y &lt;- c(1:4) # 벡터 y 생성 (1부터 4까지) y &lt;- matrix(y, ncol = 2) # 2개의 열로 구성된 행렬로 변환 (기본적으로 열 우선 방식) y # 행렬 y 출력 t(x) %*% y # x의 전치된 행렬과 y를 행렬 곱셈 수행 t(x) %*% y ( C[i,j] ) 계산 예제 결과 값 첫 번째 행(1, 5)과 첫 번째 열(1, 2)의 내적: ( 11 + 52 = 1 + 10 ) 11 첫 번째 행(1, 5)과 두 번째 열(3, 4)의 내적: ( 13 + 54 = 3 + 20 ) 23 두 번째 행(2, 6)과 첫 번째 열(1, 2)의 내적: ( 21 + 62 = 2 + 12 ) 14 두 번째 행(2, 6)과 두 번째 열(3, 4)의 내적: ( 23 + 64 = 6 + 24 ) 30 세 번째 행(3, 7)과 첫 번째 열(1, 2)의 내적: ( 31 + 72 = 3 + 14 ) 17 세 번째 행(3, 7)과 두 번째 열(3, 4)의 내적: ( 33 + 74 = 9 + 28 ) 37 apply(x, 1, mean) # x 행렬의 각 행(row)에 대해 평균을 계산 apply(x, 2, mean) # x 행렬의 각 열(column)에 대해 평균을 계산 연습 문제 그룹 변수인 성별(sex)의 값에 따라 변수 salary의 평균(mean)을 구하는 명령은 ? a. tapply(salary, sex, mean) 데이터 객체의 처음 6개의 케이스를 출력하고자 한다. R 명령은 ? &gt; ( b )(ex.data) a. head 다음과 같은 텍스트 파일을 읽어 들이는 R 명령은 ? ex.data = ( a )(\"c:/data/example.txt\", header=T) a. read.table  데이터 객체 ex.data의 변수들을 직접 사용하고자 한다. 유용한 명령은? a. attach(ex.data) package xlsx를 인스톨하였다. 이를 가동 시키기 위한 명령은?  a. library(xlsx) " }, { "title": "[파이썬 프로그래밍 기초] 12강 - 파일", "url": "/posts/knou-python-12/", "categories": "Language, Python", "tags": "knou, python", "date": "2025-05-10 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '파이썬 프로그래밍 기초' 강의를 개인 공부 목적으로 메모하였습니다. 학습 목표 파일의 역할에 대해 설명할 수 있음 파일 함수를 통해 데이터를 읽고 쓰고 추가할 수 있음 딕셔너리를 사용할 수 있음주요 용어 파일 이름 파일 경로를 내포하는 파일의 고유 식별자 파일 포인터 파일 내부에서 작업 위치를 나타내는 포인터 딕셔너리 키와 값의 쌍을 저장하는 시퀀스 강의록파일의 이해파일의 역할 컴퓨터에 의해 처리될 또는 처리된 데이터와 정보가 임시적으로 저장된 상태 일련의 연속된 바이트 프로그램(파이썬 소스 코드)에 읽혀 가공 · 처리 자동화할 도구 처리 및 가공 파일의 구성 연속된 바이트와 파일의 시작, 파일 포인터, 파일의 끝(EoF)으로 표현 파일의 종류 데이터가 저장되는 방식에 따라 구분 텍스트 파일 바이너리 파일 실제 바이너리의 숫자로 저장 적은 데이터 용량 파일 함수 파일의 시작, 파일 포인터, 파일의 끝을 활용하여 데이터 읽기, 쓰기를 위한 함수 및 메소드를 내장 멤버 설명 open(): file obj 파일과 연결되어 있는 파일 객체 생성 read() 특정 개수의 문자를 반환 readline() 한 라인의 문자열을 반환 readlines(): list 전체 라인의 문자열을 리스트로 반환 write(s: str): 파일에 문자열을 작성 close() 파일 닫기 및 파일 객체 삭제 객체 지향 대규모의 프로그램을 유용하게 사용할 수 있는 새로운 패러다임 객체 생성, 사용, 삭제의 과정을 거침 객체의 Life cycle 생애 주기 객체가 프로그램 내부에서 사용되는 과정에 대한 고민 Garbage Collector 파이썬 인터프리터는 참조 변수로 쓰이지 않는 객체들을 주기적으로 점검하고 정리함 파일 생성, 사용, 삭제의 과정을 거침 파일 객체 생성 구문 형식 파일객체_참조변수 = open(파일이름, 모드) 물리적인 파일과 연결된 파일 객체를 생성하고 참조 변수에 할당 모드 설명 'r' 읽기 용도 'w' 새로운 파일을 쓰기 용도 'a' 파일의 끝에 데이터를 덧붙이기 용도 open 함수를 사용하는 것 빼고는 객체 사용법과 거의 동일 파일 이름 파일의 고유 식별자 역할 및 저장 장치 내부에서 파일의 위치를 표현하는 파일 경로를 내포 해당 파일에 접근하기 위한 모든 정보가 다 들어있음 파일의 현재 위치 정보도 가지고 있음 파이썬 프로그램이 텍스트 파일과 같은 폴더에 있다면 앞의 경로 생략 가능 파일 읽기 특정 범위의 데이터를 파일에서 읽고 문자열로 반환 파일 포인터의 이동을 동반 h_fp = open(\"Hamlet_by_Shakespeare.txt\", \"r\") # 경로가 없는 걸로 보아 같은 폴더 내에 있다는 뜻, 읽기 모드 사용 title = h_fp.read(6) # 입력 받은 바이트 수 만큼 파일 포인터를 읽으면서 데이터를 반환함 author = h_fp.readline() # 다음에 있는 개행 포인터가 보일 때까지 쭉 읽어들이는 함수 h_fp.close() \\n new line character 한 줄을 밑으로 내려라 close()를 하지 않았을 경우 잘못 된 연산이 이루어지거나 파일이 깨질 수도 있음 close()를 해야 flushing이 이루어짐 flushing 메모리에 있는 값이 디스크에 저장 되는 것 파일 쓰기 문자열을 파일 포인터가 위치한 지점에 기록 w 모드로 존재하는 파일 오픈 시 데이터 삭제 p_fp = open(\"python.txt\", \"w\") p_fp.write(\"KNOU\\n\") p_fp.write(\"python programming\\n\") p_fp.close( ) w모드의 특징 무조건 이름을 새로 생성하고 파일 포인터를 맨 앞에 위치 시킴 기존 파일의 내용이 모두 사라질 수 있음 실제 경로에 이미 존재하는 파일인지 꼭 확인 데이터 추가 파일의 끝에 데이터를 덧붙이는 작업 파일 오픈 후 파일 포인터를 EoF로 이동 open 하자마자 맨 뒤로 이동 존재하지 않는 파일은 write와 동일 a_fp = open(\"python.txt\", \"a\") a_fp.write(\"\\nby CS\\n\") a_fp.close() 파일 읽고 쓰고 수정하는 프로그램 ‘Khan.txt’ 파일을 읽고 처리하는 프로그램을 작성하시오. 모든 내용을 출력하시오. 마지막에 ‘-칭기스 칸-‘을 삽입하시오. Lifecycle에 맞추어 파일 생성부터 시작 khan_fp = open(\"Khan.txt\", \"r\") print(khan_fp.read(10)) # 10글자를 읽고 출력 print(khan_fp.readline()) # 개행 문자가 있는 곳까지 읽고 출력 khan_fp.close() 파일 생성 구문 형식 파일 객체_참조 변수 = open(파일_이름, 모드) 텍스트 한줄 씩 읽고 출력하기 khan_fp = open(\"Khan.txt\", \"r\") # \\n으로 한줄 띄우고 print로 한줄 띄워지면서 새로운 줄이 생김 for motto in khan_fp.readlines(): # 텍스트 파일에 있는 모든 라인을 읽음(한줄 씩을 리스트로 읽어내는 명령) print(motto) \t # 문자열에 있는 개행 문자 삭제 for motto in khan_fp.readlines(): # 텍스트 파일에 있는 모든 라인을 읽음(한줄 씩을 리스트로 읽어내는 명령) print(motto.strip()) # 특정 문자를 제거 khan_fp.close() 텍스트 파일 맨 뒤에 새로운 텍스트 삽입 khan_fp = open(\"Khan.txt\", \"a\") khan_fp.write(\"\\n\") khan_fp.write(format(\"-칭기스 칸-\", \"&gt;50s\")) # 파일 포인터가 이미 맨 뒤에 위치해 있으므로, write 함수를 사용 # 문자열을 50폭, 오른쪽으로 정렬해서 추가 khan_fp.close() 파일의 활용데이터 분석 프로그램 “Hamlet_by_Shakespeare.txt” 파일에 포함된 단어가 출현한 횟수를 출력하는 프로그램을 작성하시오. 일렬로 나열 된 연속 된 데이터 리스트의 상위 개념 시퀀스 시퀀스의 개념 순서 화 된 값의 집합체를 저장할 수 있는 데이터 타입 단일 식별자로 연속된 저장 공간 접근 수단 제공 개별 원소의 값을 수정, 추가, 삭제 가능 원소(element)의 나열을 저장할 수 있는 타입 리스트, 세트, 투플, 딕셔너리 등 딕셔너리의 이해 키와 값의 쌍(pair)을 저장하는 시퀀스 단어를 값을 가지고 어떠한 새로운 값들을 찾아갈 수 있음 딕셔너리, 시퀀스도 생성, 수정, 삭제 등의 Lifecycle이 존재함딕셔너리의 생성 구문 형식 딕셔너리_이름 = {키1:값1, 키2:값2, …, 키n:값n} 세트, 리스트, 딕셔너리는 키 불가능 키와 값을 : 으로 연결 후 ,로 나열 빈 딕셔너리 생성 구문 형식 딕셔너리_이름 = {} 딕셔너리_이름 = dict() 항목의 추가 및 삭제 추가 구문 형식 딕셔너리_이름[키] = 값 삭제 구문 형식 del 딕셔너리_이름[키] 딕셔너리 멤버 멤버 설명 keys(): tuple 포함된 모든 키를 반환 values(): tuple 포함된 모든 값을 반환 items(): tuple (키, 값)의 형태의 투플로 모든 항목을 반환 clear(): None 모든 항목을 삭제 get(key): value 키에 해당하는 값을 반환 pop(key): value 키에 해당하는 값을 반환하고 항목을 삭제 popitem(): tuple 무작위로 한 (키, 값)을 반환하고 선택된 항목을 삭제 딕셔너리 순회 순회(traversal) 각각의 항목을 순서대로 한 번씩만 방문하는 과정 순회 형식 for key in dictionary : print(key + \":\" + str(dictionary[key])) key_사용_블록 데이터 분석 프로그램 “Hamlet_by_Shakespeare.txt” 파일에 포함된 단어가 출현한 횟수를 출력하는 프로그램을 작성하시오. 텍스트 파일을 열어 데이터 분석(딕셔너리 사용) h_fp = open(\"Hamlet_by_Shakespeare.txt\", \"r\") word_dict = dict() # 빈 딕셔너리 생성 # 각각의 라인을 읽어 내어 word 별로 저장 for line in h_fp.readlines(): # 텍스트를 줄 단위로 읽어냄 \t# 한 줄에 있는 여러 단어들을 하나 하나씩 끊어 주어야 함 for word in line.strip().split(): # 불 필요한 개행 문자 제거(strip) -&gt; 결과물을 하나씩 분할(split) word = word.strip(\" .,;?[]\\\"\\':=!\").lower() # 제거할 문자들을 전부 입력 후 소문자로 변환 if word_dict.get(word) is not None: # 정돈 된 word를 word_dict의 key로 가져온 것이 있다면 count = word_dict[word] # 기존 단어의 출현 횟수(value)를 count로 가져오는 작업 else: count = 0 word_dict[word] = count + 1 한 단어씩 끊어낸 후 불필요한 기호, 공백 등을 제거 인용 부호를 나타낼 때에는 “가 아닌 \"라고 적어주어야 함 대 · 소문자를 모두 구별하는 딕셔너리, 모든 문자를 소문자 또는 대문자로 통일 딕셔너리 순회 for key in word_dict: print(\"[\" + key + \"]\", str(word_dict[key]) + \"회\") # key 값(단어들)과 카운트한 횟수(word_dict[key]) 출력하는 작업 \t h_fp.close() # 파일 사용하고 난 후에는 꼭 close() 처리해 줄 것 데이터 분석 프로그램 개선 ‘Hamlet_by_Shakespeare.txt’ 파일에 출현 횟수가 100 이상되는 단어와 출력 횟수를 정렬하여 출력하는 프로그램을 작성하시오. 딕셔너리 정렬한 후 출력하기 h_fp = open(\"Hamlet_by_Shakespeare.txt\", \"r\") word_dict = dict() # 빈 딕셔너리 생성 # 각각의 라인을 읽어 내어 word 별로 저장 for line in h_fp.readlines(): # 텍스트를 줄 단위로 읽어냄 \t# 한 줄에 있는 여러 단어들을 하나 하나씩 끊어 주어야 함 \tfor word in line.strip().split(): # 불 필요한 개행 문자 제거(strip) -&gt; 결과물을 하나씩 분할(split) \t\tword = word.strip(\" .,;?[]\\\"\\':=!\").lower() # 제거할 문자들을 전부 입력 후 소문자로 변환 \t\t \t\tif word_dict.get(word) is not None: # 정돈 된 word를 word_dict의 key로 가져온 것이 있다면 \t\t\tcount = word_dict[word] # 기존 단어의 출현 횟수(value)를 count로 가져오는 작업 \t\telse: \t\t\tcount = 0 \t\t \t\tword_dict[word] = count + 1 # key와 value를 바꾸어 줄 새로운 딕셔너리 생성 word_r_dict = {v:k for (k, v) in word_dict.items()} # word_dict에서 리스트로 가져온 것들의 key와 value를 뒤바꾸어 새로운 word_r_dict에 넣기 word_dict = {k:v for (v, k) in sorted(word_r_dict.items(), reverse=True)} # word_r_dict에서 가져온 것들을 정렬 후 다시 딕셔너리로 구성 **for key in word_dict: \tif word_dict[key] &gt;= 100: # 100회 이상 등장하는 단어만 출력 \t\tprint(\"[\" + key + \"]\", str(word_dict[key]) + \"회\") # key 값(단어들)과 카운트한 횟수(word_dict[key]) 출력하는 작업 \t h_fp.close() # 파일 사용하고 난 후에는 꼭 close() 처리해 줄 것 sorted() 정렬을 쉽게 해주는 내장 함수 key 값으로만 정렬이 가능 → key와 value를 교환 reverse=True 내림차 순으로 정렬하는 sorted 함수의 옵션 연습 문제 데이터를 구성하는 개별 문자를 인코딩 체계를 통해 바이트로 변경하여 연속적으로 저장한 파일의 종류는? a. 텍스트 파일 시퀀스에서 각각의 항목을 순서대로 한 번씩만 방문하는 과정은? a. 순회 파일 python.txt에 텍스트 데이터를 추가하려고 할 때 빈 칸에 들어가야 할 것은? a_fp = open(\"python.txt\", _______) a_fp.write(\"\\nby CS\\n\") a_fp.close() a. \"a\" 학습 정리 파일은 컴퓨터에 의해 처리될 또는 처리된 데이터와 정보가 임시적으로 연속된 바이트의 형태로 저장된 상태임 파일은 연속된 바이트와 파일의 시작, 파일 포인터, 파일의 끝(EoF)으로 구성 됨 파일은 데이터가 저장되는 방식에 따라 텍스트 파일과 바이너리 파일로 구분 됨 파이썬은 인터프리터에서 파일의 시작, 파일 포인터, 파일의 끝을 활용하여 데이터 읽기, 쓰기를 위한 함수를 제공 함 파일은 파일 객체 생성, 읽기/쓰기/추가하기 작업, 파일 객체 삭제 과정을 통해 처리됨 파일의 이름은 파일의 고유 식별자 역할 및 저장 장치 내부에서 파일의 위치를 표현하는 파일 경로를 내포함 딕셔너리는 키와 값의 쌍(pair)을 저장하는 시퀀스임" }, { "title": "[데이터베이스 시스템] 12강 - 해싱과 특수 인덱스", "url": "/posts/knou-dbs-12/", "categories": "Database", "tags": "knou, database", "date": "2025-05-10 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '데이터베이스 시스템' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 DBMS에서 인덱스는 조건에 부합하는 레코드를 빠르게 탐색할 수 있도록 돕는 보조적 구조이며, 일반적으로는 B+-트리가 가장 널리 사용 됨 B+-트리는 범위 질의나 정렬된 데이터 접근에 효과적이지만, 모든 질의 유형에 대해 항상 최상의 성능을 보장하지는 않음 특히 일치 검색을 반복적으로 수행하거나, 특정 조건에 대해 검색 효율을 높여야 하는 경우에는 B+-트리보다 다른 구조가 적합할 수 있음 DBMS 운용 시 다양한 인덱스 기법을 상황에 맞게 선택하여 활용하는 것이 필요함 해시 함수를 기반으로 하는 인덱싱 방식인 해싱(hashing) 기법을 중심으로 살펴봄 해싱은 특히 등가 조건에 대한 빠른 탐색에 효과적인 방법이며, 정적 해싱과 동적 해싱을 포함한 다양한 기법이 존재함 속성의 도메인이 제한적인 경우에 대량의 읽기 기반 질의에서 공간 효율성과 성능 측면에서 유리한 특성을 갖는 특수한 인덱싱 구조인 비트맵 인덱스(bitmap index)에 대해서도 함께 학습함주요 용어 해시 함수 레코드의 탐색 키에 따라 레코드를 버킷에 대응 시키기 위해 사용하는 함수 버킷 한 개 이상의 레코드를 저장할 수 있는 저장 공간 단위 충돌 서로 다른 레코드가 같은 버킷 주소로 대응되는 상황 오버 플로 버킷에 레코드를 저장할 수 있는 충분한 여유 공간이 없는 상태 비트맵 주어진 릴레이션에 존재하는 레코드의 수 만큼의 비트로 특정 컬럼 값의 유무를 표현한 비트 열 강의록해싱의 이해해싱의 개념 해시(hash) 탐색 키에 산술적인 연산을 통해 버킷의 주소를 계산하는 해시 함수를 사용하여 데이터 배분 및 접근하는 기법 버킷(bucket) 한 개 이상의 레코드를 저장할 수 있는 저장 공간의 단위 일반적으로 버킷의 크기는 디스크 블록의 크기와 일치 해시의 구조해시의 사용 h(K₃) = h(K₇) = 3 해시 함수의 역할 최상의 경우 균등하고 예쁘게 저장 각각의 버킷에 담겨 있는 레코드의 수는 최소화 되고 버킷내에서 특정 레코드를 찾을 때 훨씬 적은 시간 소요 됨 최악의 경우 나머지 버킷 낭비 버킷 내에서 특정 레코드를 찾을 때 많은 시간 소요 됨 일반적인 경우 해시 파일 구조 학번의 마지막 자릿수를 6으로 나눈 나머지로 해시 함수를 정의 해시 함수로 어떻게 구조화 하는 지를 아는 것이 중요 정적 해싱의 특징 버킷의 개수가 고정 된 해싱 기법 해시 함수로 키 값이 어떻게 유지 되는지를 파악하는 것이 중요 키 값이 Kᵢ인 레코드 삽입 h(Kᵢ)를 통하여 Kᵢ에 대응하는 버킷 주소를 생성하고 레코드를 해당 버킷에 저장 인덱스 엔트리를 버킷에 저장한다면 더 빠른 검색이 가능 키 Kᵢ를 가진 데이터를 저장할 때, 해시 함수 h(Kᵢ)로 해시 값을 계산하고 해당 버킷에 데이터를 저장함 데이터 키: Kᵢ = 25 해시 함수: h(Kᵢ) = Kᵢ % 10 결과: h(25) = 25 % 10 = 5 → 데이터를 버킷 5번에 저장 키 값이 Kᵢ인 레코드 검색 h(Kᵢ)을 통하여 버킷 주소를 생성하고 버킷에 저장 된 레코드 접근 h(Kᵢ) = h(Kⱼ) = m인 경우가 발생하기 때문에 버킷 m에 저장 된 모든 레코드를 탐색하여 선택하는 과정이 필요 키 Kᵢ로 저장된 데이터를 찾으려면, 해시 함수 h(Kᵢ)를 적용하여 해당 주소를 찾음 검색 키: Kᵢ = 25 해시 함수: h(Kᵢ) = Kᵢ % 10 결과: h(25) = 25 % 10 = 5 → 버킷 5번에서 데이터를 읽음 충돌과 동거자 같은 버킷 아이디가 나왔을 때 사용하는 용어들 해시 함수는 때때로 다른 탐색 키에도 같은 버킷 주소를 내보냄 탐색 키는 다르지만 같은 버킷에 있음 충돌 서로 다른 두 레코드가 동일한 버킷에 대응 충돌은 서로 다른 상황에서 발생하기 때문에 균등하게 데이터가 배분되기 보다 불균형이 생겨 버킷 id마다 서로 다른 갯수의 레코드가 저장될 수 있음 동거자 충돌에 의해 같은 버킷 주소를 갖는 레코드 h(rᵢ) = h(rⱼ) 오버플로우(overflow) 버킷에 레코드를 저장할 수 있는 여유 공간이 없는 상황에 발생 추가적인 버킷 또는 다음 버킷에 할당하여 처리 오버플로우가 발생할 수록 접근 시간이 증가하고 해시 성능이 저하 오버플로우 버킷에 추가적인 디스크 접근을 요구하므로 검색의 성능이 저하될 수 있음 오버플로우 처리 방법 다음 아이디에 해당 레코드 저장 해당 버킷에 추가적으로 공간 할당 균등한 분배를 할 수 있도록 설계하는 것이 관건해시 인덱스 해시 파일 구조의 동작 방식을 레코드가 아닌 인덱스 엔트리에 적용한 인덱스 정적 해싱의 문제 데이터베이스의 크기가 커짐에 따른 성능 감소 사전에 큰 공간을 잡을 경우 초기에 상당한 양의 공간이 낭비 재구성 시 새롭게 정의 된 해시 함수를 사용하여 모든 인덱스 엔트리에 대하여 다시 계산하고 버킷에 재 할당하는 대량의 비용이 발생 해시 구조의 크기가 동적으로 결정 되는 동적 해싱 기법 제안 동적 해싱동적 해싱의 개념 동적 해싱의 정의 버킷의 개수를 가변적으로 조절할 수 있는 해싱 기법 데이터베이스의 크기에 따라 버킷의 크기가 비례 데이터베이스의 증대 혹은 축소에 따른 인덱스의 구조를 조절하기 위해 해시 함수를 동적 변경하는 기법 확장성 해싱 동적 해싱의 일종으로 디렉터리와 버킷의 2단계 구조 디렉터리는 디스크에 저장되는 버킷 주소 테이블 디렉터리 깊이를 의미하는 정수 값 d를 포함하는 헤더와 데이터가 저장 된 버킷에 대한 2ᵈ개의 포인터로 구성 확장성 해싱 모조 키(pseudo key) 레코드 탐색 키 값이 해시 함수에 의해 일정 길이의 비트 스트링으로 변환 된 키 모조 키의 첫 d 비트를 사용하여 디렉터리에 접근 해시 함수가 탐색 키를 모조 키로 만드는 역할을 함 버킷 헤더 정수 값 i(≤ d)가 저장 되어 있음을 표시 i는 버킷에 저장되어 있는 레코드의 모조 키들이 처음부터 i 비트까지 일치함을 표시 확장성 해싱의 구조 데이터가 많아질 때, 디렉터리와 버킷 구조를 동적으로 확장함으로써 충돌 문제를 해결 모조 키(pseudo key): 해시 함수 h를 통해 탐색 키(key)를 일정 길이의 비트 스트링으로 변환 모조 키는 해싱 결과의 비트 스트링 ex) 키 값 Kᵢ → h(Kᵢ) → 11001101 디렉터리 버킷에 접근하기 위한 “주소 목록” 역할 최상위 d 비트(탐색 키의 앞부분)를 사용하여 실제 저장소(버킷)에 대한 주소를 관리 디렉터리는 2^d개의 엔트리를 가짐 d는 디렉터리 깊이 버킷 실제 데이터를 저장하는 공간 버킷 내에 존재하는 모든 레코드들은 공통적으로 탐색 키의 상위 i비트까지가 동일 이 정보를 버킷 헤더(bucket header)에 기록해서 관리 전체 모조 키 중 앞 3자리는 버킷의 위치를 알려주는 이정표 인덱스 엔트리 검색 → 레코드 접근 → 레코드를 메모리에 적재 B4가 꽉찬 상태확장성 해싱의 분할 레코드 삽입에 의해 분할 된 확장성 해싱 파일 추가적인 할당을 통해 재분배를 하는 확장성 해싱 포인터 재분배 비트맵 인덱스비트맵 인덱스의 개념 탐색 키의 중복 비율이 높은 컬럼을 대상으로 하는 질의를 효율적으로 처리하기 위해 고안 된 특수한 형태의 인덱스 B+- 트리 상에서 탐색 키 삽입, 삭제 했던 개념과 유사 중복이 많은 컬럼은 비트맵 인덱스를 권장 중복이 많은 컬럼 값에 적용하게 되면 레코드의 개수가 길어진다하더라도 비트맵도 길어지기 때문에 비트 논리곱 연산이 빠르게 수행 가능 비트맵 간단한 비트의 배열 릴레이션 r의 속성 A에 대한 비트맵 인덱스는 A가 가질 수 있는 값에 대해 비트맵을 구성 각 비트맵은 릴레이션에 있는 레코드의 수 n개 만큼 n개의 비트로 표현 비트맵 인덱스 구성 i번째 레코드가 컬럼 A에 해당 값을 가지면 비트 맵의 i번째 비트를 1로, 그렇지 않으면 0으로 설정 비트맵 인덱스의 사용 성별이 남자이고 성적이 B인 학생의 정보를 출력 SELECT * FROM 학생 \tWHERE 성별 = '남자' AND 성적 = 'B' 성별의 ‘남자’와 성적의 ‘B’의 비트 열에 대한 비트 논리 곱 연산을 수행 비트맵 인덱스의 사용 비트 맵의 활용 컬럼에 대한 값의 범위가 유한하고 비교적 개수가 적은 규모일 때 용이 조건이 맞는 레코드를 빠르게 찾을 수 잇음 적용 직책, 학과, 혈액형 등 비트맵 인덱스의 크기 레코드의 크기가 수백 바이트 이상이 되어도 비트 맵 인덱스에서는 하나의 비트로 표시 실제 릴레이션 크기에 비해 매우 작은 것이 장점 기본 키 또는 UNIQUE가 설정 된 키에 비트맵 인덱스를 적용할 경우, 인덱스의 크기가 굉장히 커질 수도연습 문제 다음 해시 인덱스 구조에서 탐색 키를 버킷 주소에 대응 시키는 h를 무엇이라고 하는가? a. 해시 함수 해싱 기법이란 탐색 키를 특정 버킷에 대응 시켜 레코드를 그룹화 함으로서 특정 탐색 키를 검색하는 조건에 대해 대응되는 버킷만 검색하여 속도를 높이는 기법을 말함 이 때 각각의 탐색 키를 특정 버킷에 대응 시키는 역할은 해시 함수가 수행함 데이터베이스의 크기에 따라 버킷의 개수가 조절되는 형태의 해싱을 무엇이라고 하는가? a. 동적 해싱 해시 기법은 크게 정적 해싱과 동적 해싱으로 구분 됨 정적 해싱은 버킷의 개수가 데이터베이스의 크기와 관계없이 고정되어 있는 해싱을 기법을 말함 동적 해싱은 공간 낭비를 최소화 하기 위해 데이터베이스 크기에 따라 버킷의 개수가 유동적으로 변하는 해싱 기법을 말함 다음과 같은 테이블에 대해 성별 컬럼에 비트맵 인덱스를 생성했을 때, ‘남자’에 대한 비트 열로 올바른 것은? 학번 성별 학과 20120451 남자 컴퓨터과학 20135132 남자 국어국문학 20132549 남자 컴퓨터과학 20145942 여자 행정학 20145315 남자 경제학 20156857 여자 컴퓨터과학 20153546 여자 경제학 a. 1110100 비트 맵 인덱스는 컬럼 값의 종류가 극히 적은 컬럼에 생성할 수 있는 특수한 형태의 인덱스로, 특정 컬럼 값 v에 대해 비트 열은 각각의 첫 번째 레코드부터 레코드의 컬럼 값이 v일 경우 1, v가 아닐 경우 0으로 연결하여 생성함 따라서 성별 컬럼에서 첫 번째, 두 번째, 세 번째, 다섯 번째 레코드의 성별 컬럼 값이 ‘남자’이므로 ‘남자’에 대한 비트 열은 1110100으로 생성 됨 정리 하기 해싱은 수학적 함수 개념을 사용한 데이터 관리 기법으로 버킷의 개수가 정해진 정적 해싱과 데이터베이스의 크기에 따라 버킷의 개수가 변경되는 동적 해싱으로 구분됨 해시 함수는 레코드의 탐색 키 값과 저장되어야 하는 버킷의 주소를 대응 시키는 역할을 수행하며, 레코드가 버킷에 균등하게 배분 되는 해시 함수가 가장 이상적임 충돌 발생으로 서로 다른 탐색 키가 동일한 버킷에 대응될 수 있으며 이를 동거자라고 함 특정 버킷에 많은 충돌이 발생하여 더 이상의 레코드나 인덱스 엔트리가 저장될 수 없을 때 이를 오버플로라 함 확장성 해싱은 데이터베이스의 크기에 따라 버킷이 확장되는 동적 해싱 기법의 일종으로 디렉토리와 버킷으로 구성되며 디렉토리의 주소와 버킷의 주소로 구성되는 모조 키를 사용함 비트맵 인덱스는 다중 키를 가진 질의를 보다 효율적으로 처리하기 위해 고안된 인덱스임 비트맵은 간단한 비트 배열로 이루어져 있음 비트맵 인덱스를 사용하여 레코드를 검색 시 주어진 각각의 조건에 해당하는 비트 열을 비트 AND 연산을 수행하여 최종적으로 생성되는 비트열로 조건을 만족하는 레코드의 위치를 빠르게 파악할 수 있음체크 포인트 다음은 인덱스에 관한 내용이다. (가)와 (나)가 설명하는 용어를 순서대로 나열한 것은? (가)는 많은 수의 행을 가진 릴레이션을 위해 사용하는 기법으로, 하나 이상의 열에 대해 인덱스를 생성하며 적은 수의 유일한 값들을 갖는 열들에 적합하다. (나)는 디렉터리(directory)와 버킷(bucket) 집합을 사용하는 기법으로, 데이터베이스가 증가하고 축소되는 변화에 유연하다. a. 비트맵 인덱스, 확장성 해싱 다음 ‘학생성적’ 릴레이션과 각 투플의 번호를 참고하여 ‘성적’ 속성에 대한 비트맵 인덱스를 적절히 표현한 것은? a. " }, { "title": "[Java 프로그래밍] 12강- 컬렉션과 스트림", "url": "/posts/knou-java-12/", "categories": "Language, Java", "tags": "knou, java", "date": "2025-05-08 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김희천 교수님의 'Java 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 스트림은 컬렉션이나 배열로부터 만들어지는 원소의 시퀀스를 표현하며, 간결하고 효율적인 다양한 처리 방법을 제공하는 인터페이스임 forEach()메소드를 사용하고 매개 변수로 람다 식을 제공하면 컬렉션이나 배열의 내부에서 반복을 처리함 스트림이 제공하는 다양한 기능을 활용하여 컬렉션이나 배열의 원소를 처리하는 방법을 학습함학습 목표 내부 반복과 외부 반복의 차이점을 설명할 수 있음 forEach()메소드를 활용할 수 있음 스트림을 이용하여 컬렉션/배열의 원소에 대한 병렬 처리 방법을 설명할 수 있음 스트림 파이프 라인을 이해하고 중간 처리과 최종 처리의 차이점을 설명할 수 있음강의록forEach()메소드외부 반복 컬렉션이나 배열의 원소를 다룰 때, 원소의 반복 처리를 프로그램에서 명시적으로 제어하는 방식 원소를 프로그램에서 선언된 변수로 복사한 후, 작업을 처리함 for, 향상된 for, while, do-while, Iterator등을 이용한 반복 작업이 외부 반복에 해당됨 List&lt;String&gt; names = Arrays.asList(\"Kim\", \"Lee\", \"Park\"); for (String name : names) { System.out.println(name); } Iterator&lt;String&gt; iterator = names.listIterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } 내부 반복과 forEach()메소드 원소의 반복 처리를 컬렉션 또는 스트림과 같은 데이터 구조 내부에서 반복을 처리하는 방식 프로그램에서 스트림 API를 이용하여 반복 처리를 위임하고, 처리 코드만 람다식으로 제공함 컬렉션의 forEach()메소드를 이용하고, 매개변수로 람다식을 지정 forEach()메소드는 함수형 인터페이스인 Consumer객체를 인자로 받음 List&lt;String&gt; names = Arrays.asList(\"Kim\", \"Lee\", \"Park\"); // 내부 반복 names.forEach(item -&gt; System.out.println(\"내부 반복: \" + item)); 코드가 간결해 지며, 가독성이 좋아지고, 병렬 처리가 가능하며, 성능 최적화에 유리스트림스트림 정의 컬렉션이나 배열과 같은 데이터 소스로부터 만들어지는 원소의 시퀀스를 표현하며, 간결하고 효율적 처리 방법을 제공하는 인터페이스 내부 반복과 함수형 프로그래밍 방식을 지원 멀티 코어 CPU를 활용한 병렬 처리 지원 관련 클래스와 인터페이스는 java.util.stream패키지에 있음 다양한 집합체 연산을 지원함 중간 처리 연산과 최종 처리 연산 filter(), map(), sorted(), count(), collect(), anyMatch()등 스트림의 특성 데이터 원본으로부터 스트림을 생성하며, 원본 데이터를 변경하지 않음 원본 데이터의 변경이 필요하면 새로운 스트림을 생성해야 함 스트림은 일회용 스트림 연산을 파이프라인 형태로 연결할 수 있음 지연 평가(lazy evaluation)를 통해 연산을 최적화 java.util.stream패키지에 포함된 스트림 인터페이스 숫자와 스트림 IntStream, LongStream, DoubleStream인터페이스 기본형 int, long, double형의 원소로 이루어진 데이터를 다루기 위한 스트림 주요 기능 ex) IntStream의 경우 static IntStream range(int, int), static IntStream rangeClosed(int, int) static IntStream of(int... values) sum(), average(), min(), max()등 filter(), map(), reduce()등 System.out.println(IntStream.rangeClosed(1, 100).sum()); System.out.println(IntStream.rangeClosed(1, 100).average().getAsDouble()); System.out.println(IntStream.rangeClosed(1, 100).min().getAsInt()); System.out.println(IntStream.rangeClosed(1, 100).max().getAsInt()); 배열과 스트림 Arrays.stream()를 사용하여 배열로부터 스트림을 생성할 수 있음 Arrays클래스에서 제공되는 메소드 static DoubleStream stream(double[] array) static IntStream stream(int[] array) static &lt;T&gt; Stream&lt;T&gt; stream(T[]) 원소가 객체인 배열로부터 스트림 생성 Stream은 제네릭 인터페이스 String[] strArray = { \"홍길동\", \"이순신\", \"김유신\" }; Stream&lt;String&gt; strStream = Arrays.stream(strArray); strStream.forEach(item -&gt; System.out.println(item)); int[] intArray = {1, 2, 3}; IntStream intStream = Arrays.stream(intArray); intStream.forEach(item -&gt; System.out.println(item)); 파일과 스트림 Files.lines(Path)을 사용하여 텍스트 파일로부터 행 단위 문자열로 구성 된 스트림을 생성할 수 있음 Path path = Paths.get(\"c:\\\\data\\\\data.txt\"); Stream&lt;String&gt; fileStream = Files.lines(path); fileStream.forEach(line -&gt; System.out.println(line)); fileStream.close(); 컬렉션과 스트림 Collection유형의 객체인 경우 Collection인터페이스에서 stream()과 parallelStream()메소드가 디폴트 메소드로 제공 됨 parallelStream()은 병렬 처리가 가능한 스트림을 리턴함 HashSet, ArrayList, LinkedList객체 등으로부터 스트림을 생성할 때 사용 HashMap객체인 경우 먼저 entrySet()을 사용하여 Set 유형의 객체를 얻은 후, stream()또는 parallelStream()메소드를 사용하여 스트림을 생성함 HashSet과 스트림 사용 예 HashSet객체와 스트림 import java.util.*; import java.util.stream.*; public class Main { public static void main(String[] args) { Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { set.add(i); } // 일반 스트림 사용 System.out.println(\"일반 스트림 사용\"); Stream&lt;Integer&gt; n_stream = set.stream(); n_stream.forEach(item -&gt; System.out.println(item)); // 병렬 스트림 사용 System.out.println(\"병렬처리 스트림 사용\"); Stream&lt;Integer&gt; p_stream = set.parallelStream(); p_stream.forEach(item -&gt; System.out.println(item + \"(\" + Thread.currentThread().getName() + \")\")); } } // 일반 스트림 사용 // 0 // 1 // 2 // 3 // 4 // 5 // 6 // 7 // 8 // 9 // 병렬처리 스트림 사용 // 6(ForkJoinPool.commonPool-worker-2) // 7(ForkJoinPool.commonPool-worker-2) // 4(ForkJoinPool.commonPool-worker-1) // 5(ForkJoinPool.commonPool-worker-1) // 8(main) // 9(main) // 2(ForkJoinPool.commonPool-worker-3) // 0(ForkJoinPool.commonPool-worker-4) // 1(ForkJoinPool.commonPool-worker-4) // 3(ForkJoinPool.commonPool-worker-3) ArrayList와 스트림 사용 예 객체를 원소로 갖는 ArrayList와 스트림 class People { String name; int age; People(String name, int age) { this.name = name; this.age = age; } public String toString() { return (\"name : \" + this.name + \", age : \" + this.age); } } import java.util.*; import java.util.stream.*; public class Main { public static void main(String[] args) { List&lt;People&gt; list = new ArrayList&lt;People&gt;(); list.add(new People(\"홍길동\", 30)); list.add(new People(\"이순신\", 40)); list.add(new People(\"김유신\", 50)); list.add(new People(\"유관순\", 20)); // 일반 스트림 사용 System.out.println(\"일반 스트림 사용\"); Stream&lt;People&gt; n_stream = list.stream(); n_stream.forEach(item -&gt; System.out.println(item)); // 병렬 스트림 사용 System.out.println(\"병렬처리 스트림 사용\"); Stream&lt;People&gt; p_stream = list.parallelStream(); p_stream.forEach(item -&gt; System.out.println(item + \" : \" + Thread.currentThread().getName())); } } // 일반 스트림 사용 // name : 홍길동, age : 30 // name : 이순신, age : 40 // name : 김유신, age : 50 // name : 유관순, age : 20 // 병렬처리 스트림 사용 // name : 김유신, age : 50 : main // name : 이순신, age : 40 : ForkJoinPool.commonPool-worker-1 // name : 홍길동, age : 30 : main // name : 유관순, age : 20 : ForkJoinPool.commonPool-worker-2 스트림 파이프라인스트림 파이프라인과 중간 연산 컬렉션, 배열, 또는 파일로부터 생성 된 스트림에 어떤 처리를 수행하고 새로운 스트림이 만들어지며, 계속해서 이러한 처리 과정을 반복하는 것 메소드 체이닝을 사용하여 파이프라인을 구축할 수 있음 중간 연산(또는 중간 처리) 원본 스트림에서 데이터를 반환하거나 필터링 등으로 새로운 스트림을 생성하는 연산 중간 연산에서 생성 된 스트림은 다음 연산으로 연결 되어 파이프라인을 형성 함 filter(), map(), sorted()등의 연산 스트림 파이프라인과 종료 연산 종료 연산(또는 최종 연산) 중간 연산을 거친 스트림에 대해 최종적인 결과를 만들거나 동작을 수행하는 부분 스트림 파이프라인에서 마지막에 한번만 수행 됨 forEach(), collect(), count(), anyMatch, reduce()등 List&lt;String&gt; words = Arrays.asList(\"apple\", \"banana\", \"cherry\", \"Avocado\"); long count = words.stream() // 원본 스트림 .map(String::toUpperCase) // 중간 연산 .filter(word -&gt; word.startsWith(\"A\")) // 중간연산 .count(); // 최종연산 System.out.println(count); // 2가 출력됨 스트림 파이프라인과 메소드 체이닝 메소드 체이닝의 활용 - 메소드의 연속적 호출 List&lt;Book&gt; books = new ArrayList&lt;Book&gt;(); // ... ... Stream&lt;Book&gt; stream = books.stream(); IntStream price = stream.mapToInt(book -&gt; book.getPrice()); double avg = price.average().getAsDouble(); System.out.println(avg); List&lt;Book&gt; books = new ArrayList&lt;Book&gt;(); // ... ... double avg = books.stream() .mapToInt(book -&gt; book.getPrice()) .average().getAsDouble(); System.out.println(avg); 중간 연산필터링 컬렉션 원소들 중에서 중복을 제거하거나 특정 조건을 만족하는 원소만 추출하여 새로운 스트림을 생성하는 작업 Stream&lt;T&gt;, IntStream, LongStream, DoubleStream에서 필터링 메소드는 중간 연산이므로 같은 스트림을 리턴 함 중복 제거에는 distinct()메소드를 사용 원소가 객체인 경우 hashCode()의 리턴 값이 같고, equals()로 비교할 때 true인 경우, 중복으로 판단함 조건을 통한 걸러 내기에는 filter()메소드를 사용 filter()메소드의 매개 변수는 함수형 인터페이스이며, true 또는 false를 리턴하는 람다식을 매개 변수로 전달 필터링 예 distinct()메소드로 중복을 제거하는 필터링 스트림 예 import java.util.*; class Book { String title; String author; int price; Book(String title, String author, int price) { this.title = title; this.author = author; this.price = price; } @Override public String toString() { return \"title:\" + title + \", author:\" + author + \", price:\" + price; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Book book = (Book) o; return price == book.price &amp;&amp; Objects.equals(title, book.title) &amp;&amp; Objects.equals(author, book.author); } @Override public int hashCode() { return Objects.hash(title, author, price); } } public class Main { public static void main(String[] args) { List&lt;Book&gt; books = new ArrayList&lt;Book&gt;(); books.add(new Book(\"JAVA 프로그래밍\", \"홍길동\", 10000)); books.add(new Book(\"PHP 프로그래밍\", \"이순신\", 20000)); books.add(new Book(\"빅데이터 연구\", \"유관순\", 12000)); books.add(new Book(\"커뮤니케이션 이론\", \"강감찬\", 15000)); books.add(new Book(\"PHP 프로그래밍\", \"이순신\", 20000)); books.add(new Book(\"알고리즘\", \"권율\", 17000)); books.stream() .distinct() .forEach(book -&gt; System.out.println(book)); } } // title:JAVA 프로그래밍, author:홍길동, price:10000 // title:PHP 프로그래밍, author:이순신, price:20000 // title:빅데이터 연구, author:유관순, price:12000 // title:커뮤니케이션 이론, author:강감찬, price:15000 // title:알고리즘, author:권율, price:17000 filter()메소드를 사용하는 필터링 스트림 예 import java.util.*; public class Main { public static void main(String[] args) { String[] strArray = {\"ABC\", \"BCD\", \"AFE\", \"CDE\", \"ABZ\", \"ACCZ\"}; List &lt;String&gt; strList = Arrays.asList(strArray); strList.stream() .filter(item -&gt; item.startsWith(\"A\")) .filter(item -&gt; item.endsWith(\"Z\")) .filter(item -&gt; item.length() &gt; 3) .forEach(item -&gt; System.out.println(item)); strList.stream() .filter(item -&gt; item.startsWith(\"A\") &amp;&amp; item.endsWith(\"Z\") &amp;&amp; item.length() &gt; 3) .forEach(item -&gt; System.out.println(item)); } } // ACCZ // ACCZ 매핑 원소들을 다른 원소로 변환하여 새로운 스트림을 생성하는 작업 Stream&lt;T&gt;에서 map()은 매개 변수로 주어지는 함수(람다식)를 적용하여 Stream&lt;T&gt;로, mapToInt()은 함수를 적용하여 IntStream으로 변환 시킴 flatMap()과 flatMapToInt()등은 스트림의 각 요소에 매핑 함수(람다식)를 적용하여 스트림으로 변환한 후, 여러 스트림을 다시 하나의 스트림으로 합침 IntStream에서 asDoubleStream()과 asLongStream()은 기본형을 다른 기본형으로 변환 시키는 것으로 DoubleStream또는 LongStream객체를 리턴, boxed()는 기본형 int 값을 포장형 Integer객체로 변환시키고 Stream&lt;Integer&gt;객체를 리턴 매핑 예 스트림 매핑 예 import java.util.*; import java.util.stream.*; public class Main { public static void main(String[] args) { //String 배열을 IntStream으로 변환 String[] strNums = {\"10\", \"20\", \"30\"}; Arrays.stream(strNums) .mapToInt(item -&gt; Integer.parseInt(item)) .forEach(item -&gt; System.out.println(item)); //int 배열을 Stream&lt;String&gt;으로 변환 int[] numbers = {10, 20, 30}; Arrays.stream(numbers) .mapToObj(item -&gt; String.valueOf(item)) .forEach(item -&gt; System.out.println(item + \"(\" + item.length() +\")\")); } } // 10 // 20 // 30 // 10(2) // 20(2) // 30(2) import java.util.*; import java.util.stream.*; public class Main { public static void main(String[] args) { Arrays.asList(\"Hello world, this is java\", \"Welcome to java world\") .stream() .flatMap(sentence -&gt; Arrays.stream(sentence.split(\" \"))) .forEach(word -&gt; System.out.println(word)); } } // Hello // world, // this // is // java // Welcome // to // java // world 정렬 스트림의 원소들을 오름차순 또는 내림차순으로 정렬하여 새로운 스트림을 생성하는 작업 Stream&lt;T&gt;에서 sorted()메소드 사용 정렬 된 새로운 스트림을 리턴 T 유형의 객체(원소)는 Comparable이어야 하며, 크기 비교에 compareTo()메소드가 사용 됨 기본형에 대응 되는 포장 클래스는 모두 Comparable임 정렬 예 compareTo()가 구현 된 Book 클래스와 정렬 된 스트림 생성 예 class Book implements Comparable&lt;Book&gt; { String title; String author; int price; Book(String title, String author, int price) { this.title = title; this.author = author; this.price = price; } public String toString() { return (\"title:\" + this.title + \", author:\" + this.author + \", price:\" + this.price); } @Override public int compareTo(Book book) { return Integer.compare(this.price, book.price); } } import java.util.*; public class Main { public static void main(String[] args) { List&lt;Book&gt; books = new ArrayList&lt;Book&gt;(); books.add(new Book(\"JAVA 프로그래밍\", \"홍길동\", 10000)); books.add(new Book(\"PHP 프로그래밍\", \"이순신\", 20000)); books.add(new Book(\"마이크로프로세서 입문\", \"김유신\", 14000)); books.add(new Book(\"데이터베이스 입문\", \"신사임당\", 21000)); books.add(new Book(\"빅데이터 연구\", \"유관순\", 12000)); books.add(new Book(\"커뮤니케이션 이론\", \"강감찬\", 15000)); books.add(new Book(\"PHP 프로그래밍\", \"이순신\", 20000)); books.add(new Book(\"알고리즘\", \"권율\", 17000)); books.stream().sorted().forEach(book-&gt; System.out.println(book)); } } // title:JAVA 프로그래밍, author:홍길동, price:10000 // title:빅데이터 연구, author:유관순, price:12000 // title:마이크로프로세서 입문, author:김유신, price:14000 // title:커뮤니케이션 이론, author:강감찬, price:15000 // title:알고리즘, author:권율, price:17000 // title:PHP 프로그래밍, author:이순신, price:20000 // title:PHP 프로그래밍, author:이순신, price:20000 // title:데이터베이스 입문, author:신사임당, price:21000 루핑 스트림의 원소들을 하나씩 순회하면서 반복적으로 처리하고 새로운 스트림을 생성하는 작업 peek()메소드는 각 요소를 순회하면서 주어진 동작(람다식)을 수행하는 중간 연산으로 디버깅이나 로깅에 자주 사용 됨 새로운 스트림을 반환하며, 최종 연산과 함께 사용되어야 함 참고로 forEach()메소드는 각 요소를 반복하면서 주어진 동작(람다식)을 수행하는 종료 연산 anyMatch()메소드는 종료 연산으로 주어진 조건(람다식)을 만족하는지 원소를 순회하면서 조사함 주어진 조건을 만족하는 요소를 찾으면 즉시 검색을 중단 스트림 파이프라인에서 peek()와 anyMatch()를 조합하면 처리되는 원소를, 조건식에서 처음 true가 되는 원소까지로 제한하게 됨 주로 디버깅 용도로 사용됨 종료 연산이 있어야 작동함루핑 예 peek()메소드 사용 예 import java.util.*; import java.util.stream.*; class Book { String title; String author; int price; Book(String title, String author, int price) { this.title = title; this.author = author; this.price = price; } public String toString() { return (\"title:\" + this.title + \", author:\" + this.author + \", price:\" + this.price); } } public class Main { public static void main(String[] args) { List &lt;Book&gt; books = new ArrayList &lt;Book&gt; (); books.add(new Book(\"JAVA 프로그래밍\", \"홍길동\", 10000)); books.add(new Book(\"PHP 프로그래밍\", \"이순신\", 20000)); books.add(new Book(\"마이크로프로세서 입문\", \"김유신\", 14000)); books.add(new Book(\"데이터베이스 입문\", \"신사임당\", 21000)); books.add(new Book(\"빅데이터 연구\", \"유관순\", 12000)); books.add(new Book(\"커뮤니케이션 이론\", \"강감찬\", 15000)); books.add(new Book(\"PHP 프로그래밍\", \"이순신\", 20000)); books.add(new Book(\"알고리즘\", \"권율\", 17000)); books.stream() .peek(book -&gt; System.out.println(book)) .anyMatch(m -&gt; m.price &gt; 20000); // 종료 연산 } } // anyMatch가 true를 반환하기 전까지 peek 실행 // title:JAVA 프로그래밍, author:홍길동, price:10000 // title:PHP 프로그래밍, author:이순신, price:20000 // title:마이크로프로세서 입문, author:김유신, price:14000 // title:데이터베이스 입문, author:신사임당, price:21000` 종료 연산종료 연산이란 중간 처리를 거친 스트림에 대해 집계나 결과 출력 등의 최종 처리를 수행하는 최종 연산 집계(합계, 평균, 최대, 최소 등), 매칭, 수집 등의 작업을 수행함 스트림 파이프라인의 마지막 단계에서 사용되며, 스트림을 다시 사용할 수 없게 함 종료 연산이 수행되기 전까지는 스트림 파이프라인이 실제로 실행 되지 않음(lazy evaluation) 지연 평가를 통해 스트림 파이프 라인을 효율적 구성하며 필요한 결과를 얻음 집계 원소들의 개수, 합계, 평균, 최대 값, 최소 값 등을 구하는 최종 처리 count(), sum(), average(), min(), max(), reduce() count() 스트림의 원소 개수 반환 sum() 숫자 스트림의 합계 반환 average() 숫자 스트림의 평균 반환 (OptionalDouble반환) min() 스트림의 최소 값 반환 (OptionalInt, OptionalLong, OptionalDouble반환) max() 스트림의 최대 값 반환 (OptionalInt, OptionalLong, OptionalDouble반환) reduce() 사용자 정의 집계 연산 수행 int[] intArray = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};// 1부터 10까지의 정수 중에서 짝수만 필터링하여 출력long count = Arrays.stream(intArray).filter(n -&gt; n % 2 == 0).count();System.out.println(\"2의 배수의 개수 : \" + count);// 1부터 10까지의 정수 중에서 짝수만 필터링하여 합계 계산long sum = Arrays.stream(intArray).filter(n -&gt; n % 2 == 0).sum();System.out.println(\"2의 배수의 합 : \" + sum);// 1부터 10까지의 정수 중에서 짝수만 필터링하여 최소 값 계산OptionalInt min = Arrays.stream(intArray).min();System.out.println(\"최소값 : \" + min.getAsInt());// 1부터 10까지의 정수 중에서 짝수만 필터링하여 평균 계산OptionalDouble avg = Arrays.stream(intArray).average();System.out.println(\"평균 : \" + avg.getAsDouble());// 2의 배수의 개수 : 5// 2의 배수의 합 : 30// 최소값 : 1// 평균 : 5.5매칭 스트림의 원소가 특정 조건을 만족하는지 검사하는 연산 anyMatch() 스트림의 최소 하나의 요소가 조건을 만족할 때 true 반환 allMatch() 스트림의 모든 원소가 조건을 만족할 때 true 반환 noneMatch() 스트림의 모든 원소가 조건을 만족하지 않으면 true 반환 int[] intArray = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};boolean result = false;result = Arrays.stream(intArray).anyMatch(n -&gt; n % 2 == 0);System.out.println(\"적어도 하나는 2의 배수인가? \" + result);result = Arrays.stream(intArray).allMatch(n -&gt; n % 2 == 0);System.out.println(\"모두 2의 배수인가? \" + result);result = Arrays.stream(intArray).filter(n -&gt; n % 2 != 0) .noneMatch(n -&gt; n % 2 == 0);System.out.println(\"모두 2의 배수가 아닌가? \" + result);// 적어도 하나는 2의 배수인가? true// 모두 2의 배수인가? false// 모두 2의 배수가 아닌가? true수집 스트림의 원소들을 필터링 또는 매핑한 후 최종적으로 새로운 컬렉션(List, Set, Map)을 생성하는 종료 연산 Collectors클래스는 스트림의 요소들을 수집하는 데 사용 되는 다양한 static 유틸리티 메소드를 제공 이것의 결과가 collect()의 인자로 사용 됨 collect() Collector를 인자로 받아 다양한 수집 작업 수행 Collectors.toList() List로 수집 Collectors.toSet() Set으로 수집 Collectors.toMap() Map으로 수집 Collectors.groupingBy() 특정 기준으로 그룹화하여 Map으로 수집 Collectors.joining() 문자열 스트림의 원소를 연결 List&lt;Member&gt; male_members = members.stream().filter(member-&gt;member.getGender().equals(\"남\")).collect(Collectors.toList());male_members.stream().forEach(member -&gt; System.out.println(member));Set&lt;Member&gt; female_members2 = members.stream().filter(member -&gt;member.getGender().equals(\"여\")).collect(Collectors.toSet());female_members2.stream().forEach(member -&gt; System.out.println(member));Map&lt;String, Integer&gt; ages =female_members2.stream().collect(Collectors.toMap(member -&gt;member.getName(), member -&gt; member.getAge()));System.out.println(ages);학습 정리 내부 반복은 컬렉션이나 배열의 내부에서 각 원소의 반복 처리를 수행하는 것으로, 처리용 코드만 람다 식으로 전달하며 반복 작업을 위한 코드를 작성하지 않음 forEach()메소드는 람다 식과 함께 사용하여 컬렉션과 배열의 원소들을 외부로 꺼내오지 않고 내부에서 탐색하게 함 필터링은 스트림의 원소 중에서 중복을 제거하거나 특정 조건을 만족하는 원소만 걸러 내고 새로운 스트림을 리턴하는 중간 연산임 매핑은 스트림의 원소를 다른 원소로 변환한 후 새로운 스트림으로 리턴하는 중간 연산임 매칭은 스트림의 원소 중 특정 조건을 만족하는지 확인하는 최종 연산임 수집은 스트림의 원소 중 필터링 또는 매핑 작업 후 결과 원소들을 취합하여 새로운 List, Set, 또는 Map객체를 생성하는 최종 연산임연습 문제 주어진 배열을 스트림으로 만드려고 한다. 밑줄 부분에 들어갈 적당한 내용은? int[] numbers = {1, 2, 3, 4, 5}; IntStream numberStream = ________; a. Arrays.stream(numbers) 주어진 문자열 배열에서 길이가 6 이상인 단어를 대문자로 변환한 후 정렬하여 출력하려고 한다. 밑줄 부분에 들어갈 메소드는 무엇인가? List&lt;String&gt; words = Arrays.asList(\"banana\", \"orange\", \"grape\", \"strawberry\", \"kiwi\"); List&lt;String&gt; result = words.stream() // .______(word -&gt; word.length() &gt;= 5) // 빈칸 .map(str -&gt; str.toUpperCase()) .sorted() .collect(Collectors.toList()); \t\t\t\t\t\t\t\t\t\t\t\t\t\t System.out.println(result); a. filter 중간 연산과 종료 연산의 차이를 설명하시오. a. 중간 연산은 스트림을 변환하거나 필터링 하는 등의 작업을 수행하며, 다음 단계 처리를 위해 새로운 스트림을 리턴하는데, 체인 형태로 연속해 여러 번 호출될 수 있다. 종료 연산은 스트림의 원소를 이용해 최종 결과를 만들어 리턴한다. " }, { "title": "[유비쿼터스 컴퓨팅 개론] 11강 - 인간과 컴퓨터/인간과 로봇 상호 작용 기술", "url": "/posts/knou-uqc-11/", "categories": "Computer Science, CS Theory", "tags": "knou, ubiquitous computing", "date": "2025-05-07 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정광식 교수님의 '유비쿼터스 컴퓨팅 개론' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 인간과 컴퓨터 상호 작용을 초기에는 인간과 컴퓨터, 인간과 가상 환경의 상호 작용에서 발생하는 기술적 · 사회적 · 심리적 문제를 주로 다루었음 그러나 정보통신 기술의 발전으로 인해 컴퓨터, 자연 환경, 인공 환경 등으로 이루어진 복잡한 기술 융합 특징을 지닌 유비쿼터스 컴퓨팅 환경으로 진화하면서 기존 학문, 기술, 서비스 부문에 이르는 광범위한 영역에서 변화를 주도하고 있음 마우스를 사용한 그래픽 사용자 인터페이스(GUI; Graphic User Interface)가 대중화되면서 상호 작용에 대한 편이성이 증가하였지만, 완전한 인간 중심적인 컴퓨팅 환경을 구축하기 위해서는 인간과 컴퓨터의 상호 작용(HCI; Human Computer Interaction) 관련 기술이 지속적으로 발전해야 함 최근에 지능형 서비스 로봇이 생활의 필수품으로 발전하며, 로봇을 초고속 인터넷과 연결함으로써 저렴한 가격으로 다양한 정보와 서비스를 제공할 수 있는 URC 기반 서비스 로봇으로 발전하고 있음 사람의 말과 몸짓, 표정, 목소리 등으로 사람의 의도를 종합적으로 판단하고, 그에 맞는 행동을 하기 위한 인간과 로봇 상호 작용(HRI) 기술에 관한 연구도 활발하게 진행되고 있음 점차 사용자의 사용 편리성을 고려하여 이를 구현하려는 노력과 인간이 어떻게 생각하고 행동하는 지에 대한 연구들에 대해서 공부함 인간과 컴퓨터/인간과 로봇과의 상호 작용 개념과 그 중요성을 다루고 이와 관련된 주요 기술들을 공부함학습 목표 인간의 음성 인식, 음성 합성, 자연어 처리 기술을 기반으로 인간과 컴퓨터 상호 작용 기술을 이해함 인간과 컴퓨터와의 상호 작용의 정의 및 특징을 이해하고, 실제 상호 작용 할 수 있는 인터페이스 기술에 대하여 이해할 수 있음 인간과 로봇과의 상호작용의 정의 및 특징을 이해하고, 실제 상호 작용 할 수 있는 인터페이스 기술에 대하여 이해할 수 있음강의록인간과 컴퓨터 상호 작용개요 인간과 컴퓨터 상호 작용(HCI: Human Computer Interaction) 사람들이 쉽고 편하게 컴퓨터 시스템과 상호 작용할 수 있는 방법을 찾는 학문 확장 된 개념의 인간과 컴퓨터 상호 작용 인간과 컴퓨터 상호 작용 뿐만 아니라 컴퓨터를 매개로 인간과 인간 사이에서 발생하는 상호 작용도 포함하는 개념 Intel ACAT(Assistive Context Aware Toolkit) 솔루션 뉴럴 링크 NI SENSOR HCI(Human Computer Interaction)의 구성 요소 인간 컴퓨터 상호 작용 태스크(task) 상황(환경 정황) HCI 구성 요소의 주요 특징 구분 주요 특징 인간 HCI에서 가장 중요한 구성 요소   인지 능력을 보유하고 있으며, 잘할 수 있는 것과 없는 것을 파악하여 컴퓨터(시스템)와 조화롭게 일함   자신의 정서와 감성이 외부의 자극에 의해 어떻게 영향을 받는지 파악할 수 있음 컴퓨터 (시스템) 인간과 협업하는 HCI의 중요한 구성 요소   PC, 노트북, 유비쿼터스 컴퓨팅 디바이스 및 스마트폰, 디지털TV, 지능형 가전 등을 포함 상호 작용 인간과 컴퓨터 간에 오가는 HCI의 중요한 구성 요소   HCI가 궁극적으로 구현하고자 하는 산출물, HCI를 상호 작용 설계(Interaction Design)로 정의하기도 함   컴퓨터와 인간의 상호 작용, 컴퓨터를 매개로 인간과 인간 사이에 발생하는 상호 작용도 포함 태스크 인간이 컴퓨터를 통하여 달성하려는 것으로 HCI의 중요한 구성 요소   작업 현장에서 제품의 제조 과정을 통제하는 것과 같은 기능적인 태스크, 인터넷에서 보고 싶은 영화를 내려받아 보는 감성적인 태스크 등을 포함 상황 (환경 상황) 인간이 태스크를 수행하기 위해 컴퓨터와 상호 작용하는 과정을 제공하는 환경   동일한 상호 작용일지라도 어떠한 환경 조건에서 그 상호 작용이 진행되는 가에 따라 전혀 다른 결과를 발생 시키는 것을 확인할 수 있음 인간과 컴퓨터 상호 작용의 목적 시스템을 사용할 사용자의 인지 프로세스를 어떻게 하면 컴퓨터와의 상호 작용에 잘 적용하느냐 하는 것 효율적인 HCI 시스템을 만든다면 개인이나 조직의 생산성 향상을 높일 수 있음 HCI의 효과를 수치로 직접 파악하기는 어려움 HCI의 장점은 대부분 숨겨져 있고 직접 인지할 수 없으며 비수치적이기 때문임 인간과 컴퓨터 상호작용의 주요 고려 사항 구분 내용 사용성 측면 에러 발생률 및 작업 피로감 감소   사용자 만족감 증대 및 성취감 고취   작업 시간 활용 최대화 개발사 측면 개발자에 대한 신뢰도 유도   서비스 개발 및 제품 매출 촉진 인간과 컴퓨터 상호작용의 중요성 및 발전 단계 HCI의 발전 단계 컴퓨터 시스템 중심 → 성숙 단계 → 인간 중심 단계 HCI의 발전 단계: 컴퓨터 시스템 중심 단계 단계 내용 예 컴퓨터 시스템 중심 컴퓨터 처리 능력 부족 펀치 카드 입력 시스템, TTY(전신 타자기), 키보드, 흑백 CRT, 라인 프린터 등   소수 전문가에 의한 컴퓨터 사용     컴퓨터가 이해하기 쉬운 형태의 HCI 사용   HCI의 발전 단계: 성숙 단계 단계 내용 예 성숙 컴퓨터 성능 향상 및 보급 확대 다양한 형태 키보드 : QWERTY, 드보락   다수 전문가/일반인이 컴퓨터 사용 시작 다양한 포인팅 장치 : 마우스, 라이트펜, 조이 스틱, 터치 스크린, 트랙볼 등   보다 편리한 HCI 모색 컬러 모니터   다양한 입출력 I/F 등장     GUI의 발달     초보적인 멀티미디어 지원   HCI의 발전 단계: 인간 중심 단계 단계 내용 예 인간 중심 컴퓨터 기술의 비약적인 발달 다 기능 입출력 장치 : 다 차원 조이 스틱, 데이터 글러브, HMD와 손 위치 추적   멀티미디어 기술 발달 음성 합성 및 디지털 음성 녹음, 음성 인식   다수의 일반인이 컴퓨터를 사용하므로 보다 쉬운 HCI 요구 문자 인식, 필기체 인식, 이미지 인식, 자연어 인식   인간의 한계를 극복하기 위한 수단으로 컴퓨터 사용 (시공간 초월) 가상 현실, 가상 공간   인간 중심 기술 발달   인간과 컴퓨터 상호작용의 연구 분야 HCI는 정보 통신 산업 사회의 컴퓨터 하드웨어 및 소프트웨어 관련 시스템을 연구/개발함에 있어 생리적, 지능적, 감성적 특성 등의 인간 요소를 고려한 사용자 중심 설계를 추구하여 사용자 편의성과 수용성이 우수한 최적의 컴퓨터 시스템을 구축하기 위한 연구 분야임 인간 공학 인간의 감각이나 운동에 관한 연구 산업 공학 컴퓨터와 조직에 관한 연구 심리학 행동과 개념에 관한 연구 인지 심리학 인지, 관심, 기억과 문제 해결, 사용자의 능력과 한계, 학습 등에 관한 연구 사회 심리학 사회적인 상황에서의 인간의 행동 사회학 좁게는 작업 공간에서, 크게는 사회에 영향을 주는 발전 된 기술에 관한 연구 컴퓨터 과학 사용자 인터페이스를 위한 알고리즘 개발, 시스템 구조나 소프트웨어의 개발에 관한 연구 언어학 언어에 관한 연구 대부분의 컴퓨터 운영체제는 윈도우즈(Windows)와 같은 그래픽 사용자 인터페이스(GUI) 방식을 채택하고 있으며, GUI는 HCI의 주된 목적을 충족시키고 있음 인간의 다양한 인지 기능을 사용하는 멀티 모달(Multimodal) 시스템으로 발전하고 있음 앞으로도 차세대 멀티미디어 정보 통신 서비스가 인간 생활의 유용한 수단이 되기 위해서는 복합적이면서 지능적이고 인간적인 멀티 모달 인터페이스의 연구가 필요함음성 관련 인간과 컴퓨터 상호 작용 기술개요 음성을 통한 HCI 음성 인식 음성 합성 자연어 처리(NLP; Natural Language Processing) 음성 인식 기술 1970년대에 태동한 음성 인식 기술은 사람의 기본적인 의사소통 수단인 ‘말(언어)’을 통해 더욱 편리하고 인간적인 방식의 컴퓨팅 환경을 구축하기 위한 기반 기술임 인간의 사고를 컴퓨터 및 각종 정보 기기에 접목하기 위해 키보드나 마우스 등과 같은 물리 장치와 WIMP(Window, Icons, Menus, Pointer)가 사고 전달을 받아 왔음 인간의 음성이 이를 대신할 수 있게 된다는 점에서 음성 인식 기술 부각 됨 사람의 음성 신호를 인식하는 기술 분류 음성 인식 (Speech Recognition) 기술 화자 인식 (Speaker Recognition) 기술 음성 인식 인간의 음성을 기계나 컴퓨터에서 자동으로 인식하는 것 일반적으로 음성 신호로부터 음성 텍스트를 인식하고 출력하는 기술 화자 인식 말하는 사람을 인식하는 기술 화자의 인식과 자연어 처리를 포함한 음성 이해와 의미 추출까지 포함 음성 인식 시스템 특정 화자에 대해서만 인식하는 화자 종속 시스템과 화자와는 상관없이 인식하는 화자 독립 시스템으로 분류 됨 화자 인식 화자 식별 / 화자 검증으로 분류됨 음성 인식 기술의 가장 큰 문제점 사용자에 따른 인식률의 차이 주변 잡음에 따른 인식률 저하 인식 대상 어휘의 제한으로 인하여 인식 오류 발생 이러한 문제들을 해결하기 위해 다양한 지식을 활용하게 해주는 음성 인식 프레임을 활용함 모바일 환경에서 자연스러운 인터페이스의 수요 확대 많은 사람이 음성을 사용하여 상호 작용하려 함 다양하고 방대한 사용자 음성 데이터 확보 가능 다양한 수행 환경에서 다수 화자의 방대한 종류의 어휘 확보 가능 어디서나, 누구의, 어떤 말에 대해서도 음성 인식 기반 확보 이렇게 얻은 방대한 음성 데이터의 어휘, 문법 등을 분석함으로써 자연어 음성 인식을 위한 음향학적 및 언어학적 지식의 체계화 모바일 환경 음성 검색 서비스 자연어 음성 인식 기술의 필요에 의해 자연어 음성 인식 기술을 개선할 수 있는 선순환 구조를 이루고 있음 음성 합성 기술 음성 합성 글을 말로 바꾸는 기술(TTS) 자동 응답 시스템에서 듣는 기계음의 목소리, 인터넷 신문의 기사 읽어 주기, 이메일 읽어 주기, 음성 포털, 게시판 및 전자책, 가전제품 등 가정과 산업의 여러 방면에서 이용되고 있음자연어 처리 기술 자연어 처리 (NLP: Natural Language Processing) 컴퓨터가 사람의 일상 언어를 이해하고 생성할 수 있도록 함으로써 인간의 지적 활동의 보조자 및 지원 도구로 활용하는 기술 상용화되면 사람들은 특별한 형식의 언어나 명령 없이도 컴퓨터와 상호 작용할 수 있게 됨 자연어 처리 기반 검색 기술 인터넷 상에 존재하는 다양한 정형/비정형 데이터에 인간의 일상 언어로 질의하여 결과를 문장으로 제공하는 기술 음성 검색 기술은 무제한 자연어 음성 인식 기술을 필요로 하며, 음성 대화 서비스의 출발선으로 볼 수 있음 유선 인터넷 검색에 대비되는 모바일 검색의 차이점 정확한 검색이 되어야 하고 개인 최적화 검색이 요구된다는 점 이것을 만족 시키기 위해서는 단순 음성 검색 만을 제공하는 것이 아니라 대화를 통해 사용자에게 최적화되고 정확한 검색을 제공하는 음성 대화 서비스가 필요함 음성 대화 서비스는 모바일 환경에서의 편리한 정보 검색 뿐만 아니라 외국어 학습 용도로도 큰 관심을 받고 있음 외국어 말하기 능력 향상을 위해 대화형 학습에 대한 수요가 매우 증가하는 상황임 단순 음성 검색에서 대화형 검색 서비스로 발전하는 것처럼 외국어 발음 평가에서 대화형 말하기 교육으로 발전하고 있음인간과 착용형 컴퓨터와의 상호 작용 기술개요 인간과 착용형 컴퓨터의 상호 작용을 위한 착용형 HCI (Wearable HCI) 기술 인간 중심 기술의 중심에 있는 HCI 기술과 착용 컴퓨팅 기술의 접목 착용 컴퓨팅 기술의 대표적 특징인 착용성을 가지는 상호 작용 기술 전반을 의미하며, 양손이 자유로운 채로 업무 수행 가능 착용 컴퓨팅과 HCI (주요 기술) 기반 기술 무선 칩, 패키징, 전원 관리, 열 관리 디바이스 / 컴포넌트 기술 마이크로 센서, 메모리, 전원 공급, 키보드/입력 장치, 바코드 스캐너, 디스플레이, 모바일 컴퓨터, 프린터 소프트웨어 기술 운영체제, 미들웨어, 장치 관리/보안, 음성 인식, 응용 프로그램 착용 솔루션 기술 벨트/머리 착용 장치, 손목/손가락/팔 착용형 장치, 신체 부착형 및 생체 이식형 장치, 의복 내장형 장치 착용 컴퓨팅과 HCI 사용 환경은 실내나 실외 한곳에 국한되기보다 실 내외 환경 모두에서 사용하기를 원함 착용 시스템을 데이터, 음성, 오디오, 비디오 등 데이터 전송 용으로 사용하고자 하는 요구가 많음 착용 시스템에 사용할 무선 통신 기술은 802.11 ac/n, 블루투스, ZigBee 등이 있음 착용 컴퓨팅 기술의 기본 기능 착용을 의식하지 않을 정도의 무게감과 자연스러움을 느끼는 착용감 컴퓨터와 사용자 간의 끊김 없는 통신을 지원하는 항시성 신체적인 피로의 최소화 및 유해 요소를 차단하는 안정성 사회/문화적 통념에 부합하는 외형의 사회성 섬유/패션 분야에서는 기능성 섬유, 섬유의 IT화 등과 같이 의복 또는 섬유의 기능을 다양화하는 연구가 진행되고 있음 첨단 기술과 융합되어 IT를 통한 스마트 섬유, 나노 기술을 접목한 나노 복합 섬유, 바이오 기술을 접목한 의료용 섬유 등 개념 소재로서 사용이 확대되고 있음 HCI 기술은 사용자, 컴퓨팅 시스템, 상호 작용을 기본 구성 요소로 함 목적을 효과적으로 달성하는 유용성(usefulness)과 기기를 효율적으로 사용하는 사용성(usability)을 추구하며 감성(affect)의 원칙을 충족하기 위하여 설계(design)와 평가(evaluation), 분석(analysis)의 절차를 거치며 개발 됨 착용형 HCI 착용 컴퓨팅 기술의 기본 기능을 만족하는 인터페이스 장치 및 인터페이스 장치와 사용자 간의 상호 작용 모델에 관한 연구를 포함하는 기술. 착용형 HCI 기술의 특성 HCI의 기본 기능인 유용성, 사용성, 감성을 만족 시키면서, 동시에 착용 컴퓨팅 시스템의 기본 기능인 착용성, 사회성, 안정성, 항시성 등이 고려되어야 함. 착용 컴퓨팅과 HCI 구분인간과 로봇 상호 작용개요 인간과 로봇 상호작용 (HRI: Human-Robot Interaction) 기술 로봇이 사람의 말과 몸짓, 표정, 목소리 등으로 사람의 의도를 종합적으로 판단하고, 그에 맞는 행동을 하기 위한 기술 다양한 의사소통 채널을 통해서 인지적, 정서적 상호 작용을 할 수 있도록 상호 작용 환경을 설계하고 구현 및 평가하는 기술 HRI는 URC (Ubiquitous Robotic Companion) 기반의 지능형 서비스 로봇의 핵심 기술 HRI 기술은 로봇의 자율성, 상호 작용의 양 방향성 등에서 HCI와는 근본적인 차이점이 있음 HRI 기술의 주요 가치는 협동성, 편리성, 친밀성임 협동성 사람과 로봇이 현재 상황에서 이루고자 하는 일의 목표와 목표를 이루기 위한 계획을 공유해야 한다는 의미 로봇이 사람이 원하는 일을 정확히 이해할 수 있다면, 로봇은 사람을 번거롭게 하지 않고 사람과 협력하여 주어진 일을 원활하게 수행할 수 있을 것임 편리성 효과적인 상호 작용과 사용자 편의의 증대를 의미함 로봇에게 원하는 일을 시키기 위해 복잡한 프로그램을 키보드로 입력해야 하는 것과 몇 마디 말로 명령하는 것의 차이를 생각해 보면, 인간과 로봇 상호 작용이 추구하는 편리성의 의미를 쉽게 이해할 수 있음 친밀성 사람과 로봇 간의 정서적/사회적 관계에 대한 의미 부여임 로봇이 사람의 감정 상태를 이해하고 이에 대응할 수 있어야 로봇이 인간의 진정한 동료나 도우미가 될 수 있음을 의미함 HRI 기술의 세 가지 가치(협동성, 편리성, 친밀성)를 달성하기 위해서는 아래와 같은 기술에 관한 연구가 필요함 협동성을 추구하기 위한 인지적 상호 작용 사용자의 편리성 증대를 위한 멀티 모달 상호 작용 인간과의 친밀한 관계 형성을 위한 감정 상호 작용 인간과 로봇 상호 작용 관련 기술 인간과 로봇 상호작용 기술의 분류 인식 기술 원격 조작을 위한 인터페이스 기술 인지 및 감정 상호 작용 기술 대분류 중분류 인식 기술 음성 인식   제스처 인식   얼굴 인식   촉각/힘 인식   감정 인식 원격 조작을 위한 인터페이스 기술 매개 인터페이스   힘 반향 원격 조종 장치   힘 반향 제어 및 통신   정보 표현 및 공유 인지 및 감정 상호 작용 기술 사용자 의도 인식 및 대응 기술   감정 생성 및 표현 기술 인식 기술 다양한 의사소통 채널을 통해 인간과 로봇이라는 두 개체 간의 상호 작용 및 의사 소통 연결 고리를 형성하는 기술 음성 인식, 제스처 인식, 촉각/힘 인식 및 감정 인식은 원격지에 위치한 로봇의 동작을 제어하기 위한 기술임 인지 및 감정 상호 작용 기술 인간과 로봇 간의 암묵적, 쌍 방향적 의사소통을 위한 기술 영상 기반 상호 작용 기술 인간과 로봇의 자연스러운 상호 작용이 이루어지기 위한 수단 중 가장 중요하고 유용한 인터페이스 기술 얼굴 인식 및 검증, 제스처 인식, 모션 분석 및 행동 인식, 얼굴 표정 인식 등이 있음 음성 기반 상호 작용 기술 음성을 통해 인간과 컴퓨터 또는 인간과 로봇 간의 인터페이스를 가능하게 해주는 핵심 기술임 관련 기술로는 로봇에 부착된 마이크로폰으로부터 얻은 음성 정보에 근거한 음성 인식 및 화자 인식, 음원 추적 및 음원 분리, 음성에서의 감정 인식 등이 있음 영상 및 음성 기반 상호 작용 기술의 대표적인 세 가지 기술 원거리 얼굴 인식 기술 제스처 인식 기술 음성 인식 및 화자 인식 기술 인간과 로봇 상호 작용 관련 기술 - 1) 원거리 얼굴 인식 기술 로봇의 카메라로부터 입력 된 영상에 존재하는 사람의 얼굴을 검출하여 신원을 부여하고 인증하는 기술 인간과 로봇의 자연스러운 상호 작용이 이루어지기 위한 수단 중 가장 중요하고 유용한 지능형 시각 인터페이스 기술임 지능형 로봇과 디지털 홈 등에서 근 거리뿐만 아니라 원거리에서도 사용자 얼굴 인식이 가능해야 함인간과 로봇 상호 작용 관련 기술 - 2) 제스처 인식 기술 로봇의 카메라로부터 획득한 사람의 손이나 몸동작을 인식 및 분석하여 사용자 의도에 대한 정보를 실시간으로 제공하는 기술임 로봇에게 인간의 의사를 전달하는 수단으로 손의 제스처가 자주 이용되는데, 로봇이 이러한 인간의 제스처를 이해하는 기술임 멀티 모달 인터페이스에 대한 필요성이 늘어남에 따라 제스처 인식의 중요성도 함께 증가함 제스처 인식은 먼 거리나 잡음 환경에서도 인간과 로봇 간의 정보 전달 수단이 될 수 있음인간과 로봇 상호 작용 관련 기술 - 3) 음성 인식 및 화자 인식 기술 로봇이 사용자의 음성으로부터 발성 내용을 인식함으로써 음성을 통해 인간과 로봇 상호 작용을 가능하게 하는 기술 인간과 로봇이 음성을 통해 의사 소통할 수 있는 음성 인식 기술과 특정 주제에 대해 인간과 로봇이 대화를 주고받을 수 있도록 하는 음성 언어 이해 기술이 요구됨 화자 인식 기술은 로봇이 인간의 음성으로부터 발성 내용에 상관없이 발성자가 누구인지를 식별하는 기술 로봇이 사람과 같이 생활하면서 우리 생활에 편리함을 제공하는 데 필요한 지능형 청각 인터페이스 기술임정리 하기 인간과 컴퓨터 상호 작용(HCI)은 어떻게 하면 사람들이 쉽고 편하게 컴퓨터 시스템과 상호 작용할 수 있는지와 관련된 학문임 인간과 로봇 상호 작용(HRI) 기술은 로봇이 사람의 말과 몸짓, 표정, 목소리 등으로 사람의 의도를 종합적으로 판단하고, 그에 맞는 행동을 하도록 하는 기술임연습 문제 HCI(Human-Computer Interactio)의 구성 요소에 포함되지 않는 것은 무엇인가? a. 사물 HCI(Human-Computer Interactio)의 구성 요소 인간 컴퓨터 상호 작용 음성을 통한 HCI에 포함되지 않는 것은 무엇인가? a. 상황 인식 음성을 통한 HCI에 포함 되는 것 음성 인식 음성 합성 자연어 처리 착용 컴퓨팅 기반의 HCI에서 운영체제, 미들웨어, 장치 관리/보안, 음성 인식, 응용 프로그램 등의 기술 분류는 무엇에 해당하는가? a. 소프트웨어 기술 정리 하기 인간과 컴퓨터의 상호 작용(HCI) 사람과 컴퓨터 시스템과 쉽고 편한 상호 작용 방법의 연구 인간과 컴퓨터 사이의 상호 작용 뿐만 아니라 컴퓨터를 중간 매개로 사용하여 인간과 인간 사이에서 발생하는 상호 작용도 포함함 주요 구성 요소 인간, 컴퓨터, 상호 작용, 태스크(Task), 상황(환경 정황) 음성 인식 기술 사람의 기본적인 의사소통 수단인 말(언어)을 통해 보다 편리하고 인간적인 방식의 컴퓨팅 환경을 구축하기 위한 기반 기술 음성 합성 기술 글을 말로 바꾸는 기술 자연어 처리 기술 컴퓨터가 사람의 일상 언어를 이해하고 생성할 수 있도록 함으로써 인간의 지적 활동의 보조자 및 지원 도구로 활용하고자 하는 기술 착용형(인간과 컴퓨터의)상호 작용 기술 (인간과 컴퓨터의)착용형 상호 작용 기술(Wearable HCI)은 인간 중심 기술의 중심에 있는 HCI 기술과 착용 컴퓨팅 기술의 융합 결과 " }, { "title": "[파이썬 프로그래밍 기초] 11강 - 모듈", "url": "/posts/knou-python-11/", "categories": "Language, Python", "tags": "knou, python", "date": "2025-05-06 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '파이썬 프로그래밍 기초' 강의를 개인 공부 목적으로 메모하였습니다. 학습 목표 모듈, 패키지, 라이브러리를 구분할 수 있음 모듈을 등록할 수 있음 모듈의 메소드 및 변수를 사용할 수 있음주요 용어 모듈 함수, 상수 또는 클래스를 모아 놓은 집합체 네임 스페이스 특정 객체를 이름에 따라 구분할 수 있는 범위 난수 특정한 배열 순서나 규칙적인 의미가 없는, 임의의 수를 의미 강의록모듈의 이해모듈의 역할 import 통해 남이 만든 좋은 코드를 그대로 가져다 사용 가능 파이썬은 어떤 기능을 구현할 때 이미 만들어 놓은 도구들을 이용해 간편하게 작업할 수 있음라이브러리와 프레임 워크 라이브러리 어떤 모듈과 패키지에 여러 가지의 조합들을 묶어서 어떠한 새로운 분야에 해당되는 일을 하려고 할 때 또는 기능을 구현 하려고 할 때 읽어 들이는 단위 모듈(module) 프로그래밍 과정에 극강의 효율성을 줄 수 있음 라이브러리와 프레임 워크들을 구성하는 가장 작은 단위 모듈은 하나의 파이썬 파일로 구성 모듈의 개념 함수, 상수 또는 클래스를 모아 놓은 집합체 클래스 다른 모듈의 확장 함수 특정 작업을 처리 상수(변수) 불변의 값 모듈, 패키지, 라이브러리 모듈 클래스, 함수, 상수의 집합 패키지 하위 패키지 및 모듈의 집합 라이브러리 패키지 및 모듈의 집합 모듈의 등록 구문 형식 1 import 모듈이름 [as 별칭] 파이썬 모듈을 프로그램 내부에서 사용할 수 있게 네임 스페이스에 추가하는 명령어 모듈이름 / 별칭․변수 모듈이름 / 별칭.함수() 모듈이름 / 별칭.클래스 구문 형식 2 from 모듈이름 import 메소드1, [메소드2/함수/클래스…] from 모듈이름 import * 모듈 이름 없이 변수, 함수, 클래스를 사용 변수 함수() 클래스 모듈의 등록 확인import mathdir() # 어떤 모듈들이 등록(import) 되어 있는지 확인할 수 있는 dir 함수dir(math) # math 모듈에 어떤 멤버들이 있는지 확인help(math.gamma) # 등록 된 함수의 사용 방법을 알고자 할 때 사용 dir 함수 네임 스페이스에 등록되어 있는 모든 이름들을 리스트로 반환 dir() dir(math) help 함수 대화형 도움말 시스템 호출 또는 클래스나 메소드의 사용 방법 반환 help(math.abs) help(\"python\".upper) 네임 스페이스의 이해 특정 객체를 이름에 따라 구분할 수 있는 범위 지역 NS 함수 또는 메소드 내의 이름 공간 전역 NS 모듈 전체에서 통용되는 이름 공간 빌트인 NS 모든 코드 범위 모듈의 제거 구문 형식 del 등록된_모듈이름 네임 스페이스 내 모듈의 멤버 식별자 제거 네임 스페이스에 올라온 여러 식별자들이 겹칠 수 있음 새 모듈의 함수, 변수 등의 이름이 겹치는 이유로 이전 모듈을 제거해야 할 때에는 del 사용 간혹 오류 발생 시 해당 모듈을 네임 스페이스에서 제거 원뿔 계산 프로그램 개선 math 모듈을 활용한 원뿔 계산 # 원뿔 클래스 정의 class Cone : def __init__(self, radius = 20, height = 30): self.r = radius self.h = height def get_vol(self) : return 1 / 3 * 3.14 * self.r ** 2 * self.h def get_surf(self) : return 3.14 * self.r ** 2 + 3.14 * self.r * self.h math 모듈을 사용함으로써 수학적으로 정교한 수치를 얻을 수 있음 import math print(math.pi) # 원뿔 클래스 정의 class Cone : def __init__(self, radius = 20, height = 30): self.r = radius self.h = height def get_vol(self) : return 1 / 3 * math.pi * self.r ** 2 * self.h # 3.14 보다 정확한 파이 값 사용 def get_surf(self) : return math.pi * self.r ** 2 + math.pi * self.r * self.h 유용한 모듈math 모듈 수학적 계산 문제를 해결하기 위한 수학 함수 및 상수의 집합 C 언어 표준에 정의된 수학적 계산 함수를 내장 π, e와 같은 상수 제공 math.gcd(6, 8) math.factorial(5) math.e dir(math) math 모듈 멤버 멤버 설명 pi 원주율 e 자연 로그 e fabs(x) x의 절대 값 ceil(x) x의 가장 가까운 정수로 올림 floor(x) x의 가장 가까운 정수로 버림 exp(x) x의 지수 함수(e^x) 값 log(x) x의 자연 로그 값 sqrt(x) x의 제곱근 sin(x) x의 사인 값 asin(x) sin의 역 함수에 대한 라디안 각도 cos(x) x의 코사인 값 tan(x) x의 탄젠트 값 degrees(x) 라디안 각도 x를 도 단위로 변환 삼각형 넓이 계산 프로그램 두 변의 길이 a, b와 끼인 각 α인 삼각형의 넓이를 구하는 프로그램을 작성하시오. math 모듈 활용하여 삼각형 넓이 구하기 import math a, b = 10, 20 # area = 1 / 2 * a * b * math.sin(60) # 결과 값이 음수가 나옴 파이 값으로 매개 변수 추가해야 함 # 60도를 호도법으로 바꾸어야 함 area = 1 / 2 * a * b * math.sin(math.radians(60)) # 60도를 호도법으로 바꾼 값의 sin 값 산출 print(area) 특정 함수 몇 가지만 부분적으로 호출하게 되면 해당 함수는 모듈 명을 쓰지 않고 직접 사용 가능 import math from math import sin a, b = 10, 20 # area = 1 / 2 * a * b * math.sin(60) # 결과 값이 음수가 나옴 파이 값으로 매개 변수 추가해야 함 # 60도를 호도법으로 바꾸어야 함 area = 1 / 2 * a * b * sin(math.radians(60)) # 60도를 호도법으로 바꾼 값의 sin 값 산출 print(area) random 모듈 난수(random number) 특정한 배열 순서나 규칙적인 의미가 없는, 임의의 수를 의미 난수 관련된 생성 기능을 제공하는 모듈 특정 범위의 난수를 발생 난수 발생기 번호들 사이에는 규칙이 없으나 프로그램을 실행할 때마다 동일한 값들이 도출되는 난수 발생 시드를 통해 변형을 줌으로써 전체 나오는 패턴을 바꿔줄 수 있음 같은 번호가 게속 나오면 시드를 바꾸어 주어야 함 random 모듈 멤버 멤버 설명 random() 0 ~ 1 사이의 숫자 중 난수 발생 randint(a, b) a부터 b 사이의 숫자 중 난수 발생 randrange(a, b, c) a부터 b 사이의 c의 간격으로 나열된 숫자 중 난수 발생 choice(sequence) 주어진 항목을 랜덤하게 반환 sample(sequence) 랜덤하게 여러 개의 원소를 선택 shuffle(sequence) 시퀀스의 순서를 랜덤하게 섞음 가위-바위-보 게임import random # random 모듈 importoptions = [\"가위\", \"바위\", \"보\"]user = input(\"가위,바위,보를 입력: \")com = random.choice(options) # option 리스트를 랜덤하게 반환if user == com: print(\"비겼다!\")elif user == \"바위\" and com == \"가위\": print(\"이겼다!\")elif user == \"보\" and com == \"바위\": print(\"이겼다!\")elif user == \"가위\" and com == \"보\": print(\"이겼다!\")else: print(\"졌다!\")로또 추첨 프로그램 1 ~ 45 숫자 6개를 입력 받아 당첨 숫자와 비교하는 프로그램을 작성하시오. 숫자를 입력하세요: 42, 1, 6, 22, 30, 31 당첨 숫자는 1, 2, 45, 21, 22, 39 입니다. 2개가 맞았습니다. import random # random 모듈 import # 사용자의 입력 값 그대로 사용할 수 없음 -&gt; input을 통해 들어온 긴 문자열을 콤마 기준으로 분리 guess_str = input(\"1 ~ 45 번호 6개를 쉼표로 분리하여 입력하세요 : \").split(\", \") guess_list = list() # 숫자로 된 문자열을 하나씩 읽어 int형으로 받은 뒤 guess_list 에 저장 for i in guess_str: guess_list.append(int(i)) # guess_str의 값들을 하나하나 정수로 변환하여 guess_list에 하나씩 추가 \t lotto_list = random.sample(range(1, 46, 1), 6) # 1부터 45까지의 값 중 6개의 값을 랜덤으로 추출 print(\"예상 번호는\", guess_list, \"입니다.\") print(\"추첨 번호는\", lotto_list, \"입니다.\") hit_count = 0 for guess in guess_list: if guess in lotto_list: # 비교 연산자 in hit_count = hit_count + 1 \t print(\"축하합니다 \" + str(hit_count) + \"개 맞혔습니다.\") .split(\", \") 분할 기준 되는 문자를 매개 변수로 대입 콤마와 스페이스 기준으로 분리 스무 고개 프로그램 20번의 기회 안에 1 ~ 1000 사이의 숫자를 맞히는 스무 고개 프로그램을 작성하시오. 숫자를 맞혀보세요(1번째 시도): 52 52보다 큽니다. 숫자를 맞혀보세요(2번째 시도): 69 69보다 작습니다. 숫자를 맞혀보세요(3번째 시도): … import random hit_number = random.randint(1, 1001) # 정수를 무작위로 추출 guess_count_list = range(1, 21, 1) # 1 ~ 20 까지 들어있는 리스트 생성하여 현재 몇 번째 시도인지를 출력 passfail = False # 실패했다고 가정 for guess_count in guess_count_list: # 20번 반복하는 for문 guess = int(input(\"숫자를 맞혀 보세요(\" + str(guess_count)+\"번째 시도): \")) # 반복할 때마다 몇번 째 시도인지 알려줘야 함 if hit_number == guess: passfail = True # 숫자를 20회 내에 맞힌 경우에는 반복할 필요 없음 break # 반복 중단할 때 사용 elif hit_number &gt; guess: print(str(guess) + \"보다 큽니다.\", end = \"\") else: print(str(guess) + \"보다 작습니다.\", end = \"\") if passfail == True: print(\"맞혔습니다. 축하합니다.\") else: print(\"모든 기회를 다 사용하셨습니다. 다음에 다시 도전하세요\") time 모듈 에포크 시간을 얻어 다양한 형식으로 표시하는 기능 제공 정수 부분은 초 소수 점 부분은 밀리 세컨드 시작 점은 1970년도 01월 01일 time 모듈 멤버 멤버 설명 time() 1970.1.1 자정 이후로 누적된 초를 실수 단위로 반환 gmtime() struct_time 형식으로 기준 시각 변환 localtime(time) 입력된 초를 변환하여, 지방 표준 시 기준 시각으로 변환 strftime(str, time) 지정된 형식으로 시각을 변환 ctime() 현재 시간을 반환 sleep(n) 현재 동작 중인 프로세스를 주어진 n초만큼 멈춤 소수 찾기 프로그램 1 ~ 1000 사이에 소수(prime number)를 찾고 실행 시간을 출력하는 프로그램을 작성하시오. 시작 시각은 Fri Apr 7 00:46:21 2023 입니다. 소수는 2, 3, 5, 7, 11, 13 종료 시각은 Fri Apr 7 00:46:58 2023 입니다. 총 37초 실행했습니다. import time start_time = time.time() # 1970.1.1 이후로 경과 된 시점을 초 단위로 환산 # 소수인지 판별하는 함수 def is_prime(x): for i in range(2, x): # 2부터 x-1까지 반복 if x % i == 0: return False # i로 나누었을 때 나누어 떨어지면(나머지가 0이면) 소수가 아니므로 False 반환 return True prime_count = 0 for i in range(1, 5001): # 1부터 5000까지 확인 if is_prime(i): prime_count = prime_count + 1 print(i, end = \", \") end_time = time.time() print(\"\\n\", end_time - start_time, \"초 실행했습니다.\") 연습 문제 다음은 무엇에 대한 설명인가? 클래스, 함수, 상수(변수)의 집합 a. 모듈 다음 중 모듈 사용과 관련된 명령어가 아닌 것은? a. module (a)에서 option 리스트의 값 중 하나가 무작위로 선택되어 com에 할당하도록 빈 칸 □에 들어갈 알맞은 코드는? (a) 가위 바위-보-프로그램 import random options = [\"가위\", \"바위\", \"보\"] user = input(\"가위, 바위, 보를 입력: \") com = random.choice(options) if user == com: print(\"비겼다!\") elif user == \"바위\" and com == \"가위\": print(\"이겼다!\") elif user == \"보\" and com == \"바위\": print(\"이겼다!\") elif user == \"가위\" and com == \"보\": print(\"이겼다!\") else: print(\"졌다!\") a. random.choice(options) 학습 정리 모듈은 함수, 상수 또는 클래스를 모아 놓은 집합체임 모듈, 패키지, 라이브러리는 구분되는 개념이며 패키지는 하위 패키지 및 모듈의 집합, 라이브러리는 패키지 및 모듈의 집합으로 구성되는 상위 개념임 모듈 등록 시 import 구문과 from import 구문을 사용함 import 구문을 통해 등록된 모듈은 사용 시 모듈 이름 또는 별칭을 변수/함수/클래스 앞에 붙여야 함 import는 파이썬 모듈을 프로그램 내부에서 사용할 수 있게 네임 스페이스에 추가하는 기능을 수행함 dir 함수는 네임 스페이스에 등록되어 있는 모든 이름들을 리스트로 반환함 help 함수는 대화형 도움말 시스템 호출 또는 클래스나 메소드의 사용 방법을 반환함 네임 스페이스는 특정 객체를 이름에 따라 구분할 수 있는 범위를 나타냄 del 명령어는 네임 스페이스 내 등록된 모듈의 멤버 식별자를 제거함 math 모듈은 수학적 계산 문제를 해결하기 위한 수학 함수 및 상수의 집합으로 구성됨 random은 난수 관련된 기능을 제공하는 모듈임 time은 에포크 시간을 얻어 다양한 형식으로 표시하는 기능 제공하는 모듈임" }, { "title": "[운영 체제] 11강 - 장치 관리", "url": "/posts/knou-os-11/", "categories": "OS, Operating System", "tags": "knou, os", "date": "2025-05-06 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김진욱 교수님의 '운영 체제' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 장치 관리자는 컴퓨터 시스템의 모든 주변 장치를 관리하는 역할을 함 디스플레이나 키보드, 프린터 등의 입 출력 장치, 자기 테이프나 디스크와 같은 저장 장치가 이러한 주변 장치에 해당됨 장치의 개념과 구성을 살펴보고, 입출력을 처리하는 여러 가지 방법을 살펴봄 장치와는 독립적으로 입출력을 관리하는 기법도 살펴봄학습 목표 장치의 개념과 구성을 설명할 수 있음 입출력 처리를 위한 세 가지 방법을 설명할 수 있음 장치와는 독립적으로 입출력을 관리하는 두 가지 방법을 설명할 수 있음강의록장치의 개념컴퓨터 시스템의 구성 다양한 장치들 CPU, 메모리 프로세스 실행에 필수 나머지 장치들 프로세스 실행 시 데이터 입력이나 출력에 사용되는 입 출력 장치 입출력 장치의 구분 세 가지 범주 전용 장치, 공용 장치, 가상 장치 구분 기준 장치의 기능적 특징과 장치 관리자의 관리 방법 입출력 장치의 구분 전용 장치 한 번에 단지 하나의 프로세스에만 할당 ex) 테이프 드라이브, 프린터, 플로터 등 단점 대기 시간이 길어질 수 있음 공용 장치 여러 프로세스에 동시에 할당 ex) 디스크 같은 직접 접근 저장장치 스케줄링 기법 필요 가상 장치 전용 장치를 공용 장치처럼 보이게 함 디스크 같은 공용 장치를 이용 ex) 스풀링을 적용한 플로터 등 장치의 구성논리적 구성 장치 제어기 장치를 직접적으로 다루는 전자 장치 장치에서 발생하는 각종 데이터를 전자 신호로 변환하여 운영 체제로 보냄 운영 체제가 요청하는 명령을 받아 장치를 구동 운영 체제가 보내는 출력을 장치에 맞게 변환 장치 드라이버 응용 프로그램의 입출력 요청을 해당 장치에 맞도록 변환 장치의 종류나 제조사에 따라 장치 제어기가 이해하는 명령이나 명령의 종류가 다를 수 있기 때문 보통 장치 제조사에서 해당 장치의 드라이버도 같이 제공 물리적 구성 CPU의 장치 사용법 장치 제어기의 레지스터를 이용 장치의 상태를 확인하거나 장치에 명령 메모리 사상 입출력(Memory-mapped I/O) 메모리의 특정 영역을 장치 제어기의 레지스터와 대응 시켜 둠 메모리를 읽고 쓰는 것으로 CPU가 장치를 사용 입출력 처리 유형입출력 처리 프로세스가 진행하며 입출력이 발생하는 경우 세 가지 유형 프로그램 방법 인터럽트 방법 DMA 방법 프로그램 방법 CPU만 이용하는 폴링(Polling)을 이용하여 입출력을 처리 CPU가 입출력 장치의 상태를 지속적으로 확인하며 CPU가 원하는 상태가 될 때까지 기다림 CPU 낭비가 심해 비효율적인터럽트 방법 인터럽트(interrupt)를 이용하여 입출력을 처리 인터럽트 어떤 장치가 다른 장치의 작업을 잠시 중단 시키고 자신의 상태를 알리는 기능 프로세스를 대기 상태로 보내고 인터럽트가 발생할 때까지 CPU는 다른 프로세스를 처리할 수 있음인터럽트 처리 과정 I/O장치가 가용한 상태가 되었다고 인터럽트 제어기에 신호를 보냄 인터럽트 제어기는 CPU에 인터럽트 신호를 보냄 CPU는 현재 실행 중이던 명령만 마치고 즉시 인터럽트에 응답 인터럽트 제어기는 이벤트 대상에 대한 정보를 CPU에 보냄 CPU는 현재 상태 보관 후 필요 한 입출력 처리DMA 방법 DMA(Direct Memory Access)를 이용하여 입출력을 처리 DMA 제어기를 이용하여 CPU를 통하지 않고 메모리에 직접 접근하여 데이터를 전송하는 방법 인터럽트 발생 횟수를 단 한번으로 줄여 CPU 효율 증대 사이클 스틸링(cycle stealing) CPU와 DMA 제어기가 동시에 메모리 액세스를 시도하면 DMA 제어기에 우선권을 줌 DMA 처리 과정 CPU는 입출력에 필요한 정보를 DMA 제어기에 넘김 DMA 제어기는 소스에서 목적지로 데이터를 보내도록 장치 제어기에 요청하고, 이를 CPU가 지시한 양만큼 반복 입출력이 끝나면 DMA 제어기는 인터럽트 제어기에 신호 보냄 인터럽트 제어기는 CPU에 인터럽트 보냄입출력 관리입출력 관리 입출력 장치와는 독립적인 입출력 관리 방법 두 가지 방법 버퍼링 스풀링 버퍼링 CPU의 데이터 처리 속도와 I/O 장치의 데이터 전송 속도의 차이로 인한 문제를 버퍼를 통해 해결 메모리를 일시적인 데이터 저장 장소인 버퍼로 이동 단일 버퍼링 저장과 처리를 동시에 할 수 없어 비효율적 이중 버퍼링 순환 버퍼링 스풀링 입출력 프로세스와 저속 입출력 장치 사이의 데이터 전송을 자기 디스크와 같은 고속 장치를 통하도록 하는 것 프로세스 입장에서는 입출력 작업이 빨리 끝남 전용 장치를 가상 장치로 변화 시킴정리 하기 운영 체제에서 장치 관리자는 시스템의 모든 주변 기기를 관리하며 입출력의 균형을 유지함 장치는 일반적으로 전용 장치, 공유 장치 그리고 가상 장치의 세 가지 범주로 구분 됨 입출력이 발생하는 경우 이를 처리하는 방법으로 프로그램 방법, 인터럽트 방법, DMA 방법이 있음 프로그램 방법은 CPU가 입 출력 장치의 상태를 지속적으로 확인하여 CPU가 원하는 상태가 될 때까지 기다리는 폴링을 이용하는 방법임 인터럽트 방법은 어떤 장치가 다른 장치의 작업을 잠시 중단 시키고 자신의 상태를 알리는 인터럽트를 이용하는 방법임 DMA는 DMA 제어기를 이용하여 CPU를 통하지 않고 메모리에 직접 접근하여 데이터를 전송하는 방법임 장치와는 독립적으로 입출력을 관리하는 방법으로 버퍼링과 스풀링이 있음 버퍼링은 CPU의 데이터 처리 속도와 데이터 전송 속도의 차이로 인한 문제를 메모리의 일부를 일시적인 데이터 저장 장소로 사용하는 버퍼를 이용하여 해결하는 방법으로, 단일 버퍼링, 이중 버퍼링, 순환 버퍼링이 있음 스풀링은 입출력의 속도를 높이기 위해 입출력 프로세스와 저속 입출력 장치 사이의 데이터 전송을 자기 디스크와 같은 고속 장치를 통하도록 하는 방법임" }, { "title": "[Java 프로그래밍] 11강 - 컬렉션", "url": "/posts/knou-java-11/", "categories": "Language, Java", "tags": "knou, java", "date": "2025-05-06 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김희천 교수님의 'Java 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 컬렉션이란 여러 원소를 저장하고 관리하는 자료구 조임 JCF는 컬렉션을 관리하기 위한 클래스와 인터페이스를 제공하는 통합 프레임워크임 Collection, Set, List, Queue, Map등의 인터페이스와 그것을 구현한 HashSet, ArrayList, LinkedList, HashMap등의 클래스 사용법을 학습함학습 목표 JCF의 기본 구조를 설명할 수 있음 HashSet클래스를 사용하여 프로그램을 작성할 수 있음 ArrayList와 LinkedList클래스의 차이를 설명할 수 있음 HashMap클래스를 사용하여 복잡한 자료를 관리할 수 있음강의록JCF컬렉션이란 여러 원소를 하나의 그룹으로 묶어 관리하기 위한 자료 구조 JCF는 컬렉션 즉, 데이터 목록을 관리하기 위한 인터페이스와 클래스의 모음 JCF(Java Collections Framework) 컬렉션을 표현하고 다루기 위한 통합된 프레임 워크 클래스와 인터페이스의 집합 컬렉션을 다양한 방식으로 저장, 정렬, 검색, 수정하는 도구를 제공 컬렉션을 일관 된 방법으로 다룰 수 있음 표준화 된 인터페이스 컬렉션을 다루기 위한 기능을 표현 어떻게 표현되는 지와 상관없이 일관성 있게 다룸 클래스 인터페이스를 구현한 클래스를 제공 JCF의 구조 JCF의 인터페이스 Set 데이터의 순서는 의미가 없으며 중복을 허용하지 않는 자료 구조 List 중복을 허용하고 순서가 있는 자료 구조 Queue List와 유사하나 원소의 삽입/삭제가 FIFO 방식 Map 원소가 &lt;key, value&gt;의 형태이며 키는 유일해야 함 JCF의 인터페이스와 클래스 java.util패키지에 포함되며 제네릭 타입 다루는 자료의 유형을 지정해야 함 구분 Set List Queue Map 해시 테이블 HashSet     HashMap 배열   ArrayList, Vector, Stack     연결 리스트   LinkedList LinkedList   해싱 + 연결 리스트 LinkedHashSet     LinkedHashMap 정렬 SortedSet     SortedMap 트리 TreeSet     TreeMap 컬렉션 객체의 선언 변수 선언은 해당 인터페이스 유형으로, 객체 생성은 인터페이스를 구현하는 클래스를 사용 Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); Collection&lt;E&gt;인터페이스 Set, List, Queue에서 공통으로 지원해야 하는 기능을 정의 원소의 삽입과 삭제 메소드 메소드 설명 boolean add(E e) 주어진 요소를 현재 컬렉션에 추가함, 성공적으로 추가되면 true를 리턴 boolean addAll(Collection&lt;? extends E&gt; c) 주어진 컬렉션의 모든 요소를 현재 컬렉션에 추가 boolean remove(Object o) 주어진 요소를 컬렉션에서 제거 boolean removeAll(Collection&lt;?&gt; c) 주어진 컬렉션에 포함된 모든 요소를 현재 컬렉션에서 제거 boolean retainAll(Collection&lt;?&gt; c) 현재 컬렉션의 요소 중 주어진 컬렉션에 있는 요소만 남김 void clear() 컬렉션의 모든 요소를 제거하여 비움 원소 탐색 메소드 메소드 설명 boolean contains(Object o) 현재 컬렉션이 주어진 요소를 가지고 있으면 true를 리턴 boolean containsAll(Collection&lt;?&gt; c) 현재 컬렉션에 주어진 컬렉션의 모든 요소가 포함되어 있으면 true를 리턴 boolean isEmpty() 현재 컬렉션이 빈 컬렉션이면 true를 리턴 기타 메소드 메소드 설명 int size() 현재 컬렉션에 포함된 요소의 개수를 리턴 int hashCode() 현재 컬렉션의 해시 코드값을 리턴 Object[] toArray() 현재 컬렉션을 객체의 배열로 변환하여 리턴 Iterator&lt;E&gt; iterator() Iterator 객체를 리턴 boolean equals(Object) 두 컬렉션이 같은 요소를 같은 순서로 포함하면 true를 리턴 HashSet, ArrayList, LinkedList클래스HashSet클래스 예제 HashSet클래스 사용 예 import java.util.*; public class Main { public static void main(String args[]) { Set&lt;String&gt; set = new HashSet&lt;String&gt;(); // HashSet 객체를 생성 // HashSet에 문자열 값 추가 set.add(\"one\"); set.add(\"two\"); set.add(\"three\"); set.add(\"four\"); System.out.println(set.add(new String(\"one\"))); // HashSet은 중복을 허용하지 않으므로 이미 존재하는 \"one\"을 추가하지 않음 System.out.println(set.size()); // HashSet의 현재 크기를 출력 System.out.println(set.contains(\"four\")); // HashSet이 \"four\"라는 요소를 포함하고 있는지 확인 System.out.println(set.contains(\"one\")); // HashSet이 \"one\"이라는 요소를 포함하고 있는지 확인 System.out.println(set.contains(new String(\"one\"))); // \"one\"이라는 값이 존재하는지 확인 set.remove(\"four\"); // \"four\"라는 요소 제거 set.remove(new String(\"one\")); // \"one\"이라는 문자열 제거 System.out.println(set.size()); set.clear(); // HashSet의 모든 요소를 제거 System.out.println(set.size()); // HashSet의 현재 크기를 출력 (모든 요소가 삭제되었으므로 크기는 0) } } // false // 4 // true // true // true // 2 // 0 ArrayList&lt;E&gt;클래스 List인터페이스를 구현한 클래스 크기 조절이 가능한 배열로 구현 같은 자료가 중복 될 수 있으며, 입력 된 순서대로 관리 됨 특정 위치의 자료를 참조하기 위해 첨자를 사용할 수 있음 List인터페이스를 살펴봐야 함 주요 메소드 boolean add(E e) 원소를 맨 뒤에 삽입 void add(index, E element) 해당 위치에 원소를 삽입 boolean remove(Object o) 삭제에 성공하면 true를 리턴 E remove(int index) 삭제 되는 원소를 리턴 E get(int index) 해당 위치의 원소를 리턴 E set(int index, E element) 기존 원소를 리턴 int indexOf(Object o) 리스트 내에서 지정된 객체가 처음으로 등장하는 인덱스 리턴 List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"apple\"); list.add(\"banana\"); list.add(\"apple\"); System.out.println(list.indexOf(\"apple\")); // 0 System.out.println(list.indexOf(\"grape\")); // -1 int lastIndexOf(Object o) 리스트 내에서 지정된 객체가 마지막으로 나타난 위치의 인덱스 리턴 List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"apple\"); list.add(\"banana\"); list.add(\"apple\"); System.out.println(list.lastIndexOf(\"apple\")); // 2 System.out.println(list.lastIndexOf(\"grape\")); // -1 List&lt;E&gt; subList(int from, int to) 지정된 범위(from부터 to 전까지)의 리스트(서브 리스트)를 반환 List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"apple\"); list.add(\"banana\"); list.add(\"cherry\"); List&lt;String&gt; subList = list.subList(0, 2); // \"apple\", \"banana\" System.out.println(subList); // [apple, banana] list.set(1, \"blueberry\"); // 원본 리스트 변경 시 서브리스트도 반영됨 System.out.println(subList); // [apple, blueberry] ListIterator&lt;E&gt; listIterator() 리스트 내의 요소를 양방향(앞으로 또는 뒤로)으로 탐색할 수 있는 리스트 반복 자 반환 List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"apple\"); list.add(\"banana\"); // 리스트 반복자를 생성 ListIterator&lt;String&gt; it = list.listIterator(); // 다음 요소 탐색 while (it.hasNext()) { System.out.println(it.next()); } // apple, banana ListIterator&lt;E&gt; listIterator(int index) 특정 인덱스(index)에서 시작하는 리스트 반복 자를 반환 인덱스가 유효하지 않을 경우 IndexOutOfBoundsException이 발생 List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"apple\"); list.add(\"banana\"); list.add(\"cherry\"); // 1번 인덱스부터 시작하는 Iterator 생성 ListIterator&lt;String&gt; it = list.listIterator(1); while (it.hasNext()) { System.out.println(it.next()); } // banana, cherry ArrayList클래스 예제import java.util.*;public class Main { public static void main(String args[]) { List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"one\"); list.add(\"two\"); list.add(\"three\"); list.add(1, \"one\"); list.add(\"five\"); System.out.println(list.size()); System.out.println(list.indexOf(\"one\")); System.out.println(list.get(2)); System.out.println(list.lastIndexOf(\"one\")); System.out.println(list.set(3, \"four\")); System.out.println(list.remove(4)); System.out.println(list.remove(\"one\")); }}// 5// 0// two// 1// three// five// trueimport java.util.*;public class Main { public static void main(String args[]) { List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"one\"); list.add(\"two\"); list.add(\"three\"); list.add(\"four\"); list.add(\"five\"); // for 구문을 이용한 자료 탐색 for (int i = 0; i &lt; list.size(); i++) System.out.println(list.get(i)); // 향상된 for 구문을 이용한 자료 탐색 for (String s : list) System.out.println(s); // Iterator 인터페이스를 이용한 자료 탐색 Iterator&lt;String&gt; it = list.iterator(); while (it.hasNext()) System.out.println(it.next()); }}// one// two// three// four// five// one// two// three// four// five// one// two// three// four// fiveimport java.util.*;import java.util.function.Consumer;public class Main { public static void main(String args[]) { List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"one\"); list.add(\"three\"); list.add(\"two\"); list.add(1, \"one\"); // Consumer 인터페이스를 활용해 accept 메서드를 직접 구현한 익명 클래스 Consumer&lt;String&gt; con1 = new Consumer&lt;&gt;() {\t\t // Consumer 인터페이스의 추상 메서드 accept를 구현 public void accept(String t) { System.out.println(t); // 각 요소를 처리 } }; // 리스트의 각 요소에 대해 con1의 accept 메서드를 실행 list.forEach(con1); // 람다식을 사용하여 Consumer의 동작 구현 Consumer&lt;String&gt; con2 = t -&gt; System.out.println(t); // 리스트의 각 요소를 처리하며 출력 list.forEach(con2); // 리스트의 각 항목에 대해 직접 람다 표현식 전달 list.forEach(t -&gt; System.out.println(t)); }}// one// one// three// two// one// one// three// two// one// one// three// twoIterator&lt;E&gt;인터페이스 컬렉션에 저장 된 원소를 차례대로 다룰 수 있음 다음 메소드를 제공 boolean hasNext() 순회할 다음 요소가 있으면 true리턴 E next() 다음 요소를 리턴하고, 커서를 다음 위치로 이동 void remove() next()로 반환된 가장 최근 요소를 컬렉션에서 삭제 컬렉션 HashSet, ArrayList, LinkedList등에서 Iterator객체를 리턴하는 iterator()메소드를 사용할 수 있음 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); Iterator&lt;String&gt; it = list.iterator(); // Iterator 객체 얻기 while (it.hasNext()) // 다음 요소가 있는지 확인 System.out.println(it.next()); // 다음 요소 가져와 출력 LinkedList클래스 ArrayList와 마찬가지로 List인터페이스를 구현한 클래스 앞의 예제에서 ArrayList를 LinkedList로 바꿔도 됨 스택 자료 구조에서 필요한 메소드도 제공함 앞에서 넣거나 삭제 void push(E) E pop() Queue인터페이스도 구현함 뒤에서 원소를 추가함 boolean add(E) boolean offer(E) 앞의 원소를 삭제하고 리턴함 E poll() E remove() 앞의 원소를 읽음 E peek() E element() LinkedList를 이용하여 큐를 구현한 예제 LinkedList클래스로 큐 구현하기 import java.util.*; public class Main { public static void main(String args[]) { LinkedList&lt;String&gt; queue = new LinkedList&lt;String&gt;(); queue.offer(\"one\"); queue.offer(\"two\"); queue.offer(\"three\"); queue.offer(\"four\"); String s = queue.poll(); while (s != null) { System.out.println(s); s = queue.poll(); } } } // one // two // three // four HashMap클래스Map&lt;K, V&gt;인터페이스 (key, value)로 이루어진 원소로 구성되는 컬렉션을 다루기 위한 인터페이스 key는 중복되지 않으며, 하나의 key에 하나의 value만 대응됨 원소들의 순서는 중요하지 않음 주요 메소드 메소드 설명 V put(K key, V value) 맵에 &lt;키, 값&gt; 매핑을 추가, 키가 존재하면 값이 변경됨 V get(Object key) 맵에서 키와 매핑 된 값을 리턴, 없으면 null을 리턴 V remove(Object key) 키에 대응하는 매핑을 제거하고 값을 리턴, 없으면 null boolean containsKey(Object key) 지정된 키가 맵에 있으면 true를 리턴 Collection&lt;V&gt; values() 맵에 존재하는 값들로 구성된 컬렉션을 리턴 Set&lt;K&gt; keySet() 맵에 존재하는 키들로 구성된 Set 객체를 리턴 HashMap클래스 해싱을 이용하여 Map인터페이스를 구현한 클래스 자료 탐색 방법이 ArrayList나 LinkedList클래스와 다름 복잡한 자료 관리(교재의 예) 복잡한 자료 관리 – HashMap클래스 예제 성적 관리 프로그램 Map&lt;String, Integer&gt; lectures; // 학생별 과목 점수를 저장할 Map 생성 선언 Map&lt;String, Map&lt;String, Integer&gt;&gt; scores = new HashMap&lt;&gt;(); // String, Map&lt;String,Integer&gt;로 타입 명시 List&lt;String&gt; names = new ArrayList&lt;String&gt;(); // 학생의 이름을 담을 리스트 생성 names.add(\"김철수\"); names.add(\"이영희\"); Iterator&lt;String&gt; it = names.iterator(); // 이름 리스트를 순회하기 위해 Iterator 생성 // 이름 리스트의 각 학생에 대해 과목 점수를 설정 while (it.hasNext()) { String name = it.next(); // 다음 이름 가져오기 if (name.equals(\"김철수\")) { lectures = new HashMap&lt;String, Integer&gt;(); // 새로운 과목 점수를 저장할 HashMap 생성 lectures.put(\"국어\", 100); lectures.put(\"영어\", 95); lectures.put(\"수학\", 80); scores.put(name, lectures); // 전체 점수 Map(scores)에 추가 } else { lectures = new HashMap&lt;String, Integer&gt;(); lectures.put(\"국어\", 90); lectures.put(\"영어\", 95); lectures.put(\"수학\", 95); scores.put(name, lectures); } } Iterator&lt;String&gt; it2 = names.iterator(); while (it2.hasNext()) { String name = it2.next(); System.out.println(name); System.out.print(\"국어 : \"); System.out.println(scores.get(name).get(\"국어\")); // scores.get(name)으로 Map&lt;String, Integer&gt; 얻고 다시 get(\"과목\") System.out.print(\"영어 : \"); System.out.println(scores.get(name).get(\"영어\")); System.out.print(\"수학 : \"); System.out.println(scores.get(name).get(\"수학\")); System.out.println(); } // 김철수 // 국어 : 100 // 영어 : 95 // 수학 : 80 // 이영희 // 국어 : 90 // 영어 : 95 // 수학 : 95 학습 정리 컬렉션은 여러 원소를 저장하고 관리하는 객체를 통칭하는 용어이며, JCF는 컬렉션을 효율적으로 다루기 위한 API를 제공하는 프레임워크임 Set은 원소의 순서에 의미가 없고 중복을 허용하지 않는 컬렉션을 다루기 위한 인터페이스임 List와 Queue는 자료의 중복을 허용하고 순서에 의미가 있는 컬렉션을 관리하기 위한 인터페이스임 Queue는 FIFO 방식으로 자료를 관리하는 인터페이스임 Map인터페이스는 &lt;키, 값&gt;의 쌍으로 구성되는 자료의 묶음을 관리하는 메소드를 제공함 LinkedList클래스는 List인터페이스와 Queue인터페이스를 모두 구현한 클래스이며, 스택 자료구조에서 필요한 메소드도 제공함연습 문제 ArrayList클래스에 관한 설명으로 적당하지 않은 것은? a. 같은 자료를 중복으로 저장할 수 없다. ArrayList클래스에 대한 설명으로 적당한 것 List인터페이스를 구현한 클래스임 여러 원소를 저장하기 위해 내부적으로 배열을 사용함 원소의 순서가 의미를 가짐 같은 자료를 중복으로 저장할 수 있음 (key, value) 형태의 원소로 구성되는 자료 묶음을 다루기 위한 인터페이스나 클래스가 아닌 것은? a. HashSet (key, value) 형태의 원소로 구성되는 자료 묶음을 다루기 위한 인터페이스나 클래스 HashMap Hashtable Map LinkedList&lt;E&gt;를 이용하여 큐 자료구조를 구현할 때, 자료를 추가하는 메소드와 삭제하는 메소드는 무엇인가? a. 추가 시 boolean offer(E), boolean add(E), 삭제 시 E remove() " }, { "title": "[데이터베이스 시스템] 11강 - 인덱싱", "url": "/posts/knou-dbs-11/", "categories": "Database", "tags": "knou, database", "date": "2025-05-06 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '데이터베이스 시스템' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 현실의 데이터베이스 응용에서는 대부분의 질의가 전체 데이터가 아닌 일부의 레코드만을 대상으로 함 별도의 검색 구조 없이 조건을 만족하는 레코드를 찾기 위해서는 파일 내의 모든 레코드를 처음부터 끝까지 순차적으로 확인해야 하며, 이러한 방식은 데이터 양이 많아질수록 성능 저하가 급격하게 발생하게 됨 이를 해결하기 위해 DBMS는 인덱스라 불리는 자료 구조를 이용하여 특정 레코드를 보다 효율적으로 탐색할 수 있도록 지원함 인덱스의 개념과 필요성, 그리고 인덱싱 기법의 기본적인 분류 방식에 대해 다루고 관계형 데이터베이스에서 가장 널리 사용되는 B+-트리 인덱스의 구조적 특징과 삽입, 삭제, 탐색 연산의 동작 방식을 중심으로 인덱스가 실제로 어떻게 구성되고 동작하는 지를 구체적으로 학습함주요 용어 탐색 키 한 파일에서 레코드를 찾기 위해 사용되는 컬럼이나 컬럼 값의 집합 인덱스 엔트리 탐색 키와 탐색 키에 해당하는 레코드의 레코드 포인터의 쌍을 저장한 구조 다단계 인덱스 인덱스를 외부 인덱스와 내부 인덱스의 다단계 구조로 나누어 외부 인덱스에서 희소하게 분포 시켜 인덱스 파일의 크기를 적정하게 유지할 수 있는 인덱스 이진 탐색 트리 이진 트리의 일종으로 왼쪽은 부모 노드보다 작은 노드 값, 오른쪽에는 부모 노드보다 큰 노드 값을 위치 시켜 특정 노드 값을 빠르게 찾을 수 있도록 구조화한 트리 강의록인덱스의 이해일반적인 데이터 검색 과정 레코드 3개가 하나의 블록 단위로 메모리 사이에 입출력 된다고 가정인덱스의 개념 데이터 검색 시 발생하는 비효율적인 데이터 입출력 문제를 해결하기 위한 목적으로 시작 인덱스 요청된 레코드에 빠르게 접근할 수 있도록 지원하는 데이터와 관련된 부가적인 구조 인덱싱 인덱스를 구성하고 생성하는 작업 인덱스의 탐색 키를 이용하여 해당 레코드가 저장 된 블럭의 위치를 파악하고 해당 블럭을 빠르게 적재 탐색 키(검색 키) 파일에서 레코드를 찾는데 사용되는 컬럼이나 컬럼의 집합 인덱스 기반의 데이터 검색 과정인덱스의 종류와 평가 기준 인덱스의 종류 순서 인덱스 특정 값에 대해 정렬된 순서 구조 해시 인덱스 버킷의 범위 안에서 값의 균일한 분포에 기초한 구조로 해시 함수가 어떤 값이 어느 버킷에 할당되는지 결정 인덱스의 평가 기준 접근 시간 데이터를 찾는 데 소요되는 시간 유지 비용 새로운 데이터 삽입 및 기존 데이터 삭제 연산으로 인한 인덱스 구조 갱신 비용 공간 비용 인덱스 구조에 의해 사용되는 부가적인 공간 비용 순서 인덱스순서 인덱스의 특징 탐색 키로 정렬된 순차 파일에 대하여 레코드에 대한 빠른 접근이 가능하도록 구성한 인덱스 탐색 키를 정렬하여 해당 탐색 키와 탐색 키에 대한 레코드와의 연계를 통하여 인덱스 생성 순서 인덱스의 종류 밀집 인덱스 희소 인덱스 다단계 인덱스 순차 파일 구조 다음 레코드 위치를 알려주는 포인터 범위 검색에는 유리하나 첫 요청 레코드 찾기는 어려움 인덱스 엔트리 인덱스 엔트리 구조 블럭 ID 해당 레코드는 어느 블록에? 오프셋 해당 블록의 몇 번째에 위치? 인덱스 엔트리 구성 인덱스 엔트리가 담아내야 하는 것들 어떤 정보를 담고 있는지? 디스크 어느 위치에 저장? 밀집 인덱스(dense index) 모든 레코드에 대해 탐색 키 값:포인터 쌍을 유지 모든 인덱스에 대해 인덱스 엔트리를 유지해서 사용하는 인덱스 장점 원하는 레코드를 빠르게 찾을 수 있음 단점 레코드 수만큼 인덱스 엔트리 존재 인덱스의 크기가 방대해짐 레코드가 많으면 조회 시 오랜 시간 소요 희소 인덱스(sparce index) 인덱스의 엔트리가 일부의 탐색 키 값만을 유지 가끔씩 존재하는 인덱스 엔트리 요청 된 탐색 키보다 작거나 같은 인덱스의 탐색 키 값 중 가장 큰 인덱스 엔트리의 포인터가 가리키는 블럭을 스캔 인덱스 엔트리가 만들어지지 않은 레코드를 찾는 방법 장점 밀집 인덱스에 비해 작은 크기 인덱스 메모리 적재 빠른 속도 단점 인덱스 엔트리에 없는 레코드를 찾아야 할 경우, 블록 내에서 재 검색 필요 다단계 인덱스의 필요 4KB 크기의 한 블록에 100개의 엔트리가 삽입될 때, 100,000,000개의 레코드에 대한 밀집 인덱스 1,000,000개의 블록 = 4GB의 공간 필요 인덱스 크기에 따른 검색 성능 인덱스 크기 &gt; 메모리 크기 저장된 블록을 여러 번 나누어 읽어야 하기 때문에 디스크 I/O 비용이 증가하여 탐색 시간이 증가 인덱스 크기 &lt; 메모리 크기 디스크 I/O이 줄어 탐색 시간이 축소 복수 계층의 인덱스를 구성다단계 인덱스의 구조 내부 인덱스와 외부 인덱스로 구성 외부 인덱스를 내부 인덱스보다 희소한 인덱스로 구성하여 엔트리의 포인터가 내부 인덱스 블럭을 지칭 B+ - 트리 인덱스카드 찾기 카드를 더 빨리 찾으려면? 탐색 키가 정렬되어 있으면 훨씬 더 빠르게 원하는 값을 찾을 수 있음 숫자끼리도 연결 고리를 만들어 줌 포인터를 만들어 연결하면 더 빨리 찾을 수 있음 - B+트리 인덱스 이진 트리 인덱스의 확장판 각 노드에 여러 개의 키 값을 넣는다면? B+ - 트리의 구조 데이터의 양이 많아져도 트리의 높이는 그리 안 커짐 루트 노드부터 모든 단말 노드에 이르는 경로의 길이가 같은 높이 균형 트리 순서 인덱스는 파일이 커질수록 데이터 탐색에 있어서 접근 비용이 커지는 문제점을 해결하기 위해 제안 상용 DBMS에서도 널리 사용되는 대표적인 순서 인덱스 B+ - 트리의 노드 구조 팬 아웃 값이 적으면 트리 높이가 커짐 B+ - 트리의 구성 요소 인덱스 세트 루트 노드와 중간 노드로 구성 단말 노드에 있는 탐색 키 값을 신속하게 찾아갈 수 있도록 경로를 제공하는 목적으로 사용 [n / 2] ~ n 사이의 개수를 자식으로 소유 트리 높이가 커지지 않도록 제약 중간 노드가 가리키는 범위에 가면 원하는 포인터를 찾을 수 있음 힌트 제공 순차 세트 단말 노드로 구성 모든 노드가 순차적으로 서로 연결 실제 레코드의 포인터가 모여 있는 단말 노드 적어도 [(n - 1)/ 2] 개의 탐색 키를 포함 탐색 키에 대한 실제 레코드를 지칭하는 포인터를 제공 왼쪽 → 오른쪽 노드로 신속히 접근 가능 키 값과 같은 것은 왼쪽을 따라 가면 해당 레코드가 있는 곳 찾을 수 있음 단말 노드의 구성 인덱스 엔트리와 역할이 동일한 포인터B+ - 트리의 예 세 단계의 노드 접근으로 원하는 정보 얻을 수 있음B+ - 트리 상에서의 삽입, 삭제 레코드 삽입, 삭제 시 B+-트리 수정 레코드 삽입 노드에서 유지해야 할 탐색 키와 포인터 수 증가로 인해 노드를 분할해야 하는 상황이 발생 레코드 삭제 노드에서 유지해야 할 탐색 키 값과 포인터 수 감소로 형제 노드와 키를 재분배 또는 병합해야 하는 상황이 발생 높이 균형 유지 노드가 분할 되거나 병합되면서 높이의 균형이 맞지 않는 상황이 발생 B+-트리 상에서의 삽입과 삭제 삽입 검색과 같은 방법을 사용하여 삽입되는 레코드의 탐색 키 값이 속할 단말 노드를 탐색 해당 단말 노드에 &lt;탐색키, 포인터&gt; 쌍을 삽입 삽입 시 탐색 키가 순서를 유지 삭제 삭제 될 레코드의 탐색 키를 통해 삭제될 탐색 키와 포인터를 포함한 단말 노드를 탐색 같은 탐색 키 값을 가지는 다중 엔트리가 존재할 경우, 삭제될 레코드를 가리키는 엔트리를 찾을 때까지 탐색 후 단말 노드에서 제거 단말 노드에서 제거된 엔트리의 오른쪽에 있는 엔트리들은 빈 공간이 없도록 왼쪽으로 이동 레코드, 탐색 키 변화는 자동적으로 인덱스에도 영향을 끼침 작은 값이 왼쪽, 큰 값이 오른쪽으로 정렬되도록 함노드가 분할 되는 삽입 COM24 삽입 삽입 대상 노드에 추가적인 저장할 공간 부족: 노드 분할 COM12를 하나의 단말 노드로 구성 COM24와 COM31이 하나의 단말 노드로 구성 부모 노드에 탐색 키를 조정하고 추가 된 노드에 대한 포인터를 삽입 탐색 키의 삭제 COM44 삭제 COM12 삭제 탐색 키가 재분배 되는 삭제 COM12 삭제 COM12가 있는 단말 노드를 검색하고 탐색 키를 삭제 해당 단말 노드는 삭제 후 탐색 키가 존재하지 않음 [(n - 1) / 2]개 보다 탐색 키가 적으므로 다른 노드와 별도의 재구조화 작업이 필요 COM12가 저장된 노드의 오른쪽의 형제 노드와 키를 재분배 가장 작은 탐색 키 값 COM24를 중간 노드로 재구조화 연습 문제 다음 중 요청된 레코드에 빠르게 접근할 수 있도록 하는 구조인 인덱스의 효율성에 대한 평가 기준이 아닌 것은? a. 사용자가 질의에 사용할 조건을 자유롭게 지정할 수 있는 정도 사용자가 질의 조건을 자유롭게 지정할 수 있는 정도는 질의 언어(SQL)나 인터페이스 표현력과 관련 된 요소로, 인덱스 구조의 효율성과는 직접적인 관련이 없음 인덱스의 효율성에 대한 평가 기준 새로운 데이터 삽입 시 발생하는 인덱스 구조 유지 비용 인덱스를 통해 데이터를 찾고 접근하는데 걸리는 시간 인덱스를 저장하기 위해 부가적으로 필요한 공간 비용 다음의 설명은 어떤 인덱스에 대한 설명인가? 모든 탐색키 값에 대해 탐색키 &lt;값, 포인터&gt; 쌍으로 구성된 인덱스 엔트리를 갖고, 인덱스 파일의 크기가 커서 I/O 비용이 증가하여 탐색 시간이 오래 걸릴 수 있는 단점을 지님 a. 밀집 인덱스 밀집 인덱스와 같이 모든 탐색 키 값에 대하여 탐색 키를 갖게 되면 인덱스가 메모리에 상주할 수 있는 정도의 크기라면, 추가적인 I/O 비용의 발생이 없이 원하는 데이터를 찾을 수 있음 하지만 모든 레코드의 탐색 키를 사용하여 인덱스를 생성하면 데이터의 크기가 커질 수록 밀집 인덱스도 커지게 되어 메모리에 모두 적재되지 못하여 인덱스를 탐색하면서 추가적인 I/O 비용이 발생할 수 있음 따라서 인덱스의 크기를 줄이기 위해 일부의 탐색 키만을 사용하여 인덱스인 희소 인덱스를 사용하기도 하고 다단계 인덱스를 사용하기도 함 다음은 B+ 트리의 예시이다. ‘이순신’을 탐색하는 과정에서 거치는 포인터를 올바른 순서로 나열한 것은? a. 1, 5, 8 이순신을 탐색하기 위해 루트 노드에 있는 정도전과 비교하여 사전 순서로 정도전보다 값이 작은 것을 알 수 있음 따라서 1번 포인터를 타고 왼쪽의 자식 노드에 접근함 그 다음 박지성과 안창호를 비교했을 때, 박지성과 안창호보다 이순신의 값이 큰 것을 알 수 있음 따라서 5번 포인터로 오른쪽 자식 노드에 접근하여 최종적으로 이순신의 왼쪽에 저장 된 8번 포인터를 통하여 디스크에 저장 된 이순신 레코드에 접근하게 됨 정리 하기 데이터베이스 시스템에서는 데이터에 대한 빠른 탐색을 지원하기 위해 인덱싱과 해싱을 이용함 인덱스는 데이터 파일에 대한 빠른 탐색을 지원하는 부가적인 자료구조이며 인덱스를 생성하는 작업을 인덱싱이라고 함 탐색 키의 순서로 정렬된 순차 파일에서는 데이터 레코드에 대한 빠른 임의 접근이 가능 하도록 순서 인덱스를 사용할 수 있음 인덱스는 모든 레코드에 대하여 인덱스 엔트리를 구성하는 밀집 인덱스와, 일부 레코드에 해당하는 인덱스 엔트리를 사용하여 인덱스를 구성하는 희소 인덱스, 밀집 인덱스와 희소 인덱스의 개념을 모두 사용한 다단계 인덱스로 구분할 수 있음 B+–트리 인덱스는 루트에서 단말(leaf) 노드까지 모든 경로의 길이가 같은 높이 균형 트리로 트리에서 단말 노드나 루트 노드가 아닌 중간(internal) 노드는 [n / 2]과 n 사이의 자식을 갖는 대표적인 인덱스 구조임 B+–트리를 활용한 특정 탐색 키 탐색은 루트부터 시작해서 단말 노드에 도달할 때까지 비교 연산을 하며 이루어짐 말단 노드에 도착하면 탐색이 종료 됨 새로운 레코드의 삽입과 삭제 시, B+–트리는 재 구조화 됨 B+–트리 구조의 생성 조건을 유지 시키기 위해 인덱스 엔트리 삽입과 삭제 시 노드의 분할 및 노드의 병합이 이뤄짐 체크 포인트 데이터베이스의 인덱스와 관련한 설명으로 틀린 것은? a. 인덱스의 추가, 삭제 명령어는 각각 ADD, DELETE이다. 인덱스는 데이터베이스 객체이기 때문에 CREATE, DROP 명령어 사용함 인덱스와 관련 된 설명으로 옳은 것 문헌의 색인, 사전과 같이 데이터를 쉽고 빠르게 찾을 수 있도록 만든 데이터 구조임 테이블에 붙여진 색인으로 데이터 검색 시 처리 속도 향상에 도움이 됨 대부분의 데이터베이스에서 테이블을 삭제하면 인덱스도 같이 삭제 됨 B+-트리 인덱스에 대한 설명으로 옳은 것만을 모두 고르면? ㄱ. 루트(root)를 포함한 내부 노드(internal node)는 데이터 파일 레코드를 가리키는 포인터를 갖는다. ㄴ. 트리의 루트에서 단말 노드(leaf node)까지 모든 경로의 길이가 같은 균형 트리(balanced tree) 형태이다. ㄷ. 단말 노드는 검색 키 값을 기초로 선형 순서로 되어 있어 데이터 레코드들을 그 키 값의 순서에 따라 능률적으로 순차 접근할 수 있게 해 준다. a. ㄴ, ㄷ 트리의 루트에서 단말 노드(leaf node)까지 모든 경로의 길이가 같은 균형 트리(balanced tree) 형태임 단말 노드는 검색 키 값을 기초로 선형 순서로 되어 있어 데이터 레코드들을 그 키 값의 순서에 따라 능률적으로 순차 접근할 수 있게 해줌 " }, { "title": "[데이터 정보 처리 입문] 11강 - 엑셀 활용 2", "url": "/posts/knou-dip-11/", "categories": "Data Science, Data Analysis", "tags": "knou, data information processing", "date": "2025-05-04 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김성수, 이기재 교수님의 '데이터 정보 처리 입문' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 엑셀 차트 기능을 활용하면 주어진 함수의 그래프를 그릴 수 있고, 목표 값 찾기 기능을 이용하여 주어진 함수가 축과 만나는 점을 찾을 수 있음 엑셀의 함수 기능을 활용하여 주어진 적분 값을 근사적으로 구하는 법을 익힘 엑셀을 활용하여 해결할 수 있는 다양한 예제를 살펴봄으로써 엑셀의 활용 능력을 높임학습 목표 엑셀 함수 기능을 이용하여 원리 합계를 계산할 수 있음 엑셀 차트 기능을 이용하여 주어진 함수의 그래프를 그릴 수 있음 목표 값 찾기 기능을 활용할 수 있음 엑셀을 활용하여 적분 값을 계산할 수 있음주요 용어 상대 참조 행 이름이나 열 이름만을 사용하여 셀을 참조하는 방법 ex) A1, B2, A1:F1 등 절대 참조 참조하는 셀이나 셀 범위를 표시할 때 “$“를 사용하여 참조하는 방법 ex) $A$1, $B$2, $A$1:$F$1 등 혼합 참조 행 이름이나 열 이름의 한 쪽에만 “$”를 사용하여 참조하는 방법 ex) $A1, B$2, A$1:F$1 등 목표 값 찾기 기능 엑셀의 여러 기능 중 특정 수식 값을 목표하는 값(목표 값)과 같아지도록 수식과 관련된 입력 값을 조정하여 찾는 기능을 말함 강의록원리 합계 계산셀 참조 방법 상대 참조 (Relative Reference) 행 이름이나 열 이름만을 사용하여 셀을 참조함 수식을 복사하면 위치에 따라 참조가 변경 됨 ex) A1, D3, =AVERAGE(A2:G2) 절대 참조 (Absolute Reference) 참조하는 셀이나 셀 범위를 표시할 때 $ 표시를 사용함 수식을 복사해도 참조가 변경되지 않음 ex) $A$1, $D$3, =AVERAGE($A$2:$G$2) 혼합 참조 (Mixed Reference) 행 이름이나 열 이름의 한쪽에만 $ 표시하여 참조함 ex) $A1 (A열 고정, 행 변경 가능) ex) D$3 (D열 변경 가능, 3행 고정) ex) =AVERAGE($A2:$G2) 원리 합계 계산 예제 복리로 계산 되는 경우에 현재 금액 p에 대한 일정 기간 후의 원리 합계 G는 연 이율을 r, 기간을 n으로 주어졌을 때 다음과 같이 계산 됨 G = p * (1+r)^ 원금이 1,000만원인 경우 연 4.5%, 5.0%, 5.5%, 6.0%로 주어진 경우에 향후 20년이 경과하였을 때 원리 합계가 얼마나 차이가 생기는가? 기본 정보를 입력하고, 경과 년수는 채우기 기능을 이용하여 20까지 입력 참고 함수 식에서 원리 합계를 구할 때 원금은 절대 참조 이용 함수 식에서 연 이율과 경과 년수는 혼합 참조 이용 참조 B5 셀에 =$B$1*(1+B$2)^$A5을 입력하고, 채우기 기능을 이용하여 채움 원금($B$1)은 항상 고정 절대 참조 $B$1 연 이율(B$2, C$2, …)은 열 별로 다르지만 행은 고정 혼합 참조 B$2 열은 상대, 행은 절대 경과 년수($A5, $A6, …)는 행 별로 다르지만 열은 고정 혼합 참조 $A5 열은 절대, 행은 상대 B5:E5까지 선택하고 드래그 &amp; 드롭으로 20년이 경과한 후까지 채움 채우기를 마친 후 B5 셀을 선택하여 [보기]-[창] 그룹에서 [틀 고정]을 선택 [틀 고정] 기능을 이용하면 워크 시트를 읽을 때 편리함 연 이율 1%의 차이가 20년 후에 약 500만원 이상의 차이로 나타남 함수 그래프 그리기와 해 찾기엑셀을 활용한 함수 그래프 그리기, 해 찾기 함수 기능과 차트 기능을 활용하면 간단한 함수의 그래프 개형 뿐만 아니라 방정식의 해도 구할 수 있음 예제: 함수의 그래프 개형을 구간 (-3, 3) 에서 그려보고 그 구간에서 만족하는 근사적인 해 찾기 함수 그래프 그리기 -3.0부터 3.0까지 0.1 간격으로 채우기 기능 실행 B2 셀에는 =-A2^3 + 2*A2^2 - 2*A2 + 3을 입력 나머지 셀들에 대해서 드래그 &amp; 드롭을 통해서 채워 넣음 (-3, 3) 범위에서 함수의 그래프 그리기 차트 종류 중 분산형 선택 차트의 종류 중에서 분산형을 선택하여 그래프 작성 목표 값 찾기 기능을 이용하여 해 찾기 함수 f(x) = -x^3 + 2x^2 - 2x + 3을 만족하는 정확한 해는 엑셀 목표 값 찾기 기능을 이용하면 편리하게 구할 수 있음 함수 그래프 그리기를 통해서 함수 f(x) = -x^3 + 2x^2 - 2x + 3의의 근사적인 해는 1.8 근처의 값임을 알 수 있음 워크 시트에 구하고자 하는 함수 식에 대한 근사적 해를 입력함. 편의 상 A2셀에 1.8를 입력 B2 셀에 =-A2^3+2*A2^2-2*A2+3을 입력 [데이터] 탭의 [데이터 도구]에서 [가상 분석]-[목표 값 찾기] 선택 목표 값 찾기 대화 상자 화면에서 다음 정보를 입력 수식 셀(E) 함수 식이 입력된 셀 (B2) 찾는 값(V) 목표하는 함수 값 (0) 값을 바꿀 셀(V) 해를 찾기 위해 변경할 셀 (A2) 구하고자 하는 해는 1.8105임을 알 수 있음 적분 계산엑셀을 활용한 적분 값 계산 1 엑셀을 이용하여 함수의 정적분 값을 근사적으로 계산할 수 있음 주로 구분구적법 또는 사다리꼴 공식의 원리를 이용 근사 적분 값 계산 2 먼저 구간 [a, b]를 n개로 등분함 각 부분의 밑변의 길이는 n / b - a 으로 동일 분할 된 n 개의 직사각형 넓이를 왼쪽부터 S₁, S₂, …, Sₙ 으로 표시 Sₖ = 2 / f(xₖ ₋ ₁) + f(xₖ) * ∆x (직사각형 넓이 = 밑변 길이 * 높이) 여기서, ∆x = n / b - a , xₖ = a + k∆x S₁, S₂, …, Sₙ 을 모두 합하면 면적의 근사 값이 됨 n을 늘림에 따라 I = k=1 Σ n * Sₖ는 더 정확한 근사 값이 됨 밑변의 길이 계산 n / b - a ∆x = n / b - a , xₖ = a + k∆x f(x), 높이, 직사각형 넓이 계산 실습 예제 7.4 원리 합계 계산 예제 7.5 함수 그래프 그리기, 해 찾기 함수 f(x) = -x^3 + 2x^2 - 2x + 3의 그래프 개형을 구간 (-3, 3)에서 그려보고, 그 구간에서 f(x) = 0 을 만족하는 근사적인 해를 엑셀을 이용해 구해보자 연습 문제 풀이 다음 정적분을 엑셀을 이용하여 계산하시오. 적분 값은 0.1359이다. 구간 [-3, 3] 범위에서 함수 f(x) = √2π / 1 * e^-2/x²의 그래프를 그리시오 구간 [1, 2]를 n = 10 등분하여 적분 값을 계산하시오 함수 식에서 π의 계산은 =PI()를 이용한다. 연습 문제 함수 f(x) = -x^3 + 2x^2 - 2x + 3의 개형을 (-3, 3) 범위에서 그리고자 한다. 차트 마법사의 차트 종류 입력 상자에서 선택할 차트 종류로 알맞은 것은? a. 분산형 함수 f(x) = -x^3 + 2x^2 - 2x + 3의 개형을 (-3, 3) 범위에서 그렸더니 2 근처에서 x축을 통과한다는 것을 알았다. 엑셀을 활용하여 (-3, 3) 범위에서 -x^3 + 2x^2 - 2x + 3 = 0의 정확한 해를 구하고자 한다면 어떤 기능을 이용해야 하는가? a. 목표 값 찾기 기능 다음과 같이 셀 C7에 입력되어 있는 수식을 드래그 &amp; 드롭으로 C11까지 채워서 1월부터 6월까지의 미달러($) 기준의 수출액을 원화(￦) 기준으로 바꾸고자 한다. 셀 C6에 입력할 수식으로 맞는 것은?  a. =B6*B$2 복리로 계산 될 때 연 이율 r, 기간이 n인 경우 현재 금액 p에 대한 일정 기간 후의 원리 합계는 G = p * (1 + r)^n으로 계산할 수 있다. 원금이 1,000만원인 경우에 연 4.5%와 연 5.0%로 향후 20년까지 경과하였을 때 원리 합계가 얼마인지 계산하고자 한다. 채워 넣기를 이용하여 계산한다고 할 때 B5 셀에 알맞은 함수 식은? a. =$B$1*(1+B$2)^$A5 " }, { "title": "[유비쿼터스 컴퓨팅 개론] 10강 - 상황 인식 처리 기술", "url": "/posts/knou-uqc-10/", "categories": "Computer Science, CS Theory", "tags": "knou, ubiquitous computing", "date": "2025-05-02 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정광식 교수님의 '유비쿼터스 컴퓨팅 개론' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 상황 인식 컴퓨팅 기술은 여러 센서들로부터 얻은 상황 정보를 응용 서비스에 적합하게 처리하고, 사용자의 현재 상황에 가장 적합한 서비스를 찾아내어 이를 동적으로 재구성하여 사용자에게 제공함 사용자에게 필요한 서비스를 주변에 편재 된 컴퓨터들이 제공해주기 위해서 사용자 및 환경에 대한 동적인 모델을 수용하고 센서를 통해 상황 정보를 인식할 수 있는 기술을 공부함 환경 정보를 지능적으로 판단하고, 가공한 후에 적절한 서비스로 제공해주는 과정을 이해함 상황을 정보로 모델링하는 상황 정보 표현 기술을 공부함학습 목표 상황 정보를 수집 기술을 이용하여 상황 인식 서비스를 제공하기 위해 필요한 요소 기술에 대하여 이해함 상황 정보를 정의하고 이를 표현하는 다양한 방식에 대하여 배우고 익힘강의록상황 인식 컴퓨팅개요 상황 인식 컴퓨팅(Context-Aware Computing) 실 세계에서 획득한 정보를 추상화하고 연계하여 상황 정보를 지식으로 만들고, 응용 분야에 적합한 지식 표현을 기반으로 사용자와 서비스를 연계하는 응용 기술임 상황 인식 컴퓨팅 정의 상황 인식 컴퓨팅 기술 사용자의 현재 위치, 시각, 주변에 있는 다른 사람이나 기기들, 사용자의 행동이나 이력 등과 같은 사용자의 현재 상황 정보를 파악하고 분석한 후, 사용자가 현 상황에서 필요로 하는 서비스를 검색하여 구동 시켜 주는 기술 상황 정보는 센서 네트워크 내의 수많은 센서로부터 수집 된 자료들을 분석하여 파악할 수 있음상황의 정의 상황 또는 상황 정보 상황을 인식하는 데 필요한 기본 정보 사용자와 다른 사용자, 시스템 혹은 디바이스의 응용 프로그램의 상호 작용에 영향을 미치는 사람, 장소, 사물, 개체, 시간 등 주변 상황의 특징을 규정하는 정보 상황 실 세계에 존재하는 실체의 상태를 특징화하여 정의한 정보 상황 정보의 대상이 되는 실체 사람이나 사람 그룹, 물리적 사물이나 고려 대상인 시스템 등 상황/실체의 정의는 개발 과정에서 응용 서비스 시나리오를 위한 상황 전개 작업을 쉽게 함 상황의 정의 만약 어느 정보가 상호 작용하는 참여자의 상황을 특징 지을 수 있다면, 그 정보는 바로 상황이 됨 에이전트 관점에서는 감지기를 통하여 수집할 수 있는 모든 정보가 대상이 될 수 있음 상황에는 사용자, 물리적 환경, 컴퓨팅 시스템 상황, 사용자 컴퓨터 상호 작용 이력 등의 정보 등이 포함될 수 있음 슐리트(B.N.Schilit)의 정의 컴퓨팅 상황 Computing Context 네트워크 연결성/통신 비용/통신 대역폭/프린터/디스플레이 등 주변에 존재하는 자원 사용자 상황 User Context 사용자 프로필/위치/현재의 사회적 상황을 포함한 사용자 정보 물리적 상황 조명/소음 수준/교통 상황/온도 등 그 외에 시간적 상황을 고려하기도 함 시간적 상황 시간/요일/월·일/계절 등 상황의 분류 상황의 사례를 분류하는 방법 퍼코프(Perkop)와 버네트(Burnett)에 의한 외부적(external)범위와 내부적(internal) 범위로 구분한 방식 호퍼(Hofer)의 물리적(physical) · 논리적(logical) 상황으로 구분한 방식 외부적 상황의 범위 위치, 빛, 소리, 움직임, 촉감, 온도나 공기 압력 등 과 같이 흔히 하드웨어 센서로 측정 가능한 상황을 나타냄 내부적 상황 정보 사용자의 목표, 업무, 업무 상황, 비즈니스 처리, 사용자의 감정 상태와 같이 사용자에 의해 주어지거나 사용자의 상호 작용을 관찰함으로써 얻어지는 것들임 상황 인식 시스템 상황 인식 시스템 최근 상황 인식 컴퓨팅에서 사용자의 동작이나 작업과 관련 있는 적절한 정보 또는 서비스를 사용자에게 제공하는 과정에서 상황을 사용하는 시스템 상황 인식 시스템 구성 요소 상황 인식 시스템은 클라이언트 기기, 상황 인식 시스템 아키텍처, 상황 인식 모델로 구성 됨 클라이언트 기기 각종 센서, 스마트폰 등의 유비쿼터스 단말기 사용자에게 제공 되는 서비스 종류 및 사용 방식을 결정하는데 중요한 요소로 작용 함 상황 인식 시스템 아키텍처 직접적인 센서 활용 방식 미들웨어 인프라 구조를 이용한 방식 상황 서버를 기반으로 한 방식 상황 인식 모델 상황 데이터를 기계가 처리할 수 있는 형태로 정의하고 저장하기 위한 것임 상황 인식 컴퓨팅에서 사용될 수 있는 상황 정보 상황 정보의 분류 사용자 물리적 환경 컴퓨팅 시스템 사용자 - 컴퓨터 상호 작용 이력 기타 미 분류 상황 상황 인식 기술 전반에 대한 개념적인 시스템 구성 사용자 신원(ID, 성명) 신체(맥박, 혈압, 체온, 음성) 물리적 환경 공간(위치, 방향, 속도) 시간(일자, 시각, 계절) 환경(온도, 습도, 조도, 소음) 활동(인적인, 행동, 일정) 컴퓨팅 시스템 가용 자원(배터리, 디스플레이, 인터넷, 시스템) 가용 상황(자원, 장비, 시설) 접근 상황(사용자, 허용 정보, 인접성) 사용자-컴퓨터 상호 작용 이력 이력(사용자, 서비스, 시간) 장애(시간-사용자-서비스) 기타 미분류 상황 상황 인식 기술의 응용 상황 인식 응용이 지원할 수 있는 특징 사용자에게 정보와 서비스 제공(presentation) 사용자를 위한 서비스의 자동 실행(execution) 이후 검색을 위한 상황 정보의 표시(tagging) 응용 개발 과정에서 설계로부터 실제 구현을 위한 두 가지 접근 방법 설계자가 구조적인 서비스 또는 특징을 조합하여 응용을 구축하는 방법 설계자가 대상이 되는 응용을 좀 더 높은 차원에서 생각할 수 있도록 추상화 하는 방법 상황 인식 기술의 실제 구현을 지원하는 상황 인식 응용 개발 도구 기술 상황 정보의 획득과 접근 상황 인식 응용에 독립적인 상황 인식 정보의 저장 배포 및 실행 상황 인식 기술의 실제 구현을 지원하는 기술 요소 상황 정보의 추상화를 위한 기술 상황 정보를 해석하는 기술 유사한 상황 정보를 수집하는 기술 상황 인식 서비스 요소 기술개요 초기의 상황 인식 서비스 연구 다양한 상황 정보와 수집 기술을 조합하여 특정 플랫폼만을 위한 개별적인 프로토 타입 형태의 응용을 주로 연구함 초기 상황 인식 시스템은 특정 플랫폼에만 연관되어 있어 확장을 위해서는 많은 사전 지식이 필요하였음 공통 된 기능에 대한 모듈화가 되어 있지 않아 재사용이 어려움 이러한 문제점을 인식하여 상황 인식 서비스 인프라와 관련 된 연구가 활발히 진행되었음 상황 인식 응용 개발에 필요한 공통 기능을 응용 레벨에서 분리하여 미들웨어 형태로 개발자에게 제공하는 방안이 연구 됨 상황 인식 서비스 인프라는 개발자에게는 응용과 관계 된 기능에만 집중할 수 있도록 하고, 사용자에게는 일반화 된 응용 서비스를 제공함 상황 인식 서비스 인프라에 대한 요구 사항 기능적 요구 사항 상황 정보 수집, 저장 및 관리, 신청 및 배달, 분해 및 융합 등이 포함 됨 기능 외적인 요구 사항 확장성, 모듈성, 보안성, 이동성, 인터페이스 적절성, 결함 포용성, 서비스 품질, 플랫폼 간 호환성 등이 있음 상황 인식 서비스 요소 기술 상황 정보 수집 기술 상황 정보 모델링 기술 상황 정보 추론 기술 상황 정보 관리 기술 상황 정보 교환 기술 상황 정보 수집 기술 상황 인식 컴퓨팅에서 가장 기본이 되는 상황 정보를 얻기 위해서는 상황 정보 수집(sensing) 기술이 필요함 상황 정보는 사용자 인터페이스, 다양한 센서, 센서 네트워크 등을 통해 수집 됨 사용자는 키패드나 터치 스크린 등과 같은 사용자 인터페이스를 이용하여 자신의 기본적인 개인 정보나 개인 일정 등과 같은 정적인 상황 정보를 입력함 온도, 습도와 같은 환경 상황 정보와 체온, 혈압 등 사용자와 관련 된 정보들은 단말에 부착 된 센서를 통해 직접 수집할 수도 있고, 사용자 주변의 센서 네트워크 또는 상위 계층 네트워크와 통신을 통해 수집할 수도 있음 이렇게 수집 된 상황 정보는 상황 정보 모델에 따라 내부에 저장 된 후 향후 추론을 위한 기초 자료로 활용 됨 다수의 상황 정보는 시간이 지남에 따라 변화할 수 있음 각각의 상황 정보는 서로 다른 특성을 가지므로 변화 되는 주기도 다양함 예를 들어 사용자의 프로파일 정보는 거의 변화하지 않지만, 사용자의 위치 정보는 사용자가 이동함에 따라 수시로 변화함 상황 정보가 변화되었다는 사실은 주기적인 폴링(polling)이나 전파(broadcasting) 기법에 의해 파악할 수 있음 수집 된 값이 특정 조건을 만족할 때에만 보고 받는 형태의 정보 수집도 가능함 사람이나 사물 등과 같은 객체의 식별 정보도 위치 정보와 마찬가지로 상황 인식 서비스를 위해 기본적으로 요구 되는 상황 정보임 객체 식별을 위해서는 RFID 기술이 주목 받고 있음 다양한 방식에 의해 상황 정보 수집 시간 정보 내장 된 시계를 통해서 인접 객체에 대한 정보 위치 서버를 통해서 대역폭 커널 모듈에서 제공하는 API를 통해 조명의 밝기 감광성 반도체 소재를 통해서 가속도와 진동 가속도계 통해서 인접 객체 감지 수동형 적외선 센서를 통해서 소리 마이크로 폰을 통해서 기후 정보 온도계나 습도계를 통해서 상황 정보 모델링 기술 센서가 측정한 아날로그 정보 → 디지털 정보로 변환 → 센서 네트워크를 통한 전송 → 센서 네트워크 미들웨어 등을 통해 저장 되고 추론에 활용 됨 사용자에게 유용한 서비스를 제공하기 위해서는 수집 되고 저장 된 정보를 사용자의 여러 정보와 결합하여 고 차원의 상황 정보로 분석하고 추론할 수 있어야 함 상황 정보 및 사용자 정보 중에서 서비스를 제공하는 데 필수적인 정보만을 얻기 위해서는 먼저 잘 작성 된 모델을 바탕으로 정보들을 정형화하여 저장한 후, 체계적이고 효율적으로 공유할 수 있어야 함 상황 정보를 기계가 처리할 수 있는 형태로 정의하고 저장하기 위해서는 표준화 된 모델링 기술이 필요함 상황 정보의 표현 방식 및 교환 되는 데이터 구조를 기반으로 정보를 표현하는 방법의 분류 키 값(Key-value) 기반 모델 마크업 기반 모델 그래픽 기반 모델 객체 지향 기반 모델 로직 기반 모델 온톨로지 기반 모델 하나의 상황 타입 + 수집한 값 부수적으로 상황 데이터가 수집 된 시간, 정보 획득 대상, 데이터의 확신성 등을 적용하여, 상황 인식 시스템을 가동하면 더욱 유용해질 수 있음상황 정보 모델링 기술 - 키-값 기반 모델 셸 변수 등의 표현 방법으로도 많이 사용 되고 있는 가장 간단한 형태의 모델링 방식으로 정보를 나타내고 다루기 쉬움 텍스트 형식으로 표현 된 값에 패턴 매칭 등의 방식으로 질의 처리는 할 수 있지만, 정형화 된 형식이 있어야 하는 효율적인 정보 검색에는 부적합함 많은 상황 인식 시스템의 서비스 발견 프로토콜은 대부분 키 값으로 저장된 정보에 대하여 단순히 문자 비교 방식으로 필요한 서비스를 찾음 현재 개발 된 일부 상황 인식 시스템은 이 모델을 이용하여 사용자, 위치, 주변의 정보, 컴퓨터 장치 시간 등의 동적인 상황 정보를 나타냄상황 정보 모델링 기술 - 마크업 기반 모델 태그, 속성, 내용을 계층 구조의 재귀적 형태로 상황 정보를 표현함 간단하고 유연하며 구조화 되어 있음 편재 되어 있는 컴퓨팅에 적합함 응용 프로그램 수준에서 계층적으로 구조화 된 정보를 해석해야 함 정보 간의 복잡한 관계를 정의하기 힘든 단점이 있음상황 정보 모델링 기술 - 온톨로지 기반 모델 정보를 구조화하는 데 효과적이며 상호 관계성 및 부분적인 상황 정보를 쉽게 표현함 다양한 상황 인식 프레임 워크는 주로 온톨로지 기반 모델을 채택하고 있음 온톨로지 작성을 지원하는 도구들과 자원 기술 프레임워크(RDF), 온톨로지 웹 언어(OWL) 등을 이용하여 상황 정보를 선언함 자원 기술 프레임워크(RDF) &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns:feature=\"http://www.linkeddatatools.com/clothing-features#\"&gt; &lt;rdf:Description rdf:about=\"http://www.linkeddatatools.com/clothes#t-shirt\"&gt; &lt;feature:color rdf:resource=\"http://www.linkeddatatools.com/colors#white\"/&gt; &lt;/rdf:Description&gt; &lt;/rdf:RDF&gt; 상황 정보 추론 기술 수집 된 여러 데이터를 분석하여 상위 상황 정보를 도출하려면 확률적인 메커니즘도 제공되어야 함 계층적 상황 정보를 기반으로 지능적인 추론 방법도 제공되어야 함 온톨로지를 이용한 모델이 상황 지식의 공유 가능, 재사용 지원, 높은 추론 기능을 제공할 수 있음 이와 관련 된 추론 시스템 연구가 활발하게 연구되고 있음 상황 정보 교환 기술 센서나 장치, 대상 객체와의 상호 작용을 지원하기 위해 이벤트 기반 또는 폴링 기반의 통신 메커니즘을 제공해야 함 SOAP(Simple Object Access Protocol)은 분산 환경에서 데이터를 교환하기 위한 XML 기반 프로토콜임 SOAL은 표준 인코딩 모델을 가지고 있으므로 서로 다른 시스템 간에도 호환성을 제공함상황 정보 관리 기술 상황 정보 관리에서 가장 중요한 이슈는 응용이 필요한 상황 정보를 기능적으로 조합하여 효율적으로 제공하는 것임 상황 정보 툴킷 서버와 해석기로 구성 됨 서버 상황 정보 위젯으로부터 필요한 다양한 상황 정보를 취합함 해석기 상황을 다른 형태나 의미로 변환하여 상위 레벨의 응용에 제공함 상황 정보 위젯, 서버, 해석기가 외부 제약 없이 언제나 효율적으로 센서와 응용 서비스를 지원하기 위하여 각 컴포넌트는 서로에 대한 완벽한 추상화를 제공해야 함 상황 정보의 조합 문제를 응용과 독립적으로 설계할 수 있으며, 이를 통해 센서나 응용 서비스의 추가 및 제거가 발생하더라도 부가적인 조정을 하지 않아도 됨상황 정보의 정의 및 표현개요 초기의 유비쿼터스 컴퓨팅 응용은 단순히 센서가 수집한 데이터만 이용하였음 다양한 형태의 센싱 정보가 아니라 한 종류의 데이터만 가지게 됨 센서 관련 기술이 발전되어 센서의 단가가 낮아지고 다양한 기능을 가진 센서가 등장함 상황 인식 미들웨어도 여러 종류의 센서로부터 다양한 데이터를 수신할 수 있게 되었음 다양해진 데이터를 정의하고 표현할 방법이 필요하게 됨 상황 정보의 정의는 사용자에게 좀 더 정확하게 제공하는 데 필요함 수집 된 상황 정보가 한 개인에게 국한 된 것이 아니므로 상황 정보를 일반적으로 표현하여 다수의 사용자에게 공통적인 정보로 제공하는데 필요함시맨틱 웹 시맨틱 웹 컴퓨터가 정보의 의미를 이해하고 의미를 조작할 수 있는 웹 형태의 정보 표현 시맨틱 웹은 웹을 통해 동일한 개념으로 다양한 정보를 보다 효과적으로 활용할 수 있게 함 월드 와이드 웹 단순한 문서의 의미 내용도 컴퓨터가 알지 못하는 수준 시맨틱 웹 정보와 지식을 처리할 수 있는 웹의 환경 시맨틱 웹 환경에서 지식을 표현하기 위한 언어는 자원 기술 프레임워크, 온톨로지 추론 계층, DARPA 에이전트 마크업 언어 등이 있음정리 하기 상황 인식 컴퓨팅은 현실 공간과 가상 공간을 연결하여 가상 공간에서의 현실의 상황을 정보화하고 이를 활용하여 사용자 중심의 지능화 된 서비스를 제공하는 기술임 상황 인식 서비스를 위해서는 상황 정보 수집 기술, 모델링 기술, 추론 기술과 같은 주요 요소 기술을 필요로 함연습 문제 상황의 분류에 포함되지 않는 것은 무엇인가? a. 지식적 상황 상황의 분류에 포함 되는 것 컴퓨팅 상황 사용자 상황 물리적 상황 상황(또는 상황 정보, Context)의 정의에 포함되지 않는 것은 무엇인가? a. 사용자의 주변을 구성하는 가상화 된 자원 정보 상황(또는 상황 정보, Context)의 정의에 포함되는 것 상황 인식을 하기 위해 필요한 기본 정보 실 세계에 존재하는 실체의 상태를 특징화하여 정의한 정보 사용자의 상황을 특징 지을 수 있는 정보 상황 인식 서비스 요소 기술이 아닌 것은 무엇인가? a. 상황 정보 연계 기술 상황 인식 서비스 요소 기술 상황 정보 모델링 기술 상황 정보 추론 기술 상황 정보 관리 기술 정리 하기 상황 인식 컴퓨팅(Context-Aware Computing) 실 세계에서 획득한 상황 정보를 추상화하고 연계하여 상황 정보를 지식으로 만들고, 응용 분야에 적합한 지식 표현을 기반으로 사용자와 서비스를 연계하는 응용 기술 상황 인식 기술의 효율적인 이용을 위한 요구 사항 상황에 대한 이해 상황 정보의 선택/활용 방법/상황 인식 행위의 결정을 지원해줌 상황과 관련된 기술 구조에 대한 이해 응용 서비스의 구축을 지원해줌 상황(또는 상황 정보, Context)의 정의 상황 인식을 하기 위해 필요한 기본 정보 실 세계에 존재하는 실체의 상태를 특징화하여 정의한 정보 사용자의 상황을 특징 지을 수 있는 정보 상황의 분류 컴퓨팅 상황(Computing Context) 사용자 상황(User Context) 물리적 상황(Physical Context) 상황 인식 시스템의 구성 클라이언트 기기 상황 인식 시스템 상황 인식 모델 상황 인식 응용 개발 도구 기술 상황 정보의 추상화(Abstraction) 기술 상황 정보의 해석(Interpretation) 기술 유사한 상황 정보의 수집(Aggregation)기술 상황 인식 서비스 요소 기술 상황 정보 수집 기술 상황 정보 모델링 기술 상황 정보 추론 기술 상황 정보 관리 기술 " }, { "title": "[운영 체제] 10강 - 페이지 교체 알고리즘", "url": "/posts/knou-os-10/", "categories": "OS, Operating System", "tags": "knou, os", "date": "2025-05-02 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김진욱 교수님의 '운영 체제' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 새로운 페이지를 메모리에 적재하려는데 빈 페이지 프레임이 없을 경우 페이지 프레임 중 한 칸을 선택하여 거기에 든 페이지 대신 새로운 페이지를 넣어야 함 어떤 페이지를 교체 대상으로 선택 하느냐에 따라 컴퓨터 시스템의 성능에 영향을 주게 됨 다중 프로그래밍 환경에서는 각 프로세스가 사용할 수 있는 페이지 프레임의 개수를 제한할 필요가 있는데, 이 개수 또한 컴퓨터 시스템의 성능에 영향을 줌 여러 가지 페이지 교체 알고리즘에 대해 학습함 프로세스 별 페이지 집합을 관리하는 기법도 살펴봄학습 목표 다양한 페이지 교체 알고리즘을 설명할 수 있음 프로세스 별 페이지 집합 관리를 설명할 수 있음강의록페이지 교체 알고리즘페이징 기법 모든 페이지 프레임이 사용되고 있을 때 새로 적재되어야 할 페이지를 위해 적절한 교체 대상을 결정 교체 대상 선택 최적화의 원칙 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체 대상으로 선택 이론적으로 최적이나 미래를 예측할 수 없어 실현 불가능 선택을 위한 기본 정책 대체로 좋은 결론은 내리면서 선택을 위한 시간 및 공간 오버 헤드가 적은 방법 교체 제외 페이지 페이징을 위한 커널 코드 영역 보조 기억 장치 드라이버 영역 시간을 맞춰 동작해야 하는 코드 영역 입출력 장치를 위한 데이터 버퍼 영역 등 페이지 교체 알고리즘 FIFO 페이지 교체 LRU 페이지 교체 LFU 페이지 교체 2차 기회 페이지 교체FIFO 페이지 교체 FIFO (First-In First-Out) 메모리 내에 가장 오래 있었던 페이지를 선택하여 교체 구현 FIFO 큐 이용 교체 대상 페이지 선택 (FIFO 큐의 선두) 가상 메모리에 보관 새로운 페이지 적재 (FIFO 큐의 끝에 추가) 단점 가장 많이 쓰이는 페이지를 교체 시킬 가능성 있음 Belady의 이상 현상 프로세스에 더 많은 수의 페이지 프레임을 할당하면 오히려 페이지 부재가 더 많이 발생할 수 있는 현상 Belady의 이상 현상 예 LRU 페이지 교체 LPU(Least Recently Used) 메모리 내에서 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체 국부성(locality) 휴리스틱에 기반 최근의 상황이 가까운 미래에 대한 좋은 척도 시간 국부성, 공간 국부성 구현 참조 시각 또는 리스트 이용 참조 시각을 이용한 구현 각 페이지가 참조될 때마다 그때의 시각을 테이블에 기록 교체가 필요한 경우 참조 시각이 가장 오래된 페이지를 선택하여 교체 교체가 필요할 때 참조 시각이 가장 오래된 C를 B와 교체 리스트를 이용한 구현 각 페이지가 참조될 때마다 리스트의 선두로 옮김 교체가 필요한 경우 리스트의 끝에 있는 페이지를 선택하여 교체 장점 Belady의 이상 현상 발생하지 않음 많은 경우 최적화 원칙에 근사한 선택 가능 단점 국부성이 맞지 않는 상황도 존재 막대한 오버 헤드 LFU 페이지 교체 LFU(Least Frequently Used) 메모리 내에서 참조 된 횟수가 가장 적은 페이지를 선택하여 교체 구현 참조 횟수 이용 각 페이지가 참조될 때마다 참조 횟수를 기록 교체가 필요한 경우 참조 횟수가 가장 적은 페이지를 선택하여 교체 단점 가장 최근에 메모리로 옮겨진 페이지가 교체될 가능성 높음 초기에 매우 많이 사용된 후 더 이상 사용되지 않는 페이지는 교체 가능성 낮음 막대한 오버 헤드 2차 기회 페이지 교체 참조 비트가 0이면서 메모리 내에 가장 오래 있었던 페이지를 선택하여 교체 구현 FIFO 큐와 참조 비트 이용 각 페이지가 메모리에 적재될 때는 참조 비트 0 적재된 상태에서 추가로 참조되면 참조 비트 1 참조할 페이지가 메모리에 없는 경우 빈 페이지 프레임이 있으면 페이지 적재, 큐에 추가, 참조 비트는 0으로 설정 빈 페이지 프레임이 없으면 큐의 선두 항목을 꺼내 참조 비트 조사 참조 비트가 1이면 0으로 바꿔 큐의 뒤에 추가 후 1) 단계로 이동 참조 비트가 0이면 교체 대상으로 선택하여 교체 참조할 페이지가 메모리에 있는 경우 큐 위치 변화 없이 참조 비트만 1로 설정 큐를 이용한 구현 B 페이지 참조 큐에서 A의 참조 값 1 확인 후 참조 값 0으로 바꿔 큐의 맨 뒤로 이동 큐에서 C의 참조 값 1 확인 후 참조 값 0으로 바꿔 큐의 맨 뒤로 이동 큐에서 D의 참조 값 0 확인 후 참조 값 0이므로 B로 교체 변형 된 원형 큐를 이용한 구현(클럭 페이지 교체 알고리즘) 포인터는 마지막에 추가된 페이지의 다음 위치를 가리킴 빈 페이지 프레임이 있는 경우: 빈칸 페이지 프레임이 꽉 찬 경우: 큐의 선두 프로세스 별 페이지 집합 관리 프로세스마다 사용할 수 있는 페이지 프레임의 개수만큼 메모리에 유지 되는 페이지 집합 집합의 크기가 작을수록 시스템 처리량 증대 각 프로세스 별 페이지 부재는 자주 발생하여 성능 저하 집합의 크기가 클수록 프로세스 별 페이지 부재는 감소 메모리에 적재될 수 있는 프로세스 수는 줄어듦 각 프로세스가 사용할 수 있는 페이지 프레임 개수 관리 워킹 세트 알고리즘, PFF 알고리즘 워킹 세트 알고리즘 워킹 세트(working set) 모델 페이지 부재 비율을 감소 시키기 위해 Denning이 제안한 모델 프로세스의 워킹 세트 W(t, ∂) 시각 t에 t를 포함한 직전 ∂시간 동안 참조한 페이지의 집합 워킹 세트 알고리즘 프로세스가 수행 됨에 따라 그 프로세스의 워킹 세트는 변할 수 있으며 워킹 세트의 크기도 달라질 수 있음 워킹 세트 알고리즘의 원칙 프로세스의 워킹 세트를 메모리에 유지 시키는 것 워킹 세트를 메모리에 유지하지 않으면 쓰래싱 유발 가능 쓰래싱 (thrashing) 페이지 부재가 비정상적으로 많이 발생하여 프로세스 처리보다 페이지 교체 처리에 너무 많은 시간을 소비하여 시스템의 처리량이 급감하는 현상 프로세스마다 워킹 세트 크기에 맞게 페이지 프레임 개수 조절 충분한 여분의 페이지 프레임이 존재 실행 프로세스 수 늘림 실행 중인 프로세스들의 워킹 세트 크기의 합이 총 페이지 프레임 수를 넘어섬 우선 순위가 낮은 프로세스를 일시 중지 문제점 과거를 통해 미래를 예측하는 것이 정확하지 않음 워킹 세트를 정확히 알아내고 계속 업데이트하는 것이 현실적으로 어려움 워킹 세트 윈도 크기 ∂의 최적 값을 알기 어려우며 이 역시 변화할 수 있음 PFF 알고리즘 페이지 부재 빈도(PFF)를 이용하여 프로세스 별 페이지 집합의 크기를 변화 시키는 기법 PFF(Page Fault Frequency) 얼마나 자주 페이지 교체가 발생하는 지를 나타내는 척도 페이지 부재가 발생하면 직전 페이지 부재 이후로 경과 된 시간의 역수 PFF의 상한과 하한을 정해 둠 PFF가 상한보다 높으면 페이지 프레임 개수를 1 증가 PFF가 하한보다 낮으면 그 사이에 참조되지 않았던 페이지를 모두 제거 장점 프로세스 별 페이지 집합이 워킹 세트 알고리즘처럼 자주 바뀌지 않음 정리 하기 페이지 교체는 메모리가 완전히 사용되고 있을 때, 새로 적재되어야 할 페이지를 위해 어느 페이지가 교체되어야 하는 지를 다룸 페이지 교체 알고리즘에는 FIFO, LRU, LFU, 2차 기회 페이지 교체 등이 있음 최적의 페이지 교체 방법은 앞으로 가장 오랫동안 사용되지 않을 페이지를 선택하는 방법이지만 현실적으로 불가능함 프로세스는 기억 장치 내의 정보를 균일하게 액세스하는 것이 아니라 어느 한순간에는 특정 부분을 집중적으로 참조하는 국부성을 보임 워킹 세트는 한 프로세스가 최근에 참조한 페이지의 집합임 프로세스가 효율적으로 수행되기 위해서는 워킹 세트가 메모리 내에 유지되어야 함 PFF 알고리즘의 기본 아이디어는 페이지 부재 빈도가 높으면 페이지 프레임을 해당 프로세스에 더 배정하고 낮으면 회수하는 것임" }, { "title": "[데이터베이스 시스템] 10강 - 데이터 저장과 파일", "url": "/posts/knou-dbs-10/", "categories": "Database", "tags": "knou, database", "date": "2025-04-30 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '데이터베이스 시스템' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 현대의 DBMS는 사용자에게 물리적 저장 세부 사항을 숨기고, 논리적 관점에서 데이터를 정의하고 조작할 수 있도록 다양한 추상화 계층을 제공함 이러한 추상화 덕분에 응용 개발자나 일반 사용자는 저장 장치의 구조나 접근 방식에 대해 직접 고려하지 않아도 되며, 데이터 모델과 질의 언어 수준에서 시스템을 이용할 수 있음 그러나 데이터의 실제 저장 방식, 파일 구조, 접근 방식 등은 데이터베이스 성능에 직접적인 영향을 미치기 때문에, 데이터베이스 관리자(DBA)는 이러한 물리적 저장 계층에 대한 깊은 이해를 바탕으로 적절한 설계를 수행하고 운영 전략을 결정해야 함 DBMS가 파일 시스템을 기반으로 데이터를 어떻게 저장하고 관리하는 지를 이해하기 위해, 저장 장치의 계층 적 구조, 데이터 파일의 구성 방식, 레코드의 조직 방법, 저장 장치 접근 기법 등 물리적 저장 관련 핵심 개념들을 살펴봄 이를 통해 논리적 수준에서 설계된 데이터베이스가 실제 저장 장치 상에서 어떻게 표현되고 동작하는 지를 파악할 수 있음주요 용어 파일 디스크에 데이터를 저장하고 사용하기 위해 접근 되는 가장 기초적인 논리적 저장 단위 블록 디스크에 데이터를 저장하는 고정적 크기의 물리적 저장 단위 레코드 블록을 구성하는 요소로 더 이상 분리될 수 없는 최소 데이터 저장 단위 멀티 셋 한 레코드의 컬럼 값이 여러 개인 컬럼 강의록물리적 저장 장치와 파일물리적 저장 장치의 구성 물리적 저장장치는 데이터 접근 속도, 용량을 기준으로 다양한 장치로 계층 적(hierarchical) 구성 물리적 저장 장치 별 특징 기억 지속성 관점으로 휘발성과 비 휘발성으로 구분 휘발성 저장 장치 캐시 CPU 내부에 위치하여 자주 사용될 것으로 예상되는 데이터를 저장 메인 메모리 임의 접근이 가능한 고속의 저장 공간 비 휘발성 저장 장치 플래시 메모리 메인 메모리와 유사하나 비 휘발성 자기 디스크 자성체를 통해 영구적으로 데이터를 저장 광학 디스크 드라이브 CD, DVD, Blu-ray 등 테이프 용량이 크고 저렴하나 순차 접근 방식으로 접근 속도가 매우 느림 데이터베이스 저장 구조 데이터베이스는 하나 이상의 파일로 구성될 수 있음 각 파일은 여러 블럭으로 나뉨 블럭 내에는 레코드들이 저장됨 사용자가 원하는 부분을 DBMS에 요청 DBMS가 내부 관리하고 있는 파일의 데이터에 접근 · 전달 데이터베이스 구성 요소 파일 데이터를 영구적으로 저장하기 위해 사용되는 가장 기초적인 논리적 구조 블럭 파일을 고정적인 길이로 분할하여 생기는 균등한 크기의 데이터 묶음 일반적으로 메모리와 디스크 간 데이터 전송 단위로 결정 데이터 전송 단위(page size) 레코드 블럭에 저장되는 요소 관계형 모델에서 분리될 수 없는 최소 데이터 저장 단위 입출력은 최소 단위인 레코드 단위로만 상황에 따라 두 가지 타입으로 구분 테이블에 존재하는 모든 레코드가 항상 길이가 같을 때 → 고정 길이 레코드 테이블에 존재하는 레코드마다 길이가 모두 다를 때 → 가변 길이 레코드 고정 길이 레코드 고정적인 바이트 수를 갖는 레코드 저장 시 고려되는 기법 사원 릴레이션 사번 (CHAR(8)) 이름 (VARCHAR(20)) 부서명 (CHAR(10)) 연봉 (INT) 12012 홍길동 인사부 90,000,000 12034 임꺽정 재무부 80,000,000 13019 이순신 법무지원부 90,000,000 13030 장보고 인사부 75,000,000 13044 나철수 시설관리부 80,000,000 14001 김영희 마케팅부 90,000,000 14004 유관순 총무부 92,000,000 14017 안창호 생산부 98,000,000 데이터 접근 모든 레코드는 42 바이트 크기로 구성 i번째 레코드 접근 (i - 1) * 42 + 1 번째 바이트부터 42개의 바이트를 읽어 접근 고정 길이 레코드 할당 블럭의 길이가 레코드 길이로 정확히 나눠지지 않아 잔여 공간을 비워두는 방법 블럭 내의 남은 공간 낭비 레코드 k + 1을 저장하고자 함 → 블럭 1에 충분한 공간이 없음 → 남겨놓고 다음 블럭에 저장 블럭의 길이가 레코드 길이로 정확히 나눠지지 않아 한 레코드를 두 블럭에 나누어 저장하는 방법 레코드 접근 시 두 개의 블럭에 접근 필요 고정 길이 레코드 할당 시 고려 사항 레코드 삭제 시 해당 레코드가 저장 된 위치에 빈 공간이 생성 장시간 레코드의 삽입 및 삭제 발생 시, 저장 공간에 많은 낭비가 발생 레코드 삭제 시 대체 방안 마지막 레코드로 공백 대체 삭제 레코드 이후의 레코드를 이동 가용 리스트 관리 레코드 삭제 대처 마지막 레코드로 공백 대체 사번 이름 부서명 연봉 12012 정용호 인사부 90,000,000 12034 임꺽정 재무부 80,000,000 13019 이순신 법무지원부 90,000,000 13030 장보고 인사부 75,000,000 13044 나철수 시설관리부 80,000,000 14001 김영희 마케팅부 90,000,000 14004 유관순 총무부 92,000,000 14017 안창호 생산부 98,000,000 속도 저하는 없으나 삽입과 접근의 순서가 달라질 수도 있음 삭제 레코드 이후의 레코드를 이동 사번 이름 부서명 연봉 12012 정용호 인사부 90,000,000 12034 임꺽정 재무부 80,000,000 13019 이순신 법무지원부 90,000,000 13044 나철수 시설관리부 80,000,000 14001 김영희 마케팅부 90,000,000 14004 유관순 총무부 92,000,000 14017 안창호 생산부 98,000,000 레코드 4번 삭제 후 이동 사번 이름 부서명 연봉 13030 장보고 인사부 75,000,000 저장의 순서와 접근의 순서가 크게 달라지지 않음 순서는 유지되나 성능 저하가 크게 일어날 수도 있음 가용 리스트 관리 새로운 레코드가 들어오려 할 때 가용 리스트의 첫 번째 헤더에 할당해 저장 시킴 포인터의 정보를 연속적으로 유지, 보유해야 함 가변 길이 레코드 블럭에 저장 되는 레코드의 길이가 서로 다른(가변적)레코드를 할당하는 방법 가변 길이 레코드는 길이를 예상할 수가 없음 → 수식을 통해 데이터에 접근할 수 없음 가변 길이 레코드가 고려되어야 하는 상황 한 블럭 내에 저장 되는 레코드 유형이 둘 이상 길이가 고정되지 않은 컬럼의 개수가 하나 이상 레코드가 멀티 셋을 허용하는 컬럼을 가질 때 멀티셋 레코드의 컬럼 값이 여러 개인 컬럼 가변 길이에 해당하는 컬럼은 맨 뒤에 배치시킴 가변 길이 컬럼이 시작하는 시작 포인터와 길이를 레코드 맨 앞에 위치 시킴 NULL 가변 길이와 고정 길이를 구분하기 위해 추가 1byte 슬롯 페이지 구조 가변길이 레코드를 관리하기에 최적의 방법 블럭 헤더 몇 번째 레코드를 읽어와야 하는 지를 파악 파일 구조화 방법 파일 구조화 파일 수준에서 레코드를 관리(순서 등)하는 기법 테이블에 존재하는 블록 중 어느 순서에 저장해야 할까?(어디에) 파일 구조화 방법의 종류 힙 파일 구조 저장 순서 고려 없이 파일 내 임의 블럭에 배치 장점 저장 순서가 빠름 단점 검색의 속도가 떨어짐 어느 블록에 있는지 일일이 확인해야 함 순차 파일 구조 레코드가 탐색 키 기준으로 정렬되어 저장 장점 검색 순서가 빠름 단점 힙 파일 구조보다는 저장 속도가 떨어짐 해시 파일 구조 해시 함수를 사용하여 블럭 주소를 계산 힙 파일 구조와 순차 파일 구조의 중간 지점에 해당 순차 파일 구조의 예순차 파일 구조 레코드가 탐색 키 순서대로 정렬 레코드가 파일에 삽입 되는 시점에서 키 값이 부여 장점 검색 키에 대한 정렬 연산이 불 필요, 키 값들의 순서로 레코드를 판독하는 연산에 효율적 현재 레코드에서 정렬 된 키 순서로 다음 레코드를 찾을 때 부가적인 블럭 접근이 불필요 이진 탐색을 사용하면 더 빠르게 레코드를 검색 단점 레코드 삽입, 삭제에 많은 비용 소요 오버 플로우 블럭 순차 파일 구조에서 레코드의 정렬 된 상태 유지를 위해 삽입 된 신규 블럭 신규 데이터를 삽입할 때 기존 저장 공간에 여유가 없거나 데이터의 순서를 유지하기 위해 데이터가 원래의 블럭에 적합하지 않을 경우, 이를 저장하기 위해 새롭게 생성되는 추가 블럭 새로운 래코드가 삽입 되어야 할 위치가 정해져 있지만 해당 블럭에 여유 공간이 없는 경우 새로운 블럭을 생성하여 데이터를 생성함 기존 블럭과 오버 플로우 블럭을 포인터로 연결해 기존의 순차성을 유지하면서 추가 데이터 검색할 수 있음 단점 데이터 접근 속도와 검색 효율성 저하 저장 장치 관리저장 장치 접근 파일은 논리적 관점에서의 저장 객체 실제 저장 될 때에는 여러 개의 물리적 단위인 블럭으로 저장 블럭은 메모리와 디스크 간 데이터의 전송 단위 일반적으로 2KB ~ 32KB 사용 블럭 전송을 최소화할 수록 입출력 소요 시간이 단축 사용 중인 블럭을 지속적으로 메모리에 적재 한정적 공간으로 인하여 필요에 따라 특정 블럭 할당을 해지 메모리 내부에 버퍼라는 공간에 블럭을 저장하고, 이를 관리하기 위한 버퍼 관리자를 사용 버퍼 관리자 DBMS가 메모리 내부의 공간인 버퍼(buffer)를 효율적으로 관리하기 위한 하위 시스템 계속 사용하고 잇는 블럭을 고정시켜 효율적으로 메모리를 사용 DBMS 상의 소프트웨어는 필요한 블럭이 있을 때 버퍼 관리자에게 해당 블럭을 요청 요청 된 블럭이 버퍼에 있다면, 버퍼 관리자는 블럭이 위치한 메모리 주소를 프로그램에게 전달 요청 된 블럭이 없는 경우, 버퍼 관리자는 버퍼 내의 새로운 공간을 할당하고 해당 블럭을 적재 더 이상 적재할 공간이 없다면, 버퍼에 있는 기존 블럭을 선택하여 할당을 해지하고 해당 블럭을 적재 버퍼 교체 전략 교체의 우선순위를 조작버퍼 관리자의 기능 버퍼 교체 가용 공간을 확보 하기 위해 기존에 적재 된 블록을 특정 기준에 의하여 해지 미래에 가장 적게 사용 될 블록을 선택하여 디스크로 내보내는 것이 이상적인 버퍼 교체 전략 버퍼 교체 전략 LRU(Least Recently Used) 최근에 가장 적게 참조 된 블럭을 교체 MFU(Most Frequently Used) 특정 기간 동안 가장 여러 번 사용 된 블럭을 선택하여 블럭을 교체 블럭 고정 장애로 메모리의 데이터가 손실 되어 작업이 중단될 경우, 중단 된 작업의 결과물이 디스크에 기록되는 것을 방지 디스크 블럭이 교체되는 것을 제한 블럭 강제 출력 시스템 로그와 같이 중요한 데이터는 디스크에 영구적으로 기록되어야 할 필요 버퍼 공간이 필요 없어도 강제로 디스크에 기록 고정 블럭과 블럭 강제 출력연습 문제 다음 물리적 저장 장치들 중 휘발성과 비휘발성 장치를 올바르게 짝지은 것은? 디스크, 메인 메모리, 자기 테이프, 캐시 a. 휘발성-&lt;캐시, 메인 메모리&gt;,  비휘발성-&lt;디스크, 자기 테이프&gt; 전원 공급이 없을 때 데이터가 사라지는 휘발성 저장장치로는 주로 CPU가 이용하는 주 기억 장치인 레지스터, 캐시, 메인 메모리가 있음 전원 공급이 없어도 데이터가 보존되는 비 휘발성 저장장치는 디스크와 같이 주 기억 장치보다 하위에 위치하는 보조 기억 장치와 3차 기억 장치인 광학 디스크 드라이브와 자기 테이프가 있음 다음은 어떤 파일 구조에 대한 설명인가? 모든 레코드를 파일 내 임의의 위치에 저장하며, 저장하는 순서를 고려하지 않는 파일 구조 a. 힙 파일 구조 순차 파일 구조에서는 레코드들이 특정 컬럼에 대한 값을 기준으로 정렬되어 저장이 됨 해시 파일 구조에서는 레코드가 입력 되면 레코드가 저장 될 블록 주소를 반환해주는 해시 함수를 사용함 다중 테이블 클러스터링 파일 구조는 빈번히 조인 되는 테이블을 하나의 파일에 저장하기 위해 미리 테이블이 조인 되어 저장 되어있는 구조임 다음은 어떤 버퍼 교체 전략에 관한 설명인가? 미래에 가장 적게 사용될 블록을 선택하여 버퍼에 적재하기 위해 특정 기간동안 가장 여러 번 사용된 블럭을 선택하여 블럭을 교체 a. MFU LRU의 경우 최근에 참조된 블록은 다시 참조 될 가능성이 높다고 판단하여 가장 최근에 적게 참조 된 블록을 교체하는 전략임 SJF(최단 작업 우선 스케줄링)와 FCFS(선입 선처리 스케줄링)는 CPU에 프로세스를 할당하기 위한 전략임 정리 하기 물리적 저장 장치들은 데이터 접근 속도 관점에서 계층 적으로 분류됨 상위 계층은 접근 속도가 빠르지만 고가의 장비이며, 하위 계층은 접근 속도가 느리지만 저가의 장비임 일반적으로 상위의 저장 장치들은 전원 공급이 차단되면 데이터가 소멸되는 휘발성이며, 하위의 저장장치들은 전원 공급이 차단되어도 데이터가 소멸되지 않는 비 휘발성임 데이터베이스는 여러 파일로 구현됨 파일이란 데이터를 영구적으로 저장하기 위해 사용하는 구조임 파일은 물리적으로 여러 블럭으로 나뉘어 저장되기도 함 하나의 파일은 다수의 레코드를 저장하고 있음 레코드의 형식은 고정 길이 레코드와 가변 길이 레코드가 있음 레코드의 형식에 따라 파일 및 블럭에서 레코드를 관리하는 방식이 달라짐 특히 슬롯 페이지 구조는 가변 길이 레코드를 관리할 때 이용되는 블럭 구조임 특정 필드에 대한 빠른 접근이 요구되는 경우, 파일에 저장되는 레코드를 구조화하는 것이 좋음 파일 구조화 방법으로는 힙 파일 구조화, 순차 파일 구조화, 해시 파일 구조화가 있음 파일 구조 중 다중 테이블 군집 파일 구조는 여러 개의 테이블을 하나의 파일에서 관리하는 특수한 파일 구조임 메모리와 디스크는 블럭 단위로 데이터를 주고받음 이때 데이터베이스 시스템에서는 블럭의 입출력을 최소화하기 위해 메모리 내에 버퍼라는 공간을 만들며, 버퍼를 효율적으로 관리하기 위해 버퍼 관리자를 사용함 버퍼 관리자는 버퍼 공간에 대한 추가적인 공간 요청 시 버퍼 교체 전략을 사용하여 사용 된 블록을 디스크로 내보내어 공간을 확보함체크 포인트 데이터베이스 저장 구조에 대한 설명으로 옳지 않은 것은? a. 해싱 파일은 각 레코드의 속성에 해싱 함수를 적용한 후 레코드들을 정렬하여 저장 레코드를 정렬하지는 않음 데이터베이스 저장 구조에 대한 설명으로 옳은 것은? 힙 파일은 파일에서 빈 공간이 있다면 레코드를 어느 위치에나 저장 순차 파일은 검색키 값의 순서에 따라 정렬된 형태로 레코드들을 저장 다중테이블 클러스터링 파일은 서로 다른 릴레이션들의 관련 레코드들을 같은 블록에 저장 다음 중 가변 길이 레코드 방식이 필요한 이유가 아닌 것은? a. 레코드의 수정이 매우 자주 발생할 때 가변 길이 레코드 방식이 필요한 이유 레코드가 멀티셋(multiset)을 이용하는 컬럼을 가질 때 한 블록 내에 저장되는 레코드 유형이 둘 이상일 때 길이가 고정되지 않은 컬럼이 한 개 이상일 때 " }, { "title": "[파이썬 프로그래밍 기초] 10강 - 객체 지향", "url": "/posts/knou-python-10/", "categories": "Language, Python", "tags": "knou, python", "date": "2025-04-29 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '파이썬 프로그래밍 기초' 강의를 개인 공부 목적으로 메모하였습니다. 학습 목표 객체 지향의 개념에 대해 설명할 수 있음 객체 유사성을 도출하여 추상화할 수 있음 클래스와 인스턴스를 정의할 수 있음주요 용어 객체 지향 객체와 객체 사이의 상호 작용으로 프로그램을 구성하는 프로그래밍 패러다임 클래스 실 세계의 객체에 대한 데이터와 연산을 표현한 단위 초기자 객체의 상태를 초기화하는 특수 메소드 객체 멤버 접근 연산자 객체의 데이터 필드 접근 및 메소드 호출에 사용되는 연산자 강의록객체 지향의 이해유사성 공통적인 것은 미리 만들어 놓고 서로 다른 점만 따로 구현한다면 훨씬 더 효과적인 대형의 프로그램을 개발할 수 있음 하나의 프로그램 내부에서도 서로 다른 객체 사이의 공통점을 또 찾아내 구현하고 다른 점만 별도로 구현객체 지향의 이해객체 지향의 개념 객체와 객체 사이의 상호 작용으로 프로그램을 구성하는 프로그래밍 패러다임 프로그램을 유연하고 변경을 쉽게 만들어 대규모 소프트웨어 개발에 사용 객체 지향 패러다임의 특징 추상화 공통의 속성이나 기능을 도출 캡슐화 데이터 구조와 데이터의 연산을 결합 상속 상위 개념의 특징이 하위 개념에 전달 다형성 유사 객체의 사용성을 그대로 유지 객체와 클래스 객체는 추상화와 캡슐화의 결과 실 세계의 사물에 대한 상태(데이터)와 연산(메소드)을 표현한 단위 멤버(데이터 필드, 메소드)는 클래스에 의해 결정 클래스를 통해 어떠한 객체를 만들어서 실제 사물을 만들 경우 initializer가 동작하면서 초기화시켜주고 기본 값으로 만들어 주는 역할을 함 클래스 정의 구문 형식 class 클래스_이름: # 초기자 정의 (__init__) # 메소드 정의 함수와 동일하게 정의 되는 메소드 메소드(method) 객체에 대한 행동(연산)을 정의 함수의 정의 및 사용 방법과 동일 초기자(initializer) 객체의 상태를 초기화하는 특수 메소드 항상 __init__ 으로 명명 메소드의 정의 구문 형식 class 클래스_이름: def 메소드_이름(self, 매개 변수_리스트): # 코드 블럭 self 매개 변수 모든 메소드의 첫번째 매개 변수 메소드의 구현에 사용되지만 메소드 호출 시 사용되지 않음 객체 자신을 참조하여 클래스 정의에 포함된 멤버에 접근 시 사용 클래스 내부의 변수에 접근할 때 데이터 필드임을 알려줌 원뿔 계산 프로그램 개선 객체 지향 개념이 적용 된 원뿔 클래스 # 원뿔 겉넓이 계산 함수 정의 def rtn_cone_surf(r, h): # 원뿔 부피 계산 함수 정의 def rtn_cone_vol(r, h): # 원기둥 부피 계산 함수 정의 def rtn_cylinder_vol(r, h): # 사각형 넓이 계산 함수 정의 def rtn_rect_area(w, h): # 원뿔 클래스 정의 class Cone: def __init__(self, radius = 20, height = 30): # 초기자 지정 # 변수 r과 h의 스코프는 __init__ 메소드 내부 # 지역 변수 r = radius h = height def get_vol(self): # 원뿔 부피 계산: 1 / 3 * pi * r^2 * h return 1 / 3 * 3.14 * self.r ** 2 * self.h def get_surf(self): # 원뿔 겉넓이 계산: pi * r^2 + pi * r * h return 3.14 * self.r ** 2 + 3.14 * self.r * self.h # 데이터 필드의 r과 h라는 것을 알려주기 위해 꼭 self.를 앞에 표시해주어야 함 # 원뿔 클래스 정의 class Cone: def __init__(self, radius = 20, height = 30): # 초기자 지정 # self.r, self.h의 스코프는 클래스 전역 # self.r, self.h는 인스턴스 변수 (클래스 내 다른 메소드에서도 접근 가능) self.r = radius self.h = height def get_vol(self): # 원뿔 부피 계산: 1 / 3 * pi * r^2 * h return 1 / 3 * 3.14 * self.r ** 2 * self.h def get_surf(self): # 원뿔 겉넓이 계산: pi * r^2 + pi * r * h return 3.14 * self.r ** 2 + 3.14 * self.r * self.h 클래스 설계 UML 클래스 다이어그램 통해 데이터 필드, 생성자, 메소드 표현 방법 표준화 데이터 필드 이름: 데이터 필드 타입 클래스 이름(매개 변수 이름: 매개 변수 타입) 메소드 이름(매개 변수 이름: 매개 변수 타입): 반환 값 타입 Unified Modeling Langauage 의 약어로, 표준화 된 모델링 언어를 의미 클래스가 어떻게 구성되어 있는 지를 알 수 있는 표기 원뿔 클래스의 표현 UML 클래스 다이어그램 Cone 데이터 필드와 타입 Cone 클래스 이름으로 된 메소드, 생성자, 객체를 생성하려고 할 때 자연스럽게 불러지는 함수 BMI 계산 프로그램 이름, 나이, 몸무게, 키를 사용하여 BMI 수치 및 상태를 반환하는 BMI 클래스를 정의 class BMI: def __init__(self, name, age, weight, height): # 초기자 지정 self.name = name # 입력 파라미터에 들어온 값들을 데이터 필드에 넣어주는 작업 self.age = age self.weight = weight self.height = height def get_BMI(self): return self.weight / (self.height) / 100 ** 2 def get_status(self): # 위에서 반환 된 BMI 값을 가지고 판정하는 부분 BMI = self.get_BMI() if BMI &gt;= 25: return \"비만\" elif BMI &gt;= 23 and BMI &lt; 25: return \"과체중\" elif BMI &gt;= 18.5 and BMI &lt; 23: return \"정상\" else: return \"저체중\" get_BMI에서 반환 된 값을 부르는 방법 내부의 메소드를 직접 호출 def get_status(self): # 위에서 반환 된 BMI 값을 가지고 판정하는 부분 if self.get_BMI() &gt;= 25: return \"비만\" elif self.get_BMI() &gt;= 23 and self.get_BMI() &lt; 25: return \"과체중\" elif self.get_BMI() &gt;= 18.5 and self.get_BMI() &lt; 23: return \"정상\" else: return \"저체중\" 변수에 메소드 반환 값을 저장해 놓고 해당 변수를 호출 def get_status(self): # 위에서 반환 된 BMI 값을 가지고 판정하는 부분 BMI = self.get_BMI() if BMI &gt;= 25: return \"비만\" elif BMI &gt;= 23 and BMI &lt; 25: return \"과체중\" elif BMI &gt;= 18.5 and BMI &lt; 23: return \"정상\" else: return \"저체중\" 클래스와 인스턴스원뿔 클래스 활용 원뿔 클래스를 사용하려면? # 원뿔 클래스 정의 class Cone : def __init__(self, radius = 20, height = 30): self.r = radius self.h = height def get_vol(self) : return 1 / 3 * 3.14 * self.r ** 2 * self.h def get_surf(self) : return 3.14 * self.r ** 2 + 3.14 * self.r * self.h 객체와 인스턴스 구문 형식 클래스_이름(초기자_파라미터) 클래스의 생성자(constructor)를 통해 클래스의 인스턴스를 생성 생성자 호출 객체와 인스턴스는 동일 개념 클래스의 생성자는 클래스의 이름과 동일 클래스의 이름과 초기자의 매개 변수를 사용하여 생성자를 호출 정의했던 설계 도면대로 실제 객체 생성 됨 실체화 된 대상이기 때문에 값 저장, 변형 등이 가능 객체의 생성 과정Cone(20, 30) 클래스에 해당하는 객체 생성 __init__() 메소드 호출하여 객체 초기화 Cone(20, 30) 호출 시 r=20, h=30 으로 설정 초기자에 있었던 반지름과 높이 값 메모리에 객체가 저장될 수 있는 저장 영역을 만들게 되고 그 다음에 초기자가 실제 처음으로 객체가 만들어졌을 때 기본적으로 실행되어야 하는 여러가지 행동들을 정의하며 세팅 객체의 사용 객체의 데이터 필드 접근 및 메소드 호출 객체 멤버 접근 연산자 (.) 사용 객체로 조작, 연산을 하고 싶다면 객체 참조 변수에 점(.)만 찍으면 됨 객체 접근 객체_참조변수.데이터_필드 객체_참조변수.메소드(파라미터) 객체 참조 변수를 사용하여 객체를 생성하고 접근 생성자를 통해 만들어진 객체에 접근할 수 있는 지칭 도구 객체_참조변수 = 클래스_이름(초기자_파라미터) # 생성자를 통해 만들어진 객체 원뿔 클래스 활용 단위 원뿔과 반지름과 높이가 각각 50, 100인 원뿔의 부피와 겉넓이를 출력하는 프로그램 unit_cone = Cone() # 객체 참조 변수 = 클래스명(초기자 파라미터), 별도로 정의해주지 않으면 위에서 정의한 기본 값이 적용 big_cone = Cone(50, 100) # 멤버에 접근하기 위해서는 연산자 .을 사용 unit_cone.get_vol() # 부피 구하는 메소드 호출 unit_cone.get_surf() # 겉넓이 구하는 메소드 호출 print(\"단위 원뿔의 겉넓이와 부피는\", unit_cone.get_surf(), unit_cone.get_vol(), \"입니다.\") print(\"큰 원뿔의 겉넓이와 부피는\", big_cone.get_surf(), big_cone.get_vol(), \"입니다.\") BMI 클래스 활용 가상의 이름, 나이, 몸무게, 키를 사용하여 BMI 객체를 사용하는 프로그램 person1 = BMI(\"홍길동\", 40, 78, 182) # 객체 참조 변수를 만들고 BMI 객체를 호출함 print(person1.name + \"님(\" + str(person1.age) + \"세)의 BMI 수치는\", person1.get_BMI(), \"결과는\", person1.get_status(), \"입니다.\") 객체 지향의 활용데이터 타입과 객체\"Korea National Open University\".lower() # 소문자로 변형 되어서 문자열 출력number = 20print(type(number)) # &lt;class 'int'&gt;print(id(number)) # id: 1403902********28symbol = \"파이썬\"print(type(symbol)) # &lt;class 'str'&gt;print(id(symbol)) # id: 1403892********08 파이썬의 기본 데이터 타입 (int, str 등)도 객체임 모든 변수는 객체 객체 지향형 프로그래밍 언어에서는 모든 것은 다 객체를 통해 이루어짐 type() 함수 객체의 타입 확인할 수 있음 id() 함수 객체의 고유 식별자(메모리 주소)를 확인할 수 있음 str 메소드 .upper(), .lower() 메소드 대/소문자로 변경 .title() 메소드 각 단어의 첫 글자를 대문자로 변경 .strip(), .rstrip(), .lstrip() 메소드 양쪽/오른쪽/왼쪽의 특정 문자를 제거 .replace() 메소드 문자열 특정 부분을 대체 .split() 구분자로 분할하여 리스트로 반환 \"I love python\".upper() # \"I LOVE PYTHON\"\"I love python\".replace(\"o\", \"i\") # \"I live pythin\"isymbol = \"I love python\".replace(\"o\", \"i\")# dir(str) # str 객체가 가진 모든 메소드와 속성 확인원뿔 클래스 개선 멤버 r 또는 h에 음수를 입력하면? # 원뿔 클래스 정의 class Cone: def __init__(self, radius = 20, height = 30) # 초기자 지정 self.r = radius self.h = height def get_vol(self): return vol = 1 / 3 * 3.14 * self.r ** 2 * self.h #데이터 필드의 r과 h라는 것을 알려주기 위해 꼭 self.를 앞에 표시해주어야 함 def get_surf(self): return suf = 3.14 * self.r ** 2 + 3.14 * self.r * self.h unitcone = Cone(50, 100) unitcone.r = -50 # 외부에서 데이터 필드에 직접 접근하여 음수 값을 할당하는 것이 가능 -&gt; 부피/겉넓이 계산에 문제 일으킴 악의적인 사용자가 Cone 클래스에 접근하지 못하도로 제약을 줄 필요가 있음 나이, 몸무게, 키는 private로 지정해 변경 방지 데이터 필드 감추기 데이터 은닉(Data Hiding) 데이터 필드의 직접 변경을 방지하기 위해 사용자의 직접적 접근을 차단 public과 다른 private 데이터 필드로 정의 private 데이터 필드 클래스 내부에서만 접근 가능 앞 두 밑줄(__)로 정의 self.__r self.__h 접근자와 변경자 private으로 정의된 데이터 필드는 객체 외부에서 직접 접근 불가능 File \"&lt;ipython-input-7-a73e9d167542&gt;\", line 13 \t\tprint(unitcone.__r = - 50) \t\t\t\t\t^ SyntaxError: expression cannot contain assignment, perhaps you meant \"==\"? print(unitcone.__r) 와 같은 접근 시 에러 발생 private 데이터 필드에 접근하기 위한 메소드 접근자(Accessor) 데이터 필드 반환 (Getter) 변경자(Mutator) 데이터 필드 설정 (Setter) 잘못 된 값으로 객체가 만들어지는 것을 막기 위한 접근자와 변경자원뿔 클래스 개선 멤버 __r과 __h에 대한 접근자와 변경자 정의 클래스에 잘못 된 접근 차단하기 접근자와 변경자 통한 private 데이터 필드 접근 만들어진 객체들이 정상 범위 내에서 동작하도록 해야함 데이터 필드 값 접근 막아야 함 class pCone: def __init__(self, radius = 20, height = 30): # 초기자 지정 if radius &gt; 0 and height &gt; 0: self.__r = radius # private 선언 -&gt; 객체 외부에서는 접근이 불가능한 반지름과 높이 값 self.__h = height def get_vol(self): vol = 1 / 3 * 3.14 * self.__r ** 2 * self.__h #데이터 필드의 r과 h라는 것을 알려주기 위해 꼭 self.를 앞에 표시해주어야 함 return vol def get_surf(self): suf = 3.14 * self.__r ** 2 + 3.14 * self.__r * self.__h return suf def get_radius(self): # 접근자 통한 데이터 필드 반환 return self.__r def set_radius(self, radius): # 변경자 통한 데이터 필드 설정 if radius &gt; 0:# 음수 값이 입력되지 않도록 if문으로 제어 self.__r = radius perfect_cone = pCone(100, 200) perfect_cone.get_vol() # 기존에 보였던 데이터 필드 r, h가 보이지 않음 perfect_cone.r = -50 print(perfect_cone.get_surf()) BMI 클래스 활용 가상의 이름, 나이, 몸무게, 키를 사용하여 BMI 객체를 사용하는 프로그램 class BMI: def __init__(self, name, age, weight, height): # 초기자 지정 self.__name = name # 입력 파라미터에 들어온 값들을 데이터 필드에 넣어주는 작업 self.__age = age self.__weight = weight self.__height = height def get_BMI(self): return self.__weight / (self.__height) / 100 ** 2 def get_status(self): # 위에서 반환 된 BMI 값을 가지고 판정하는 부분 BMI = self.get_BMI() if BMI &gt;= 25: return \"비만\" elif BMI &gt;= 23 and BMI &lt; 25: return \"과체중\" elif BMI &gt;= 18.5 and BMI &lt; 23: return \"정상\" else: return \"저체중\" 연습 문제 다음 중 객체 지향 패러다임의 특징이라고 할 수 없는 것은? a. 개방화 객체 지향 패러다임의 특징 추상화 캡슐화 상속 다음 코드의 빈 칸에 공통으로 들어가야 하는 것은? a. self 다음 코드의 실행 결과는? \"I love python\".replace(\"o\", \"i\").upper() a. \"I LIVE PYTHIN\" 학습 정리 객체와 객체 사이의 상호작용으로 프로그램을 구성하는 프로그래밍 패러다임을 객체 지향이라고 함 객체 지향 패러다임의 특징에는 추상화, 캡슐화, 상속, 다형성이 있음 클래스는 실 세계의 사물에 대한 상태(데이터)와 연산(메소드)을 표현한 단위임 클래스는 객체의 행동을 정의하는 메소드와 객체의 상태를 초기화하는 특수 메소드로 구성 됨 모든 메소드의 첫 번째 매개 변수는 self 임 클래스의 생성자(constructor)호출을 통해 클래스의 인스턴스인 객체가 생성 됨 클래스의 생성자는 클래스의 이름과 동일하며 초기자의 매개 변수를 사용함 객체의 데이터 필드 접근 및 메소드 호출에 객체 멤버 접근 연산자(.)를 사용함 객체의 데이터 필드의 직접 변경을 방지하기 위해 사용자의 직접적 접근을 차단하기 위해 데이터 은닉을 사용함 private 데이터 필드는 클래스 내부에서만 접근 가능하며 앞 두 밑줄(__)로 정의함 private 데이터 필드에 대해 접근하기 위한 접근자와 변경자 메소드가 정의되어야 함" }, { "title": "[Java 프로그래밍] 10강 - java.nio 패키지의 활용", "url": "/posts/knou-java-10/", "categories": "Language, Java", "tags": "knou, java", "date": "2025-04-28 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김희천 교수님의 'Java 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 java.nio패키지는 기존 java.io패키지를 개선한 새로운 입출력 패키지임 File클래스를 대체하는 Path인터페이스, 입출력 기능을 모두 제공하고 버퍼를 사용하게 설계된 FileChannel클래스, 파일의 읽기/쓰기나 조작을 위한 정적 메소드를 제공하는 Files클래스 등을 학습함 WatchService는 디렉터리에 생기는 변화를 감시하는 서비스임학습 목표 Path인터페이스의 사용법을 이해함 Files클래스를 사용하여 Path객체를 조작할 수 있음 버퍼와 FileChannel클래스를 이용하여 파일 입출력을 수행할 수 있음 WatchServie를 활용하여 디렉터리의 변화를 감시할 수 있음강의록java.nio패키지java.nio패키지 NIO는 New Input Output의 약자 기존 java.io패키지를 개선한 새로운 입출력 패키지 JDK 7부터는 파일 I/O를 개선한 NIO2도 등장 java.nio와 그것의 서브 패키지 형태 java.nio.file, java.nio.channels, java.nio.charset등 File 클래스보다 다양한 기능을 제공하는 Path Files의 static메소드를 통한 파일/디렉터리의 조작, 파일의 읽기/쓰기 파일 입력과 파일 출력이 모두 가능한 FileChannel 클래스 버퍼링 기능, 멀티 스레드에 안전 비 동기식 파일 입출력을 위한 AsynchronousFileChannel 클래스 non-blocking 방식 파일 입출력 Path인터페이스 java.nio.file패키지에 존재하며 java.io.File클래스를 대신함 파일 시스템에 존재하는 파일이나 디렉터리에 해당하는 경로를 표현 절대 경로 또는 상대 경로로 표현 됨 경로의 생성, 경로의 비교, 경로 정보 추출, 경로 요소 조작 기능 등을 제공 java.nio.file.Files클래스의 static메소드를 이용해 Path객체에 대한 다양한 실제 조작(생성, 읽기, 쓰기, 복사, 이동 등)이 가능함 Path객체의 생성 방법 Path p = Paths.get(\"C:\\\\tmp\\\\foo\"); 파일이나 디렉터리의 절대 또는 상대 경로를 명시해야 함 Path인터페이스의 메소드 주요 메소드 메소드 설명 int compareTo(Path other) 두 경로를 비교하여 같으면 0을 반환 Path getFileName() 디렉터리 또는 파일의 이름을 Path객체로 리턴 FileSystem getFileSystem() Path객체를 만들어 준 FileSystem객체를 리턴 Path getName(int index) 경로에서 index에 해당하는 이름을 Path객체로 리턴 int getNameCount() 경로에 포함된 원소의 개수를 리턴 Path getParent() 부모 경로를 Path객체로 리턴 Path getRoot() 루트 디렉터리를 Path객체로 리턴 Iterator&lt;Path&gt; iterator() 경로에 존재하는 모든 디렉터리 또는 파일의 이름을 Iterator 객체로 리턴 File toFile() Path객체를 File객체로 변환하여 리턴 String toString() Path객체를 문자열로 변환하여 리턴 Path인터페이스의 사용 예 Path인터페이스 사용 예제 import java.util.*; import java.nio.file.*; public class Main { public static void main(String args[]) { try { Path path = Paths.get(\"C:\\\\windows\\\\system32\\\\drivers\\\\etc\\\\hosts\"); System.out.println(\"파일 이름 : \" + path.getFileName()); System.out.println(\"상위 폴더 : \" + path.getParent().getFileName()); System.out.println(\"경로 길이 : \" + path.getNameCount()); System.out.print(\"현재 경로 : \"); for (int i = 0; i &lt; path.getNameCount(); i++) System.out.print(path.getName(i) + \"\\\\\"); Iterator&lt;Path&gt; it = path.iterator(); // Iterator를 사용하여 경로를 순회 System.out.print(\"\\n현재 경로 : \"); while (it.hasNext()) System.out.print(it.next().getFileName() + \"\\\\\"); System.out.println(); } catch (Exception e) { System.out.println(e); } } } // 파일 이름 : hosts // 상위 폴더 : etc // 경로 길이 : 5 // 현재 경로 : windows\\system32\\drivers\\etc\\hosts\\ // 현재 경로 : windows\\system32\\drivers\\etc\\hosts\\ FileSystem클래스와 FileStore클래스 FileSystem 클래스의 메소드 FileSystem은 파일 시스템에 대한 인터페이스를 제공 FileSystems.getDefault()은 기본 파일 시스템을 리턴 함 Iterable &lt;FileStore&gt; getFileStores() 하나 이상의 파일 스토어로 구성됨 WatchService newWatchService() FileStore 클래스의 메소드 FileStore는 저장소(파티션 또는 볼륨)를 표현함 String name(), String type() long getTotalSpace() long getUnallocatedSpace() long getUsableSpace() FileSystem과 FileStore클래스의 사용 예 FileSystem객체로 디스크 정보 출력하기 import java.nio.file.*; public class Main { public static void main(String args[]) throws Exception { FileSystem fs = FileSystems.getDefault(); for (FileStore store: fs.getFileStores()) { System.out.println(\"드라이브 이름 : \" + store.name()); System.out.println(\"파일시스템 : \" + store.type()); long total = store.getTotalSpace(); long free = store.getUnallocatedSpace(); System.out.println(\"전체 공간 : \" + total + \" bytes\"); System.out.println(\"사용 중인 공간 : \" + (total - free) + \" bytes\"); System.out.println(\"사용 가능한 공간 : \" + free + \" bytes\"); System.out.println(); } } } // 드라이브 이름 : C드라이브 // 파일시스템 : NTFS // 전체 공간 : 499431501824 bytes // 사용 중인 공간 : 462690144256 bytes // 사용 가능한 공간 : 36741357568 bytes Files클래스 파일 조작 기능을 제공하는 static메소드를 제공함 메소드는 Path객체를 인자로 가지고 작업함 파일의 읽기와 쓰기 메소드 byte[] readAllBytes(Path) Path write(Path, byte[]) 파일이나 디렉터리의 검사/생성/삭제/복사/이동/속성 관리 메소드 boolean isDirectory(Path) boolean isRegularFile(Path) Path createFile(Path) Path createDirectory(Path) void delete(Path) Path copy(Path, Path) Path move(Path, Path) long size(Path) UserPrincipal getOwner(Path) Files클래스의 사용 예 디렉터리 내용 확인하기 import java.nio.file.*; public class Main { public static void main(String args[]) throws Exception { Path path = Paths.get(\"C:\\\\Java\"); DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(path); for (Path p : ds) { if (Files.isDirectory(p)) { System.out.println(\"[디렉터리] \" + p.getFileName()); } else { System.out.print(\"[파일] \" + p.getFileName()); System.out.println(\" (\" + Files.size(p) + \")\"); } } } } // [디렉터리] Example // [파일] FileInputStreamTest.java (434) // [파일] FilesTest1.java (800) // [디렉터리] temp // [파일] winhlp.exe (9728) // [파일] winhlp32.exe (9728) 버퍼버퍼 데이터 생산자로부터 프로그램으로 데이터가 입력 될 때, 입력 속도와 처리 속도의 차이로 인해 지연이 발생할 수 있음 프로그램으로부터 데이터 소비자로 데이터가 출력 될 때도 마찬가지 버퍼를 사용하면 지연 현상을 방지할 수 있음 프로그램은 버퍼로부터 데이터를 읽음(입력) 프로그램은 버퍼로 데이터를 출력함(출력) 버퍼의 역할 Buffer클래스 버퍼는 기본형 값을 저장하는 데이터 보관소 채널 입출력에 사용되며 버퍼 단위로 입출력할 수 있음 Buffer는 추상 클래스로 java.nio패키지에 존재 자식 클래스에서 구현해야 할 공통의 메소드를 선언 실제 사용을 위해 boolean을 제외한 모든 기본형에 대해 Buffer의 서브 클래스가 존재함 ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer 버퍼의 생성 버퍼의 생성 방법 Buffer buffer = ByteBuffer.allocate(1024*1024); byt[] barray = new byte[100]; Buffer bbuffer = ByteBuffer.wrap(barray); 버퍼의 속성 0 ≤ mark≤ position≤ limit≤ capacity capacity 버퍼의 크기(데이터의 개수)로, 생성 될 때 정해짐 position 읽기나 쓰기가 적용되는 위치 position≤ limit limit 읽거나 쓸 수 없는 최초 위치 limit≤ capacity mark reset()되었을 때 position이 가리킬 위치 Buffer클래스의 메소드 주요 메소드 메소드 설명 Buffer mark() mark를 position의 값으로 설정 Buffer reset() position을 mark의 값으로 설정 Buffer rewind() position을 0으로 바꾸고 mark를 삭제함, 처음부터 다시 읽기를 준비하는 것 Buffer flip() limit를 position값으로 설정하고 position은 0으로 변경함, 버퍼에 쓰기를 끝내고 버퍼 읽기를 준비하는 것 Buffer clear() 버퍼를 초기 상태로 돌림, 새로운 쓰기를 준비하는 것 int capacity() 현재 capacity값을 리턴 int position() 현재 position값을 리턴 int limit() 현재 limit값을 리턴 버퍼 읽기와 쓰기 Buffer의 서브 클래스에서 제공 ByteBuffer CharBuffer DoubleBuffer 상대적 읽기/쓰기 메소드 현재 position의 위치에서 읽기 또는 쓰기를 수행하며, 읽거나 쓴 요소 만큼 position값이 증가함 byte get() ByteBuffer get(byte[]) ByteBuffer put(byte) ByteBuffer put(byte[]) 절대적 읽기/쓰기 메소드 읽거나 쓸 위치를 매개 변수 index로 지정 position값에 영향을 주지 않음 byte get(int index) ByteBuffer put(int index, byte b) FileChannel클래스FileChannel클래스 java.io패키지의 파일 관련 입출력 스트림을 대체 java.nio.channels패키지에 존재 파일에 대한 읽기와 쓰기를 모두 제공 멀티 스레드 환경에서도 안전하게 사용할 수 있음 읽기와 쓰기 메소드 int read(ByteBuffer dst) int write(ByteBuffer src) 객체 생성 방법 FileChannel.open(Path path, OpenOption ... options) 옵션은 StandardOpenOption.READ 그 외 CREATE, WRITE, APPEND등 FileInputStream, FileOutputStream또는 RandomAccessFile객체에서 getChannel() FileChannel클래스로 파일 만들기public class Main { public static void main(String args[]) throws IOException { String[] data = { \"안녕하세요, 여러분\", \"Java 프로그래밍 언어의 세계로 오신 것을 환영합니다.\", \"JDK를 설치하는 방법에서부터 \", \"Java 프로그램을 compile하고 실행시키는 \", \"모든 방법에 대해 공부해봅시다.\" }; Path path = Paths.get(\"c:\\\\Java\\\\temp\\\\file.txt\"); Files.createDirectories(path.getParent()); FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.WRITE); Charset charset = Charset.defaultCharset(); ByteBuffer buffer; int byteCount = 0; for (int i = 0; i &lt; data.length; i++) { buffer = charset.encode(data[i]); byteCount = fileChannel.write(buffer); } System.out.println(byteCount); fileChannel.close(); }}FileChannel클래스로 파일 읽기public class Main { public static void main(String args[]) throws IOException { Path path = Paths.get(\"c:\\\\java\\\\temp\\\\file.txt\"); FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.READ); ByteBuffer buffer = ByteBuffer.allocate(1024 * 1024); Charset charset = Charset.defaultCharset(); StringBuffer sb = new StringBuffer(); int byteCount; while ((byteCount = fileChannel.read(buffer)) &gt;= 0) { buffer.flip(); sb.append(charset.decode(buffer)); buffer.clear(); } System.out.println(sb); fileChannel.close(); }}// 안녕하세요, 여러분Java 프로그래밍 언어의 세계로 오신 것을 환영합니다. JDK를 설치하는 방법에서부터 Java 프로그램을 compile하고 실행시키는 모든 방법에 대해 공부해 봅시다.WatchService인터페이스WatchService인터페이스 WatchService 어떤 대상을 정한 후 변화나 이벤트가 생기는 것을 감시(watch) 감시 대상은 Watchable객체로, register()메소드를 사용하여 WatchService객체에 감시 대상으로 등록 됨 디렉터리를 표현하는 Path객체의 변화를 감지 디렉터리 내의 파일 또는 서브 디렉터리의 생성, 삭제, 수정 java.nio.file패키지에 존재 감시자의 생성 먼저 WatchService객체를 생성함 WatchService ws = FileSystem.getDefault().newWatchService(); 감시 절차 감시 서비스를 구현하는 절차 감시 대상 디렉터리를 WatchServcie에 등록 Path path = Paths.get(\"c\\\\java\\\\temp\"); 등록 시 알림을 받고자 하는 이벤트를 명시 path.register(ws, StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY); WatchService는 take()메소드를 호출하여 감시함 무한 루프 안에서, 이벤트가 발생할 때 까지 기다림 While(true) { WatchKey key = ws.takae(); } 이벤트가 발생하면, take()가 리턴하는 WatchKey객체를 이용하여 이벤트를 처리 WatchKey는 감시 상태, 감시 대상 디렉터리, 이벤트 정보를 가짐 pollEvents()를 호출하여 WatchEvent객체를 얻고 어떤 변화가 생겼는지 알 수 있음 for (WatchEvent&lt;?&gt; event : key.pollEvents()) { WatchEvent.Kind k = event.kind(); // 이벤트 종류 Path p = (Path) event.context(); // 파일 이름 \t\t\t } boolean valid = key.reset(); // 계속 감시하기 위해 if (!valid) break; WatchService 예제 WatchServcie인터페이스 이용하기 try { WatchService ws; ws = FileSystems.getDefault().newWatchService(); Path path = Paths.get(\"c:\\\\java\\\\temp\"); path.register(ws, StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY); while (true) { WatchKey key = ws.take(); for (WatchEvent&lt;?&gt; event : key.pollEvents()) { WatchEvent.Kind k = event.kind(); Path p = (Path) event.context(); if (k == StandardWatchEventKinds.ENTRY_CREATE) { System.out.println(\"File \" + p.getFileName() + \" is created.\"); } else if (k == StandardWatchEventKinds.ENTRY_DELETE) { System.out.println(\"File \" + p.getFileName() + \" is deleted.\"); } boolean valid = key.reset(); if (!valid) break; } } } // File file.txt is modified. // File 새 텍스트 문서.txt is created. // File 새 텍스트 문서.txt is deleted. // File 새 문서.txt is created. 학습 정리 java.nio와 그것의 서브 패키지는 java.io패키지를 개선한 새로운 입출력 패키지임 java.nio.file패키지의 Path인터페이스는 java.io패키지의 File클래스보다 풍부한 기능을 제공함 Files클래스는 실제 파일(또는 디렉터리) 조작과 읽기 · 쓰기 기능을 수행하는 static메소드를 제공함 채널 입출력에서 버퍼는 기본형 데이터의 보관소이며, 버퍼 단위로 입출력할 수 있음 java.nio.file의 FileChannel은 입출력을 모두 제공하고 기본적으로 버퍼링을 사용하며 멀티 스레드 환경에서도 안전하도록 설계되어 있음 java.nio.file패키지의 WatchService는 디렉터리에 발생하는 이벤트를 감시하는 서비스임연습 문제 Path인터페이스에 관한 설명이다. 잘못된 것은? a. 파일 내용의 읽기와 쓰기 기능을 제공한다. Path인터페이스에 관한 설명으로 옳은 것 java.io.File클래스를 대체할 수 있음 파일 시스템에 존재하는 파일이나 디렉터리의 경로를 표현함 경로의 생성, 경로의 조작/비교, 경로의 요소를 조회하는 기능을 제공함 FileChannel클래스에 관한 설명으로 틀린 것은 무엇인가 a. 파일 입력을 위해 FileChannelReader, 파일 출력을 위해 FileChannelWriter를 사용한다. FileChannel클래스에 관한 설명으로 옳은 것 java.io패키지의 파일 관련 스트림 클래스를 대체하기 위한 클래스임 FileChannel.open(path)으로 객체 생성을 하면 해당 파일을 읽기 용으로 열게 됨 멀티 스레드 환경에서도 안전하게 사용할 수 있게 설계되었음 WatchService를 이용해 디렉터리를 감시할 때, take()메소드를 호출한다. 이때 디렉터리에 이벤트가 발생하면 take()가 WatchKey객체를 리턴한다. WatchKey에 관해 설명하라. a. WatchKey는 등록된 디렉터리에 어떤 관심 이벤트가 등록되어 있으며, 실제 어떤 이벤트가 일어났는 지에 관한 상태 정보를 가지고 있다. " }, { "title": "[유비쿼터스 컴퓨팅 개론] 9강 - 유비쿼터스 센서 네트워크", "url": "/posts/knou-uqc-9/", "categories": "Computer Science, CS Theory", "tags": "knou, ubiquitous computing", "date": "2025-04-27 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정광식 교수님의 '유비쿼터스 컴퓨팅 개론' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 여러 센서들이 수집한 데이터를 실시간으로 전송하기 위해 네트워크 형태로 발전시킨 것이 유비쿼터스 센서 네트워크(Ubiquitous Sensor Network; USN)을 공부함 유비쿼터스 센서 네트워크에는 주변 환경 데이터를 수집하고 처리하는 센서, 이 데이터를 전달하기 위한 유・무선 네트워크, 이 데이터를 받아서 저장・가공・통합하는 서버들로 구성된 유비쿼터스 센서 네트워크에 대해서 이해함 USN을 구성하는 주요 구성 요소들의 기능 및 관련 기술을 공부함학습 목표 주변 상황에 대한 데이터를 수집하고 처리한 후 전달하는 기능을 갖춘 센서의 개념 및 특징을 이해할 수 있음 유비쿼터스 센서 네트워크의 구조 및 유비쿼터스 센서 네트워크의 미들웨어 기능을 이해하고 향후 기술 발전 방향을 논의함강의록센서의 기능 및 특징센서의 개념 센서(Sensor) 또는 센서 노드(Sensor Node) 유비쿼터스 센서 네트워크에서 외부의 변화를 감지하고 필요한 데이터를 수집 일반적으로 측정 대상물을 감지 또는 측정하여 그 측정 량을 전기 신호로 변환하는 장치임 물리 량과 화학 량의 절대치나 변화, 소리, 빛, 전파의 강도를 감지하여 유용한 신호로 변환하는 기능을 가진 장치센서의 종류 센서는 감지한 측정량을 전기적 신호로 변환하는 원리에 따라 분류 물리 센서 : 압력, 가속도 각속도, 자기장 등 광센서 : CMOS 이미지, 후면 조사형 CMOS 이미지, 적외선, 조도 등 화학 센서 : 이산화 탄소, 오존과 암모니아, 수소 이온 농도 지수 등 바이오 센서 : DNA 칩, 촉각, 암 진단 용, 지문, 심박 등 센서의 발전 센서 기술은 센서의 형태 및 적용 대상의 요구 사항에 따라 발전되어 왔으며, 최근에는 마이크로 제어 장치의 제어, 판단, 저장, 통신 인공 지능까지 구현되는 스마트 센서로 발전하였음 센서는 스마트 공장 뿐만 아니라 사무실, 가정에 이르기까지 폭 넓게 사용되고 있으며 종류도 다양함 센서가 고정밀, 고정확도 등 신뢰성을 생명으로 하는 고부가 가치형 첨단 기술 산업에서 중요한 역할을 할 수 있음을 의미함센싱 기술 대부분의 개인용 기기에서 이미 어떠한 형태로든 센서가 여럿이 정밀하게 조합되어 사용되고 있음 산업 분야에서도 스마트 공장 및 사무 자동화가 진전 됨에 따라, 그 핵심 기술의 하나로서 센서의 역할이 점차 중요해지고 있음 센서는 환경 보전, 재해 방지, 교통, 농업, 산업 현장, 서비스업, 자율 주행 자동차, 의료 분야 등 거의 모든 산업에 널리 활용되고 있음센서의 구비 조건 센싱 기능의 고도화 물리 센서의 경우 온도, 압력, 속도, 가속도 등에 대한 측정 정밀도는 현저히 높아지고 있으나 u-네트워크용 센서의 경우 기능을 고도화해야 함 화학 센서인 가스, 이온, 습도, 바이오 센서의 경우 이들을 유비쿼터스 네트워크에 응용하기 위해서 안정도와 감도를 높이는 기능의 고도화, 첨단 신소재 개발, 소자 구조의 최적화 등의 연구가 이루어지고 있음 초소형화 유비쿼터스 네트워크에 이용될 센서는 여러 기능을 갖추어야 함 아울러 SoC 개념의 소형화 칩으로 개발되어야 함 MEMS 기술의 발달로 소자의 소형화 기술 전망은 밝은 편임 센서의 소형화는 물리 센서 분야에서 빠르게 실현되고 있으며 화학 센서의 경우에도 실온 또는 저온 동작용 첨단 감지 재료가 개발됨으로써 마이크로화가 급진전 되고 있음 SoC의 구현으로 기능 대비 가격도 크게 낮아지고 있음 저전력화 센서 노드가 설치되는 장소는 물리적인 접근이 불편하거나 쉽지 않은 곳도 많음 이러한 곳의 센서들은 소형 배터리로 동작해야 함 배터리를 사람이 매번 교체하거나 충전하는 것이 쉽지 않으므로, 최대한 전력 소모를 적게 설계하여 센서 노드의 수명을 최대화 하는 연구가 지속적으로 이루어지고 있음 칩형화 이식이 쉬운 센서 칩을 개발하기 위해 생체 또는 사물에 쉽게 부착할 수 있는 몰딩 재료의 개발과 아울러 칩 구조의 최적화가 이루어지고 있음 손목 시계나 스마트폰, 의복이나 안경 등에 부착하는 형태가 가능하며, 이 역시 물리 센서 분야에 쉽게 적용될 수 있음 유비쿼터스 센서 네트워크의 구조유비쿼터스 센서 네트워크의 개념 유비쿼터스 센서 네트워크(USN)는 여러 개의 센서 네트워크 영역이 게이트 웨이를 통해 외부 네트워크에 연결되는 구조임 센서 노드는 수집 된 데이터를 가까운 싱크 노드를 거쳐 게이트 웨이로 전송함 게이트웨이는 관리자에게 전달할 데이터를 위성 통신, 유무선 인터넷 등을 통해 전송하는데, 이러한 접속망은 기존의 통신 인프라를 이용함 유비쿼터스 센서 네트워크의 구조 유비쿼터스 센서 네트워크(USN) 개념도 접속망은 IPv6 광 대역 통합 망(BcN)인 인터넷 통합 망을 가정하며, 이는 모든 센서 노드에 IPv6가 적용될 수 있음을 의미함 센서 네트워크의 응용을 위한 미들웨어로서 서비스 플랫폼이 제공되어 사용자는 이를 통해 지능형 센서 네트워크를 자유롭게 이용하게 됨센서 네트워크 센서 네트워크는 네트워크를 구성하는 일정 지역에 아주 작은 크기의 센서가 수백 개에서 수천 개까지 설치되어 통신하는 구조로 되어 있음 노드들이 주고 받는 데이터는 크기도 작고 데이터의 발생 빈도 또한 낮아 통신하는 양은 많지 않을 것으로 가정함 하지만, 최근에는 보다 다양한 분야에서 활용되면서 이러한 가정이 성립되지 않기도 함제약 조건 - 배터리 센서 노드의 가장 큰 문제는 배터리의 크기임 현재 기술력으로 센서 노드에 적용할 수 있는 크기의 배터리가 많지 않음 센서를 활용한 연구는 우선적으로 에너지 효율성을 고려하여 진행함 두 노드 간의 통신이 가장 많은 에너지를 소모하는 기능 중 하나이므로, 가능하면 적은 양의 데이터와 신호를 주고 받는 것이 중요한 고려 사항임 제약 조건 - 메모리 크기 노드의 크기가 작으면 메모리 크기도 제약 받을 수 있음 메모리 기술은 상당히 발전하였지만, 센서에 부착된 메모리 용량이 너무 작기 때문에 많은 데이터를 저장할 수 없음 네트워크나 라우팅 정보 중 필수적인 것만 저장하여 이용하도록 간단한 프로토콜이 요구 됨제약 조건 - 통신 노드 간의 통신 거리와 방법에 한계가 잇음 센서 노드는 서로 가까이 위치한 노드끼리 통신한다고 가정하므로, 원격지에 있는 사용자와 관리자는 센서 노드와 직접 통신할 수 없게 됨 센서 네트워크는 항상 네트워크 필드 안에 다른 노드들과 통신할 수 있는 다른 형태의 노드가 필요함 싱크 노드 싱크 노드는 크기도 크고 처리 능력도 우수하며, 배터리의 제약 조건도 없다고 가정함 센서 네트워크 내에서 발생 된 데이터는 모두 싱크 노드로 집적 되어 외부 네트워크에 전송 됨 싱크 노드의 특성에 따라 위성 통신, 무선 LAN, 블루투스, 유선 인터넷 등의 방식을 가질 수 있음센서 네트워크의 구성 요소 센서 네트워크는 기본적으로 센서 노드(Sensor Node)와 싱크 노드(Sink Node)로 구성 됨 센서 네트워크 기본 구성도 센서 네트워크의 기본적인 구성 센서 노드 저가의 초소형 저전력 장치로 센싱을 위한 장치 ADC(Analog to Digital Converter) 센싱 된 아날로그 정보를 디지털 신호로 변환 배터리 데이터 처리를 위한 프로세서와 메모리 전원 공급 무선 송수신기 데이터 송수신 센서 노드는 정해진 위치에 설치 될 수도 있음 자동차, 비행기 등을 통해 무작위로 뿌려 임의의 위치에 배치될 수도 있음 기본적으로는 한번 설치 된 위치에 고정됨 자동차나 사람처럼 이동 가능한 사물에 설치되어 이동하는 상태로 동작할 수도 있음 싱크 노드 센서 네트워크 내의 각각의 센서 노드에서 센싱 된 데이터는 싱크 노드에 수집 되어 인터넷 등의 외부 네트워크를 통하여 사용자에게 제공 됨 센서 네트워크 내의 센서 노드를 관리하고 제어 함 센서 노드들이 센싱한 데이터를 수집하는 등 외부 네트워크로의 게이트 웨이 역할을 수행 함 센서 네트워크의 요소 기술 센서 네트워크의 대표적인 요소 기술로는 프로토콜 아키텍처와 애드 혹 네트워킹 기술이 있음 센서 네트워크 프로토콜 아키텍쳐 전력 관리 측면, 이동성 관리 측면, 업무 관리 측면으로 이루어짐 각 측면은 물리 계층, 데이터 링크 계층, 네트워크 계층, 응용 계층의 4계층으로 구성 됨 센서 네트워크 프로토콜 스택 센서 네트워크는 중앙 집중 식 기지 국이나 접근 점의 도움 없이 이동 센서 간의 통신을 수행하는 애드 혹 네트워크 특성도 가짐 각 센서 노드의 전력 관리, 이동성 관리, 각각의 작업 분배 관리 측면이 있음 센서의 센싱 작업 시 전력 소모를 줄이는 데 도움을 줌 전력 관리 측면 센서 노드에서의 전력을 어떻게 사용할 지를 관리함 이웃하는 다른 노드에서 데이터 메시지를 수신한 후에는 자신의 전원을 절전 상태로 변환하는 방식임 중복 된 메시지 수신을 피하기 위함 센서의 수신 전력 레벨이 낮을 때는 이웃하는 노드에 정보를 보내어 라우팅에 참여하지 않을 수 있음 남은 전력은 센싱 작업 등을 위하여 비축해 둠 이동성 관리 측면 센서 노드의 움직임을 감지하고 등록하여 사용자가 꾸준히 사용할 수 있도록 라우팅하는 것을 말함 센서 노드는 이웃하는 센서 노드가 어떤 노드인지를 추적함으로써 전력의 효율적 사용과 작업과의 조화를 유지함 업무 관리 측면 특정 지역에 주어진 센싱 작업에 공평한 분배와 스케줄링 작업을 수행함 일반적으로 어느 한 지역에서 모든 센서 노드가 동시에 센싱 작업을 수행하도록 요구되지는 않기 때문에 어떤 센서는 전력 잔량에 따라 더 많은 작업을 수행하기도 함 작업 관리의 기준은 전력의 효율적 사용과 이동형 센서 네트워크의 데이터 라우터, 센서 노드 간의 자원 공유임 유비쿼터스 센서 네트워크의 미들웨어개요 센서 노드로부터 수집 되는 센싱 정보를 효율적으로 관리함 USN 응용 서비스로부터 주어지는 질의에 신속하게 응답함 USN 미들웨어는 센싱 정보를 관리할 때, 다수의 센서 노드로부터 지속적으로 발생하는 대용량 센싱 정보를 효율적으로 관리하는 방법, 연속적인 센싱 정보 요청을 센서 네트워크 및 센서 노드의 컴퓨팅, 통신, 저장 능력 등을 고려하여 처리하는 방법도 제공해야 함 응용 서비스 클라이언트의 질의에 실시간으로 응답할 수 있어야 함 유비쿼터스 환경에서 발생 가능한 단발성, 연속, 이벤트 질의와 같이 다양한 형태의 질의도 처리할 수 있어야 함 센서 네트워크 구성에 대한 추상화 기능을 지원함으로써 이 기종의 센서들이 네트워크 구성에 참여함 서로 다른 기종의 센서 노드와 센서 네트워크, 그리고 다양한 유형의 USN 응용 서비스들이 독립성을 유지하면서도 상호 유연하게 통합될 수 있게 함유비쿼터스 센서 네트워크 미들웨어의 개념 USN 미들웨어는 물리적으로 USN 응용 서비스 시스템과 센서 네트워크 중간에 위치하여 그 둘 간의 통합이 유연하게 이루어지도록 하는 역할을 수행함 유비쿼터스 센서 네트워크의 구조 USN 미들웨어는 응용 서비스 지원을 위하여 서버 시스템에 설치하지만, 노드들의 원활한 동작과 성능 향상을 위하여 싱크 노드에 설치하기도 함 USN 미들웨어가 설치되는 위치에 따라서 서버 시스템에 설치되는 경우는 서버 측 미들웨어, 그리고 싱크 노드에 설치되는 경우는 네트워크 내부 미들웨어로 구분함 서버 측 미들 웨어 기본 기능 다수의 USN 응용 서비스 관리 응용 서비스의 다중 질의 처리 센싱 정보/메타 정보의 효율적 관리 고급 기능 센싱 정보와 기존의 비즈니스 정보를 통합하여 새로운 상황 정보의 생성 응용 서비스가 요구하는 지능형 이벤트 처리를 수행하는 컴포넌트의 역할 네트워크 내부 미들웨어 대부분 센서 노드와 싱크 노드 수준에서의 질의 처리, 센서 노드 간 위상 정보 관리, 센서 노드의 상태 정보 관리, 그리고 센서와 구동기를 제어할 수 있는 작은 모듈로 구성될 수 있음 유비쿼터스 센서 네트워크(USN) 미들웨어 개념 모델 유비쿼터스 센서 네트워크 미들웨어의 발전 동향 국방 및 환경 분야를 위한 USN 응용 서비스 시스템 구축과 더불어 개발되기 시작한 초기의 USN 미들웨어는 기능이 각 응용 분야의 서비스에만 적용될 수 있는 수준으로 단순하였으며 중요성 또한 크지 않았음 최근 들어 USN 응용 서비스에서 센서 노드의 수가 급격히 증가하였고, 응용 서비스에도 QoS를 보장해야 하며, 다중 센서 네트워크 간의 연계와 같은 고수준 기능을 필요로 하게 되었음 복잡도가 높은 USN 응용 서비스 모델들이 새롭게 제시되고, USN 응용 서비스 시스템 간의 통합이 일반화 됨에 따라 USN 미들웨어에 대한 요구 조건도 다양화되고 중요성도 증가하였음 스마트 시티 구축 사업과 같이 행정, 의료, 교통, 환경, 재난 방재 등의 다양한 USN 응용 서비스 분야가 통합 된 경우에는 USN 미들웨어에 대한 요구가 더욱 커지게 됨USN 미들웨어의 주요 기능 - 다양한 질의 유형 지원 USN 응용 서비스의 다양한 요구 사항을 효율적으로 만족 시키기 위해서 USN 미들웨어는 다양한 형태의 질의를 지원할 수 있어야 함 예를 들면, 현재 센싱 된 정보를 실시간으로 요청하는 단발성 질의, 센싱 정보를 일정한 주기로 연속적으로 요청하기 위한 연속 질의, 특별한 상황 또는 이벤트가 발생했을 때에만 센싱 정보를 요청하는 이벤트 질의가 기본적으로 지원되어야 함 이동 센서 노드를 지원하는 USN 미들웨어의 경우에는 시간 변화에 따른 위치 정보의 획득이 가능한 시공간 질의도 지원할 수 있어야 함 USN미들 웨어가 지원해야 할 질의 유형 및 SQL 표현 USN 미들웨어의 주요 기능 - 센싱 정보 관리 USN 미들웨어는 응용 서비스가 요청한 질의에 응답하기 위하여 센서 노드로부터 계속하여 센싱 정보들을 획득함 획득 된 센싱 정보를 관리하는 가장 간단한 방법은 센서 노드로부터 주어진 정보들을 저장하지 않고, 이를 필요로 하는 USN 응용 시스템에 전달하는 것임 상황에 따라서 USN 미들웨어는 과거 센싱 정보에 대한 요청을 처리하기 위하여, 또는 센싱 정보에 대한 데이터 마이닝 등을 수행해야 할 필요가 있음 모든 수집한 데이터들을 시간 흐름에 따라 효율적으로 저장 및 관리할 수 있는 기능을 제공해야 함 이를 위하여 USN 미들웨어는 센싱 정보를 효율적으로 저장하기 위하여 저장(Local Storage), 외부 저장(External Storage), 클러스터 저장(Clustered Storage) 방식을 이용함 USN 미들웨어의 주요 기능 - 메타 정보 관리 USN 미들웨어는 센서 네트워크 및 센서 노드에 관한 메타 정보를 효율적으로 유지하고, USN 응용 서비스 시스템에 제공할 수 있어야 함 USN 응용 서비스 시스템은 이러한 메타 정보를 이용함으로써 다수의 센서가 복잡하게 연결된 USN 미들웨어로부터 자신이 원하는 정보만을 손쉽게 추출하여 획득할 수 있음 메타 정보 종류 정적 메타 정보 시간 흐름에 따라 변화가 없음 동적 메타 정보 시간 흐름에 따라 변화가 발생함 USN 미들웨어의 주요 기능 - 서로 다른 기종의 센서 네트워크 통합 지원 스마트 시티 구축 사업과 같은 USN 응용 시스템에서는 많은 센서 네트워크를 통합하여 시스템을 구성함 만약 USN 미들웨어에 연결 된 모든 센서 네트워크 인프라가 동일한 종류의 센서 노드와 동일한 무선 통신 방법을 이용하고, 동일한 기능을 제공하는 경우에는 USN 미들웨어와 센서 네트워크와의 통합에 큰 어려움이 없음 ZigBee, 블루투스, 무선 LAN, CDMA 등과 같이 다양한 종류의 무선 통신 방법이 이용되고, 모트(Mote) 계열, 나노(Nano) 계열, 뉴러폰(NeurFon) 계열 등 다양한 종류의 센서 노드가 이용되는 현실에서 USN 미들웨어는 이들을 추상화 시킴으로써 센서 노드 및 무선 통신 방법에 독립적으로 USN 응용 서비스의 모든 요구를 처리할 수 있는 기능을 반드시 지원해야 함USN 미들웨어의 주요 기능 - 상황 정보 생성 및 관리 최근에 소개되는 USN 응용 서비스 모델은 센싱 정보를 획득하고 검증하여 단순히 사용자에게 제공하는 수준이 아니라, 수집 된 센싱 정보를 이용하여 과거에 저장된 정보와 비교 · 분석하고, 예측하고, 추론하여 새로운 상황 정보를 생성할 수 있는 기능을 필요로 함 USN 미들웨어는 상황 정보 생성을 위하여 과거 수집 된 정보 데이터베이스와 외부 비즈니스 데이터베이스 등을 연계하기 위한 기능과 상황 정보 생성을 위한 규칙을 정의하고, 이러한 규칙을 처리하는 방법 등을 지원해야 함 상황 정보 생성 기능은 센서 노드 성능의 효율성과 다양한 USN 응용 서비스 모델을 지원하기 위하여 서버 측 미들웨어에서 뿐만 아니라, 네트워크 내부 미들웨어에서도 지원하도록 구현하는 것이 바람직함USN 미들웨어의 주요 기능 - QoS 보장 스마트 병원, 스마트 의료, 스마트 교통 시스템 서비스처럼 안전과 관계 되는 USN 응용 서비스 들은 수집 되는 센싱 정보에 대하여 높은 신뢰도를 요구함 신뢰도 수집 된 센싱 정보의 정확성 수집 된 센싱 정보의 실시간성 사람의 안전과 관계 되는 USN 응용 서비스는 수집 된 센싱 정보의 오차가 작아야하고, 센싱 정보가 요구하는 시간 내에 수집되어야 한다는 의미임 USN 미들웨어는 응용 서비스의 우선 순위가 높은 질의를 효율적으로 수행하기 위하여 서버 측 미들웨어에서의 우선 순위 질의 큐를 이용하는 방법과 네트워크 내부 미들웨어에서의 무선 통신 및 센서 노드의 자원을 우선적으로 할당 받는 방법 등을 제공해야 함 USN 미들웨어의 주요 기능 - 센싱 정보의 보안 센서 네트워크는 기본적으로 센서 노드 간의 무선 통신으로 구성되어 있기 때문에 센싱 정보가 타인에 의하여 도청 당하거나, 비정상적인 값으로 조작 될 가능성이 큼 USN 미들웨어는 미들웨어에서 센서 노드 및 게이트웨이 간의 협력을 통하여 센싱 정보를 보호하는 방법을 반드시 제공해야 함 센싱 정보 보안에서 주의할 점은 정보 보호 기능을 구현할 때, 효율성을 위하여 센서 노드 자원의 점유를 최소화해야 한다는 것임USN 미들웨어의 주요 기능 - 센서 노드의 위치 인식 이동 센서 노드를 이용할 때는 센싱 정보 이외에 실시간으로 센서 노드의 위치를 파악하는 기능이 중요함 실제로 사람 또는 이동체에 센서 노드를 부착하여 실시간으로 센서 노드의 위치를 기반으로 센싱 정보를 획득할 수 있는 기능은 다양한 USN 응용 서비스 모델을 생성할 수 있게 해줌 스마트 병원에서 환자, 의료 장비, 의사, 간호사들에 대한 실시간 위치 추적과 이러한 위치 정보를 기반으로 환자들의 상태 정보를 수집하여 서비스 할 수 있음 USN 미들웨어는 센서 노드 간의 무선 통신을 이용하여 센서 노드들의 상대적인 위치를 파악하고, 기준 위치가 되는 고정 싱크 노드들을 이용하여 실제 위치를 파악할 수 있는 기능을 제공해야 함정리 하기 유비쿼터스 센서 네트워크는 여러 센서가 수집한 데이터를 전송하기 위한 네트워크임 유비쿼터스 센서 네트워크는 일반 센서와 싱크 노드로 구성 됨연습 문제 일반적으로 측정 대상물을 감지 또는 측정하거나 전파의 강도를 감지/측정하여 유용한 신호로 변환하고, 그 측정량을 전기신호로 변환하는 장치는 무엇인가? a. 센서 센서 네트워크의 센서 네트워크 프로토콜 아키텍처의 기능 측면에 해당되지 않는 것은 무엇인가? a. 자원 분배 측면 센서 네트워크 프로토콜 아키텍쳐 기능 측면에 해당 되는 것 전력 관리 측면 이동성 관리 측면 업무 관리 측면 USN 미들웨어의 기능이 아닌 것은 무엇인가? a. 센서들의 센싱을 모아서 외부 네트워크로 전송 USN 미들웨어의 기능 다양한 질의 유형 지원 센싱 정보 관리 서로 다른 기종의 센서 네트워크 통합 지원 정리 하기 유비쿼터스 네트워크는 여러 센서들이 수집한 데이터를 실시간으로 전송하기 위한 목적의 네트워크임 센서는 일반적으로 측정 대상물을 감지 또는 측정하거나 전파의 강도를 감지/측정하여 유용한 신호로 변환하고, 그 측정 량을 전 기신호로 변환하는 장치임 물리량이나 화학량의 절대치와 변화, 혹은 소리, 빛 등을 감지함 유비쿼터스 센서 네트워크는 여러 개의 센서 네트워크 영역이 게이트웨이를 통해 외부 네트워크에 연결되는 구조이며, 센서 노드는 집적 된 데이터를 가까운 싱크 노드를 거쳐 게이트웨이로전송함 센서 네트워크는 기본적으로 센서 노드(Sensor node)와 싱크 노드(Sink node)로 구성 됨 싱크 노드는 센서 네트워크 내의 센서 노드들을 관리하고 제어하며, 센서 노드들이 수집한 데이터를 모아서 외부 네트워크로 전송하는 게이트웨이 역할을 수행 함 USN 미들웨어는 물리적으로 USN 응용 서비스 시스템과 센서 네트워크의 중간에 위치하며, USN 응용 서비스 시스템과 센서 네트워크의 통합이 유연하게 이루어지도록 하는 역할을 수행 함 대부분의 USN 미들웨어는 응용 서비스 지원을 위하여 서버 시스템에 설치되거나 노드들의 원활한 동작과 성능 향상을 위하여 센서 노드와 싱크 노드에도 설치 됨 USN 미들웨어는 다양한 질의 유형 지원, 센싱 정보 관리, 메타 정보 관리, 서로 다른 기종의 센서 네트워크 통합 지원, 상황 정보 생성 및 관리, QoS 보장, 센싱 정보의 보안센서 노드의 위치 인식 등의 기능을 수행 함" }, { "title": "[운영 체제] 9강 - 가상 메모리", "url": "/posts/knou-os-9/", "categories": "OS, Operating System", "tags": "knou, os", "date": "2025-04-27 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김진욱 교수님의 '운영 체제' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 가상 메모리는 실제 메모리(주 기억 장치)의 용량보다 더 많은 양의 기억 공간이 필요한 프로그램을 실행할 수 있게 하는 중요한 개념임 이러한 동작이 가능하기 위해서는 가상의 커다란 프로세스 기억 공간을 정해진 방법으로 분할하고, 그 중 현재 필요한 부분만 메모리에 적재되도록 해야 함 이를 위해 프로세스에 의해 참조되는 주소를 실제 메모리에서 사용하는 주소와 분리하고 필요한 영역을 적절한 시점에 메모리에 적재함 이러한 처리를 위한 가상 메모리 관리 기법을 알아보고, 가상 주소와 실 주소 사이의 변환 방법을 학습하고 메모리 호출 기법을 알아봄학습 목표 가상 메모리의 개념과 주소 변환에 대해 설명할 수 있음 페이징 기법과 세그먼테이션 기법에서의 주소 변환 과정을 설명할 수 있음 요구 페이지 호출 기법과 예상 페이지 호출 기법을 설명할 수 있음강의록가상 메모리의 개념연속 메모리 할당 메모리 크기보다 더 큰 기억 공간이 필요한 프로세스는 실행 불가 가상 메모리 메모리 크기보다 더 큰 기억 공간이 필요한 프로세스도 실행할 수 있게 하는 방법 실행 중인 프로세스에 의해 참조되는 주소를 메모리에서 사용하는 주소와 분리 현재 필요한 일부만 메모리에 적재 현재 실행하고 관련 있는 일부분만 실제 메모리에 올려 실행 가능 가상 주소 a를 실 주소 b로 사상해야 함 시스템 형태 보조 기억 장치에 어떤 특정한 곳에 해당하는 프로세스의 전체 가상 주소 공간 저장되어있음 필요할 때마다 일부분만 가져와 실제 메모리 상에 올림 CPU가 메모리에서 해당 부분 동작 시킴 사상(mapping) 프로세스 실행을 위해 가상 주소를 실 주소로 변환하는 과정 동적 주소 변환(DAT) 프로세스가 실행되는 동안 사상 인위적 연속성 가상 주소 공간에서 연속적인 주소가 실 주소 공간에서도 연속적일 필요는 없음 실 주소에서는 위치가 연속적이지 않지만 가상 주소에서는 연속적일 수 있음 → 동적 주소 변환으로 인해 바로 찾을 수 있음 블록 단위 주소 변환주소 변환 주소 변환 사상 표 동적 주소 변환을 위한 정보를 가진 표 주소 변환이 바이트나 워드 단위로 이뤄지면 변환에 필요한 정보 량이 너무 많아 비효율적임 → 블록 사상 시스템 사용해 주소 변환블록 사상 시스템 블록 단위로 주소 변환 가상 메모리의 각 블록이 메모리의 어디에 위치하는지 관리 가상 주소 v = (b, d) b: 블록 번호 d: 블록의 시작 점으로부터의 변위 가상 주소 표현 v라는 가상 주소는 b 블록 안에서 시작 위치로부터 d만큼 떨어져 있는 위치에 존재 사상표 b → b’ 실주소 r은 b’에서 d만큼 떨어져 있는 위치에 존재 블록의 크기는 적절히 정해야 함 크기가 커질수록 사상 표 크기 감소 블록 전송 시간 증가, 동시에 적재할 프로세스 수 감소 크기가 작아질수록 블록 전송 시간 감소, 동시에 적재할 프로세스 수 증가 사상 표 크기 증가 블록 구성 방식 페이지(page) 블록의 크기가 동일 세그먼트(segment) 블록의 크기가 다를 수 있음 페이징 기법 가상 메모리를 페이지 단위로 나누어 관리하는 기법 메모리 영역도 페이지와 동일한 크기의 페이지 프레임으로 나눔 페이지 프레임 페이지를 담을 수 있는 틀 실제 메모리에 존재하는 페이지 프레임에다 가상 메모리 상에 있는 특정 페이지 적재할 수 있음 페이지가 페이지 프레임에 적재 된 정보를 가지고 있어야 함 → 페이지 사상 표 페이지 사상 표 가상 주소를 실 주소로 동적 변환할 수 있게 함 페이지 번호에 대한 페이지 프레임 번호 저장 페이지 번호를 인덱스로 사용 페이지 존재 비트 실제 메모리에 적재가 되어있는 페이지인지 체크 0 페이지가 실제 메모리 프레임에 올려져 있지 않음 1 페이지가 실제 메모리 프레임에 적재되어 있음 보조 기억 장치 주소 실제 보조 기억 장치에서의 주소 값 페이징 기법 직접 사상에 의한 동적 주소 변환 페이지 사상 표를 직접 이용 연관 사상 표에 의한 동적 주소 변환 페이지 변환 정보를 연관 메모리에 저장한 연관 사상 표를 이용 연관 메모리 그곳에 저장되어 있는 어떤 데이터들이 있을 때 저장된 값을 가지고 바로 위치를 찾아 액세스 후 값을 볼 수 있는 고속 메모리 페이지 번호가 저장 되어 있어 해당 페이지 번호 찾아 빠르게 페이지 프레임 번호 찾을 수 있음 연관/직접 사상에 의한 동적 주소 변환 연관 사상 표에는 가장 최근에 참조된 페이지만 보관 연관 사상 표에 없을 때만 직접 사상 이용 3번 페이지가 최근에 사용되었을 경우 연관 사상 표에서 3번 페이지 찾음 대응 되는 5번 프레임 번호 찾아 실 주소 계산할 수 있음 3번 페이지가 최근에 사용되지 않았을 경우 연관 사상 표에서 3번 페이지 찾지 못함 페이지 사상 표에서 실 주소 계산해야 함 해당하는 프로세스의 시작 주소가 b주소라는 것을 어딘가에 보관하고 있음 시스템에 많은 프로세스들이 존재하여 페이지 사상 표가 여러 개 존재하기 때문에 페이지 별로 해당하는 사상 표가 시작하는 특정 주소가 필요함 페이지 사상 표는 하나의 프로세스 마다 하나씩 존재함 찾고자 하는 가상 주소의 페이지 번호 더해 b + 3라는 위치 찾아냄 페이징 기법의 특징 논리적 의미와 무관한 동일 크기의 페이지로 나눔 메모리 보호는 페이지 단위로 이루어짐 외부 단편화가 발생하지 않음 내부 단편화는 발생 가능세그먼테이션 기법 가상 메모리를 세그먼트 단위로 나누어 관리하는 기법 세그먼트 논리적 의미에 부합하는 다양한 크기의 블록 세그먼트 사상표 세그먼트 번호에 대한 실 주소에서의 시작 위치 저장 인덱스로 사용 세그먼트 길이는 오버플로 확인용 동적 주소 변환 페이징/세그먼테이션 혼용 기법 세그먼테이션 기법의 논리적 장점 + 페이징 기법의 메모리 관리 측면의 장점 가상 메모리를 세그먼트 단위로 분할 후 각 세그먼트를 다시 페이지 단위로 분할 메모리는 페이지 프레임으로 분할 가상 주소 v = (s, p, d) s : 세그먼트 번호 p : 페이지 번호 d : 페이지 내 변위 세그먼트 사상 표에 각각 저장되어 있는 값들은 각각의 페이지 사상 표의 위치를 가지고 있음 세그먼트로 페이지 사상 표를 찾고 그 곳에서 페이지 프레임 번호를 찾아 실제 메모리를 찾음 동적 주소 변환 연관 사상 표에 있을 경우 세그먼트 번호와 페이지 번호 이용해 연관 사상 표에서 검색 3, 7에 대응되는 사상 정보 5 확인 5번 페이지 프레임에 변위 값 더해 실제 주소 찾음 연관 사상 표에 없을 경우 세그먼트 시작 주소 활용 해 세그먼트 값 3 더해 b+3 인덱스를 찾음 s’ 주소 확인 해당 주소 값은 페이지 사상 표의 시작 주소 값 s’ + 7 값 가지고 실제 주소 찾음 메모리 호출 기법메모리 호출 기법 어느 시점에 페이지 또는 세그먼트를 메모리에 적재할 것인가를 결정하는 기법 페이징 기법에서의 호출 기법 종류 요구 페이지 호출 기법 예상 페이지 호출 기법 요구 페이지 호출 기법 프로세스의 페이지 요구가 있을 때 요구 된 페이지를 메모리에 적재하는 방법 예상 페이지 호출 기법 곧 사용될 것으로 예상되는 페이지를 미리 메모리에 적재하는 방법 메모리 호출 기법 비교 요구 페이지 호출 기법 옮길 페이지 결정에 대한 오버 헤드 최소화 적재된 페이지는 실제로 참조됨 프로세스 시작 시점에는 연속적으로 페이지 부재 발생 예상 페이지 호출 기법 예상이 잘못된 경우 시간과 메모리 공간 낭비 프로세스 시작 시점에 적용하면 성능이 개선됨 정리 하기 가상 메모리는 메모리 크기보다 더 큰 기억 공간을 사용하는 프로세스를 실행할 수 있음 프로세스에서 사용 되는 가상 주소는 동적 주소 변환을 통해 메모리의 실 주소로 변환 됨 연속적인 가상 주소가 실 주소 공간에서도 연속적일 필요는 없음 페이징 기법은 페이지라는 고정 된 크기의 블록 단위로 기억 장치를 관리하는 기법임 세그먼테이션 기법은 모듈화에 따른 논리적 의미에 부합하는 다양한 크기의 세그먼트 단위로 기억 장치를 관리하는 기법임 요구 페이지 호출 기법은 페이지가 필요한 시점에 메모리에 적재하는 방법임 예상 페이지 호출 기법은 앞으로 사용 될 것으로 예쌍 되는 페이지를 미리 메모리에 적재하는 방법임" }, { "title": "[데이터 정보 처리 입문] 10강 - 엑셀 활용", "url": "/posts/knou-dip-10/", "categories": "Data Science, Data Analysis", "tags": "knou, data information processing", "date": "2025-04-26 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김성수, 이기재 교수님의 '데이터 정보 처리 입문' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 엑셀 함수의 기능과 사용법에 대해서 살펴봄 엑셀 함수의 기본적인 기능, 날짜/시간 함수와 텍스트 함수를 활용한 다양한 사례를 살펴봄으로써 엑셀 활용 능력을 배양함학습 목표 엑셀 함수의 기능을 이용할 수 있음 엑셀 함수의 기능을 활용하여 실제 문제를 해결할 수 있음 날짜/시간 함수를 이용할 수 있음 텍스트 함수 기능을 활용하여 실제 문제에 적용할 수 있음주요 용어 채우기 기능 연속된 숫자나 일정한 규칙을 갖고 변화하는 숫자들을 쉽게 입력할 수 있게 하는 엑셀 기능을 말함 SUMPRODUCT 함수 두 배열의 대응되는 값끼리 곱해서 합을 구해 주는 기능 DATE(year, month, day) 함수 특정 날짜의 일련 번호를 구해주는 엑셀 날짜/시간 함수 중 하나 YEAR(날짜 또는 숫자) 함수 날짜에 해당하는 연도를 표시해 주는 엑셀 함수 NOW() 함수 현재 시점을 나타내는 엑셀 함수로 인수가 필요 없는 날짜/시간 함수 이 함수를 입력하는 시점마다 함수 결과 값이 변화함 LEFT(text, num_chars) 함수 문자열의 첫 문자부터 지정된 개수의 문자를 표시해 줌 RIGHT(text, num_chars) 함수 문자열의 마지막 문자부터 지정된 개수의 문자를 표시해 줌 MID(text, start_num, num_chars) 함수 문자열의 지정한 위치로부터 지정된 개수의 문자를 표시해 줌 강의록함수의 기능과 형식엑셀의 채우기 기능 연속된 숫자나 일정한 규칙으로 변화하는 숫자들을 쉽게 입력할 수 있도록 함엑셀 함수 기능과 형식 기능 값, 셀 참조, 함수 등을 사용하여 새로운 값 생성 형식 = 함수 이름(인수, 인수, …, 인수) 예 =SUM(A1:A3) 함수 사용의 규칙 수식은 등호(=)로 시작 함수 이름 다음에 인수를 묶는 양쪽 괄호는 반드시 필요 인수는 숫자, 셀 범위, 논리 값, 문자 값, 다른 함수도 가능 인수가 여러 개 사용되는 함수는 콤마(,)로 분리함수 사용에 대한 예들 =SUM(A1:A3) =SUM(2,3,4,5,5) =SUM(5+2,AVERAGE(5,7),10)엑셀을 이용한 계산엑셀 채우기와 함수 사용 예제 예제: 오늘 1원 저금하고 내일은 그 2배 그 다음은 전날의 두 배, 이렇게 저금하면 며칠 째 되는 날에 누적 액이 1억 원을 돌파할까? A1 셀에 ‘날짜’, B1 셀에 ‘저금액’, C1 셀에 ‘누적 저금액’ 입력 A2 셀과 A3 셀에 각각 1과 2를 입력하고, 자동 채우기 기능을 이용해서 드래그 &amp; 드롭 하여 30까지 채우기 실행 B2 셀에 첫 날의 저금액인 1을 입력하고, C2 셀에 “=B2“을 입력 B3 셀에 “=2*B2”, C3 셀에 “=C2+B3“을 입력 B3:C3의 셀 범위를 선택하고, 채우기 핸들을 드래그 &amp; 드롭 해서 30일째 되는 날까지 채우기 실행 누적 액이 처음으로 1억원을 넘는 날짜는 27일째임을 확인 SUM 함수를 이용하여 평점 평균 구하기 교과목의 성적 등급 및 평점 등급 A+ A0 A- B+ B0 B- C+ C0 C- D+ D0 D- F 평점 4.3 4.0 3.7 3.3 3.0 2.7 2.3 2.0 1.7 1.3 1.0 0.7 0 어느 학생의 성적표에 대한 평점 평균 구하기 과목명 신청 학점 성적 경영학개론 3 B0 세계의 역사 3 A- 컴퓨터의 이해 3 A0 데이터정보처리 입문 3 A+ 인터넷서비스 3 B+ 계 15   해당 과목의 성적에 대응하는 평점을 각각 입력 E1 셀에 ‘학점 * 평점‘을 입력, E2 셀에 함수 ‘=B2 * D2‘를 입력 E2 셀을 선택하고 드래그 &amp; 드롭으로 E6 셀까지 채움 이 과정을 통해서 각 과목에 대해서 학점 * 평점의 값을 계산 E7 셀에 SUM(E2:E6)/B7 을 입력하여 평점 평균 계산 평점 평균 = 학점의 합계 / (학점 * 평점)의 합계 = ∑학점 / ∑학점 * 평점 SUMPRODUCT 함수 배열의 대응되는 값끼리 곱해서 합을 구해주는 기능 평점 평균 계산 =SUMPRODUCT(B2:B6,D2:D6)/B7을 D7 셀에 입력 날짜/시간 및 문자 함수 이용날짜/시간 함수의 예 DATE(year, month, day) 특정 날짜의 일련 번호를 구해 주는 기능 YEAR(날짜 또는 숫자) 날짜에 해당하는 연도를 표시 NOW() 현재 시점을 나타내는 기능으로 인수가 필요 없는 날짜/시간 함수 입력하는 시점마다 값이 변화함 텍스트 함수의 예 LEFT(text, num_chars) 문자열의 첫 문자부터 지정된 개수의 문자를 표시 ex) A1 셀에 “대한민국”이 입력되었다면 LEFT(A1,2) = \"대한\" RIGHT(text, num_chars) 문자열의 마지막 문자부터 지정된 개수의 문자를 표시 ex) RIGHT(\"Sale Price\",5) = \"Price\" MID(text, start_num, num_chars) 문자열의 지정한 위치로부터 지정한 개수의 문자를 표시 ex) MID(\"대한민국\", 3, 2) =\"민국\" 날짜/시간 및 문자 함수 이용 예제 각 사람의 주민등록번호와 입사일로부터 나이와 근속 년수 계산 월급은 통화표시 ‘₩‘를 넣고 3자리마다 단위 표시 G1 셀에 ‘생년월일‘을 입력하고, G2 셀에 =DATE(LEFT(C2,2), MID(C2,3,2), MID(C2,5,2))을 입력 H1 셀에 ‘나이‘를 입력 H2에 =YEAR(NOW( )) - YEAR(G2)를 입력 근속년수도 I2 셀에 =YEAR(NOW( ))-YEAR(D2)을 입력하여 구함 월급을 통화표시 ‘₩‘를 넣고 3자리마다 단위를 표시하기 위하여 F2:F6의 셀 범위를 선택하고, [홈]-[표시형식] 그룹을 클릭하여 셀 서식 대화 상자에서 ‘통화’ 서식을 선택 서식 도구 모음에서 테두리를 선택하여 보기 좋은 표 형식으로 완성 실습 날짜/시간 및 문자 함수 이용 연습 문제 풀이 다음 물음에 답하시오. 학과 코드의 첫째 자리 알파벳이 A이면 법학과, B이면 경영학과, C이면 통계학과 학생이다. 학과 셀에 학과를 표기하여라. (Left 함수 사용) =IF(LEFT(A2, 1) =\"A\", \"법학과\", IF(LEFT(A2, 1) = \"B\", \"경영학과\", \"통계데이터과학과\")) 시험 점수와 과제물, 태도 점수의 평균에서 결석 일수에 5를 곱한 수를 뺀 것으로 점수로 계산하여라. =AVERAGE(D2:F2)-5*G2 평가 항목은 다음과 같이 장학생, 이수, 재수강으로 나뉘며, 평가 기준에 의해 평가 항목을 계산하여라. =IF(AND(H2&gt;=90,G2=0),\"장학생\",IF(OR(H2&lt;=60,G2&gt;=5),\"재수강\",\"이수\")) - 평가 기준 장학생: 점수가 90점 이상이고 결석을 한 번도 하지 않은 경우 재수강: 점수가 60점 이하이거나 결석을 5회 이상인 경우 이수: 재수강이 아닌 경우 연습 문제 A2 셀에 “대한민국”이라고 입력되어 있다. “=MID(A2, 2, 2)“의 결과로 알맞은 것은? a. 한민 G2 셀에 어떤 사람의 생년월일이 “1980-12-5”로 같이 입력되어 있다고 한다. 엑셀 함수 “=YEAR(NOW())-YEAR(G2))“의 결과를 바르게 설명한 것은? a. 현재 시점의 나이를 구한다. 학과코드의 첫 번째 자리 알파벳이 A이면 통계 · 데이터과학과, B이면 컴퓨터학과 학생이다. 학과 셀에 학과를 표기하고자 한다. C2 셀에 알맞은 함수 식은? a. =IF(LEFT(A2,1)=\"A\", \"통계·데이터과학\", \"컴퓨터\") 최종 점수는 시험점수와 과제물, 태도점수의 합계에서 결석일수에 5를 곱한 수를 뺀 것으로 계산하고자 한다. H2 셀에 알맞은 함수 식은?  a. =SUM(D2:F2)-5*G2 다음과 같이 워크 시트에 값이 입력되어 있을 때 ‘=SUMPRODUCT(A1:A3, B1:B3)’을 D1 셀에 입력하면 얻게 되는 계산 값은 얼마인가? a. 10 " }, { "title": "[데이터베이스 시스템] 9강 - 저장 객체", "url": "/posts/knou-dbs-9/", "categories": "Database", "tags": "knou, database", "date": "2025-04-26 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '데이터베이스 시스템' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 SQL은 비절차적 언어로 필요한 정보에 대한 조건만 기술할 뿐 구체적으로 처리 과정을 기술하지 못함 보다 데이터에 대한 절차적 처리가 가능하도록 SQL에 프로그래밍 언어와 유사하게 조건문이나 반복문과 같은 기능을 추가되어 데이터베이스 내에 하나의 객체로 저장되어 관리되는 응용 프로그램과 같은 기능이 제공되는데, 이를 저장 객체라고 함 저장 객체의 종류로는 저장 프로시저, 함수, 트리거 등이 있으며 저장 객체의 기능을 정의하기 위한 Transact-SQL이라는 확장된 언어를 사용하여 세세한 기능을 정의함 저장 프로시저와 함수의 명령문과 변수들을 이용한 여러 가지 사용 예와 트리거의 동작에 대해 학습함주요 용어 저장 객체 데이터베이스 내에 하나의 객체로 저장되어 관리되는 응용 프로그램과 같은 기능을 제공하는 SQL의 확장 기능 저장 프로시저 자주 사용되거나 복잡한 SQL 문을 저장하여 하나의 개체로 관리하는 저장 객체의 한 형태 함수 SELECT문에 포함되어 특정 값을 반환하는 저장 객체의 한 형태 트리거 테이블에 INSERT, UPDATE, DELETE등의 이벤트가 발생했을 때 자동으로 실행되는 저장 객체 매개 변수 저장 객체에 값을 전달하거나 값을 반환 받기 위한 IN, OUT, INOUT타입의 변수 강의록저장 프로시저데이터베이스 언어의 특징 SQL DBMS에 대한 강력한 작업 지시 기능을 제공 인간의 언어와 매우 유사하고 간단, 명료 비절차적(선언형) 언어, 필요한 데이터만 기술 비절차적 언어(non-procedural language) 목표만 명시하고 수행에 대한 절차는 기술하지 않음 높은 가독성과 동작 순서에 대한 구체적 기술이 없어 오류가 상대적으로 적은 점이 장점 프로그램의 성능 최적화, 디버깅, 오류 추적 및 복잡한 로직 구현이 한계 저장 객체를 통해 SQL의 단점을 보완 저장 객체의 이해 저장 객체의 정의 SQL 문을 확장하여 절차적으로 처리하기 위한 기능을 제공하는 언어 SQL/PSM(Persistent Stored Module) 기반의 확장 언어 SQL을 절차형 언어로 확장 저장 객체의 구조 CREATE PROCEDURE do_repeat (param1 INT) -- 형식 정의 부분 BEGIN -- 기능 정의 부분 SET @x = 0; REPEAT SET @x = @x + 1; UNTIL @x &gt; param1 END REPEAT; END; 반복되는 작업 과정을 한데 담아냄으로써 효율성을 높임 저장 프로시저 함수 트리거 저장 객체의 장단점 저장 객체의 장점 네트워크 전송 효율 클라이언트와 DBMS 사이에 트래픽 감소 오가는 데이터의 양을 줄일 수 있음 효율적 실행 속도 저장 객체는 컴파일되어 캐시에 저장 모듈화 대규모 작업의 시간 단축, 프로그램 크기의 축소 여러 단계에 나눠 처리해야 할 SQL 문을 하나의 객체로 처리 보안성 향상 사용자 별, 작업 단위별로 권한 부여 가능 저장 객체의 단점 처리 성능 저하 서버 메모리 사용량이 증가로 인한 성능 저하 어려운 디버깅 저장 객체를 위한 디버깅 환경 미지원 통합 개발 환경(IDE; Integrated Development Environment) 프로그램 개발에 관련된 모든 작업을 하나의 프로그램 안에서 처리하는 환경을 제공하는 소프트웨어 저장 객체의 종류 저장 프로시저 자주 사용되거나 복잡한 과정을 거치는 SQL문을 저장하여 하나의 개체로 관리 함수 저장 프로시저의 유사, 결과 값을 반환하는 기능 제공 SELECT문에 포함되어 실행 트리거 데이터 갱신 시 지정된 애플리케이션이 동작 또는 다른 테이블의 데이터를 변경 DBMS가 자동으로 반응하도록 만드는 역할 저장 객체에 사용되는 언어는 상용 DBMS 마다 차이가 있음저장 프로시저의 이해 저장 프로시저의 정의 응용 작업 중 자주 사용되거나 다수의 SQL 문으로 구성되는 복잡한 과정이 저장 된 개체 데이터를 주고받는 여러 개의 SQL 문을 묶어서 단계 별로 실행 절차를 기술해서 결과를 만들어내는 객체 저장 프로시저의 특징 함수와는 달리 이름을 이용하여 값을 반환하지 않음 매개 변수를 받아들이거나 반환 프로시저 내에서 또 다른 프로시저 호출 가능 실행과 관련된 제어 값과 메시지를 반환 저장 프로시저의 생성 생성 구문 형식 CREATE [DEFINER {사용자 | 현재사용자}] PROCEDURE 프로시저명 ([매개 변수[, ...]]) BEGIN SQL문 END 매개 변수 정의 [IN | OUT | INOUT] 매개 변수명 데이터 타입 매개 변수 기본 값 IN 저장 프로시저의 활용 1 저장 프로시저 생성 DELIMITER $$ CREATE PROCEDURE GetStudentByGender() BEGIN SELECT 성별, COUNT(*) FROM 학생 GROUP BY 성별; END $$ DELIMITER; 프로시저를 정의하는 것도, DELIMITER도 작성하는 것도 중요 만든 프로시저는 바로 실행되지 않고 DBMS 내부 어딘가에 저장됨 문장 구분자 DELIMITER는 개별 SQL 문 구분하는 구분자 정의 BEGIN-END블럭 내에 SQL 문과 기능 정의 부분의 구분자 구별 필요 저장 프로시저의 호출 호출 구문 형식 CALL 저장 프로시저면([매개 변수[, ...]]); CALL 저장 프로시저명[()]; ex) 호출 CALL GetStudentByGender(); 학생번호 학생이름 성별 생년월일 나이 전화번호 201831-331215 김마리아 여 1991-06-18 29 010-0000-0002 201834-021216 유관순 여 1902-12-16 118 010-0000-0001 201926-880215 지청천 여 1988-02-15 32 010-0000-0005 성별 COUNT(*) 여 5 남 7 저장 프로시저의 수정과 삭제 저장 프로시저의 수정 ALTER PROCEDURE명령어를 사용 보안 및 동작 방식 속성 제외 실제 ALTER문을 통해 변경할 수 있는 것이 거의 없음 보안 및 동작 방식에 대한 측면을 변경할 때만 사용 저장 프로시저 생성 → 모든 객체 정보 동일 함수, 트리거도 동일 저장 프로시저의 삭제 DROP PROCEDURE 저장 프로시저명; DROP PROCEDURE GetStudentByGender; 매개 변수의 사용 매개 변수의 역할 외부로부터 주어지는 값이나 기본 값을 매개 변수를 통해 저장 프로시저로 전달 저장 프로시저를 실행한 결과 값을 반환 IN, OUT, INOUT세 타입의 매개 변수 제공 IN 기본 타입, 외부로부터의 값을 전달 외부에서 내부로 전달 OUT 반환 값을 저장 내부에서 외부로 꺼내는 용도 INOUT IN과 OUT의 목적으로 모두 사용 매개 변수의 활용 - INDELIMITER $$CREATE PROCEDURE GetBalancebyNameBirth( IN name VARCHAR(20), IN birth DATE) -- **두 매개 변수를 프로시저 외부**로부터 받아들임BEGIN SELECT 잔액 FROM 학생, 계좌 WHERE 학생.학생번호 = 계좌.학생번호 AND 학생.학생이름 = name AND 학생.생년월일 = birth;END $$ -- 위에서 받은 학생 이름과 생년월일을 토대로 해당 학생의 계좌에서 잔액을 조회DELIMITER;CALL GetBalancebyNameBirth('안중근', '1979-09-02'); -- 매개 변수화 시켜서 프로시저에 전달 잔액 100000 매개 변수의 활용 - OUTDELIMITER $$CREATE PROCEDURE GetPhoneByStudentID( IN sid CHAR(13), OUT phone CHAR(15)) -- 전화 번호를 OUT 해서 @phone에 저장BEGIN SELECT 전화번호 INTO phone FROM 학생 -- 전화번호를 phone에 저장 WHERE 학생번호 = sid;END $$DELIMITER;CALL GetPhoneByStudentID('202034-596541', @phone);SELECT @phone; -- 화면에 출력 @phone 010-0000-0008 변수의 사용 저장 객체에서 처리하는 응용 과정에서 발생하는 임시적인 값을 저장하고 재 사용하는 기능 제공 사용자 정의 변수 @시작 별도의 선언 없이 사용 로컬 변수 저장 객체 내에서만 사용 DECLARE로 선언 구문 형식 DECLARE 변수명[, ...] 데이터 타입[(크기)] [DEFAULT 기본값]; 데이터 타입(크기) 변수가 가질 수 있는 데이터 타입과 크기를 지정 DEFAULT 기본 값 변수가 선언될 때 초기 값을 지정 변수 값 할당 선언된 변수에 값을 저장(할당)하는 방법 SET명령 DECLARE total_count INT DEFAULT 0; SET total_count = 10; SELECT INTO문 숫자 타입만 가능 DECLARE total_student INT DEFAULT 0; SELECT COUNT(*) INTO total_student FROM 학생; -- COUNT(*) 값이 total_student에 저장 SQL 문의 실행 결과를 특정 변수에 넣어준다는 의미 선택 구조 - IF 주어진 조건이나 식의 값에 따라 SQL 문의 실행 여부를 제어 구문 형식 IF 조건식 THEN SQL문 [ELSEIF 조건식 THEN SQL문] [ELSE SQL문] END IF; IF문의 활용 학생 번호에 해당하는 학생의 이수 학점을 가져 온 후, 이수 학점에 따라 학년(nGrade)을 추출하고자 하는 프로시저 DELIMITER $$ CREATE PROCEDURE GetGradeByCredit( IN sid CHAR(13), -- 학생번호 OUT nGrade TINYINT) -- 학년 BEGIN DECLARE nTotalCredit SMALLINT; -- 총 이수학점 (이수 학점의 합을 임시로 저장하기 위한 로컬 변수) SELECT SUM(이수학점) INTO nTotalCredit FROM 전공 WHERE 학생번호 = sid; IF nTotalCredit &gt; 120 THEN SET nGrade = 4; ELSEIF (nTotalCredit &gt; 80 AND nTotalCredit &lt; 120) THEN SET nGrade = 3; ELSEIF (nTotalCredit &gt; 40 AND nTotalCredit &lt; 80) THEN SET nGrade = 2; ELSE SET nGrade = 1; END IF; END $$ DELIMITER ; 입력(IN) 및 출력(OUT) 매개 변수 sid nGrade 로컬 변수 선언 nTotalCredit 특정 학생의 총 이수 학점을 저장하는 변수 학년 구분 조건 4학년: 총 이수 학점(nTotalCredit)이 120 이상인 경우 3학년: 이수 학점이 81 이상 119 이하인 경우 2학년: 이수 학점이 41 이상 80 이하인 경우 1학년: 이수 학점이 40 이하인 경우 CALL GetGradeByCredit('202036-590930', @grade); SELECT @grade 위 호출에서 학생 202036-590930의 학년 결과가 계산되어 @grade라는 변수로 반환 @grade 4 선택 구조 - CASE 다중 IF ELSE문을 간편하게 사용하기 위한 명령어 CASE 변수 WHEN 비교 변수값 1 THEN SQL문 [WHEN 비교 변수값 2 THEN SQL문] ... [ELSE SQL문] END CASE; CASE WHEN 조건식 1 THEN SQL문 [WHEN 조건식 2 THEN SQL문] [ELSE SQL문] END CASE; CASE문의 활용 수강 신청 결과(신청자 수)에 따라 강의실을 배정하는 프로시저 DELIMITER $$ CREATE PROCEDURE GetRoomSize( IN sClassCode CHAR(5), -- 과목코드 OUT sClassSize VARCHAR(20)) -- 강의실 규모 BEGIN DECLARE nClassVolumn INT; -- 신청자수 SELECT COUNT(*) INTO nClassVolumn FROM 수강 WHERE 과목코드 = sClassCode; CASE WHEN nClassVolumn &gt; 4 THEN SET sClassSize = '대 강의실'; WHEN (nClassVolumn &gt; 2 AND nClassVolumn &lt; 4) THEN SET sClassSize = '중 강의실'; ELSE SET sClassSize = '소 강의실'; END CASE; END $$ DELIMITER ; 특정 과목 코드(sClassCode)를 입력받아 해당 과목 신청자 수(nClassVolumn)를 기반으로 강의실 규모(sClassSize)를 판단하는 프로시저 입력(IN) 및 출력(OUT) 매개 변수 sClassCode sClassSize 로컬 변수 선언 nClassVolumn 특정 과목의 전체 신청자 수를 저장하는 변수 강의실 규모 구분 조건 대 강의실: 신청자 수가 4명 초과인 경우 중 강의실: 신청자 수가 3명인 경우 소 강의실: 신청자 수가 2명 이하인 경우 CALL GetRoomSize('COM12',@size); SELECT @size; COM12 과목의 신청자 수를 확인하여 강의실 규모 결과(소 강의실, 중 강의실, 또는 대 강의실)를 반환 반환 값은 @size 변수에 저장 @size 대 강의실 반복 구조 MySQL은 특정 SQL문을 주어진 조건이 만족하는 동안 특정 구간을 반복 시킬 수 있는 세가지 구문을 제공 WHILE REPEAT LOOP 반복문 안에서 반복 작업을 제어하기 위해 LEAVE와 ITERATE문을 사용 LEAVE는 반복 종료 break;와 동일 ITERATE는 현재 반복 구간을 중단하고 조건을 재검사하여 반복 여부를 판별 continue;와 동일 WHILE문의 활용 특정 과목(sCourseCode)이 가진 선수 과목을 재귀적으로 탐색하여 최종적으로 학생이 반드시 들어야 할 “최초의 선수 과목”(sPrerequisite)을 반환하는 프로시저 DELIMITER $$ CREATE PROCEDURE GetFirstCourse( IN sCourseCode CHAR(5), OUT sPrerequisite CHAR(5)) BEGIN DECLARE sInputCourse CHAR(5); SET sInputCourse = sCourseCode; pre: WHILE true DO -- 시작 특정 지점을 나타내는 구간 SELECT 선수과목 INTO sPrerequisite FROM 과목 WHERE 과목코드 = sCourseCode; IF sPrerequisite IS NOT NULL THEN SET sCourseCode = sPrerequisite; ELSE LEAVE pre; END IF; END WHILE; IF sCourseCode = sInputCourse THEN SET sPrerequisite = NULL; ELSE SET sPrerequisite = sCourseCode; END IF; END$$ DELIMITER ; 입력(IN) 및 출력(OUT) 매개 변수 sCourseCode sPrerequisite 로컬 변수 선언 sInputCourse 최초 입력된 과목 코드를 저장 WHILE 루프 구조 조건 선수 과목(sPrerequisite)이 있을 경우, 해당 과목으로 재설정(sCourseCode = sPrerequisite)하고 다시 탐색 종료 조건 더 이상 선수 과목이 없으면 루프를 빠져 나감 결과 확인 만약 입력 과목 코드(sInputCourse)와 최종적으로 도달한 과목 코드(sCourseCode)가 동일하면 선수 과목이 없음을 의미하므로, NULL로 반환 CALL GetFirstCourse('COM31', @code); SELECT @code; 최종적인 선수 과목은 @code 변수에 저장 만약 선수 과목이 없다면 결과는 NULL로 반환 @code COM12 함수함수의 이해 DBMS는 문자 함수, 숫자 함수, 날짜 함수, 집계 함수 등 많은 편리한 함수를 제공 사용자가 프로그래밍 언어의 기능을 사용하여 직접 함수를 정의하는 사용자 정의 함수 기능을 제공 저장 프로시저와 함수의 차이 저장 프로시저는 OUT매개 변수를 통해 결과 값을 반환, 함수는 RETURN문에 의해 특정 값을 반환 저장 프로시저는 CALL명령에 의해 실행되나, 함수는 SELECT문에 포함되어 실행(호출) 함수의 생성 구문 형식 CREATE [DEFINER {사용자 | 현재사용자}] FUNCTION 함수명([매개 변수[, ...]]) RETURNS 데이터 타입 [Characteristic] BEGIN SQL문 END 프로시저의 구문 형식과 매우 유사 매개 변수 IN타입의 매개 변수만 사용 가능 OUT매개 변수가 없음 Characteristic SQL 문의 특성을 기술 NO SQL 실행되는 SQL문이 없을 경우 READ SQL DATA SELECT만 하는 경우 MODIFIES SQL DATA INSERT, UPDATE, DELETE사용할 경우 함수의 생성 계좌 잔액에 따라 다르게 적용되는 이율(fIR)을 반환해 주는 함수 DELIMITER $$ CREATE FUNCTION GetInterestRate(nBalance INT) RETURNS DECIMAL(4, 2) READS SQL DATA BEGIN DECLARE fIR DECIMAL(4, 2); -- DECIMAL(전체 숫자의 자릿 수, 정수의 자릿 수) IF nBalance &gt;= 500000 THEN SET fIR = 0.03; ELSEIF nBalance &gt;= 100000 AND nBalance &lt; 500000 THEN SET fIR = 0.02; ELSEIF nBalance &lt; 100000 THEN SET fIR = 0.01; ELSE SET fIR = 0.0; END IF; RETURN (fIR); END$$ DELIMITER; 함수의 활용SELECT 학생번호, 계좌번호, 잔액, GetInterestRate(잔액) AS 이율 -- 앞에서 정의한 함수 FROM 계좌 WHERE 잔액 &gt;= 300000; 학생번호 계좌번호 잔액 201831-331215 123434-222222 800000 201834-021216 123434-111111 600000 201926-880215 123434-555555 300000 201931-781109 123434-444444 400000 201934-080621 123434-777777 300000 201934-790902 123434-666666 100000 202034-596541 123434-888888 1200000 202031-816515 123434-999999 150000 학생번호 계좌번호 잔액 이율 201831-331215 123434-222222 800000 0.03 201834-021216 123434-111111 600000 0.03 201978-610408 123434-333333 400000 0.02 201931-781109 123434-444444 400000 0.02 201926-880215 123434-555555 300000 0.02 201934-080621 123434-777777 300000 0.02 202034-596541 123434-888888 1200000 0.03 함수는 별도 라인 별로 적용, 결괏 값은 컬럼으로 나타남트리거트리거의 이해 데이터 변경 시 자동으로 지정된 애플리케이션이 동작하거나 다른 테이블의 데이터를 변경하도록 설계된 저장 프로시저의 특별한 형태 어떤 일이 일어나면 후속 일 자동 발생 트리거의 단점 실제 DBMS 내부에서 동작했을 때 어떤 트리거가 발동되었는지 유추하기 힘듦 연쇄적인 트리거 발생은 때때로 DBMS의 실패 상황을 야기할 수 있음 트리거의 역할 전체적인 데이터베이스의 무결성과 일관성을 유지하도록 동작 조건에 따른 데이터 적합성 검사 가능 연속적 트리거 실행 시 다른 데이터베이스나 서버에 대한 광범위한 참조 무결성 검사도 가능 트리거의 종류 트리거 이벤트와 트리거 시점으로 구분 | 트리거 이벤트 | 실행 시점 | 기능 | | — | — | — | | INSERT | BEFORE | 테이블에 데이터가 입력되기 전에 실행 | | | AFTER | 테이블에 데이터가 입력된 후에 실행 | | UPDATE | BEFORE | 테이블의 데이터가 수정되기 전에 실행 | | | AFTER | 테이블의 데이터가 수정된 후에 실행 | | DELETE | BEFORE | 테이블의 데이터가 삭제되기 전에 실행 | | | AFTER | 테이블의 데이터가 삭제된 후에 실행 | 트리거 이벤트 자동으로 반응하는 SQL 문 트리거 시점 트리거가 실행될 시점을 명시 트리거의 생성 구문 형식 CREATE TRIGGER 트리거 이름 \t트리거시점 트리거이벤트 ON 테이블이름 \tFOR EACH ROW BEGIN SQL문 END OLD와 NEW키워드 OLD 해당 테이블에 변경이 가해지기 전의 레코드 NEW 해당 테이블에 변경이 가해진 후의 레코드 트리거의 활용 과목테이블의 학점이 업데이트될 때, 학점 값이 1 미만이거나 3 초과인 경우 각각 1 또는 3으로 강제 조정되도록 하는 트리거 DELIMITER $$ CREATE TRIGGER before_과목_update \tBEFORE UPDATE ON 과목 -- 과목 테이블이 업데이트 하기 전 \tFOR EACH ROW BEGIN IF NEW.학점 &lt; 1 THEN -- 새롭게 바뀔 학점(NEW 학점) SET NEW.학점 = 1; -- NEW 레코드가 과목 테이블에 반영 ELSEIF NEW.학점 &gt; 3 THEN SET NEW.학점 = 3; END IF; END $$ DELIMITER ; -- 과목 테이블에서 과목코드가 'COM34'인 행의 학점을 5로 업데이트하려고 시도 UPDATE 과목 \tSET 학점 = 5 \tWHERE 과목코드 = 'COM34'; -- 학생 테이블의 모든 데이터를 조회 SELECT * FROM 학생; 트리거 조건에 의해 NEW.학점의 값은 3으로 변경되고, 실제 과목테이블에는 학점이 5가 아닌 3으로 업데이트 과목코드 과목명 학점 선수과목 이수구분 교수번호 COM11 컴퓨터의 이해 3   교양 … COM12 파이썬 프로그래밍 기초 3   교양 … COM24 자료구조 3 COM12 전공필수 … COM31 데이터베이스 시스템 3 COM24 전공필수 … COM34 알고리즘 3 COM24 일반선택 … COM44 클라우드 컴퓨팅 3   전공필수 … ECE24 놀이지도 3   전공필수 … ECE31 유아언어교육 3 ECE31 전공필수 … 연습 문제 다음 중 저장 객체에 포함되지 않는 것은? a. 인덱스 저장 객체는 저장 프로시저, 함수, 트리거 등을 포함하지만, 인덱스는 테이블의 검색 성능을 향상 시키기 위한 데이터베이스 객체임 다음 중 매개 변수 타입이 아닌 것은? a. RETURN 매개 변수 타입은 IN, OUT, INOUT세 가지가 있고, RETURN은 매개 변수 타입이 아닌 함수에서 값을 반환하는 명령어임 저장 프로시저와 함수의 차이점으로 올바른 것은? a. 함수는 RETURN문으로 값을 반환하지만, 저장 프로시저는 RETURN문으로 값을 반환하지 않는다 함수는 RETURN문을 통해 특정 값을 반환하는 반면, 저장 프로시저는 값을 반환하지 않거나 OUT/INOUT매개 변수를 통해 값을 반환함 함수는 SELECT문에 포함되어 사용되지만, 저장 프로시저는 CALL명령으로 독립적으로 실행 됨 정리 하기 저장 객체는 비절차적 SQL 언어의 한계를 보완하여 데이터에 대한 절차적 처리가 가능하도록 개발된 데이터베이스 내 저장되는 프로그래밍 요소로, 저장 프로시저, 함수, 트리거 등이 있음 저장 객체는 네트워크 전송 효율, 실행 속도의 효율성, 모듈화 기능, 보안 향상 등의 장점이 있으나, 낮은 처리 성능과 디버깅의 어려움이라는 단점도 있음 MySQL에서 변수는 세션 전체에서 사용 가능한 사용자 정의 변수(@로 시작)와 저장 객체 내에서만 사용 가능한 로컬 변수(DECLARE로 선언)로 구분 됨 저장 프로시저는 CREATE PROCEDURE로 생성되며, 매개 변수를 통해 값을 전달 받거나 반환할 수 있음 매개 변수는 IN, OUT, INOUT세 가지 타입이 있으며, CALL명령으로 호출 됨 저장 객체에서는 IF-THEN, CASE WHEN같은 조건문과 WHILE, REPEAT, LOOP같은 반복문을 사용할 수 있으며, 이를 통해 복잡한 업무 로직 구현이 가능함 함수는 저장 프로시저와 유사하지만 RETURN문을 통해 특정 값을 반환하며, SELECT문에 포함되어 실행된다는 점에서 차이가 있음 트리거는 테이블에 INSERT, UPDATE, DELETE이벤트 발생 시 자동으로 실행되는 특별한 저장 객체로, 데이터베이스의 무결성과 일관성을 유지하는 데 활용 됨 MySQL에서는 BEFORE/AFTER와 INSERT/UPDATE/DELETE조합으로 총 여섯 가지 트리거 유형을 제공하며, OLD와 NEW키워드를 통해 변경 전후의 데이터 값을 참조할 수 있음 저장 객체를 수정할 때는 일반적으로 DROP명령으로 객체를 삭제한 후 CREATE명령으로 다시 생성해야 하며, ALTER명령은 보안 및 동작 방식 속성 변경에만 사용 됨 MySQL 워크 벤치에서는 GUI 방식으로 저장 객체를 편리하게 생성, 수정, 삭제할 수 있어 개발 생산성을 높일 수 있음체크 포인트 저장 객체에 대한 설명으로 가장 적절하지 않은 것은? a. 저장, 프로시저 함수, 트리거는 비절차적 언어로 작성된다. - 비절차적 언어는 목표만 있고 중간 과정이 없는 언어 - 저장 객체에 대한 설명으로 적절한 것 - 데이터베이스 시스템의 성능을 개선한다. - 트리거에서 `COMMIT`, `ROLLBACK`을 사용할 수 없다. - 함수는 반드시 리턴이 있다. - 저장, 프로시저 함수, 트리거는 절차적 언어로 작성된다. 테이블 R(A, B, C, D, E)와 S(E, F, G)에 대해 두 릴레이션을 요약하는 별도의 테이블 RS(A, B, E, G)를 생성하였다. 테이블의 R의 B 속성에 대한 갱신 연산이 발생할 경우 RS에 전파하는 트리거를 작성하려고 할 때 빈 칸에 알맞은 것이 순서대로 나열 된 것은? CREATE TRIGGER After_Update_On_R_B \tALTER UPDATE B ON R \tFOR EACH ROW BEGIN \tUPDATE RS \t\tSET B = _____ \t\tWHERE RS.A = _____ AND RS.E = _____**; END;** a. NEW.B, OLD.A, OLD.E R에 업데이트가 일어났을 때 B의 값을 R의 Key인 A와 E 값이 일치하는 경우만 변경 " }, { "title": "[파이썬 프로그래밍 기초] 9강 - 함수", "url": "/posts/knou-python-9/", "categories": "Language, Python", "tags": "knou, python", "date": "2025-04-25 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '파이썬 프로그래밍 기초' 강의를 개인 공부 목적으로 메모하였습니다. 학습 목표 함수의 개념에 대해 설명할 수 있음 반환 값이 없는 함수와 반환 값이 있는 함수의 차이점을 설명할 수 있음 변수가 참조 될 수 있는 영역을 파악할 수 있음주요 용어 동시 할당 복수 개의 변수에 값을 동시에 할당하는 명령 스코프 프로그램에서 변수가 참조될 수 있는 영역 기본 매개 변수 함수 호출 시 매개 변수가 전달되지 않을 경우 기본 값이 전달되는 매개 변수 가변 매개 변수 함수 호출 시 매개 변수를 사용자가 원하는 개수 만큼 지정할 수 있는 매개 변수 강의록함수의 이해원뿔 계산 프로그램 개선 원뿔 계산을 불규칙적으로 다른 환경에서 요청하는 상황이면? #반지름 rad = 10, 높이 hei = 20 #반지름 radius = 20, 높이 height = 30 #반지름 r = 5, h = 50 vol = 1/3 * 3.14 * r ** 2 * h suf = 3.14 * r ** 2 + 3.14 * r * h print(\"원뿔의 부피는\", vol, \"입니다.\") print(\"원뿔의 겉넓이는\", suf, \"입니다\") 반지름과 높이가 무조건 10으로 한정 되어 있는 좋지 않은 함수 다른 반지름과 높이를 적용하려면 r, h를 수정해야 함 #반지름 rad = 10, 높이 hei = 20 prt_cone_vol(rad, hei) #반지름 radius = 20, 높이 height = 30 prt_cone_vol(radius, height) #반지름 r = 5, h = 50 prt_cone_vol(r, h) 함수의 개념 특정 작업을 수행하는 명령문의 집합 특정 작업을 함수의 이름으로 대체 유사한 유형의 문제를 해결할 수 있도록 고려 사용자 정의 함수 내장 함수와 달리 사용자의 목적에 따라 정의된 함수 반환 값에 따른 함수의 종류 반환 값이 없는 함수 print 반환 값이 있는 함수 input, format, int 등 반환 값이 없는 함수 정의 구문 형식 함수 이름은 식별자 매개 변수 리스트는 0개 이상의 값을 함수 내부로 전달 함수 내부에서 매개 변수 리스트는 변수와 동일하게 사용 원뿔 계산 함수 정의# 원뿔 계산 함수 정의def prt_cone_vol(): r = 10 h = 10 if r &gt; 0 and h &gt; 0: # r,h 모두 양수일 때 vol = 1 / 3 * 3.14 * r ** 2 * h print(\"원뿔의 부피는\", vol, \"입니다.\") else: # r, h가 음수일 때 print(\"반지름과 높이 값에 양수를 입력하세요\")# 원뿔 계산 함수 정의def prt_cone_vol(r, h): if r &gt; 0 and h &gt; 0: # r, h 모두 양수일 때 vol= 1 / 3 * 3.14 * r ** 2 * h print(\"원뿔의 부피는\", vol, \"입니다.\") else: # r, h가 음수일 때 print(\"반지름과 높이 값에 양수를 입력하세요\") 프로그램을 구성하는 하나의 코드 블럭이기 때문에 단독 실행 불가 함수 호출해야 사용 가능 함수의 호출과 실행 흐름# 원뿔 계산 함수 정의def prt_cone_vol(r, h): if r &gt; 0 and h &gt; 0: #r,h 모두 양수일 때 vol = 1/3 * 3.14 * r ** 2 * h print(\"원뿔의 부피는\", vol, \"입니다.\") else : #r, h가 음수일 때 print(\"반지름과 높이 값에 양수를 입력하세요\")#반지름 30, 높이 50rad = 30 hei = 50 prt_cone_vol(rad, hei) 함수 호출 만들어진 함수를 별도로 사용할 수 있는 방법 숫자 역순 출력 프로그램 숫자를 입력 받고 역순으로 출력하는 함수를 사용한 프로그램을 작성하시오. 역순으로 출력할 숫자를 입력하세요: 4567 7654 digits = 1234 def reverse_number(num): while num != 0: digit = num % 10 num = num // 10 print(digit, end=\"\") # 개행 문자 대신 한 줄에 이어서 출력 reverse_number(digits) 반환 값이 있는 함수원뿔 계산 프로그램 개선 원뿔 계산 결과 출력 결과 형식을 상황에 따라 변경하고 싶다면? # 원뿔 계산 함수 정의 def prt_cone_vol(r, h) if r &gt; 0 and h &gt; 0 : # r, h 모두 양수일 때 vol = 1 / 3 * 3.14 * r ** 2 * h print(\"원뿔의 부피는\" , vol, \"입니다.\") else : # r, h가 음수일 때 print(\"반지름과 높이 값에 양수를 입력하세요\") # 원뿔 계산 함수 정의 def prt_cone_vol(r, h): if r &gt; 0 and h &gt; 0 : # r, h 모두 양수일 때 vol = 1 / 3 * 3.14 * r ** 2 * h return vol else: # r, h가 음수일 때 print(\"반지름과 높이 값에 양수를 입력하세요\") 반환 값이 있는 함수 정의 구문 형식 실행 후 결과 값을 남기는 함수 return 명령어와 반환 값을 열거 함수 내부에 여러 개의 return 사용 가능 format 함수 실수 데이터 형식화 형식 지정자 def rtn_cone_vol(r, h): # 원뿔의 부피를 출력해주는 함수 정의 if r &gt; 0 and h &gt; 0 : # r, h 모두 양수일 때 vol = 1/3 * 3.14 * r ** 2 * h return vol else: # r, h가 음수일 때 print(\"반지름과 높이 값에 양수를 입력하세요\")# 원뿔 부피 계산 함수 호출rtn_cone_vol(10, 20)print(rtn_cone_vol(10, 20), \"입니다\")print(format(rtn_cone_vol(10, 20), \"&gt;20.3f\"), \"입니다\")print(format(rtn_cone_vol(10, 20), \"&lt;20.3f\"), \"입니다\")# 원뿔 계산 함수 정의def prt_cone_vol(r, h) : if r &gt; 0 and h &gt; 0 : # r, h 모두 양수일 때 vol = 1/3 * 3.14 * r ** 2 * h r, h = 0, 0 return vol else : # r, h가 음수일 때 print(\"반지름과 높이 값에 양수를 입력하세요\")#반지름 10, 높이 50rad = 10hei = 50print(format( prt_cone_vol(rad, hei) , \"&gt;10.3f\"))print(rad, hei)원뿔 계산 프로그램 개선 부피와 겉넓이를 모두 반환하려면? # 원뿔 계산 함수 정의 def prt_cone_vol(r, h) if r &gt; 0 and h &gt; 0: # r, h 모두 양수일 때 vol = 1/3 * 3.14 * r ** 2 * h return vol else: # r, h가 음수일 때 print(\"반지름과 높이 값에 양수를 입력하세요\") def rtn_cone_vol_surf(r, h): # 원뿔의 부피를 출력해주는 함수 정의 if r &gt; 0 and h &gt; 0 : # r, h 모두 양수일 때 vol = 1/3 * 3.14 * r ** 2 * hei surf = 3.14 * r ** 2 + 3.14 * r * h return vol, surf # vol과 surf 동시 리턴 else: # r, h가 음수일 때 print(\"반지름과 높이 값에 양수를 입력하세요\") print(rtn_cone_vol_surf(50, 100)) vol1, surf1 = rtn_cone_vol_surf(50, 100) print(vol1, \"입니다.\") print(surf1, \"입니다.\") 동시 할당의 개념 복수 개의 변수에 값을 동시에 할당 변수의 개수에 상응하는 값을 콤마(,)로 나열 temp = 27 season = \"summer\" temp, season = 27, \"summer\" 교환(swap) 복수 개의 변수에 할당하는 값을 맞바꿈 temp = hei hei = rad rad = temp rad, hei = hei, rad 정렬 프로그램 세 개의 사용자 입력을 오름차순으로 정렬하는 함수를 이용하여 정렬된 값을 출력하는 프로그램을 작성하시오. 첫번째 숫자를 입력하세요: 59 두번째 숫자를 입력하세요: 1 세번째 숫자를 입력하세요: 103 정렬된 숫자는 1, 59, 103 입니다. a = int(input(\"첫번째 숫자를 입력하세요: \")) b = int(input(\"두번째 숫자를 입력하세요: \")) c = int(input(\"세번째 숫자를 입력하세요: \")) def sort3(a, b, c): if a &gt; b: a, b = b, a if a &gt; c: a, c = c, a if b &gt; c: b, c = c, b print(a, b, c) sort3(a, b, c) print(\"출력 이후\" , a, b, c) # 함수 내부에는 값만 전달되므로, 변수에는 영향이 가지 않음 함수의 확장반환 값이 있는 함수의 호출# 원뿔 계산 함수 정의def prt_cone_vol(r, h) : if r &gt; 0 and h &gt; 0 : # r, h 모두 양수일 때 vol = 1/3 * 3.14 * r ** 2 * h return vol else : # r, h가 음수일 때 print(\"반지름과 높이 값에 양수를 입력하세요\") #반지름 10, 높이 50rad = 10hei = 50format(prt_cone_vol(rad, hei) , \"&gt;10.3f\")# 원뿔 계산 함수 정의def prt_cone_vol(r, h) : if r &gt; 0 and h &gt; 0 : # r, h 모두 양수일 때 vol = 1/3 * 3.14 * r ** 2 * h r, h = 0, 0 return vol else : # r, h가 음수일 때 print(\"반지름과 높이 값에 양수를 입력하세요\")#반지름 10, 높이 50rad = 10hei = 50print(format(prt_cone_vol(rad, hei) , \"&gt;10.3f\"))print(rad, hei)값의 전달 함수가 호출될 때, 값이 매개 변수에 전달 x = 1 print(\"x의 값은\", x) inc(x) # inc 함수 정의 전이기 때문에 오류 발생 def inc(x): x = x + 1 print(\"x의 값은\", x) print(\"x의 값은\", x) 값에 의한 전달이므로 함수 내부에서 계산된 값이 함수 외부에는 반영 되지 않음 변수가 전달 되는 것이 아니라 값이 전달됨 변수의 스코프 프로그램에서 변수가 참조될 수 있는 영역 x = 1 print(\"x의 값은\", x) def inc(x): x = x + 1 print(\"x의 값은\", x) \t\t inc(x) print(\"x의 값은\", x) 전역 변수 프로그램 전체 영역에서 접근 지역 변수 선언된 함수 내부에서만 접근 y 호출 부분에 오류 발생 함수 내부에서의 변수와 함수 외부에서의 변수는 다름 def rtn_cone_vol(r, h): # 원뿔의 부피를 출력해주는 함수 정의 if r &gt; 0 and h &gt; 0 : # r, h 모두 양수일 때 vol = 1/3 * 3.14 * r ** 2 * hei r, h = 0, 0 # 0으로 초기화 return vol else: # r, h가 음수일 때 print(\"반지름과 높이 값에 양수를 입력하세요\") radius = 50 height = 100 print(format(rtn_cone_vol(radius, height), \"&gt;10.3f\")) print(\"함수 사용 후 \", radius, height) 원뿔 계산 프로그램 개선 단위 원뿔(반지름 20, 높이 30)의 부피와 겉넓이를 출력하려면? # 원뿔 계산 함수 정의 def prt_cone_vol_surf(r, h) : if r &gt; 0 and h &gt; 0 : # r, h 모두 양수일 때 vol = 1/3 * 3.14 * r ** 2 * h suf = 3.14 * r ** 2 + 3.14 * r * h return vol, surf else : # r, h가 음수일 때 print(\"반지름과 높이 값에 양수를 입력하세요\") 기본 매개 변수 함수 호출 시 매개 변수가 전달되지 않을 경우 기본 값이 전달되는 매개 변수 print(\"Hello\", \"I am Python\") print(\"Hello\", \"I am Python\", sep = \" \") 기본 매개 변수의 정의 구문 형식 일반 매개 변수 앞에 위치할 수 없음 매개 변수를 입력하지 않으면 기본 값이 적용되는 프로그램 def rtn_cone_vol_surf(r = 20, h = 30): # 함수 정의 부분에 기본 값 지정 if r &gt; 0 and h &gt; 0 : # r, h 모두 양수일 때 vol = 1/3 * 3.14 * r ** 2 * hei surf = 3.14 * r ** 2 + 3.14 * r * h return vol, surf # vol과 surf 동시 리턴 else: # r, h가 음수일 때 print(\"반지름과 높이 값에 양수를 입력하세요\") print(rtn_cone_vol_surf(100, 200)) print(rtn_cone_vol_surf()) 원뿔 계산 프로그램 개선 반지름은 10이고 높이가 1, 5, 14, 26, 31인 원뿔의 부피와 겉넓이를 각각 출력하시오. 반지름 10 , 높이 1 원뿔 부피: 104.66666666666666 높이: 345.4 반지름 10 , 높이 5 원뿔 부피: 523.3333333333333 높이: 471.0 반지름 10 , 높이 31 원뿔 부피: 3244.6666666666665 높이: 1287.4 함수를 이용해서 만들되, 리스트를 만든 것과 같은 효과가 나는 프로그램 가변 매개 변수 함수 호출 시 매개 변수를 사용자가 원하는 개수 만큼 지정할 수 있는 매개 변수 x = 10 y = 20 z = 30 print(\"x는\", x, \"y는\", y, \"z는\", z) 변수의 개수가 한정되어 있지 않음 실제 전달 될 때 리스트 형태로 전달 됨 for 문 사용 시퀀스 개념을 사용하여 하나의 할당 연산자만으로 여러 값들을 한번에 전달 가변 매개 변수의 정의 구문 형식 일반 매개 변수 앞에 위치할 수 없음 가변 매개 변수는 1개만 사용 가능 파라미터의 개수가 가변적인 형태의 함수 파라미터의 개수가 정해지지 않았다면 파라미터로 넘어오는 값들은 시퀀스 형태로 전달 반복이 사용 됨 def var_sum_avg(*numbers): sum = 0 count = 0 # 파라미터의 개수를 알아내기 위한 변수 for i in numbers: # 시퀀스 내에 있는 값들을 하나씩 가져오기 위해 for문 사용 sum = sum + i count = count + 1 # 평균을 구하기 위해 파라미터의 개수 구함 return sum, sum/count print(var_sum_avg(10, 20, 30 , 40)) print(var_sum_avg(20, 25, 10, 85, 100 , 150)) # 입력 값의 개수가 달라져도 정상 동작함 연습 문제 다음 중 반환 값에 따른 함수의 종류를 구분할 때, 나머지와 다른 하나는? a. print 반환 값에 따른 함수의 종류가 같은 것 input format int 다음 코드의 실행 결과는? temp, season = 27, \"summer\" season, temp = temp, season print(season) a. 27 다음 코드의 실행 결과는? x = 1 def updatex(): x = 2 x = x + 1 updatex() print(x) a. 1 학습 정리 함수란 특정 작업을 함수의 이름 만으로 수행하는 명령문의 집합을 말함 반환 값의 유무에 따라 반환 값이 없는 함수와 반환 값이 있는 함수로 구분 됨 반환 값이 없는 함수는 함수 실행 후 어떤 값도 남기지 않는 함수임 반환 값이 있는 함수는 함수 내부에서 return 명령어를 통해 값을 남김 동시 할당이란 복수 개의 변수에 값을 동시에 할당하는 연산임 이를 통해 단일 명령문으로 변수의 값을 맞바꿈이 가능함 값의 전달에 의한 호출이란 함수 호출 시 함수 내부에는 매개 변수의 값이 전달 됨 변수의 스코프는 프로그램에서 변수가 참조 될 수 있는 영역임 변수의 스코프에 따라 변수는 전역 변수와 지역 변수로 구분 됨 기본 매개 변수란 함수 호출 시 매개 변수가 전달되지 않을 경우 기본 값이 전달 되는 매개 변수를 말함 함수 호출 시 매개 변수를 사용자가 원하는 개수 만큼 지정할 수 있는 매개 변수를 가변 매개 변수라고 하며, 함수 정의 시 매개 변수 이름 앞에 *를 사용함" }, { "title": "[Java 프로그래밍] 9강 - java.io 패키지와 스트림", "url": "/posts/knou-java-9/", "categories": "Language, Java", "tags": "knou, java", "date": "2025-04-25 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김희천 교수님의 'Java 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 File클래스는 파일과 디렉터리의 생성과 삭제, 정보의 검색과 변경 기능을 제공하나 입출력 기능을 제공하지는 않음 Java 언어에서 스트림을 통해 입출력을 수행할 수 있음 입력 스트림과 출력 스트림, 바이트 단위 스트림과 캐릭터 단위 스트림, 기본 스트림과 보조 스트림의 차이를 살펴봄학습 목표 스트림 개념을 이해하고 종류와 특성을 설명할 수 있음 File클래스의 사용법을 설명할 수 있음 RandomAccessFile클래스를 사용하여 파일 입출력을 할 수 있음 보조 스트림 클래스를 사용하여 입출력을 할 수 있음강의록입출력 스트림입출력 스트림 Java 프로그램에서 스트림을 통해 입출력을 수행할 수 있음 입력 스트림은 데이터 생산자(소스)와 프로그램을 연결 출력 스트림은 프로그램과 데이터 소비자(목적지)를 연결 입출력 종류(파일, 주변 장치, 네트워크 소켓 등)에 상관없이 동일한 방법으로 프로그램을 작성 스트림을 통해 입출력을 제어함 입출력에 필요한 스트림 클래스는 java.io패키지에서 제공 스트림의 정의와 특성 데이터 생상자(또는 데이터 소비자)와 프로그램 사이 데이터의 흐름 순서가 있는 일련의 데이터 흐름으로, 정해진 방향으로 전달되고, 순차적으로 접근할 수 있음 입력 스트림과 출력 스트림 프로그램은 입력 스트림으로부터 데이터를 읽을 수 있음 외부로부터 데이터를 읽어 프로그램으로 가져오기 위한 스트림 데이터 소스가 설정 되어야 함 프로그램은 출력 스트림으로 데이터를 쓸 수 있음 프로그램에서 데이터를 생성하여 외부로 보내기 위한 스트림 데이터 목적지가 설정되어야 함 스트림의 분류 바이트 스트림과 캐릭터 스트림 바이트 스트림은 byte 단위로 데이터를 다룸 관련 클래스는 xxxInputStream과 xxxOutputStream 캐릭터 스트림은 char 단위로 데이터를 다룸 관련 클래스는 xxxReader과 xxxWriter 기본 스트림과 보조 스트림 기본 스트림은 입출력 기능을 제공하는 스트림 보조 스트림은 자체적으로 입출력 기능을 수행할 수는 없으며, 기본 스트림과 함께 사용되어 보조 기능을 제공하는 스트림 스트림 관련 클래스 처리 단위 처리 방향 입력 스트림 출력 스트림 기본 스트림 바이트 스트림 InputStream, FileInputStream, ByteArrayInputStream OutputStream, FileOutputStream, ByteArrayOutputStream   문자 스트림 Reader, FileReader, CharArrayReader, StringReader Writer, FileWriter, CharArrayWriter, StringWriter 보조 스트림 바이트 스트림 BufferedInputStream, DataInputStream, ObjectInputStream BufferedOutputStream, PrintStream, DataOutputStream, ObjectOutputStream   문자 스트림 BufferedReader BufferedWriter, PrintWriter   기타 InputStreamReader OutputStreamWriter 프로그램에서 스트림 사용하기 프로그램에서 어떤 스트림 클래스를 사용할 것인가? FileInputStream fis = new FileInputStream( ); BufferedInputStream bis = new BufferedInputStream(fis); 입력 스트림? 출력 스트림? 데이터 생산자와 소비자를 결정 기본 스트림을 반드시 사용해야 함 문자 단위? 바이트 단위? 보조 스트림이 필요한가? 필요하다면 기본 스트림 객체를 먼저 생성하고, 기본 스트림을 감싸 보조 스트림 객체를 생성함 바이트 스트림InputStream클래스 바이트 단위 입력 스트림 클래스 중 최상위 추상 클래스 이것의 하위 클래스는 xxxInputStream 주요 메소드 read메소드 입력 스트림으로부터 1 바이트를 읽어 정수로 리턴함 abstract int read( ) 입력 스트림으로부터 읽어서 byte 배열에 저장하고 읽어 들인 바이트 개수를 리턴 int read(byte[] b) len 바이트를 읽어서 바이트 배열의 off 위치부터 저장함 int read(byte[] b, int off, int len) available메소드 다음 read()할 때, 블로킹 없이 입력 스트림에서 읽을 수 있는 바이트 단위의 데이터 길이 int available() skip메소드 입력 스트림에서 n 바이트를 건너 뜀 long skip(long n) mark메소드 입력 스트림에서 현재 위치를 표시함 void mark(int readlimit) reset메소드 mark()에서 표시 된 위치로 스트림의 현재 위치를 이동 void reset() OutputStream클래스 바이트 단위 출력 스트림 클래스 중 최상위 추상 클래스 이것의 하위 클래스는 xxxOutputStream 주요 메소드 write메소드 1 바이트의 데이터를 출력 스트림에 씀 void write(int b) byte형 배열 b의 모든 바이트를 출력 스트림에 씀 void write(byte[] b) byte형 배열 b의 off 위치부터 len 바이트를 출력 스트림에 씀 void write(byte[] b, int off, int len) close메소드 출력 스트림을 닫고 자원을 돌려줌 void close() flush메소드 출력 스트림에 남아 있는 모든 데이터를 최종 목적지로 보냄 void flush() Reader클래스 입력용 캐릭터 단위 스트림 클래스 중 최상위 추상 클래스 이것의 하위 클래스는 xxxReader 주요 메소드 read메소드 입력 스트림에서 1개 문자(2바이트)를 읽어 리턴함 int read() 입력 스트림에서 문자들을 읽어 char형 배열 cbuf에 저장하고, 읽어 들인 문자의 개수를 리턴함 int read(char[] cbuf) ready메소드 입력 스트림에 입력 데이터가 준비되었으면 true를 리턴함 boolean ready() close메소드 입력 스트림을 닫고 자원을 반환 함 abstract void close() Writer클래스 출력용 캐릭터 단위 스트림 클래스 중 최상위 추상 클래스 이것의 하위 클래스는 xxxWriter 주요 메소드 write메소드 1개의 문자(2 바이트)를 출력 스트림에 씀 void write(int c) char형 배열 cbuf의 모든 문자를 출력 스트림에 씀 void write(char[] cbuf) 문자열 str을 출력 스트림에 씀 void write(String str) 문자열 str에서 off 위치부터 len 개의 문자를 출력 스트림에 씀 void write(String str, int off, int len) close메소드 출력 스트림을 닫고 자원을 반환함 abstract void close( ) flush메소드 출력 스트림에 남아 있는 모든 데이터를 최종 목적지로 보냄 void flush( ) 파일 입출력File클래스 파일이나 디렉터리를 표현 상대 또는 절대 경로(path)를 가짐 파일이나 디렉터리의 정보 조회 또는 조작 기능을 제공 이름과 경로의 조회 파일과 디렉토리의 생성과 삭제 입출력 메소드는 제공되지 않음 생성자 File(String pathname) File myFile1 = new File(\"D:\\\\eclipse\\\\workspace\\\\Test\\\\src\"); File myFile2 = new File(\"notepad.exe\"); pathname은 상대 또는 절대 경로로 표현될 수 있음 File클래스의 주요 메소드 주요 메소드 exists메소드 File객체로 표현된 것이 실제 파일 또는 디렉터리로 존재하는가 boolean exists() isDirectory메소드 File객체에 지정된 경로가 디렉터리인가 boolean isDirectory() isFile메소드 File객체에 지정된 경로가 파일인가 boolean isFile() getName메소드 파일 또는 디렉터리의 이름을 리턴함 String getName() getPath메소드 경로 전체를 리턴함 String getPath() length메소드 파일인 경우, 크기를 바이트 단위로 리턴함 long length() createNewFile메소드 File객체에 지정된 파일을 생성함 boolean createNewFile() delete메소드 File객체에 지정 된 파일이나 디렉터리를 삭제함 boolean delete() mkdir메소드 File객체에 지정된 것을 디렉터리로 만듦 맨 마지막 디렉터리만 생성할 수 있음 boolean mkdir() mkdirs메소드 mkdir메소드와 같으나 지정 된 경로 상의 모든 필요한 디렉터리를 생성 boolean mkdirs() list메소드 File객체에 지정 된 디렉터리 안에 포함 된 파일과 디렉터리의 이름을 문자열 배열로 리턴함 String[] list() listFiles메소드 list메소드와 같으나 File객체의 배열로 리턴함 File[] listFiles() getParent메소드 상위 디렉터리 이름을 문자열로 리턴함 String getParent() getParentFile메소드 상위 디렉터리를 File객체로 리턴함 File getParentFile() listRoots메소드 파일 시스템에 존재하는 루트 디렉터리를 File객체의 배열로 리턴함 static File[] listRoots() File클래스 예제 디렉터리 내용 보여주기 import java.io.*; public class Main { public static void main(String args[]) { File file = new File(\"c:\\\\windows\"); File files[] = file.listFiles(); int i = 0; while(i &lt; files.length) { System.out.print(files[i].getPath()); System.out.println(\"\\t\" + files[i].length()); i++; } }\t } // c:\\windows\\addins 0 // c:\\windows\\AgSetup.logs 90624 // c:\\windows\\AhnInst.log 2328622 RandomAccessFile클래스 랜덤 엑세스 파일 파일의 임의 위치에서 읽기 또는 쓰기 연산을 지원 파일을 오픈하고, 위치를 지정하고, 읽기 또는 쓰기를 함 읽고 쓰는 위치는 파일 포인터가 가리킴 파일 포인터가 가리키는 위치부터 바이트 단위로 읽거나 쓸 수 있음 byte 단위로 읽고 쓰며, 읽거나 쓸 때 파일 포인터가 이동 됨 랜덤 엑세스 파일을 커다란 byte 배열로 볼 수 있음 RandomAccessFile클래스의 메소드 생성자 RandomAccessFile(File file, String mode) RandomAccessFile(String name, String mode) mode는 읽기 전용의 r또는 읽기/쓰기 겸용의 rw 주요 메소드 read메소드 파일로부터 1 바이트를 읽어 리턴함 int read() 파일로부터 읽어 byte 배열에 저장함 int read(byte[] b) 파일로부터 최대 len 바이트를 읽어 byte형 배열의 off 위치부터 저장함 int read(byte[] b, int off, int len) seek메소드 pos에 지정 된 위치로 파일 포인터를 이동함 void seek(long pos) write메소드 byte 배열의 내용을 파일에 씀 void write(byte[] b) byte 배열에서 off 위치부터 len 바이트를 파일에 씀 void write(byte[] b, int off, int len) RandomAccessFile클래스 예제 RandomAccessFile이용하여 파일에 쓰고 읽기 import java.io.*; public class Main { public static void main(String args[]) { try (RandomAccessFile raf = new RandomAccessFile(\"c:\\\\java\\\\test.txt\", \"rw\")) { for(int i = 0; i &lt; 10; i++) raf.write(i); for(int i = 9; i &gt;= 0; i--) { raf.seek(i); System.out.print(raf.read( )); } raf.close(); } catch (Exception e) { System.out.println(e); } } } // 9876543210 FileInputStream과 FileOutputStream클래스 파일로부터 데이터를 읽기/쓰기 위한 입력/출력용 기본 스트림 바이트 단위의 입력/출력을 처리하므로 이미지나 오디오 파일과 같은 이진 파일을 다룰 때 유용함 FileInputStream클래스의 생성자 기존 파일과 연결된 입력 스트림 객체를 생성 FileInputStream(File file) FileInputStream(String name) FileOutputStream클래스의 생성자 기존 파일(없다면 생성)과 연결된 출력 스트림 객체를 생성 FileOutputStream(String name) FileOutputStream(File file, boolean append) FileOutputStream예제 FileOutputStream클래스 사용 예 import java.io.*; public class Main { public static void main(String args[]) { File inFile = new File(\"D:\\\\01_KNOU\\\\test.txt\"); // 입력 파일 경로 지정 File outFile = new File(\"D:\\\\01_KNOU\\\\test2.txt\"); // 출력 파일 경로 지정 // try-with-resources 문을 사용해 자원을 자동으로 닫음 try ( InputStream is = new FileInputStream(inFile); OutputStream os = new FileOutputStream(outFile)) { int nData; nData = is.read(); // 파일에서 1바이트 읽기 while(nData != -1) { // 파일 끝까지 반복 os.write(nData); // 읽은 바이트를 출력 파일에 쓰기 nData = is.read(); // 다음 바이트 읽기 } } catch (Exception e) { System.out.println(e); } } } FileReader와 FileWriter클래스 텍스트 파일을 읽거나 쓰는데 사용되는 기본 스트림 문자 단위로 입력 또는 출력을 처리 FileReader클래스의 생성자 FileReader(File file) FileReader(String fileName) FileWriter클래스의 생성자 FileWriter(File file) FileWriter(String fileName) FileWriter(File file, boolean append) 콘솔 입출력과 보조 스트림Console클래스 콘솔 입출력을 제공하는 클래스 키보드 입력과 화면 출력을 편리하게 지원 명령 프롬프트 창과 같은 콘솔 환경에서 사용자와의 상호 작용을 지원 System.console()을 사용하여 콘솔 객체를 생성함 주요 메소드 readLine메소드 콘솔에서 한 라인을 읽음 String readLine() readPasssword메소드 콘솔에서 비밀번호를 읽음. 비밀번호를 입력할 때 화면에 보이지 않음 char[] readPasssword() writer메소드 콘솔과 연결 된 PrintWriter 객체를 리턴함 PrintWriter writer() reader메소드 콘솔과 연결 된 Reader 객체를 리턴함 Reader reader() Console클래스 예제 Console클래스를 이용한 입출력 import java.io.*; public class Main { public static void main(String args[]) { String name; char[] pw; Console con = System.console(); System.out.print(\"name : \"); name = con.readLine( ); System.out.print(\"password : \"); pw = con.readPassword( ); con.printf(\"name : %s\\n\", name); con.printf(\"password : %s\\n\", new String(pw)); } } // name : kildong // password : // name : kildong // password : [C@16d3586 보조 스트림 기본 스트림의 성능을 높이거나 편의성을 높이는 보조 기능을 제공하는 스트림 입출력 기능은 기본 스트림을 이용해야 함 기본 스트림 객체를 먼저 생성하고, 이것을 보조 스트림 객체를 생성할 때, 생성자의 인자로 이용함 FileInputStream fis = new FileInputStream(\"text.txt\"); BufferedInputStream bis = new BufferedInputStream(fis); 기본 스트림을 보조 스트림으로 감싼다라고 함 프로그램에서는 보조 스트림 객체를 사용해 입출력하면 됨 보조 스트림의 종류 버퍼링 기능의 제공 BufferedInputStream, BufferedOutputStream BufferedReader, BufferedWriter Java의 기본 자료형을 그대로 읽기/쓰기 위한 기능의 제공 DataInputStream, DataOutputStream 다양한 출력 형식의 제공 PrintStream, PrintWriter 텍스트 파일을 라인 단위로 읽거나 라인 번호를 관리하는 메소드 제공 LineNumberReader 바이트 스트림과 캐릭터 스트림의 호환 InputStreamReader, OutputStreamWriter LineNumberReader클래스 텍스트 파일을 라인 단위로 읽어 들이는 메소드 제공 import java.io.*; public class Main { public static void main(String args[]) { try (FileReader fr = new FileReader(new File(\"c:\\\\Java\\\\Main.java\")); LineNumberReader rd = new LineNumberReader(fr)) { String line; while ((line = rd.readLine()) != null) { System.out.println(line); } } catch (Exception e) { System.out.println(e); } } } BufferedReader의 서브 클래스 주요 메소드 int read() String readLine() int getLineNumber() long skip(long) InputStreamReader클래스 바이트 입력 스트림을 캐릭터 입력 스트림으로 변환해 주는 클래스 바이트 단위로 읽히는 스트림을 문자 단위로 읽을 수 있게 함 특정 문자 인코딩을 사용하여 변환할 수 있음 try (InputStreamReader isr = new InputStreamReader(System.in, \"euc-kr\")) { while ((i = isr.read()) != '끝') { System.out.print((char) i); } } catch (Exception e) { System.out.println(e); } // abc // abc // 한국 // 한국 // 땅끝 // 땅 바이트 단위로 읽은 후 문자로 바꾸어 처리함 생성자 InputStreamReader(InputStream in, Charset cs) 주요 메서드 int read() **//** 1개 문자를 읽어 리턴함 int read(char[] cbuf, int offset, int length) 학습 정리 Java 프로그램에서는 스트림을 통해 데이터 생산자(또는 소비자)의 종류와 무관하게 동일한 방법으로 입력(또는 출력)을 수행할 수 있음 File클래스는 파일(또는 디렉터리)를 표현하는 클래스로 파일(또는 디렉터리)를 조작할 수 있는 메소드를 제공하나 입출력 메소드는 제공하지 않음 RandomAccessFile클래스는 파일의 읽기/쓰기를 지원하며 파일 포인터가 가리키는 임의의 위치에 읽기/쓰기가 가능함 BufferedInputStream(OutputStream)과 BufferedReader(Writer)는 보조 스트림으로 버퍼링 기능을 제공하여 입출력 성능을 향상 시킴 기본 스트림의 객체를 먼저 생성하고, 그 객체를 인자로 하여 보조 스트림 객체를 생성함 InputStreamReader는 바이트 단위 입력 스트림을 캐릭터 단위 입력 스트림으로 변환하는 기능을 함연습 문제 입력 스트림은 기본 스트림과 보조 스트림으로 나뉜다. 다음 중 기본 스트림에 해당하지 않는 것은? a. BufferedReader 기본 스트림에 해당 하는 것은? CharArrayReader FileReader ByteArrayInputStream BufferedReader 클래스에 관한 설명으로 틀린 것은 무엇인가? a. 바이트 단위의 입력 기능을 제공한다. BufferedReader클래스에 관한 설명으로 옳은 것은? Reader의 자식 클래스임 read()와 readLine()등 다양한 입력 메소드를 제공함 입력 과정에 버퍼링 기능을 제공함 키보드에서 한글을 입력받기 위해서 바이트 단위의 표준 입력 스트림(System.in)을 캐릭터 스트림으로 변환하는 것이 필요하다. 다음 밑줄 부분에 공통으로 들어갈 클래스 이름은 무엇인가? _____ isr = new _____ (System.in); try { \tint i = isr.read( ); \tSystem.out.println((char) i); } a. InputStreamReader " }, { "title": "[데이터 정보 처리 입문] 9강 - 엑셀을 이용한 그래프 그리기 2", "url": "/posts/knou-dip-9/", "categories": "Data Science, Data Analysis", "tags": "knou, data information processing", "date": "2025-04-25 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김성수, 이기재 교수님의 '데이터 정보 처리 입문' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 엑셀을 활용하면 그래프를 손쉽게 작성할 수 있고, 이를 통해서 데이터가 갖고 있는 정보를 시각적으로 나타낼 수 있음 히스토그램, 산점도 작성 법에 대하여 엑셀 실습과 함께 살펴봄 히스토그램을 그리기 위한 기초 작업인 도수 분포 표 작성 법을 공부하고, 상관 분석을 통해서 두 변수 사이의 연관성 분석에 대해서 공부 함학습 목표 도수 분포를 작성할 수 있음 엑셀을 이용하여 히스토그램을 작성할 수 있음 산점도를 작성하여 두 변수의 연관성을 설명할 수 있음 상관 분석의 개념과 분석 결과를 해석할 수 있음주요 용어 도수 분포 표(frequency table) 겹치지 않는 몇 개의 범주 즉, 계급에 속한 관측 치의 개수를 요약하여 작성한 표 정성적 데이터뿐만 아니라 정량적 데이터에도 적용할 수 있음 히스토그램(histogram) 연속 형 데이터에 대해서 데이터의 특징이나 분포 모양을 살펴볼 때 널리 이용되는 그래프 수평 축 위에 계급 구간을 표시하고 그 위로 각 계급의 상대 도수에 비례하는 넓이의 직사각형을 그린 것 산점도(scatter plot) 두 연속형 변수 사이의 관계를 그래프를 통해서 살펴보고자 할 때 사용되는 그래프 두 변수 사이의 연관성 정도를 살펴보기 위한 분석의 첫 단계임 상관 계수 두 변수간의 선형 관계(직선 관계)의 정도를 나타내 주는 측도임 상관 계수는 -1과 1사이의 값을 갖고, 절대 값이 1에 가까울수록 두 변수는 강한 선형 연관성, 상관 계수의 절대 값이 0에 가까울수록 약한 선형 연관성이 있다고 함 강의록히스토그램도수 분포 표(frequency table) 겹치지 않는 몇 개의 범주 즉, 계급에 속한 관측 치의 개수를 요약하여 작성한 표 정성적 데이터뿐만 아니라 정량적 데이터에도 적용할 수 있음 정량적 데이터에 대한 도수 분포 표를 작성할 때는 사용되는 범주(계급)정의에 세심한 고려가 필요함도수 분포 표 작성 방법 데이터 수를 세고 데이터의 최대 값과 최소 값을 구함 계급의 수 결정 √n ± 2~3 (보통 5에서 20개) 계급의 폭 결정 계급의 폭 = (최대 값 - 최소 값)/계급의 수 계급의 경계 값과 중앙 값을 구함 첫 번째 하한 경계 값 = 최소 값 - (측정의 최소 단위/2) 첫 번째 상한 경계 값 = 하한 경계 값 + 계급의 폭 계급 값 = (하한 경계 값 + 상한 경계 값) / 2 도수 분포 표 작성히스토그램(histogram) 연속형 데이터에 대하여 데이터의 특징이나 분포 모양을 살펴볼 때 널리 이용되는 그래프 수평 축 위에 계급 구간을 표시하고 그 위로 각 계급의 상대 도수에 비례하는 넓이의 직사각형을 그린 것히스토그램 그리기 절차 [데이터] 탭의 [분석] 그룹의 [데이터 분석] 명령을 선택 분석 도구 중 ‘히스토그램‘을 선택하고 [확인]을 선택 만약 [데이터 분석] 명령이 없으면 [파일] 단추를 클릭한 후 [옵션]에서 [추가 기능]을 선택하여 분석 도구 항목을 선택함 대화 상자에서 ‘입력 범위‘에 데이터 범위 지정 ‘출력 옵션’에서 히스토그램을 출력할 셀 주소를 입력하거나 ‘새로운 워크시트’를 선택한 후 ‘차트 출력‘을 클릭 히스토그램 수정 히스토그램의 여러 막대 중 하나를 선택하고, 마우스의 오른쪽 단추를 클릭 [단축 메뉴]에서 [데이터 계열 서식]을 선택 후 데이터 계열 서식 대화 상자에서 [계열 옵션] 탭을 선택 ‘간격 너비(W)’ 입력란에 150 대신에 0을 입력하고 [확인]을 선택 차트 도구 모음에서 히스토그램 그리기 산점도와 상관 분석산점도(scatter plot) 두 연속 형 변수 사이의 관계를 그래프를 통해서 살펴보기 위해서 사용함 두 변수 사이의 연관성 정도를 살펴보기 위한 분석의 첫 단계산점도 그리기 데이터를 선택하고, [삽입] 리본메뉴의 [차트] 그룹에서 ‘분산형’ 선택 ‘분산형’ 차트 유형 중에서 적합한 세부 차트 모양 결정 차트마법사 대화상자 제 2단계에서 ‘계열 위치‘를 지정 출력 결과 상관 분석 상관 계수 두 변수 간의 선형 관계(직선 관계)의 정도를 나타내 주는 측도 상관 계수 ρ는 -1과 1사이 값을 가짐 ** ρ 의 값이 1에 가까울수록** 두 변수는 강한 선형 연관성 ** ρ 의 값이 0에 가까울수록** 두 변수는 약한 선형 연관성 산점도와 상관 계수상관 분석 절차 [데이터] 탭의 [분석] 그룹에서 [데이터 분석] 명령 선택 통계 데이터 분석 대화 상자에서 ‘상관 분석’ 항목을 선택 대화 상자에 ‘입력 범위‘와 ‘데이터 방향‘을 지정함 ‘첫째 행 이름표 사용’ 체크 박스는 첫째 행의 정보를 변수 이름으로 사용하고자 하는 가를 묻는 항목임 출력 결과 두 변수 간의 상관 계수는 -0.82임 두 변수 간에 뚜렷한 음의 상관 관계가 있다고 할 수 있음 실습 : 성적데이터 히스토그램 : 통계 분석 도구 이용 히스토그램 : 차트 이용 산점도 그리기 상관 계수 구하기 연습 문제 풀이 10명의 음식 전문가가 서울 시내 유명 양식 점 3곳을 조사하여 맛, 가격, 청결도, 서비스, 분위기의 5개 항목을 5점 척도(대단히 만족:5, 만족:4, 보통: 3, 불만족:2, 대단히 불만족:1) 조사함 세 음식점의 질을 종합적으로 비교하기 위한 차트는? 방사형 차트 연습 문제 두 연속인 변수 X와 Y 사이의 상관 계수를 구했더니 0.9가 나왔다. 올바른 해석은? a. X 값이 커지면 Y 값은 직선 관계를 가지고 커진다. 도수 분포 표에 대한 다음 설명 중 옳지 않은 것은? a. 정성적 데이터에 대한 분석에는 활용할 수 없다. 도수 분포 표에 대한 옳은 설명은? 겹치지 않는 몇 개의 범주 또는 계급에 속한 관측 치의 개수를 요약하여 작성한 표임 연속형 데이터에 대한 분석에서 도수 분포 표를 기초로 히스토그램을 그릴 수 있음 연속형 데이터에 대해 도수 분포 표를 작성할 때는 계급의 개수와 폭을 결정하는 것이 중요함 두 변수들 사이의 관계를 살펴보기 위해 산점도를 그리고자 한다. 차트 마법사의 차트 종류 입력 상자에서 선택할 차트 종류는?  a. 분산 형 엑셀 함수를 이용하여 구한 시간의 흐름에 따른 전압 값을 다음과 같은 그래프로 표시하였다. 이와 같은 그래프를 얻기 위해서 사용된 엑셀 차트의 유형은 무엇인가? a. 분산형 다음의 산점도에 대한 상관계수로 가장 적합할 것으로 생각되는 값은? a. r = 0.92 " }, { "title": "[유비쿼터스 컴퓨팅 개론] 8강 - 클라우드 컴퓨팅", "url": "/posts/knou-uqc-8/", "categories": "Computer Science, CS Theory", "tags": "knou, ubiquitous computing", "date": "2025-04-22 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정광식 교수님의 '유비쿼터스 컴퓨팅 개론' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 클라우드 컴퓨팅은 인터넷을 통해 액세스할 수 있는 IT 서비스로서 사용자가 신청하여 즉시 사용할 수 있고, 사용한 만큼 비용을 지불하는 컴퓨팅 서비스임 클라우드 서비스는 우리 주변에서 쉽게 찾아볼 수 있고 개인적인 업무 뿐 만 아니라 기업체의 전산 시스템과 서비스의 기반 플랫폼이 되었음 특히 우리나라에서는 민간 클라우드를 공공 기관의 업무에 활용하기 위하여 정부 규정 및 지침에 맞춰 G 클라우드 시스템을 구축하고 클라우드 서비스의 활성화를 꾀하고 있음 4차 산업혁명의 기반 시스템인 클라우드 컴퓨팅 의 개념과 정의, 그리고 데이터 클라우드에 관해서 살펴봄학습 목표 클라우드 컴퓨팅의 정의 및 특징을 이해함 클라우드 컴퓨팅 배포 모델과 클라우드 컴퓨팅 서비스 모델에 대해서 살펴봄 데이터 클라우드의 개념과 특징을 알아봄강의록클라우드 컴퓨팅클라우드 컴퓨팅 개요 인터넷을 의미하는 ‘클라우드(cloud)’와 컴퓨터의 다양한 기능을 뜻하는 ‘컴퓨팅(computing)’이 결합되어 ‘클라우드 컴퓨팅‘이라는 신조어가 탄생하였음 클라우드 컴퓨팅은 인터넷을 통해 액세스할 수 있는 IT 서비스로서 사용자가 신청하여 즉시 사용할 수 있고 사용한 만큼 비용을 지불하는 컴퓨팅 서비스 1961년 스탠퍼드 대학의 존 매카시(John McCarth)가 제시한 현재의 클라우드 컴퓨팅과 유사한 개념의 전화 시스템과 같은 공공 유틸리티 시설처럼 구성되는 유틸리티 컴퓨팅(utility computing) 미래의 컴퓨팅 환경으로 예견하였음 1970년 인터넷의 시초인 ARPANET의 등장과 함께 현실적으로 인식되기 시작함 1996년 컴팩 컴퓨터(Compaq Computer)사의 ‘Internet Solution Division’ 전략 보고서에서 클라우드 컴퓨팅이라는 용어가 등장함 2002년 아마존의 아마존 웹 서비스(AWS: Amazon Web Service)가 시작되면서 본격적인 상업적 클라우드 서비스가 시작되었음 현재는 아마존, 구글, 마이크로소프트에서 제공하는 클라우드 서비스와 국내의 KT 및 네이버에서 다양한 클라우드 서비스를 제공하고 있음 클라우드 컴퓨팅의 개념 일반적으로 사용료와 계약 조건에 따라 사용자 수에 대한 제한이 달라짐 사용자의 필요 용도에 따라 클라우드 컴퓨팅에서 제공하는 서비스의 성능도 가변적으로 변경 가능함클라우드 컴퓨팅의 정의 미국 국립표준기술연구소는 “클라우드 컴퓨팅은 컴퓨팅 리소스에 언제, 어디서나 필요에 따라 편리하게 네트워크를 통해 접근하는 기능을 제공하는 컴퓨팅 모델이다” 라고 정의하고 있음 가트너(Gartner)의 보고서에서는 “확장 가능하고 탄력적인 기능이 인터넷을 사용하는 외부 고객들에게 서비스 형태로 제공되는 컴퓨팅 방식이다” 라고 정의하고 있음. 우리나라는 2017년에 제정된 「클라우드 컴퓨팅 발전 및 이용자 보호에 관한 법률」에서 클라우드 컴퓨팅 집적 · 공유된 정보 통신 기기, 정보 통신 설비, 소프트웨어 등 정보 통신 자원을 이용자의 요구나 수요 변화에 따라 정보 통신 망을 통하여 신축적으로 이용할 수 있도록 하는 정보 처리 체계를 말한다 클라우드 컴퓨팅 서비스 클라우드 컴퓨팅을 활용하여 상용으로 타인에게 정보 통신 자원을 제공하는 서비스”라고 정의함 클라우드 컴퓨팅에서 공유되는 컴퓨팅 자원은 하드웨어와 소프트 웨어로 구분할 수 있음 하드웨어(H/W) 물리 서버, CPU, 메모리, 네트워크 장비, 저장 장치 등 소프트웨어(S/W) 운영 체제, 애플리케이션, 그룹 웨어 등 필요한 컴퓨팅 자원을 직접 구매하고 설치하거나 물리적인 컴퓨팅 환경을 구축하지 않아도 사용자가 원하는 작업을 장소와 시간에 구애 받지 않고 통신 네트워크를 이용하여 활용할 수 있음 클라우드 컴퓨팅에서 제공되는 특정 프로그램은 물리적인 위치에 대한 인식 없이 인터넷을 통해 접속하고, 사용자가 원하는 작업 및 서비스를 제공 받을 수 있는 것이 클라우드 컴퓨팅임 즉, 사용자가 원하는 서비스는 통신 네트워크를 통해 제공되며, 언제, 어디서나 컴퓨팅 자원에 접근과 사용이 가능해야 함클라우드 컴퓨팅의 장점 클라우드 컴퓨팅은 사용자에게 유연하고 편리한 접근성, 상황 변화에 대한 시스템 적용의 민첩성 및 확장성, 정보 서비스 및 시스템의 가용성과 유연성이 향상되는 이점을 제공함 특히 가변적인 외부 환경과 서비스 수요에 대한 능동적인 확장과 축소를 가능하게 함으로써 시스템 변화에 대한 비용 효율성을 제공함 비용 절감 IT 인프라 구축 및 관리 비용 절감, 사용한 만큼 지불하는 방식으로 비용 효율성 증대 유연성 및 확장성 필요에 따라 자원을 동적으로 할당하고 확장하거나 축소할 수 있음 접근성 인터넷 연결을 통해 언제 어디서든 데이터와 애플리케이션에 접근 가능 관리 효율성 클라우드 제공 업체가 인프라를 관리하므로 사용자는 핵심 비즈니스에 집중 가능 혁신 가속화 최신 기술과 서비스를 빠르게 도입하여 혁신적인 서비스 개발 및 제공 컴퓨팅 서비스 환경의 발전클라우드 컴퓨팅의 발전 배경 특히 인공 지능과 빅데이터와 같이 데이터 처리를 위한 필수 컴퓨팅 자원의 규모가 지속적으로 증가하면서 슈퍼 컴퓨터와 유사한 컴퓨팅 자원이 필요해졌음 하지만 개별 기업이나 연구소가 슈퍼 컴퓨터를 운영하는 것은 현실적이지 않았으며, 이에 대한 최적의 대안으로 떠오른 것이 클라우드 컴퓨터임 기술 발전 가상화, 분산 처리, 고성능 네트워크 등 핵심 기술의 발전 경제적 요인 IT 자원의 효율적 활용 및 비용 절감 요구 증대 비즈니스 환경 변화 디지털 전환 가속화 및 유연한 IT 인프라 필요성 증가 사용자 요구 언제 어디서나 정보에 접근하고 싶어 하는 사용자 요구 증가 모바일 확산 스마트폰, 태블릿 등 모바일 기기의 확산으로 클라우드 서비스 이용 증가 클라우드 컴퓨팅의 배경 서버의 유후 컴퓨팅 자원의 활용과 타 서버의 갑작스럽고 순간적인 컴퓨팅 자원의 부족이 맞물리는 상황에서, 경제적인 유휴 컴퓨팅 자원 활용에 대한 요구가 증가하면서 클라우드 컴퓨팅이 가장 적절한 대안이 되었음 중앙 처리 장치(CPU)의 처리 속도와 메인 메모리(RAM)의 저장 용량, 5G와 같은 초고속 통신 네트워크 기술과 같은 하드웨어 기술의 급속한 발전이 클라우드 컴퓨팅의 기반이 되었음 개인 및 기업 사용자에 대한 개별화 및 맞춤형 형태의 정보 통신 서비스에 대한 수요가 증가하였음 이에 따라 수집하고 관리해야 할 데이터가 증가하였고, 이러한 데이터의 처리는 정보 통신 서비스의 품질을 결정하는 결정적인 요소가 되었음클라우드 컴퓨팅의 특징 서비스 접근 용이성 시간과 장소에 상관 없이 통신 네트워크를 통해 클라우드 서비스의 이용이 가능하며, 표준화 된 접속을 통해 다양한 컴퓨팅 환경에서 서비스를 활용할 수 있음 서비스의 유연한 운영 클라우드 공급자는 갑작스러운 사용량 및 인원수 증가와 감소에 대해 능동적이고 유연하게 확장 및 축소를 할 수 있고, 신속하고 유연하게 대응할 수 있음 시스템의 유지 · 보수의 편리함 물리적 인프라의 구성이 불필요하며, 시스템의 관리 · 유지에 필요한 모든 부분이 소프트웨어 형식으로 제공되므로, 서비스의 형태에 따라 클라우드 제공업자에게 운영이 위탁되어 운영 및 확장 등의 관리 작업이 불필요함 보안 효율성 사용자는 클라우드 서비스 제공자와 직접적인 상호 작용을 거치지 않고, 자율적으로 자신이 원하는 클라우드 서비스를 이용할 수 있음 컴퓨팅 자원의 확장성 하나의 서버를 여러 대의 서버처럼 사용하거나 여러 서버를 하나로 묶어 운영하는 가상화 기술을 접목하여 컴퓨팅 자원의 사용을 최적화할 수 있으며, 방대한 작업을 여러 서버에 분산처리할 수 있어 시스템 부하를 최소화할 수 있음 사용 기준 비용 사용자는 클라우드 서비스 사용량에 대해서만 비용을 지불함 클라우드 아키텍처 클라우드 아키텍처는 가상화 기술을 이용하여 물리적인 시스템 계층, 가상화 계층, 프로비저닝 계층, 클라우드 컴퓨팅 서비스 관리 체계 계층 및 클라우드 서비스 계층으로 구성 됨 물리적 시스템 계층 가장 기본적인 계층 클라우드 인프라를 구성하는 물리적인 하드웨어 영역이며, 일반적으로 컴퓨팅 자원 포함 가상화 계층 클라우드에서 제공되는 가상 인프라를 제공하는 영역 다양한 사용자의 요구 사항과 클라우드 서비스 요구 계약 사항(SLA)에 따라 가상화 수행 요구 사항을 충족시킬 수 있도록 물리적 하드 웨어에 대한 가상화 제공 가상화 하드웨어에 따라 서버 가상화, 하이버바이저, 스토리지 가상화, 네트워크 가상화 기술 사용 프로비저닝 계층 사용자의 서비스 요청에 따라 가상 인프라를 가상화 계층에 생성(프로비저닝)하고 관리하는 영역 클라우드 컴퓨팅 서비스 관리 체계 계층 클라우드 인프라를 관리하고 서비스 요청에 따라 하위 계층에 필요한 자원의 생성과 삭제 관리 수행 클라우드 서비스 요구 계약 사항(SLA)에 따른 컴퓨팅 성능 및 가용성 관리, 지원 관리 및 과금, 계정 관리, 보안 정책 등의 정의 및 수행 클라우드 서비스 계층 클라우드 서비스인 IaaS(Infrastructure as a Service), PaaS(Platform as a Service), SaasS(Software as a Service)가 제공 됨 클라우드 컴퓨팅의 분류클라우드 컴퓨팅 배포 모델 클라우드 컴퓨팅의 분류 기준 클라우드 컴퓨팅 서비스를 제공할 때의 컴퓨팅 자원의 소유권과 규모, 접근 방법, 공유 정도와 이용 범위, 시스템을 제공 · 배포 방법 을 기준으로 분류 됨 프라이빗 클라우드 (Private Cloud) 단일 조직이나 특정 기관에 의하여 독립적이고 배타적으로 운영되는 형태의 클라우드 배포 모델 단일 조직이나 특정 기관이 컴퓨팅 자원의 제어권과 운영권을 가지고 있기 때문에 다른 배포 모델에 비하여 상대적으로 보안 측면에서 강점 접근 권한을 부여 받은 사용자만 서비스를 이용할 수 있음 데이터 센터의 독립적 구축을 기반으로 폐쇄적으로 운영되는 특징 퍼블릭 클라우드 (Public Cloud) 일반에게 개방 된 형태의 클라우드 서비스가 제공되며, 불특정 다수의 사용자가 접근 가능 클라우드 컴퓨팅에서 제공하는 서버 및 데이터 저장소, 소프트웨어와 같은 컴퓨팅 자원을 불특정 다수의 사용자가 공유하는 서비스를 제공하는 클라우드 배포 모델 컴퓨팅 자원은 사용자에 따라 별도의 권한 관리가 이루어짐 서비스 사용자 간에 간섭이 존재하지 않도록 구성 대표적으로 마이크로소프트의 Azure, 아마존의 AWS, 네이버의 Naver Cloud 등이 퍼블릭 클라우드 배포 모델 하이브리드 클라우드 (Hybrid Cloud) 두 개 이상의 클라우드 배포 모델의 조합으로 구성된 형태임 데이터 보안이 중요하거나 컴퓨팅 자원에 대한 독자적인 제어가 필요한 서비스에 대해서는 사설(프라이빗) 클라우드 및 커뮤니티 클라우드를 이용하고 추가적인 컴퓨팅 자원에 대해서는 퍼블릭 클라우드의 컴퓨팅 자원을 할당 받아 사용하는 형태가 대표적임 커뮤니티 클라우드 (Community Cloud) 금융권과 같이 유사 기능과 업무를 중심으로 하는 여러 조직이나 공동의 목적을 공유하는 특정 기관들이 파트너십을 맺고 공동의 데이터 센터를 구축하여, 공유 된 접근이 해당 기관의 구성원에게만 허용되는 형태 연합 된 조직이나 특정 기관은 퍼블릭 클라우드의 개념으로 공동 사용하는 형태의 배포 모델 클라우드 컴퓨팅 서비스 모델 클라우드 컴퓨팅 서비스 모델의 종류 소프트웨어 서비스 (SaaS; Software as a Service) 모델 플랫폼 서비스 (PaaS; Platform as a Service) 모델 인프라스트럭처서비스 (IaaS; Infrastructure as a Service) 모델 클라우드 컴퓨팅 서비스 모델은 클라우드 컴퓨팅에서의 컴퓨팅 리소스의 구성 요소와 사용자와 제공자의 관리 영역에 따라 나뉘게 됨 SaaS (Software as a Service) 클라우드 사용자에게 통신 네트워크를 통해 소프웨어를 가상화하여 제공하는 모델 조직이나 개인이 쉽게 소프트웨어를 활용하고 사용할 수 있으며, 소프트웨어의 다운로드나 설치가 불필요 클라우드 제공자는 데이터 센터, 네트워킹 방화벽, 서버 보안 및 저장소, 운영 체제, 개발 도구, 데이터베이스 관리, 응용 소프트웨어나 앱 제공 서비스 운영에서, 클라우드 제공자가 기술적으로 발생하는 문제를 모두 관리하고 해결 사용자는 컴퓨팅 자원의 관리와 유지 보수에 대한 고려가 필요하지 않고, 소프트웨어의 사용과 운영에만 집중함 대표적인 SaaS 모델은 세일즈포스 닷컴의 CRM SFA, 클라우드 ERP, CRM, e 커머스 등의 서비스와 구글 앱스 등 SaaS 서비스 모델에서 사용자는 애플리케이션과 데이터만 관리 PaaS (Platform as a Service) 클라우드 사용자가 특정 소프트웨어나 자체 개발한 소프트웨어를 운영할 수 있는 플랫폼을 제공 인프라스트럭처와 무관하게 오직 애플리케이션과 비즈니스 로직의 개발에 집중할 수 있는 개발 환경을 제공 사용자는 인프라나 운영체제, 플랫폼 관리에 대해 최소한의 부담을 짐 사용자에게 소프트웨어를 개발하거나 실행하는 데 기반이 되는 컴퓨팅 자원, API, 라이브러리 등을 제공하며, 이들에 대한 관리/장애 복구에 대한 책임/유지 보수 등에 대한 책임 부여 IaaS (Infrastructure as a Service) 사용자가 운영하고자 하는 서비스에 필요한 프로세서 · 스토리지 · 메모리 등의 하드웨어를 상세하게 명시하면, 클라우드 제공자가 이에 대한 컴퓨팅 자원을 가상화하여 사용자에게 제공 기업들에 가장 많이 제공되는 서비스 종류임 하위 레벨의 인프라 부분을 사용자에게 제공하는 경우가 많음 가상 호스팅 서비스와 유사하게 보일 수도 있지만 IaaS 모델은 확장 관점에서 차이가 있음 서버, 스토리지와 네트워크 등을 가상의 환경으로 구성하여 필요에 따라 자원을 별도로 사용 가능하게 하는 점이 다름 IaaS 서비스 제공을 위해서는 대규모의 데이터 센터에 서버 구축과 서버 운용 능력, 자본력, 운영 공간, 대규모 전력 환경 구성 등이 필수적임 데이터 클라우드(Data Cloud) 기업 데이터, 데이터 스토어 및 지원 데이터 인프라를 통합하여 제공하는 데이터 관리 시스템 많은 기업체들이 데이터 센터를 유지 및 관리하는 데 큰 노력과 컴퓨팅 자원이 필요하므로 기업의 입장에서는 데이터 센터의 효율적인 운영이 필요함 이를 위해 기업 데이터의 가용성, 접근 편리성, 보안 등을 지원하는 데이터 클라우드를 도입하고 있음 데이터 클라우드 기존의 클라우드 서비스와 유사한 접근 방식을 제공함 데이터 스토리지, 데이터의 전송과 저장, 데이터에 대한 고차원 분석 기능 등을 제공함 조직 내부 데이터의 활용과 가치 창출에 도움을 주고 있음 데이터 분석을 통해 나온 결과 값을 머신 러닝 모델에 바로 적용할 수 있는 서비스들도 출시되고 있음 데이터 클라우드가 기존의 클라우드 서비스와 다른 부분은 DAaaS(Data Analytics as a Service)라는 데이터 플랫폼 서비스에 데이터 분석과 예측 서비스를 함께 제공한다는 것임 데이터 클라우드의 특징 데이터 운영의 편리함 다양한 사용 목적에 부합하는 데이터의 해석과 분석을 효율적으로 수행하기 위해 조직의 데이터를 관리하고 운영함 구조화, 반구조화 또는 구조화 되지 않은 데이터를 통합적으로 관리하여 복잡성을 줄이고 데이터 운영을 간결하게 함 AI 및 머신 러닝 모델의 지원 AI 및 머신 러닝 모델에 기반한 데이터 분석 기능을 제공함 업무 절차의 효율화와 데이터 문맥 분석을 통한 분석 결과의 고도화 등과 같은 자동화 된 분석 도구를 제공함 데이터 신뢰도의 향상 최신 상태의 데이터가 보장 됨 데이터 접근과 사용에 대한 보안이 보장 됨 데이터에 대한 사용자의 신뢰도가 높아짐 데이터에 대한 수집 및 접근 규정의 제공, 데이터 중복에 대한 방안, 데이터의 복구와 안정성 제공 기능이 함께 제공됨 정리 하기 클라우드 컴퓨팅은 컴퓨팅 리소스에 언제, 어디서나 필요에 따라 편리하게 네트워크를 통해 접근하는 기능을 제공하는 컴퓨팅 모델을 의미함 클라우드 컴퓨팅은 배포하는 방법에 따라 배포 모델을 나누고, 사용자 요구에 따라 서비스 모델을 구분함연습 문제 클라우드 서비스에 대한 설명으로 옳지 않은 것은 무엇인가? a. 고정적인 컴퓨팅 리소스에 대한 포털을 제공하는 서비스 클라우드 서비스에 대한 설명으로 옳은 것 인터넷을 통해 액세스할 수 있는 IT 서비스 사용자가 신청하여 즉시 사용할 수 있고, 사용한 만큼 비용을 지불하는 컴퓨팅 사용자의 필요 용도에 따라 클라우드 컴퓨팅에서 제공하는 서비스의 성능도 가변적으로 변경 가능한 서비스 클라우드에서 제공되는 가상 인프라를 제공하는 영역은 클라우드 아키텍처의 어느 부분인가? a. 가상화 계층 클라우드 사용자에게 통신 네트워크를 통해 소프트웨어를 가상화하여 제공하는 클라우드 서비스 모델은 무엇인가? a. SaaS 모델 정리 하기 클라우드 컴퓨팅 인터넷을 통해 액세스할 수 있는 IT 서비스로서 사용자가 신청하여 즉시 사용할 수 있고, 사용한 만큼 비용을 지불하는 컴퓨팅 서비스 컴퓨팅 리소스에 언제, 어디서나 필요에 따라 편리하게 네트워크를 통해 접근하는 기능을 제공하는 컴퓨팅 모델 확장 가능하고 탄력적인 IT 기능이 인터넷을 사용하는 외부 고객들에게 서비스 형태로 제공되는 컴퓨팅 방식 집적 · 공유된 정보 통신 기기, 정보 통신 설비, 소프트웨어 등 정보 통신 자원을 이용자의 요구나 수요 변화에 따라 정보 통신망을 통하여 신축적으로 이용할 수 있도록 하는 정보 처리 체계 클라우드 아키텍처 물리적 시스템 계층 가장 기본적인 계층으로 클라우드 인프라를 구성하는 물리적인 하드웨어 영역이며, 일반적으로 컴퓨팅 자원 포함 가상화 계층 클라우드에서 제공되는 가상 인프라를 제공하는 영역으로 다양한 사용자의 요구 사항과 클라우드 서비스 요구 계약 사항(SLA)에 따라 가상화 수행함 프로비저닝 계층 사용자의 서비스 요청에 따라 가상 인프라를 가상화 계층에 생성(프로비저닝)하고 관리하는 영역 클라우드 컴퓨팅 서비스 관리 체계 계층 클라우드 인프라를 관리하고 서비스 요청에 따라 하위 계층에 필요한 자원의 생성과 삭제 관리 수행 클라우드 서비스 계층 클라우드 서비스인 IaaS(InfrastructureasaService), PaaS(PlatformasaService), SaaS(SoftwareasaService)가 제공됨 클라우드 배포 모델 프라이빗 클라우드(Private Cloud) 단일 조직이나 특정 기관에 의하여 독립적이고 배타적으로 운영되는 형태의 클라우드 배포 모델이며, 단일 조직이나 특정 기관이 컴퓨팅 자원의 제어 권과 운영 권을 가지고 있기 때문에 다른 배포 모델에 비하여 상대적으로 보안 측면에서 강점을 갖음 퍼블릭 클라우드(Public Cloud) 일반에게 개방 된 형태의 클라우드 서비스가 제공되며, 불특정 다수의 사용자가 접근 가능하며, 클라우드 컴퓨팅에서 제공하는 서버 및 데이터 저장소, 소프트웨어와 같은 컴퓨팅 자원을 불특정 다수의 사용자가 공유하는 서비스를 제공하는 클라우드 배포 모델 하이브리드 클라우드(Hybrid Cloud) 두 개 이상의 클라우드 배포 모델의 조합으로 구성된 형태이며, 데이터 보안이 중요하거나 컴퓨팅 자원에 대한 독자적인 제어가 필요한 서비스에 대해서는 사설(프라이빗)클라우드 및 커뮤니티 클라우드를 이용하고 추가적인 컴퓨팅 자원에 대해서는 퍼블릭 클라우드의 컴퓨팅 자원을 할당 받아 사용하는 형태가 대표적임 클라우드 컴퓨팅 서비스 모델 SaaS 모델 클라우드 사용자에게 통신 네트워크를 통해 소프트웨어를 가상화하여 제공하는 모델 IaaS 모델 클라우드 사용자가 특정 소프트웨어나 자체 개발한 소프트웨어를 운영할 수 있는 플랫폼을 제공하는 모델 PaaS 모델 사용자가 운영하고자 하는 서비스에 필요한 프로세서 · 스토리지 · 메모리 등의 하드웨어를 상세하게 명시하면, 클라우드 제공자가 이에 대한 컴퓨팅 자원을 가상화하여사용자에게 제공하는 모델 " }, { "title": "[운영 체제] 8강 - 메모리 관리", "url": "/posts/knou-os-8/", "categories": "OS, Operating System", "tags": "knou, os", "date": "2025-04-21 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김진욱 교수님의 '운영 체제' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 메모리(주 기억 장치)의 구성과 관리는 운영체제의 설계에 가장 중요한 영향을 미치는 요인 중 하나로서, 실제로 시스템의 성능은 사용 가능한 메모리의 용량과 프로세스 처리 중 메모리를 얼마나 효과적으로 사용하는 가와 관련이 큼 컴퓨터 시스템의 메모리 관리와 관련된 기초적인 개념을 다룸 프로세스와 메모리의 관계, 기억 장치의 구성, 프로그래밍 환경에 따른 메모리 할당과 보호, 메모리 배치 기법 등의 기초적인 사항에 대해 살펴봄학습 목표 프로세스와 메모리의 관계를 설명할 수 있음 기억 장치 계층 구조를 설명할 수 있음 다중 프로그래밍의 의미를 설명할 수 있음 고정 분할과 동적 분할을 설명할 수 있음 메모리 배치 기법을 이해하고 적용할 수 있음강의록프로세스와 메모리프로세스의 동작 프로그램 카운터(PC)를 참조하여 수행될 명령을 메모리에서 읽어 CPU로 수행하는 것 기억 장치 계층 구조 적절한 비용으로 높은 성능을 냄 메모리 관리 메모리 호출 언제 새로운 프로세스를 메모리에 둘 것인가? 메모리 배치 다음에 실행될 프로세스를 메모리 내의 어느 곳에 둘 것인가? 메모리 교체 메모리가 꽉 찬 상태에서 새로운 프로세스를 메모리에 적재해야 한다면 어떤 프로세스를 제거할 것인가? 그 외 고정/동적 분할, 고정/유동 적재 영역 등 단일 프로그래밍 환경단일 프로그래밍 하나의 프로세스만 메모리를 전용으로 사용하는 것 프로세스는 하나의 연속된 블록으로 메모리에 할당 연속 메모리 할당 단일 프로그래밍의 문제점 메모리의 용량을 초과하는 프로세스는 실행 못함 메모리 낭비 심함 지속적으로 사용되지 않는 프로세스도 메모리에 계속 적재 주변 장치 등 자원의 낭비 심함 프로세스 처리 시간 계산 위주의 사용자 프로세스 입출력 위주의 사용자 프로세스 다중 프로그래밍 환경다중 프로그래밍 여러 개의 프로세스가 메모리에 동시에 적재되는 것 CPU 연산과 입출력을 동시에 함으로써 CPU 이용도와 시스템 처리량 증가 메모리 분할 여러 프로세스를 메모리에 적재하기 위해 고안 된 방법 하나의 분할에 하나의 프로세스가 적재되는 방식 종류 고정 분할 동적 분할 고정 분할 메모리를 여러 개의 고정된 크기의 영역으로 분할 정해진 크기의 고정된 분할 영역으로 나누어 관리 프로세스 배치 방법 1 분할 영역마다 큐를 두고 큐에 들어온 프로세스는 해당 분할 영역에만 적재 절대 번역 및 적재 필요 절대 주소 효율성 낮음 프로세스 배치 방법 2 하나의 큐만 두고 큐에 들어온 프로세스는 어느 분할 영역에든 적재 재배치 가능 번역 및 적재 필요 복잡함 문제점 내부 단편화 프로세스의 크기가 적재 된 분할 영역의 크기보다 작아서 분할 영역 내에 남게 되는 메모리 발생 수행할 프로세스의 크기를 미리 알고 그에 맞춰 고정 분할을 해야 함 현실적이지 못함 동적 분할 메모리의 분할 경계가 고정되지 않음 각 프로세스에 필요한 만큼의 메모리만 할당 문제점 외부 단편화 메모리의 할당과 반환이 반복됨에 따라 작은 크기의 공백이 메모리 공간에 흩어져 생김 해결 방법 통합 인접 된 공백을 더 큰 하나의 공백으로 만들어 외부 단편화 해결 집약 메모리 내의 모든 공백을 하나로 모아 외부 단편화 해결 메모리 보호 프로세스가 다른 할당 영역을 침범하지 않게 하는 것 하한-상한 또는 하한-크기 레지스터 쌍으로 제한 이 제한 넘어 운영체제 호출하려면 시스템 호출 이용메모리 배치 기법메모리 배치 기법 동적 분할 다중 프로그래밍에서 새로 반입 된 프로그램이나 데이터를 메모리의 어느 위치에 배치할 것 인가를 결정 종류 최초 적합 후속 적합 최적 적합 최악 적합 최초 적합 프로세스가 적재될 수 있는 빈 공간 중에서 가장 먼저 발견 되는 곳을 할당 후속 적합 최초 적합의 변형 이전에 탐색이 끝난 그 다음 부분부터 시작하여 사용 가능한 빈 공간 중에서 가장 먼저 발견 되는 곳을 할당 최적 적합 필요한 공간을 제공할 수 있는 빈 공간 중 가장 작은 곳을 선택하여 할당 큰 빈 공간을 최대한 많이 남겨 놓기 위한 방법 최악 적합 필요한 공간을 제공할 수 있는 빈 공간 중 가장 큰 곳을 선택하여 할당 작은 자투리가 남아 사용되지 못하는 공간이 발생하는 것을 최소화 하기 위한 방법 정리 하기 프로세스가 실행되기 위해서는 수행될 명령이 메모리 상에 존재해야 함 컴퓨터 시스템의 기억 장치는 적은 비용으로 높은 성능을 제공하기 위해 계층적으로 구성 됨 단일 프로그래밍 환경에서의 연속 메모리 할당 기법은 관리 기법이 단순하지만, 컴퓨터 자원을 효율적으로 사용하는 데 문제가 있음 다중 프로그래밍을 통해 CPU와 주변 장치의 이용률을 높일 수 있음 고정 분할 방식은 정해진 크기의 분할 영역으로 메모리를 활용하는 방식으로, 각 분할 영역에서 내부 단편화가 발생할 수 있음 동적 분할 방식은 각 작업에 필요한 만큼의 메모리를 할당함으로써 내부 단편화를 제거하지만 외부 단편화가 발생할 수 있음 외부 단편화는 통합과 집약 기법으로 해결 가능함 메모리 배치 기법은 프로세스를 메모리의 어디에 배치할 것인가 하는 결정과 관련되어 있으며, 최초 적합, 후속 적합, 최적 적합, 최악 적합 기법이 있음" }, { "title": "[데이터 정보 처리 입문] 8강 - 엑셀을 이용한 그래프 그리기", "url": "/posts/knou-dip-8/", "categories": "Data Science, Data Analysis", "tags": "knou, data information processing", "date": "2025-04-21 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김성수, 이기재 교수님의 '데이터 정보 처리 입문' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 엑셀로 데이터를 분석할 때 수치로 표현된 분석 결과들을 단순하게 나열하는 것보다 그래프를 함께 제시하는 것이 효과적임 그래프를 이용은 데이터가 갖고 있는 정보와 그 의미를 시각적으로 요약해서 나타내어 데이터 분석 결과를 쉽게 이해할 수 있도록 도움 실제 데이터 분석과 관련하여 널리 사용되는 있는 원 그래프, 사각형 그래프, 막대 그래프, 꺾은 선 그래프 등에 대한 개념과 엑셀을 이용해서 이들 그래프를 작성하는 방법에 대해서 살펴봄학습 목표 그래프의 역할을 설명할 수 있음 원 그래프와 사각형 그래프를 작성할 수 있음 막대 그래프를 작성할 수 있음 꺾은 선 그래프를 이용하여 데이터 분석을 할 수 있음주요 용어 정성적 데이터(qualitative data) 명목 형 척도나 순서 형 척도로 측정 된 데이터 정량적 데이터(quantitative data) 구간 척도나 비율 척도로 측정 된 연속 형 데이터 원 그래프(pie chart) 각 항목 별 비율을 나타낼 때, 각 항목의 비율과 원 그래프에서 각 항목을 나타내는 면적의 비율이 같게 만든 그래프 사각형 그래프 각 항목이 차지하는 비율을 띠 모양의 사각형에 면적의 비율이 같도록 나타낸 그래프로 집단 별로 비교할 때 효과적임 막대 그래프(bar chart) 정성적 데이터를 표현하기 위해서 흔히 사용 됨 세로 막대 형과 가로 막대 형이 있음 시계 열 데이터 시간의 흐름에 따라 특성 치를 측정하여 얻은 데이터 꺾은 선 형 그래프 시계 열 데이터의 시간 흐름에 따른 변화나 추세를 파악하고자 할 때 사용하는 그래프 강의록개요통계 분석에서 그래프의 역할 데이터가 갖고 있는 정보를 요약하여 시각적으로 명확하게 보여줌 분석 결과를 쉽게 이해할 수 있음 잘못 표현된 그래프는 정보와 그 의미를 왜곡해서 전달 할 수 있음 데이터 특성과 분석 목적에 따라 사용할 수 있는 그래프 종류가 달라짐 데이터에 알맞은 그래프를 선택하는 것이 중요함 정량적 데이터(quantitative data)이냐 정성적 데이터(qualitative data)냐에 따라 사용 가능한 그래프도 달라짐 원 그래프와 사각형 그래프원 그래프(원형 차트, pie chart)의 개념 전체에 대한 항목 별 비율이나 백분율을 강조하기 위하여 널리 사용됨 항목에 대한 상대적 비교가 쉬움 각 항목이 차지하는 비율과 원 그래프에서의 면적의 비율을 같게 만든 그래프원 그래프를 그릴 때 참고할 사항들 그래프에 대한 간단한 제목 제시 외부 데이터를 이용하였다면 그 출처를 밝힐 것 원 그래프의 조각은 8개 조각 보다 작게 할 것 작은 비율의 항목은 묶어서 ‘기타‘로 처리 특정 조각의 강조 나머지 부분과 분리, 어둡거나 밝은 색 또는 무늬 이용 원 그래프(pie chart)의 작성 절차 B열과 C열에 각각 프로그램 이름과 각 프로그램에 대한 시청률 입력 B3:C8 셀에 있는 프로그램 이름과 시청률을 드래그 &amp; 드롭으로 선택하고, 삽입 리본 메뉴의 [차트] 그룹 사용 대화 상자에서 차트 유형을 ‘원형‘으로 선택한 후 세부 모양 결정 [차트도구] 탭의 [레이아웃] 그룹에서 [차트제목]을 눌러서 원 그래프 제목 입력 [데이터 레이블]을 클릭해서 원 그래프의 표현 양식 결정 조각 강조하기: 분리를 원하는 조각을 마우스로 클릭해서 선택하고, 드래그&amp;드롭하여 원하는 위치로 이동 사각형 그래프(띠 그래프)의 개념 원 그래프와 유사한 그래프로 집단 별 차이를 살펴서 비교하는데 효과적임 ‘세로 막대형’, ‘가로 막대형’ 중 선택 막대형 그래프 작성 절차 (사각형 그래프) A3:C8 셀에 있는 프로그램 이름과 시청률 데이터를 드래그 &amp; 드롭으로 선택 [삽입] 탭의 [차트] 그룹에서 “세로 막대형” 선택하여 세부 모양 결정 “계열 위치”를 “행”으로 지정한 후 그래프를 보기 좋게 수정 막대 그래프막대 그래프(bar chart)의 활용 주로 질적 데이터를 분석하기 위해서 사용됨 수직 막대 그래프 차트 종류에서 “세로 막대 형” 선택 수평 막대 그래프 “가로 막대 형” 선택 막대 그래프 작성 법 원 그래프 작성 법과 유사하며, 차트 마법사 대화 상자에서 알맞은 차트 유형과 세부 모양을 결정하여 작성함 세로 막대 형 가로 막대 형 막대 그래프의 예: 시청률 데이터 그룹 간 비교, 시간의 흐름에 따른 변화 파악에 적합 꺾은 선 그래프시계 열 데이터 시간의 흐름에 따라 측정치를 측정하여 얻은 데이터 ex) 대기 오염도, 주가 또는 환율 동향, 수출입 동향, 월별 판매량, 실업률 등꺾은 선 그래프 시계 열 데이터의 시간 흐름에 따른 경향 파악에 유용 차트 종류에서 “꺾은 선 형” 선택 참고 데이터 수집 간격이 일정하지 않거나 기간 구분이 없는 데이터의 추세나 변화는 “꺾은 선 형” 보다는 “분산 형“을 선택하여 그래프 작성 꺾은 선 그래프의 예 두 지역의 연도 별 오염도를 쉽게 비교할 수 있고, 전체적인 경향을 파악하는데 효과적 꺾은 선 그래프를 작성할 때 주의할 사항 Y축의 눈금을 얼마나 세분화 하는 가에 따라 그래프의 의미가 다르게 해석될 수 있음 그래프 1 대기 오염도의 변화 경향을 뚜렷하게 보여줌 그래프 2 대기 오염도에 거의 변화가 없는 것처럼 보임 X 축의 시작 점에 따라 그래프의 의미가 다르게 해석될 수 있음 시계 열 데이터에서 X축의 시작 시점을 무엇으로 정하는가에 따라서 그래프의 해석이 달라짐 그래프는 효과적인 정보 전달도 가능하지만, 어떻게 작성 했는가에 따라 왜곡된 정보를 전달할 수도 있음 그래프 1 그래프 2 첫 시점을 제외하고 나머지 6개 시점의 데이터 만을 이용하였음 첫 시점을 제외하고 그래프를 그려서 대기 오염도에 거의 변화가 없어 보임 실습 : 시청률 데이터 원 그래프 그리기 사각형 그래프 그리기 연습 문제 풀이 일반적으로 축전지의 전압은 시간이 지남에 따라 다음 관계 식에 따라 떨어진다고 한다. 시간을 0부터 10초까지 변화 시키면서 전압을 계산하고, 그래프로 나타내시오. “분산형” 선택해 다음과 같은 차트 작성 시간에 따른 축전지의 전압 변화 나타냄 =10*EXP(-0.5**A2) 연습 문제 다음과 같은 성별 도수 분포를 그래프로 나타내고자 한다. 적합한 그래프끼리 묶인 것은? 구분 도수 백분율 남자 27 67.5% 여자 13 32.5% 합계 40 100% a. 막대 그래프, 원 그래프 사람들이 즐겨보는 TV 프로그램에 대한 비율을 다음과 같이 조사하였다. 이러한 경우 전체에 대한 항목별 비율을 비교하거나, 특정 항목을 강조하기 하기 위해 가장 적합한 그래프는? 뉴스 : 33.3%, 연속극 : 36.3%, 스포츠 : 9.1%, 오락 : 11.5%, 기타 : 9.9% a. 원 그래프 시간의 흐름에 따라 관측된 시계 열 데이터의 추세 변화나 경향을 파악하고자 한다. 다음 중 이와 같은 분석 목적에 가장 적합하지 않은 그래프는? a. 원 그래프 시간의 흐름에 따라 관측 된 시계 열 데이터의 추세 변화나 경향을 파악하기에 적합한 그래프 꺾은 선 그래프 세로 막대 형 그래프 분산 형 그래프 통계청 홈페이지를 방문하여 최근 5년 간의 매월 소비자 물가 지수 데이터를 구하여 적합한 그래프를 엑셀로 그려서 전체적인 경향을 파악하고자 한다. 가장 알맞은 차트의 종류는 무엇인가?  a. 꺾은 선 형 엑셀을 이용하여 간격이 일정한 시계 열 데이터의 경향을 파악하고자 한다. 엑셀 차트 중에서 가장 적합한 차트 유형은? a. 꺾은 선 형 " }, { "title": "[파이썬 프로그래밍 기초] 8강 - 체크 포인트", "url": "/posts/knou-python-8/", "categories": "Language, Python", "tags": "knou, python", "date": "2025-04-20 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '파이썬 프로그래밍 기초' 강의를 개인 공부 목적으로 메모하였습니다. 학습 목표 컴퓨터의 하드웨어적 및 소프트웨어적 동작 과정을 설명할 수 있음 파이썬의 특장점에 대해 설명할 수 있음 파이썬으로 구조적 프로그래밍 패러다임에 따라 프로그래밍 할 수 있음강의록 파이썬 인터프리터에서 기본적으로 지원하는 함수를 무엇이라고 하는가? a. 내장 함수 구조적 프로그래밍 패러다임에서 제안 된 제어 구조가 아닌 것은? a. 재귀 구조 구조적 프로그래밍 패러다임에서 제안 된 제어 구조 순차 구조 반복 구조 선택 구조 다음 코드 실행 시 에러의 원인에 대한 설명으로 올바른 것은? msg = \"Love Python\" count = 1 # count 변수 초기화 while count &lt; 5: print(msg) a. 무한 반복 count 값이 변하지 않아 조건이 항상 참 다음은 무엇에 대한 사전적 정의인가? 1. 이론을 세우는 데 기초가 되는 사실 2. 관찰이나 실험, 조사로 얻은 사실 a. 데이터 데이터는 관찰과 측정을 통해서 얻어 놓은 그 결과 값 정보는 여러 가지 가공을 통해서 만들어지는 데이터 고급 언어로 작성된 소스 코드를 컴퓨터가 이해할 수 있는 기계어로 변환해 주는 프로그램은? a. 인터프리터 (또는 컴파일러) 아래 그림의 신체 기관과 동일한 기능을 수행하는 컴퓨터 장치로 바르게 짝지어진 것은? a. HMD(Head Mounted Display) - 4 출력 컴퓨터에 있는 가상 현실에 대한 영상을 보여주는 출력 장치 아래와 같은 시퀀스를 생성하는 코드로 올바른 것은? a. odd = range(1, 10, 2) range의 두 번째 매개 변수 값보다 하나 작은 값으로 시퀀스가 생성 됨 파이썬 프로그램 실행 과정에서 다음 밑줄 친 (가)에 들어갈 알맞은 말은? a. 바이트 코드 가상 머신이 이해할 수 있는 중간 단계 언어를 만들어 모든 운영 체제에서 실행할 수 있도록 만듬 파이썬에 대한 설명으로 올바르지 않은 것은? a. 완전한 애플리케이션 단독 개발이 가능하다. 스크립트형 언어로 출발했기 때문에 GUI 환경에서 동작하는 형태의 애플리케이션을 만들기는 어려움 파이썬에 대한 설명으로 올바른 것 명령형, 절차적, 객체 지향 프로그래밍 등 다양한 패러다임을 지원함 실행할 수 있는 의사 코드 수준의 문법을 지향함 많은 개발자의 의견을 수용하고 토론하며 발전한 언어임 다음의 명령문에서 함수의 입력인 “Hello World!”를 무엇이라고 하는가? print(\"Hello World!\") a. 파라미터 매개 변수 함수에 전달해서 내부에 정의 된 코드에 의해서 실행되도록 만드는 데이터를 전달하는 매개체 아래와 같은 명령문으로 생성된 리스트의 “black” 값을 “purple”로 수정하는 명령문은? body = [181, 78, \"dark brown\", \"black\"] a. body[3] = “purple” 인덱스 3의 요소를 “purple”로 변경 인덱스는 0부터 시작함 다음 중 식별자로 사용할 수 없는 것은? a. or 예약어와 겹쳐서 사용 불가능 식별자로 사용할 수 있는 것 blue456 _24h ____________init_____________ 파이썬 개발 환경 중 오픈소스이며 문서화가 쉽고 전통적인 소스 코드-컴파일-실행 방식에서 벗어나 클라우드 기반 대화형 개발 및 실행 환경을 제공하는 것은? a. 코랩 다음 코드의 실행 결과로 올바른 것은? print(\"나는 !\")\tprint(\"파이썬을 할 수 있다.\") a. 구문 에러(error) 발생 들여 쓰기 의존적 언어이기 때문에 오류 발생 다음과 같이 5개의 장치를 통해 컴퓨터를 구성하는 방식을 무엇이라고 하는가? a. 폰 노이만 구조 다음 중 실행 결과가 나머지와 다른 하나는? a. rad = int(rad)print(input(\"숫자 입력:\")) 실행 결과가 같은 것 rad = input() rad = int(rad) print(rad) rad = input(\"숫자 입력:\") rad = int(rad) print(rad) print(int(input(\"숫자 입력:\"))) 여러 프로그램 실행이 요청되면 한정된 자원을 효과적으로 사용하도록 조율하는 운영 체제의 기능은? a. 프로세스 관리 (자원 할당 및 스케줄링 포함) 여러 프로그램 실행이 요청 되면 프로그램이 메모리로 올라와 프로세스가 됨 프로세스들이 정상적으로 병렬적, 순차적으로 돌아갈 수 있도록 제어해주는 기능 다음은 홀짝 여부를 판별하는 프로그램의 일부이다. 빈칸에 들어갈 올바른 표현식은? number = 9if ______ : print(\"홀수 입니다.\")else : print(\"짝수 입니다.\") a. number % 2 == 1 2로 나눈 나머지가 1이면 홀수 다음 코드의 실행 결과는? for i in range(1, 5) : # i는 1, 2, 3, 4 for j in range(i) : # 시작 값이 0이고, i보다 작은 수까지 1씩 증가 시킴 print(\"#\", end=\"\") # '#' 출력 후 줄바꿈 안 함 print() # 안쪽 루프 종료 후 줄바꿈 a. ########## 아래는 가위바위보 게임 소스 코드의 일부이다. 다음 물음에 따라 답하시오. import random options = [\"가위\", \"바위\", \"보\"]user = input(\"가위,바위,보를 입력: \")com = random.choice(options) # options 리스트에서 하나의 값을 무작위로 뽑음 if user == com:\t\tprint(\"비겼다!\")elif user == \"바위\" ______ com == \"가위\": # 빈칸 1\t\tprint(\"이겼다!\")elif user == \"보\" ______ com == \"바위\": # 빈칸 2\t\tprint(\"이겼다!\")elif user == \"가위\" ______ com == \"보\": # 빈칸 3\t\tprint(\"이겼다!\")\t\t______ : # 빈칸 4\t\tprint(\"졌다!\") 빈칸 1, 2, 3에 들어갈 올바른 표현(논리 연산자)은? a. and 빈칸 4 에 들어갈 올바른 표현은? a. else: 연습 문제 파이썬에서 데이터의 데이터 타입은 다른 데이터 타입으로 변경이 불가능하다.  a. X 파이썬은 히도 판로쉼이 주도하여 발전하고 있다.  a. X print(hei_list[2])의 실행 결과값은 14이다. a. O " }, { "title": "[데이터베이스 시스템] 8강 - 정규화", "url": "/posts/knou-dbs-8/", "categories": "Database", "tags": "knou, database", "date": "2025-04-20 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '데이터베이스 시스템' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 동일한 역할을 할 수 있는 릴레이션 스키마라도 속성들을 어떻게 구성하는 지에 따라 데이터베이스의 효율성이 크게 달라짐 정규화는 데이터 모델링의 결과로 생성된 릴레이션에서 저장된 데이터의 패턴을 참조하여 정규화하여 정보 중복으로 발생할 수 있는 문제점(삽입, 수정, 삭제 이상)을 방지하도록 스키마를 재구조화하는 중요한 개념임 정규화를 위한 함수적 종속성, 클로저와 카노니컬 커버에 대하여 학습하고 정규형의 조건에 따라 정규화를 수행하는 방법에 대해 알아봄주요 용어 정규화 이상 현상이 발생할 가능성을 차단하기 위해 원칙을 기반으로 효과적으로 스키마를 모델링하는데 이용되는 기법 함수적 종속성 특정 시점의 릴레이션 인스턴스에서 한 속성의 값이 다른 속성의 값을 결정하는 속성 간의 연관 관계 클로저 함수적 종속성 집합에서 추론 규칙을 사용하여 감춰진 함수적 종속성을 찾아낸 확장된 함수적 종속성 집합 카노니컬 커버 함수적 종속성 집합에서 의미적인 자명성과 중복성을 제거한 최소화된 함수적 종속성 집합 정규형 삽입, 수정, 삭제 등의 이상 발생을 방지하기 위해 릴레이션과 속성을 조건에 따라 재구성한 형식 강의록좋은 릴레이션과 나쁜 릴레이션나쁜 릴레이션의 예 고객번호 고객명 전화번호 등급 할인율 C1 유관순 010-9999-0001 GOLD 5% C2 손병희 010-9999-0002 VIP 10% C3 지청천 010-9999-0003 VIP 10% C4 안창호 010-9999-0004 GOLD 5% C5 안중근 010-9999-0005 VIP 10% 등급에 따른 할인율이 여러 레코드에 중복 저장 됨잘못된 데이터베이스 모델링의 문제점 데이터의 중복 일관성 유지의 어려움 데이터를 수정할 때 관련된 모든 중복 데이터를 찾아 똑같이 수정해야 함 누락 시 데이터 불일치 발생 저장 공간 낭비 불필요하게 같은 데이터가 여러 번 저장됨 갱신 이상 데이터 중복으로 인해 데이터 삽입, 삭제, 수정 시 원치 않는 문제가 발생하는 현상 삽입 이상 레코드 추가 시 불필요한 컬럼 값 없이는 추가하지 못하는 경우 새 데이터를 삽입하려 할 때, 불필요한 다른 데이터 값이 없으면 삽입하지 못하는 경우 ex) 새로운 등급 ‘NEW’, 할인율 ‘3%’를 추가하고 싶지만, 해당 등급의 고객 정보(고객번호 등)가 없으면 추가할 수 없음 삭제 이상 삭제 시 의도하지 않았던 다른 데이터가 삭제되는 경우 특정 레코드를 삭제할 때, 의도하지 않았던 다른 유용한 정보까지 함께 삭제되는 경우 ex) 등급이 ‘NEW’인 유일한 고객 ‘윤봉길’을 삭제하면, ‘NEW’ 등급의 할인율이 ‘3%’라는 정보까지 사라짐 수정 이상 일부 레코드 수정 시 데이터의 일관성이 훼손되는 경우 특정 값을 수정할 때, 중복된 데이터 중 일부만 수정되어 데이터의 일관성이 훼손되는 경우 ex) ‘GOLD’ 등급의 할인율을 8%로 변경 시, ‘GOLD’ 등급 고객 레코드를 모두 찾아 수정해야 하며, 하나라도 누락하면 같은 ‘GOLD’ 등급인데 할인율이 다른 데이터 불일치 발생 갱신 이상 - 삽입 이상 ‘NEW’ 등급, 할인율 ‘3%’ 정보를 추가하고 싶지만, 해당 등급의 고객이 아직 없어 고객번호, 고객명, 전화번호 정보 없이는 삽입 불가 고객번호 고객명 전화번호 등급 할인율 C1 유관순 010-9999-0001 GOLD 5% C2 손병희 010-9999-0002 VIP 10% C3 지청천 010-9999-0003 VIP 10% C4 안창호 010-9999-0004 GOLD 5% C5 안중근 010-9999-0005 VIP 10% 불필요한 정보 고객번호 고객명 전화번호 ???? ??? ??????? 추가하고자 하는 정보 등급 할인율 NEW 3% 갱신 이상 - 삭제 이상 ‘NEW’ 등급의 할인율이 ‘3%’라는 정보를 삭제하려고 하면 ‘C6 윤봉길’ 정보도 사라짐 고객번호 고객명 전화번호 등급 할인율 C1 유관순 010-9999-0001 GOLD 5% C2 손병희 010-9999-0002 VIP 10% C3 지청천 010-9999-0003 VIP 10% C4 안창호 010-9999-0004 GOLD 5% C5 안중근 010-9999-0005 VIP 10% C6 윤봉길 010-9999-0006 NEW 3% 삭제 하면 안되는 정보 고객번호 고객명 전화번호 C6 윤봉길 010-9999-0006 삭제하고자 하는 정보 등급 할인율 NEW 3% 갱신 이상 - 수정 이상 특정 ‘VIP’ 등급 할인율을 10%에서 8%로 변경 시, 데이터 불일치 발생 고객번호 고객명 전화번호 등급 할인율 C1 유관순 010-9999-0001 GOLD 5% C2 손병희 010-9999-0002 VIP 10% → 8% C3 지청천 010-9999-0003 VIP 10% → 8% C4 안창호 010-9999-0004 GOLD 5% C5 안중근 010-9999-0005 VIP 10% → 10% (수정 실패) C6 윤봉길 010-9999-0006 NEW 3% 할인율 컬럼 비일관성 좋은 릴레이션의 개념 컴퓨터 프로그래머적 관점에서의 모델 어떻게 데이터를 저장해야 하는가? 릴레이션 스키마가 얼마나 효율적으로 실세계를 반영하고 있는지 평가 고려 사항 릴레이션 내의 컬럼 간의 관계 분석 불필요한 데이터의 종속과 중복 제거 새로운 컬럼들이 데이터베이스에 추가될 때, 기존 컬럼과의 관계 수정을 최소화 좋은 릴레이션 나쁜 릴레이션 고객번호 고객명 전화번호 등급 할인율 C1 유관순 010-9999-0001 GOLD 5% C2 손병희 010-9999-0002 VIP 10% C3 지청천 010-9999-0003 VIP 10% C4 안창호 010-9999-0004 GOLD 5% C5 안중근 010-9999-0005 VIP 10% C6 윤봉길 010-9999-0006 NEW 3% 좋은 릴레이션 고객번호 고객명 전화번호 등급(FK) C1 유관순 010-9999-0001 GOLD C2 손병희 010-9999-0002 VIP C3 지청천 010-9999-0003 VIP C4 안창호 010-9999-0004 GOLD C5 안중근 010-9999-0005 VIP C6 윤봉길 010-9999-0006 NEW 등급(PK) 할인율 GOLD 5% VIP 10% NEW 3% 두 개의 릴레이션으로 분리 데이터 중복 감소 (할인율 정보는 등급 테이블에 한 번만 저장) 갱신 이상 문제 해결 삽입: 새로운 등급을 등급 테이블에 바로 추가 가능 삭제: ‘윤봉길’ 고객 삭제 시에도 ‘NEW’ 등급 정보는 등급 테이블에 유지됨 수정: ‘GOLD’ 할인율 변경 시 등급 테이블의 한 행만 수정하면 됨 함수적 종속성의 이해함수적 종속성 개념 FD(Functional Dependency) 릴레이션 인스턴스를 분석하여 속성들 간의 연관 관계를 표현한 것 릴레이션의 효율성을 향상시켜 좋은 릴레이션으로 변환하는데 이용되는 중요한 개념 형식적 정의 임의의 릴레이션 스키마 R의 인스턴스 r(R)에 포함되는 서로 다른 두 레코드 r1, r2가 컬럼 X와 Y에 대해, r1[X] = r2[X]일 때, r1[Y] =r2[Y]이면 함수적 종속성 X → Y가 성립함 X는 결정자(Determinant) Y는 종속자(Dependent) 함수적 종속성의 판별 서로 다른 두 개의 레코드에서 어떤 특정 컬럼 값이 같으면 다른 컬럼 값도 같아질 때 함수적으로 종속한다고 표현 함 X → Y 모든 레코드를 대상으로 항상 만족할 때 어떤 컬럼 X 가 Y를 종속함 같을 때만 같으면 됨 다를 때에는 같아도 되고 달라도 됨 서로 다른 두 레코드 값이 같으면 종속자 컬럼의 값도 같아야함 결정자에 같은 값이 없다면 종속자 컬럼의 값은 상관 없음 간단히 보이는 릴레이션 내부에도 많은 수의 함수적 종속성이 존재하기도 함 등급 컬럼이 할인율 컬럼을 함수적으로 종속하는 릴레이션 {등급} - 결정자, {할인율} - 종속자 고객번호 고객명 전화번호 등급 할인율 C1 유관순 010-9999-0001 GOLD 5% C2 손병희 010-9999-0002 VIP 10% C3 지청천 010-9999-0003 VIP 10% C4 안창호 010-9999-0004 GOLD 5% C5 안중근 010-9999-0005 VIP 10% C6 윤봉길 010-9999-0006 NEW 3% 등급이 같으면 할인율도 같음 등급 컬럼이 할인율 컬럼을 함수적으로 종속함 {등급} → {할인율} 복수 개의 컬럼을 암시하는 집합 기호 함수적 종속성 고객번호 → 고객명 고객명 → 등급 {고객번호, 고객명} → 할인율 최종 함수적 종속성 고객번호 → {고객명, 등급, 할인율} 고객번호의 값을 알면 고객명, 전화번호, 등급을 유일하게 결정할 수 있음 고객번호 → 고객명 고객번호 → 전화번호 고객번호 → 등급 고객번호 → {고객명, 전화번호, 등급} 으로 표현 가능 함수적 종속성의 확장 함수적 종속성은 릴레이션의 효율성 여부에 중요한 판단 기준 그러나 릴레이션의 인스턴스만으로 내재 된 모든 함수적 종속성을 찾아내기 어려움 판별되지 않은 모든 함수적 종속성을 도출하기 위해 추론 규칙 등을 사용하여 함수적 종속성을 확장 클로저(closure) 판별된 함수적 종속성 집합으로부터 유추할 수 있는 모든 함수적 종속성 집합 함수적 종속성 추론 규칙 암스트롱 공리(Armstrong’s axiom) 재귀성 규칙 : X⊇Y 이면, X→Y 이다. 어떠한 컬럼의 도메인이 다른 컬럼의 도메인보다 더 큰 집합이라면 (포함 관계를 갖고 있다면) 포함 하고 있는 컬럼이 포함 된 컬럼을 종속함 부가성 규칙 : X→Y 이면, XZ→YZ 이다. 결정자와 종속자의 부가적으로 동일한 컬럼을 합쳤을 때 종속 관계가 유지됨 이행성 규칙 : X→Y 이고, Y→Z 이면, X→Z 이다. 분해 규칙 : X→YZ 이면, X→Y 이다. X라는 컬럼이 Y, Z 두개 컬럼을 종속 하고 있는 경우 Y를 종속하고 Z도 종속함 합집합 규칙 : X→Y 이고, X→Z 이면, X→YZ 이다. 의사 이행성 규칙 : X→Y 이고, WY→Z 이면, WX→Z 이다. 카노니컬 커버 함수적 종속성 추론 규칙으로 확장된 클로저에는 자명한 종속성과 중복된 종속성을 포함 자명한 종속성 A → A 의미가 당연 중복 된 종속성 X → AB, X → B 의미가 여러 번 존재 불필요한 함수적 종속성을 제거한 표준형으로 변환 후 정규화를 수행 표준형에 대한 집합 = 카노니컬 커버 표준형 조건 F의 모든 함수적 종속성의 종속자의 속성은 반드시 1개 표준형 O: A → B, C → D 표준형 X: A → BC F에서 X→A를 X의 진부분집합 Y에 대하여 Y→A로 교체했을 때, 그 집합이 F와 동등한 집합이 불가능 가장 최소화 되어있는 지를 확인하는 조건 표준형 O: AB → C 라는 함수적 종속성이 있을 때, A → C나 B → C가 F로부터 유도되지 않는 경우 표준형 X: ABC → D 라는 함수적 종속성이 있는데, 사실 AB → D만으로도 F로부터 유도될 수 있는 경우 F에서 어떤 함수적 종속성을 제거했을 때, 그 집합이 F와 동등한 집합이 불가능 표준형 X: A → B, B → C, A → C 라는 함수적 종속성 집합이 있을 때, A → C를 제거해도 나머지 {A → B, B → C}로부터 A → C를 유도할 수 있으므로 A → C는 불필요한 함수적 종속성 의미 상 동등하다면 아직 표준형이 아님 위 집합은 표준형에 해당하므로, 반드시 필요함 어떤 종속성을 변경하거나 제외했을 때, 기존 종속성의 집합과 달라졌다는 의미 → 반드시 필요한, 포함시켜야 하는 종속성 집합 정규화 (Normalization)정규화 개념 이상 현상을 최소화하도록 특정 조건을 갖춘 릴레이션의 형식 정규형의 분류 관계형 데이터베이스 설계 시, 데이터 중복을 최소화하고 정보의 일관성을 보장하며 갱신 이상 문제를 해결하기 위해 릴레이션을 분해하는 과정 함수적 종속성 이론을 기반으로 하며, 릴레이션이 만족해야 하는 제약 조건(정규형)에 따라 단계적으로 진행 됨 정규화된 릴레이션은 일반적으로 더 구조화되고 유연하며 유지 보수가 용이함 정규화의 목적 정규화의 정의 특정 정규형의 조건을 만족하도록 릴레이션과 속성을 재구성하는 과정 정규화의 기능 데이터베이스 내에 모든 릴레이션을 효율적으로 표현 바람직하지 않은 삽입, 수정, 삭제 등의 이상 발생 방지 보다 간단한 관계 연산에 기초하여 검색 알고리즘을 효과적으로 작성할 수 있도록 지원 새로운 형태의 데이터가 삽입 될 때, 릴레이션 재구성의 필요성을 축소 제1 정규형(1NF)의 정의 가장 조건이 단순한 정규형 형식적 정의 릴레이션 스키마에서 정의 된 모든 속성의 도메인이 원자 값을 갖는 상태 각 속성 값은 더 이상 분해할 수 없는 단일 값이어야 함 관계형 모델의 특성을 만족하는 경우, 자동 적용되는 정규형 테이블의 각 칸에는 단 하나의 값만 있어야 하며, 반복되는 그룹이나 다중 값 속성이 없어야 함 ex) 한 컬럼에 여러 개의 전화번호가 쉼표로 구분되어 있거나, 주문 항목이 하나의 컬럼에 리스트 형태로 들어있는 경우 1NF 위반제1 정규형을 위배한 릴레이션 도크 릴레이션 도크번호 입항시간 출항시간 목적 도크관리자 담당도선사 D1 09:00, 11:00 10:15, 11:45 선적 김규식 김순애 D1 11:50 12:45 하역 김규식 김구 D2 09:00, 12:00 10:00, 12:45 관광, 주유 한용운 이동휘 D2 13:00 15:00 정비 한용운 윤봉길 원자 값을 갖지 않는 속성 입항시간 출항시간 목적 09:00, 11:00 10:15, 11:45   09:00, 12:00 10:00, 12:45 관광, 주유 예제 릴레이션에 대한 부연 설명 선박이 항구에 정박하기 위해 정밀한 작업이 요구 풍향과 풍속, 파도와 안개 상황 등을 고려 단순히 수신호뿐만 아니라 소형 배들로 정박하려는 대형 배를 밀어 안전하게 위치 시키는 작업을 고려 도선사 배를 도크에 안전하게 접안 시키고 항로로 인도하는 일을 하는 사람 도크 선박의 건조, 수리, 계선, 하역 작업 등을 위해 축조된 설비 및 시설의 총칭 제1 정규형을 수행한 릴레이션 도크 릴레이션 도크번호 입항시간 출항시간 목적 도크관리자 담당도선사 D1 09:00 10:15 선적 김규식 김순애 D1 11:00 11:45 선적 김규식 김순애 D1 11:50 12:45 하역 김규식 김구 D2 09:00 10:00 관광 한용운 이동휘 D2 12:00 12:45 주유 한용운 이동휘 D2 13:00 15:00 정비 한용운 윤봉길 원자적 상태의 속성값으로만 구성 (제1정규형) 함수적 종속성 판별 함수적 종속성의 형식적 정의 임의의 릴레이션 스키마 R의 인스턴스 r(R)에 포함되는 서로 다른 두 레코드 r1, r2가 컬럼 X와 Y에 대해, r1[X] = r2[X]일 때, r1[Y] =r2[Y]이면 함수적 종속성 X → Y가 성립함 도크번호 입항시간 출항시간 목적 도크관리자 담당도선사 D1 09:00 10:15 선적 김규식 김순애 D1 11:00 11:45 선적 김규식 김순애 D1 11:50 12:45 하역 김규식 김구 D2 09:00 10:00 관광 한용운 이동휘 D2 12:00 12:45 주유 한용운 이동휘 D2 13:00 15:00 정비 한용운 윤봉길 도크번호 → 도크관리자 도크 번호가 같으면 도크관리자가 같음 목적 → 도크번호 목적이 같으면 도크번호가 같음 목적 → 담당도선사 목적이 같으면 담당도선자가 같음 함수적 종속성 다이어그램 FDD(Functional Dependency Diagram) 릴레이션 내의 속성 간 종속 관계를 직관적이고 이해하기 쉽게 도식화한 표현 방식 직사각형 속성 또는 속성 집합 화살표 함수적 종속성 도크 릴레이션의 함수적 종속성 다이어그램제2 정규형(2NF)의 정의 릴레이션이 제1정규형(1NF)을 만족하고 부분 집합이 특정 속성을 종속하고 있지 않은 상태 부분 함수 종속이 존재하지 않아야 함 부분 함수 종속은 기본 키가 복합 키로 구성된 경우에 발생할 수 있음 키의 일부 속성에만 종속되는 속성이 있을 때 나타남 부분 함수 종속이 있다면, 해당 종속 관계를 별도의 테이블로 분해함 기본 키가 아닌 모든 속성은 기본 키 전체에 완전 함수 종속되어야 함 형식적 정의 주어진 릴레이션의 인스턴스가 기본 키가 아닌 속성(비주속성)이 기본 키(주속성)에 완전히 종속되어 있는 상태 X → Y에 대한 함수 종속 관계 부분 함수 종속 Y가 X의 전체가 아닌 일부분에 종속 완전 함수 종속 Y가 X의 전체에 종속 제2 정규형의 적용 도크 번호 → 도크 관리자 부분 함수 종속 제1 정규형 만족 제2 정규형 만족 X 릴레이션의 무손실 분해 무손실 분해(lossless decomposition) 정의 스키마 R에 함수적 종속성 X → Y가 존재하고 X ⋂ Y = ∅이면, R을 R-Y와 XY로 분해 도크 관리 릴레이션 무손실 분해 {도크번호} → {도크관리자} {도크번호} ⋂ {도크관리자} = ∅ 도크관리 - {도크관리자}, {도크번호, 도크관리자} 제2 정규화의 적용 도크관리 릴레이션 도크번호 입항시간&lt;/u&gt; 출항시간 목적 담당도선사 D1 09:00 10:15 선적 김순애 D1 11:00 11:45 선적 김순애 D1 11:50 12:45 하역 김구 D2 09:00 10:00 관광 이동휘 D2 12:00 12:45 주유 이동휘 D2 13:00 15:00 정비 윤봉길 관리자 릴레이션 도크번호 도크관리자 D1 김규식 D2 한용운 제2 정규형의 FDD 도크 릴레이션에서 도크관리자 제거 도크번호, 도크관리자만 존재하는 또 다른 릴레이션 생성 부분 함수 종속 사라짐 제3 정규형 (3NF)의 정의 형식적 정의 릴레이션이 제2 정규형(2NF)을 만족하고 기본 키가 아닌 속성들이 어떤 키에도 이행적으로 종속되지 않은 상태 이행적 함수 종속은 기본 키가 아닌 속성이 다른 기본 키가 아닌 속성을 결정하는 경우에 발생 A → B, B → C 일 때 A → C 관계 이행적 함수 종속이 있다면, B → C 관계를 별도의 테이블로 분해함 이행적 종속성 X → Y이고 Y → Z이면 X → Z이다. 제3 정규형의 적용이행적 종속성을 포함한 릴레이션 도크관리 릴레이션 도크번호 입항시간 출항시간 목적 담당도선사 D1 09:00 10:15 선적 김순애 D1 11:00 11:45 선적 김순애 D1 11:50 12:45 하역 김구 D2 09:00 10:00 관광 이동휘 D2 12:00 12:45 주유 이동휘 D2 13:00 15:00 정비 윤봉길 제3 정규화의 적용 도크관리 릴레이션 도크번호 입항시간 출항시간 목적 담당도선사 D1 09:00 10:15 선적 김순애 D1 11:00 11:45 선적 김순애 D1 11:50 12:45 하역 김구 D2 09:00 10:00 관광 이동휘 D2 12:00 12:45 주유 이동휘 D2 13:00 15:00 정비 윤봉길 입출항관리 릴레이션 도크번호 입항시간 출항시간 목적 D1 09:00 10:15 선적 D1 11:00 11:45 선적 D1 11:50 12:45 하역 D2 09:00 10:00 관광 D2 12:00 12:45 주유 D2 13:00 15:00 정비 도선 릴레이션 목적 담당도선사 선적 김순애 하역 김구 관광 이동휘 주유 이동휘 정비 윤봉길 BC 정규형(BCNF)의 정의 형식적 정의 릴레이션이 제3 정규형을 만족하고 릴레이션에 성립하는 X → Y 형태의 모든 함수적 종속성에 대하여 X가 수퍼키인 상태 릴레이션의 모든 결정자가 후보 키여야 함 결정자이면서 후보 키가 아닌 속성이 있다면, 해당 함수 종속 관계를 기준으로 테이블을 분해함 입출항 관리 릴레이션의 함수적 종속성 {도크번호, 입항시간} → {목적} {도크번호, 입항시간} → {출항시간} {목적} → {도크번호} BC 정규화의 적용 입출항관리 릴레이션 도크번호 입항시간 출항시간 목적 D1 09:00 10:15 선적 D1 11:00 11:45 선적 D1 11:50 12:45 하역 D2 09:00 10:00 관광 D2 12:00 12:45 주유 D2 13:00 15:00 정비 도크스케줄 릴레이션 목적 입항시간 출항시간 선적 09:00 10:15 선적 11:00 11:45 하역 11:50 12:45 관광 09:00 10:00 주유 12:00 12:45 정비 13:00 15:00 도크 릴레이션 목적 도크번호 선적 D1 하역 D1 관광 D2 주유 D2 정비 D2 결정자가 key인지 확인 정규화 결과 도크 릴레이션 도크번호 입항시간 출항시간 목적 도크관리자 담당도선사 D1 09:00 10:15 선적 김규식 김순애 D1 11:00 11:45 선적 김규식 김순애 D1 11:50 12:45 하역 김규식 김구 D2 09:00 10:00 관광 한용운 이동휘 D2 12:00 12:45 주유 한용운 이동휘 D2 13:00 15:00 정비 한용운 윤봉길 도크스케줄 릴레이션 목적 입항시간 출항시간 선적 09:00 10:15 선적 11:00 11:45 하역 11:50 12:45 관광 09:00 10:00 주유 12:00 12:45 정비 13:00 15:00 도크 릴레이션 목적 도크번호 선적 D1 하역 D1 관광 D2 주유 D2 정비 D2 관리자 릴레이션 도크번호 도크관리자 D1 김규식 D2 한용운 도선 릴레이션 목적 담당도선사 선적 김순애 하역 김구 관광 이동휘 주유 이동휘 역정규화의 개념 정규화 릴레이션 분할을 통해 데이터의 중복성을 최소화하는 과정 사용 과정에서 많은 조인 연산을 유발 지나친 정규화는 검색의 성능이 저하될 수 도 있음 역정규화 정규화의 반대 과정 정규화를 통해 분리되었던 릴레이션을 통합하는 재조정을 수행하고 정보의 부분적 중복을 허용하는 기법 데이터 접근 성능 개선 목적 검색의 결과는 빨리 나올 수 있게 정규화를 진행하되 검색에 영향을 끼치는 부분은 역정규화를 수행 정규화 되지 않은 스키마와 역정규화 스키마는 구별 해당 두 가지는 다른 개념 연습 문제 다음 중 정규화에 대한 설명으로 올바르지 않은 것은? a. 릴레이션 간 공통 부분을 도출하고 유사 릴레이션을 통합함 정규화는 컬럼 간의 연관 관계를 이용하여 릴레이션의 비효율성을 제거 함 특히 릴레이션 내부에 존재하는 데이터의 중복을 최소화하여 삽입, 갱신, 삭제 이상 현상을 제거하고, 이를 통해 새로운 데이터가 삽입될 때 릴레이션을 재구성해야하는 가능성을 최소화 시킴 정규화에 대한 올바른 설명 데이터가 삽입될 때 릴레이션 재구성의 필요성을 줄임 데이터의 중복을 제거하여 릴레이션의 효율성을 향상 시킴 삽입, 갱신, 삭제 이상(anomaly) 현상을 제거함 릴레이션 내의 컬럼 간의 종속 관계를 직관적이고 이해하기 쉽게 직사각형과 화살표로 도식화한 표현 방식을 무엇이라고 하는가? a. 함수적 종속성 다이어그램 컬럼 간의 종속 관계를 컬럼의 이름만으로 나열할 경우 관계가 전체적으로 파악하기가 어렵기 때문에 모양이 간단한 도형을 사용할 경우 종속 관계를 파악하기 쉬워짐 종속 관계를 직사각형과 화살표로 표현한 그림을 함수적 종속성 다이어그램이라고 함 다음 중 사업자 릴레이션에 포함된 함수적 종속성이라고 할 수 없는 것은? 사업자 릴레이션 사업자번호 공사구분 건축물 층수 사업자 11 B1 빌라 3층 김영수 11 C1 단독 2층 김영수 11 D1 다세대 4층 김영수 24 A1 아파트 15층 이민철 24 B2 빌라 3층 이민철 31 D2 다세대 4층 최용수 a. 사업자번호 → 공사구분 사업자번호 → 공사구분 종속성에 대해 첫 번째와 두 번째 레코드를 살펴볼 때, 사업자번호의 컬럼값은 ‘11’과 ‘11’로 같지만 공사구분의 컬럼값은 ‘B1’, ‘C1’으로 같지 않음 따라서 함수적 종속성 정의에 위배되므로 사업자번호 → 공사구분 종속성은 성립하지 않음 사업자 릴레이션에 포함 된 함수적 종속성 건축물 → 층수 사업자번호, 공사구분 → 건축물 사업자 → 사업자번호 정리 하기 데이터베이스 모델링 과정에서 효율성을 위해 어떤 속성들을 그룹화하여 테이블로 작성할 것인지 고려할 필요가 있으며 전체적인 테이블 구조는 데이터베이스의 정확성을 판단하는 데 중요한 기준이 됨 정규화는 데이터의 중복을 제거하고, 새로운 속성들이 데이터베이스에 추가될 때 기존 속성과의 관계에서 수정을 최소화해야 한다는 것이 목적임 정규화 과정을 통해 데이터 저장을 위한 공간의 낭비를 최소화 할 수 있음 정규화 이전에 데이터베이스 조작에서 발생하는 삽입, 삭제, 수정 등의 갱신 이상 현상을 정규화를 통해 방지할 수 있음 속성들 간의 연관 관계를 표현한 함수적 종속성은 릴레이션의 효율성 여부에 중요한 판단 기준이 되지만, 릴레이션의 인스턴스만으로 잠재 된 모든 함수적 종속성을 찾아내기 어렵기 때문에 이를 확장하기 위해 암스트롱 공리를 적용하여 클로저로 확장함 도출된 클로저에는 자명한 함수적 종속성이나 중복된 함수적 종속성을 포함하고 있으므로 이러한 불필요한 종속성을 제거한 카노니컬 커버를 사용하여 정규화를 진행함 함수적 종속성은 릴레이션 스키마의 속성들 사이에 명시되는 기본적인 제약 조건임 함수적 종속성에 의한 방법과 추론하는 방법을 바탕으로 기본적인 정규형을 구성할 수 있음 정규형의 만족 시켜야 하는 제약 조건에 따라 제1 정규형, 제2 정규형, 제3 정규형, BC 정규형, 제4 정규형, 제5 정규형 순서로 진행됨 정규형의 조건은 정규화가 진행될수록 강화 됨 체크 포인트 제 3정규형(3NF)에서 BCNF(Boyce-Codd Normal Form)가 되기 위한 조건은? a. 결정자가 후보키가 아닌 함수 종속 제거 이행적 함수 종속 제거 - 제3 정규형 만족 원자 값이 아닌 도메인 분해 - 제1 정규형 만족 결정자가 후보키가 아닌 함수 종속 제거 - BC 정규형 만족 부분 함수 종속 제거 - 제2 정규형 만족 다음에서 설명하는 모든 조건을 만족하는 릴레이션 R의 정규형은? 릴레이션 R의 함수 종속 관계에서 기본 키가 아닌 모든 속성들이 기본키에 이행적 함수 종속이 아니다. 제3 정규형 조건 만족 릴레이션 R에 속한 모든 속성의 도메인이 원잣 값만으로 되어 있으며, 기본 키가 아닌 모든 속성이 기본 키에 완전 함수 종속이다. 제1 정규형 , 제2 정규형 만족 릴레이션 R의 함수 종속 관계에서 결정자(determinant) 중에 후보 키가 아닌 것이 포함되어 있을 수 있다. BC 정규형 만족시키지 않음 a. 제3 정규형 " }, { "title": "[Java 프로그래밍] 8강 - java.lang 패키지", "url": "/posts/knou-java-8/", "categories": "Language, Java", "tags": "knou, java", "date": "2025-04-19 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김희천 교수님의 'Java 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 java.lang패키지에 존재하는 기본 클래스에 관해 살펴봄 모든 클래스의 조상 클래스인 Object클래스와 문자열을 표현하는 String클래스를 학습함 StringBuffer클래스의 용도와 기본형을 참조형으로 표현하고자 할 때 필요한 포장 클래스, 그리고 표준 입력과 표준 출력 스트림을 제공하는 System클래스에 관해 학습함학습 목표 Object클래스가 제공하는 메소드의 기능을 설명할 수 있음 String과 StringBuffer클래스를 적절히 사용할 수 있음 기본형, String 및 포장 클래스 간의 형 변환 방법을 설명할 수 있음 System클래스를 사용할 수 있음강의록Object클래스java.lang패키지 자바 프로그래밍에 필요한 기본 클래스를 제공 java.lang패키지에 존재하는 클래스를 사용할 때는 import문이 필요 없음 주요 클래스 Object, System, Math String, StringBuffer Process, Thread Exception, Throwable, Error 포장 클래스 Number, Integer, Double, Character, Boolean등 Object클래스와 주요 메소드 자동으로 모든 클래스의 조상이 되는 클래스 클래스 계층 구조에서 루트가 되는 클래스 모든 클래스는 자동으로 Object클래스 상속 받음 주요 메소드 객체를 복제하여 반환 protected Object clone() 같은 객체인지 참조 값으로 비교 public boolean equals(Object obj) 객체를 식별하는 정수 값을 반환 public int hashCode() 객체를 문자열로 반환 public String toString() Object클래스의 toString()메소드 객체의 문자열로 표현하여 반환함 클래스이름@16진수해시코드로 표현 문자열의 +연산 또는 System.out.print()등에서 필요함 자식 클래스에서 재정의할 수 있음 String, Integer클래스 등에서 재정의되어 있음 toString()메소드의 사용 class MyClass1 { } class MyClass2 extends Object { public String toString() { return \"This MyClass2 class\"; } } public class MyClass3 { public static void main(String args[]) { MyClass1 my_class1 = new MyClass1(); MyClass2 my_class2 = new MyClass2(); System.out.println(my_class1); System.out.println(my_class1.toString()); System.out.println(my_class2); System.out.println(my_class2.toString()); } } // MyClass1@762efe5d // MyClass1@762efe5d // This MyClass2 class // This MyClass2 class Object클래스의 equals()메소드 Object클래스에서 equals()의 의미 obj1.equals(obj2)의 결과는 (obj1 == obj2)와 같음 두 객체 변수를 비교해서 변수가 가리키는 객체의 참조 값이 같을 때 true를 반환 자식 클래스에 재정의할 수 있음 String, Integer클래스 등에서 재정의 되어있음 참조 값이 아닌 객체의 유형과 저장된 데이터 값을 비교함 Integer x = new Integer(5); Integer y = new Integer(10); Integer a = 5; Short b = 5; System.out.println(x.equals(y)); // false System.out.println(x.equals(a)); // true System.out.println(x.equals(b)); // false System.out.println(x == y); // false System.out.println(x == a); // true // System.out.println(a == b); // 컴파일 오류 Object클래스의 clone()메소드 객체를 복제하여 리턴함 Cloneable인터페이스를 구현한 클래스의 객체만 clone()메소드를 호출할 수 있음 예외(CloneNotSupportedException) 처리를 해주어야함 복제 가능한 사용자 클래스의 정의 class Box implements Cloneable { private int width, height; public Box(int w, int h) { width = w; height = h; } public int width() { return width; } public int height() { return height; } public Object clone() { try { return super.clone(); } catch (CloneNotSupportedException e) { return null; } } } public class Main { public static void main(String args[]) { Box b1 = new Box(20, 30); Box b2 = (Box) b1.clone(); System.out.println(b2.width()); //20 System.out.println(b2.height()); //30 System.out.println(b1); System.out.println(b2); } } // 20 // 30 // Box@28a418fc // Box@5305068a Object클래스의 getClass()메소드 현재 객체의 유형, 즉 클래스 정보를 가진 Class객체를 리턴함 Class클래스는 클래스의 정보 확인을 위한 메소드를 제공 public class Main { public static void main(String args[]) { Box box = new Box(20, 30); Class c = box.getClass(); String class_name = c.getName(); String super_class = c.getSuperclass().getName(); Field []fields = c.getDeclaredFields(); Method []methods = c.getDeclaredMethods(); System.out.println(\"클래스 이름 : \" + class_name); System.out.println(\"슈퍼 클래스 이름 : \" + super_class); System.out.println(\"필드 목록\"); for(int i = 0; i &lt; fields.length; i++ ) System.out.println(fields[i]); System.out.println(\"메소드 목록\"); for(int i = 0; i &lt; methods.length; i++) System.out.println(methods[i]); } } // 클래스 이름 : Box // 슈퍼 클래스 이름 : java.lang.Object // 필드 목록 // private int Box.width // private int Box.height // 메소드 목록 // public int Box.width() // public int Box.height() String클래스String클래스와 생성자 문자열을 표현하고 처리하기 위한 클래스 String s1 = new String(\"Java\"); // 객체를 생성 String클래스는 기본 자료형처럼 사용될 수 있음 String s2 = \"Java\"; // 리터럴을 대입 같은 리터럴은 1개만 만들어져 공유됨 String객체는 내용이 변하지 않는(immutable) 상수 객체 생성자 빈 문자열 객체 생성 public String() public String(String original) public String(char[] value) public String(char[] value, int offset, int count) 문자열의 비교 주요 메소드 compareTo메소드 int compareTo(String anotherString) 두 문자열이 같으면 0을 리턴하고, 다르면 0이 아닌 정수 값을 리턴함 compareToIgnoreCase메소드 int compareToIgnoreCase(String anotherString) 대소문자를 무시하고 비교 equals메소드 boolean equals(Object anObject) 두 문자열을 비교하여 같으면 true를 리턴하고 다르면 false를 리턴함 equalsIgnoreCase메소드 boolean equalsIgnoreCase(String anotherString) 대소문자를 무시하고 비교 String s1 = \"Java\";String s2 = \"Java\";String s3 = new String(\"Java\");String s4 = new String(\"Java\");문자열의 검색 주요 메소드 indexOf메소드 처음 위치부터 문자열 str을 찾아 처음 등장하는 위치(인덱스)를 리턴, 없으면 -1을 리턴함 int indexOf(String str) System.out.println(\"hamburger\".indexOf(\"urge\")); fromIndex 위치부터 문자열 str을 찾아 처음 등장하는 위치(인덱스)를 리턴하며, 없으면 -1을 리턴함 int indexOf(String str, int fromIndex) lastIndexOf메소드 int lastIndexOf(String str), int lastIndexOf(String str, int fromIndex) 마지막 위치부터 앞 방향으로 찾음 문자열의 추출 메소드 주요 메소드 charAt메소드 index 위치에 있는 문자를 리턴 함 char charAt(int index) substring메소드 beginIndex 위치부터 마지막까지의 문자열을 리턴 함 String substring(int beginIndex) System.out.println(\"hamburger\".substring(3)); substring메소드 beginIndex 위치부터 (endIndex - 1)까지의 문자열을 리턴 함 String substring(int beginIndex, int endIndex) 문자열의 변환 원본 문자열은 변경되지 않고 새로운 객체가 만들어짐 주요 메소드 replace메소드 String replace(char oldChar, char newChar) oldChar 문자를 newChar 문자로 변환하여 리턴 함 trim메소드 String trim() 문자열 앞과 뒤에 나오는 화이트 스페이스 문자를 제거하여 리턴 함 toUpperCase메소드 String toUpperCase() 모든 문자를 대문자로 변환하여 리턴 함 toLowerCase메소드 String toLowerCase() 모든 문자를 소문자로 변환하여 리턴 함 concat메소드 String concat(String str) 두 문자열을 연결하여 리턴 함 다른 자료형을 문자열로 변환하는 메소드 문자열의 변환 public class Main { public static void main(String args[]) { System.out.println(String.valueOf(123)); System.out.println(String.valueOf(5 &gt; 3)); System.out.println(String.valueOf(3.0)); System.out.println(String.valueOf('c')); int[] a = new int[5]; System.out.println(String.valueOf(a)); char[] b = { 'J', 'a', 'v', 'a' }; System.out.println(String.valueOf(b)); } } // 123 // true // 3.0 // c // [I@7de26db8 // Java 기타 메소드 startsWith메소드 boolean startsWith(String prefix) prefix로 시작하면 true를 리턴 함 endsWith메소드 boolean endsWith(String suffix) suffix로 끝나면 true를 리턴 함 toCharArray메소드 char[] toCharArray() 문자 배열로 변환하여 리턴 함 StringBuffer클래스StringBuffer클래스와 생성자 객체 생성 이후 문자열을 변경할 수 있는 클래스 StringBuffer는 내용 변경이 가능한 mutable 클래스 내부적으로 문자열을 저장하기 위해 크기가 조절되는 버퍼를 사용함 생성자 StringBuffer() // 초기 버퍼의 크기는 16 StringBuffer(int length) StringBuffer(String str) // 초기 버퍼의 크기는 (str의 길이+16) StringBuffer클래스의 주요 메소드 주요 메소드 StringBuffer s1 = new StringBuffer(\"start\"); System.out.println(s1.capacity()); // 21 System.out.println(s1.length()); // 5 System.out.println(s1.append(\"le\")); // startle capacity메소드 int capacity() 버퍼의 크기를 리턴 함 length메소드 int length() 문자열의 길이를 리턴 함 charAt메소드 char charAt(int index) index 위치의 문자를 리턴 함 indexOf메소드 int indexOf(String str) str로 시작하는 첫 위치를 리턴 함 substring메소드 String substring(int start, int end) start 위치부터 (end - 1) 위치 까지의 문자열을 리턴 함 append메소드 StringBuffer append(char c) 문자 c를 추가한 StringBuffer객체를 리턴 함 delete메소드 StringBuffer delete(int start, int end) start 위치에서 (end - 1)까지의 문자열을 삭제 insert메소드 StringBuffer insert(int offset, String s) offset 위치부터 s를 삽입 replace메소드 StringBuffer replace(int start, int end, String s) start 위치부터 (end - 1)까지의 문자열을 s로 교체 reverse메소드 StringBuffer reverse() 문자열을 역순으로 변경 String클래스를 사용할 때의 문제점 문자열을 빈번하게 변경하는 프로그램에서 메모리 낭비 문제 String은 immutable 클래스 기존 객체는 놔둔 채 새로운 String 객체가 계속 생성되어 실행이 느려짐 ex) String클래스의 메모리 낭비 public class Main { public static void main(String args[]) { final String aValue = \"abcde\"; String str = new String(); for (int i = 0; i &lt; 1000; i++) str = str + aValue; System.out.println(str); } } StringBuffer클래스와 StringBuilder클래스의 사용 String과 StringBuffer및 StringBuilder클래스의 비교 final String tmp = \"abcde\"; long start, end; String str = new String(); StringBuffer sb1 = new StringBuffer(); StringBuilder sb2 = new StringBuilder(); start = System.nanoTime(); for(int i = 0; i &lt; 10000; i++) str = str + tmp; end = System.nanoTime(); System.out.println((end-start)/1000000.0 +\" msecs\"); start = System.nanoTime(); for(int i = 0; i &lt; 10000; i++) sb1.append(tmp); end = System.nanoTime(); System.out.println((end-start)/1000000.0 +\" msecs\"); start = System.nanoTime(); for(int i = 0;i &lt; 10000; i++) sb2.append(tmp); end = System.nanoTime(); System.out.println((end-start)/1000000.0 +\" msecs\"); // 88.3837 msecs // 1.2864 msecs // 1.2675 msecs 포장 클래스포장 클래스란 기본형을 참조형으로 표현하기 위한 클래스 기본형과 상응하는 객체 사이의 형변환(박싱 또는 언박싱) 기능 제공 기본형과 String사이의 형변환 기능 제공 구분 정수형 정수형 정수형 정수형 실수형 실수형 문자형 논리형 기본형 byte short int long float double char boolean 참조형 Byte Short Integer Long Float Double Character Boolean 사용 목적 메소드의 인자로 객체가 필요할 때 Number의 자식 포장 클래스가 제공하는 상수를 사용할 때 Integer.MIN_VALUE, Integer.MAX_VALUE등 클래스가 제공하는 다양한 메소드를 사용할 때 Number클래스 Number는 숫자를 표현하는 포장 클래스인 Byte, Short, Integer, Long, Float, Double의 추상 부모 클래스 Number의 자식 클래스에서 구현된 주요 메소드 doubleValue메소드 double doubleValue() Double객체를 double 값으로 변환 unboxing toString메소드 String toString() Double객체를 String으로 변환 valueOf메소드(double) static Double valueOf(double) double 값을 Double객체로 변환 boxing toString메소드(double) static String toString(double) double 값을 String으로 변환 valueOf메소드(string) static Double valueOf(String) String을 Double객체로 변환 parseDouble메소드(string) static double parseDouble(String) String을 double 객체로 변환 compareTo메소드 int compareTo(Byte anotherByte) 인자와 비교하여, 숫자가 같으면 0을 리턴 equals메소드 boolean equals(Object obj) 같은 유형이고, 값이 같으면 true를 리턴 String과 기본형 데이터 간의 변환 포장 클래스가 제공하는 static메소드를 사용함 String을 int(또는 long)형으로 변환하는 경우 int n = Integer.parseInt(\"123\"); long l = Long.parseLong(\"1234\"); int형(또는 long)을 String형으로 변환하는 경우 String s1 = Integer.toString(4); String s2 = Long.toString(5l); String s3 = String.valueOf(123); Integer클래스 Integer, String, int사이의 변환 기능을 제공 다른 클래스들도 유사한 기능을 제공함 주요 메소드 static int parseInt(String s) // String을 int로 static String toString(int i) // int를 String으로 static Integer valueOf(int i) // int를 Integer로 static String toString() // Integer를 String으로 static Integer valueOf(String s) // String을 Integer로 박싱 기본형 데이터를 포장 클래스의 객체로 변환하는 것 ex) double 값을 Double객체로 변환 Double radius = new Double(2.59); // 생성자 사용, 옛날 방식 Double radius = Double.valueOf(10.4); // valueOf() 사용 Double radius = 2.59; // 자동 boxing 자동 박싱 기본형에서 포장 클래스의 객체로 자동 변환되는 것 인자에 전달되거나 변수에 대입 될 때 적용 됨 언박싱 포장 클래스의 객체를 기본형 데이터로 변환하는 것 포장 클래스에서 기본형 Value()메소드를 사용 ex) // radius는 Double형 객체라 가정 double r = radius.doubleValue(); // 객체.기본형Value() double r = radius; // 자동 unboxing System.out.println(Integer.valueOf(3) % 2); // 자동 unboxing 자동 언박싱 포장 클래스의 객체에서 기본형으로 자동 변환되는 것 인자에 전달되거나 변수에 대입 될 때 적용됨 System클래스System클래스 Java 플랫폼 및 시스템과 관련된 기능 제공 유용한 클래스 필드와 메소드를 가짐 모든 멤버는 static, 사용할 때 생성할 필요 없음 주요 기능 표준 입출력 객체를 제공 JVM 또는 운영체제 속성과 시스템 환경 변수의 사용과 제어 배열 복사, 시간 조회 프로그램의 제어 등 System클래스의 표준 입출력 필드 System.in 표준 입력 스트림으로 InputStream유형 키보드로부터 입력을 받을 때 사용 System.in.read()는 키보드로부터 1바이트 문자를 입력 받음 System.out 표준 출력 스트림으로 PrintStream유형 화면에 데이터를 출력할 때 사용 System.err 표준 에러 출력 스트림으로 PrintStream유형 오류 메시지를 화면에 출력할 때 사용 키보드로부터 문자 입력 받기 표준 입력을 사용하여 문자 입력 받기 import java.io.*; public class Main { public static void main(String args[]) throws IOException { char cInput = 0; int i; System.out.print(\"Input a character: \"); cInput = (char) System.in.read(); System.out.println(cInput); i = System.in.read(); System.out.println(i); i = System.in.read(); System.out.println(i); System.out.println(System.in.available()); } } // Input a character: a // a // 13 // 10 // 0 여러 자리 숫자 입력 받기 import java.io.*; public class Main { public static void main(String args[]) throws IOException { String szInputLine; int nValue; InputStreamReader isr = new InputStreamReader(System.in); BufferedReader is = new BufferedReader(isr); System.out.print(\"Input a number: \"); szInputLine = is.readLine(); nValue = Integer.parseInt(szInputLine); System.out.println(nValue); is.close(); } } // Input a number: 134 // 134 학습 정리 java.lang패키지의 클래스를 사용할 때는 import구문을 쓰지 않아도 됨 String은 문자열 처리를 위한 다양한 메소드를 제공하지만 immutable 클래스로, String객체는 생성 이후에 내용 변경이 불가능함 toString()메소드와 equals()메소드는 Object클래스에서 정의되어 있으며, 몇몇 하위 클래스들에서 적절히 재정의되어 있음 자주 변경되는 문자열을 다루어야 할 경우에는 String클래스보다 StringBuffer나 StringBuilder클래스를 사용하는 것이 보다 효율적임 기본형 값을 객체로 다루기 위해, 모든 기본형마다 상응하는 포장 클래스가 존재함 System클래스는 표준 입력과 출력, 표준 오류 출력을 위해 in, out, err객체를 제공함연습 문제 다음 프로그램의 출력 결과는 무엇인가? public class Main { public static void main(String args[]) { String s = new String(\"Jovo\"); s.replace('o','a'); s.concat(\"Exam\"); System.out.println(s); } } a. Jovo Java에서 String 객체는 불변(immutable)하기 때문에 원본 문자열은 변경되지 않음 replace와 concat 메서드는 새로운 문자열을 반환할 뿐, 기존 문자열 객체를 수정하지 않음 반환 값을 저장하지 않았기 때문에 s는 계속 \"Jovo\"를 참조하고 있음 수정된 문자열을 저장하기 위해서는 아래처럼 반환 값을 s에 다시 저장해야 함 public class Main { public static void main(String args[]) { String s = new String(\"Jovo\"); s = s.replace('o', 'a'); // 반환 값을 다시 s에 저장 s = s.concat(\"Exam\"); // 반환 값을 다시 s에 저장 System.out.println(s); // \"JavaExam\" } } Object클래스와 String클래스에 대한 설명이다. 잘못된 것은 무엇인가? a. String클래스는 표준 입출력 스트림을 위한 static필드를 제공한다. Object클래스와 String클래스에 대한 설명으로 옳은 것 모든 클래스는 묵시적으로 Object클래스를 상속 받음 Object클래스에 toString()과 equals()메소드가 정의되어 있음 String클래스에 toString()과 equals()메소드가 재정의되어 있음 String 클래스는 표준 입출력 스트림과 관련된 static필드를 제공하지 않음 표준 입출력 스트림(System.in, System.out, System.err)은 System클래스에서 제공함 교재의 소스 7-22에서 문자열 처리 시간에 차이가 생기는 이유를 설명하라. a. String클래스는 immutable 클래스여서 반복이 진행될수록 계속해서 기존 문자열은 버려지고 새로운 문자열이 새롭게 만들어지기 때문임 (버려지거나 만들어지는 문자열의 길이도 점점 커짐) StringBuffer클래스를 사용한 경우가 StringBuilder클래스를 사용한 경우보다 시간이 더 걸리는 이유는 동시성 제어를 고려하여 메소드가 구현되었기 때문임 " }, { "title": "[운영 체제] 7강 - 교착 상태", "url": "/posts/knou-os-7/", "categories": "OS, Operating System", "tags": "knou, os", "date": "2025-04-17 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김진욱 교수님의 '운영 체제' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 교착 상태의 필요 조건은 제거하지 못하는 경우도 있고 제거할 수는 있지만 자원 이용률이 낮아지는 경우도 있음 특히 환 형 대기 조건을 제거하는 방법은 적용에 어려움이 존재함 교착 상태를 처리하는 다른 기법 교착 상태 회피는 안전 순서 열이라는 개념을 이용하여 교착 상태를 피하는 방법임 교착 상태 탐지 및 복구는 교착 상태가 발생하면 사후 처리를 하는 방법임 교착 상태를 회피하는 방법을 자세히 알아보고, 교착 상태를 탐지 및 복구하는 방법에 대해서도 살펴봄학습 목표 교착 상태를 회피하는 방법을 설명할 수 있음 교착 상태를 탐지하고 복구하는 방법을 설명할 수 있음강의록교착 상태 회피교착 상태 회피 프로세스의 자원 사용에 대한 사전 정보를 활용하여 시스템이 교착 상태가 발생하지 않는 상태에 머물도록 하는 방법 사전 정보 현재 할당된 자원 가용 상태의 자원 각 프로세스들의 최대 자원 요구량 안전 상태와 안전 순서열 안전 상태 교착 상태가 발생하지 않음 교착 상태를 회피하면서 각 프로세스에 그들의 최대 요구량까지 빠짐 없이 자원을 할당할 수 있는 상태 안전 순서 열이 존재하는 경우 불안전 상태 안전 순서 열이 존재하지 않는 경우 불 안전 상태가 반드시 교착 상태를 의미하는 것은 아니지만 교착 상태로 이어질 가능성이 있는 상태임 안전 순서 열 순서 있는 프로세스의 집합 &lt;p₁, p₂, …, pₙ&gt; 각 pᵢ 에 대해, pᵢ 가 추가로 요구할 수 있는 자원의 양이 현재 가용 상태의 자원으로 충당되거나 혹은 여기에 pⱼ(단, j&lt; i)에 할당 된 자원까지 포함하여 충당 가능한 경우 안전 순서 열이 존재하면 시스템은 안전 상태 시스템 상태 자원 r₁ 단위 자원 8개 프로세스 p₁ 프로세스가 종료될 때 까지 필요한 자원 최대 요구량 5개 프로세스 p₂ 프로세스가 종료될 때 까지 필요한 자원 최대 요구량 2개 프로세스 p₃ 프로세스가 종료될 때 까지 필요한 자원 최대 요구량 8개 시각 T₁ 상태 p₁ 단위 자원 할당 X, p₂ 단위 자원 할당 1개. p₃ 단위 자원 할당 5개, r₁ 가용 가능한 단위 자원 2개 p₁ 종료 되기 위해 단위 자원 5개 더 필요, p₂ 종료 되기 위해 단위 자원 1개 더 필요, p₃ 종료 되기 위해 단위 자원 3개 더 필요 p₂에게 r₁의 가용 가능한 단위 자원 1개 할당 → 종료 후 2개 반환 → r₁ 가용 가능한 단위 자원 3개 p₃에게 r₁의 가용 가능한 단위 자원 3개 할당 → 종료 후 8개 반환 → r₁ 가용 가능한 단위 자원 8개 p₁에게 r₁의 가용 가능한 단위 자원 5개 할당 안전 순서 열 p₂ → p₃ → p₁ 시각 T₂ 상태 p₁ 단위 자원 할당 X, p₂ 단위 자원 할당 1개. p₃ 단위 자원 할당 5개, r₁ 가용 가능한 단위 자원 2개 p₁ 단위 자원 1개 할당 요청 → r₁의 가용 가능한 단위 자원은 2개 이므로 1개 할당 → r₁ 가용 가능한 단위 자원 1개 p₂에게 r₁의 가용 가능한 단위 자원 1개 할당 → 종료 후 2개 반환 → r₁ 가용 가능한 단위 자원 2개 p₁ 이 필요한 자원은 4개, p₃는 3개지만 r₁의 가용 가능한 단위 자원 2개이므로 할당 불가능 안전 순서 열 p₂ → X → 불안전 상태 시각 T₂ 상태(교착 상태 회피) p₁ 단위 자원 할당 X, p₂ 단위 자원 할당 1개. p₃ 단위 자원 할당 5개, r₁ 가용 가능한 단위 자원 2개 p₁ 단위 자원 1개 할당 요청 → r₁은 요구 간선 그대로 내버려 두고 할당하지 않음 → 그 후 안전 순서 열 계산 p₁ 종료 되기 위해 단위 자원 5개 더 필요, p₂ 종료 되기 위해 단위 자원 1개 더 필요, p₃ 종료 되기 위해 단위 자원 3개 더 필요 p₂에게 r₁의 가용 가능한 단위 자원 1개 할당 → 종료 후 2개 반환 → r₁ 가용 가능한 단위 자원 3개 p₃에게 r₁의 가용 가능한 단위 자원 3개 할당 → 종료 후 8개 반환 → r₁ 가용 가능한 단위 자원 8개 p₁에게 r₁의 가용 가능한 단위 자원 5개 할당 안전 순서 열 p₂ → p₃ → p₁ 교착 상태 회피 교착 상태는 불안전 상태에서만 발생 가능 항상 안전 상태를 유지해야 함 프로세스가 가용 상태의 자원을 요구하더라도 프로세스는 대기 상태가 될 수 있음 자원 이용율은 다소 낮아질 수 있음 교착 상태 회피 알고리즘 각 자원의 단위 자원이 하나 밖에 없는 경우 변형 된 자원 할당 그래프 이용 각 자원의 단위 자원이 여러 개 일 수 있는 경우 은행원 알고리즘 이용 각 자원의 단위 자원이 하나 밖에 없는 경우 변형 된 자원 할당 그래프 자원 정점에 표시하던 단위 자원의 개수 제거 선언 간선 (pᵢ, rⱼ) 추가 앞으로 프로세스 pᵢ가 자원 rⱼ를 요구하게 될 것임 각각의 프로세스가 종료하기 위해 추가적으로 요청할 자원이 있음을 나타냄 요구 간선과 구분을 위해 점선으로 표시 자원을 요구 받으면 해당 선언 간선을 요구 간선으로 변경 그 요구 간선을 할당 간선으로 변환해도 사이클이 생기지 않는 경우에만 자원을 할당하고 할당 간선으로 변환 ex) p₁이 r₂를 요구하는 경우 프로세스 p₁가 자원 r₂를 요청하면, 선언 간선 p₁ → r₂를 요청 간선 p₁ → r₂(실선)으로 변경함 이 요청 간선을 할당 간선 r₂ → p₁ 로 변환(즉, 자원을 할당)했을 때, 그래프에 사이클이 생기지 않는 경우에만 실제로 자원을 할당하고 할당 간선으로 변경함 사이클이 생긴다면, 자원을 할당하지 않고 프로세스는 대기함 불안전 상태 초래 가능성 방지 ex) p₂가 r₂를 요구하는 경우 프로세스 p₂가 자원 r₂를 요청하면, 선언 간선 p₂ → r₂를 요청 간선 p₂ → r₂(실선)으로 변경함 이 요청 간선을 할당 간선 r₂ → p₂로 변환했을 때 그래프 상에서 사이클이 생기김 불안정 상태를 방지하기 위해 자원을 할당하지 않고 프로세스 대기 각 자원의 단위 자원이 여러 개 일 수 있는 경우 은행원 알고리즘 자원을 요구 받으면 그 자원을 할당해 주고 난 후의 상태를 계산해서 그것이 안전 상태인지 확인 안전 상태가 보장 되는 경우에만 자원을 할당 ex) p₁의 할당 자원 0, 최대 요구량 5, 추가 요구량 5 p₂의 할당 자원 1, 최대 요구량 2, 추가 요구량 1 p₃의 할당 자원 5, 최대 요구량 8, 추가 요구량 3 r₁의 가용 자원 2 ex) p₁의 할당 자원 r₁ 0 ,r₂ 2, 최대 요구량 r₁ 7, r₂ 5, 추가 요구량 r₁ 7, r₂ 3 p₂의 할당 자원 r₁ 1 ,r₂ 5, 최대 요구량 r₁ 3, r₂ 6, 추가 요구량 r₁ 1, r₂ 5 p₃의 할당 자원 r₁ 4 ,r₂ 1, 최대 요구량 r₁ 8, r₂ 8, 추가 요구량 r₁ 4, r₂ 1 r₁의 가용 자원 3, r₂의 가용 자원 3 새로운 변수 WORK 에 현재 상태에서 가용할 수 있는 자원 AVAIL 값 복사 각 프로세스마다 FINISH 값 false로 설정 프로세스가 종료되지 않았다는 의미 WORK 값을 할당 해 NEED 값을 할당 할 수 있는 프로세스 체크 p₂한테 자원 할당 후 p₂가 종료 된 후 반환 된 1, 5 값 WORK 값에 추가 WORK 값 4, 8을 이용해 NEED 값 할당 할 수 있는 프로세스 체크 p₃한테 자원 할당 후 p₃가 종료 된 후 반환 된 4, 1 값 WORK 값에 추가 WORK 값 8, 8을 이용해 NEED 값 할당 할 수 있는 프로세스 체크 p₁한테 자원 할당 후 p₁가 종료 된 후 반환 된 0, 2 값 WORK 값에 추가 모든 프로세스 상태 FINISH = true 이므로 안전 상태가 되므로 자원 할당해줌 p₁의 할당 자원 r₁ 0 ,r₂ 2, 최대 요구량 r₁ 7, r₂ 5, 추가 요구량 r₁ 7, r₂ 3 p₂의 할당 자원 r₁ 1 ,r₂ 5, 최대 요구량 r₁ 3, r₂ 6, 추가 요구량 r₁ 1, r₂ 5 p₃의 할당 자원 r₁ 4 ,r₂ 1, 최대 요구량 r₁ 8, r₂ 8, 추가 요구량 r₁ 4, r₂ 1 r₁의 가용 자원 3, r₂의 가용 자원 3 p₁이 단위 자원 r₁ 1 ,r₂ 1 요구함 → 바로 할당하지 않고 상태 계산 먼저 함 ALLOC₁에 r₁ 1 ,r₂ 1 자원 할당 → NEED₁ r₁ 6, r₂ 4로 감소 AVAIL r₁ 1 ,r₂ 1 감소 해 r₁ 2 ,r₂ 2로 저장 새로운 변수 WORK 에 현재 상태에서 가용할 수 있는 자원 AVAIL 값 복사 각 프로세스마다 FINISH 값 false로 설정 프로세스가 종료되지 않았다는 의미 WORK 값을 할당 해 NEED 값을 할당 할 수 있는 프로세스 체크 p₂한테 자원 할당 후 p₂가 종료 된 후 반환 된 1, 5 값 WORK 값에 추가 WORK 값 3, 7을 이용해 NEED 값 할당 할 수 있는 프로세스 체크 할당 할 수 있는 프로세스 존재 하지 않음 → 불안전 상태 REQ₁에 가용할 자원이 있지만 불안정 상태가 되기 때문에 자원을 할당하지 않음 p₁의 할당 자원 r₁ 0 ,r₂ 2, 최대 요구량 r₁ 7, r₂ 5, 추가 요구량 r₁ 7, r₂ 3 p₂의 할당 자원 r₁ 1 ,r₂ 5, 최대 요구량 r₁ 3, r₂ 6, 추가 요구량 r₁ 1, r₂ 5 p₃의 할당 자원 r₁ 4 ,r₂ 1, 최대 요구량 r₁ 8, r₂ 8, 추가 요구량 r₁ 4, r₂ 1 r₁의 가용 자원 3, r₂의 가용 자원 3 p₃이 단위 자원 r₁ 1 ,r₂ 1 요구함 → 바로 할당하지 않고 상태 계산 먼저 함 ALLOC₁에 r₁ 1 ,r₂ 1 자원 할당 → NEED₁ r₁ 3, r₂ 6로 감소 AVAIL r₁ 1 ,r₂ 1 감소 해 r₁ 2 ,r₂ 2로 저장 새로운 변수 WORK 에 현재 상태에서 가용할 수 있는 자원 AVAIL 값 복사 각 프로세스마다 FINISH 값 false로 설정 프로세스가 종료되지 않았다는 의미 WORK 값을 할당 해 NEED 값을 할당 할 수 있는 프로세스 체크 p₂한테 자원 할당 후 p₂가 종료 된 후 반환 된 1, 5 값 WORK 값에 추가 WORK 값 3, 7을 이용해 NEED 값 할당 할 수 있는 프로세스 체크 p₃한테 자원 할당 후 p₃가 종료 된 후 반환 된 5, 2 값 WORK 값에 추가 WORK 값 8, 9을 이용해 NEED 값 할당 할 수 있는 프로세스 체크 p₁한테 자원 할당 후 p₁가 종료 된 후 반환 된 0, 2 값 WORK 값에 추가 모든 프로세스 상태 FINISH = true 이므로 안전 상태가 됨 안전 순서열 p₂ → p₃ → p₁으로 안전 상태가 되므로 자원 할당해줌 은행원 알고리즘: 의사 코드// 자원 요청 처리 함수 (pᵢ가 자원 REQᵢ를 요청)void bank(REQᵢ) { // 요청량 &lt;= 최대 필요량 확인 if (!(REQᵢ &lt;= NEEDᵢ)) { 오류 처리; } // 요청량 &lt;= 현재 가용량 확인 if (!(REQᵢ &lt;= AVAIL)) { pᵢ 대기; } // 할당 후와 같은 상태를 만듦 ALLOCᵢ = ALLOCᵢ + REQᵢ; NEEDᵢ = NEEDᵢ - REQᵢ; AVAIL = AVAIL - REQᵢ; // 할당 후가 안전 상태인지 (안전성 알고리즘 호출) status = safe(상태 데이터); // 안전하면 실제 할당, 아니면 원상 복구 후 대기 if (status == true) {\t REQᵢ 할당; } else { pᵢ 대기 및 상태 데이터 복구; }}// 안전성 알고리즘 (현재 상태가 안전한지 검사)boolean safe(상태 데이터) { WORK = AVAIL; // 작업용 가용 자원 벡터 FINISH[i]=false;(i=1,2,…,n) // 각 프로세스 종료 여부 (n개)\tfor(l=1; l&lt;=n; l++) {\t for(i=1; i&lt;=n; i++)\t if(FINISH[i]==false &amp;&amp; NEEDᵢ &lt;= WORK ) {\t\t\t WORK = WORK + ALLOCᵢ;\t\t\t FINISH[i] = true;\t\t\t break;\t\t }\t if (i &gt; n) break; } // 모든 프로세스가 종료될 수 있으면(모든 FINISH[i]가 true) 안전상태 if (모든 i에 대해 FINISH[i] == true) { return true; } else { return false; // 안전 순서열 찾기 실패 -&gt; 불안전상태 }}교착 상태 탐지 및 복구교착 상태 탐지 및 복구 사후에 처리하는 방법 교착 상태 탐지 시스템의 교착 상태 여부를 조사하기 위해 주기적으로 상태 조사 알고리즘 수행 교착 상태 복구 교착 상태가 탐지된 경우 적절한 조치를 취해 정상 상태로 복구 교착 상태 탐지 Shoshani와 Coffman 알고리즘 현재 할당된 ALLOC 값과 REQ 값만 필요함 p₁의 할당 자원 r₁ 0 ,r₂ 2, 요구 자원 r₁ 4, r₂ 6 p₂의 할당 자원 r₁ 1 ,r₂ 5, 요구 자원 r₁ 0, r₂ 3 p₃의 할당 자원 r₁ 4 ,r₂ 1, 요구 자원 r₁ 2, r₂ 9 r₁ 의 가용 가능 자원 3, r₂ 의 가용 가능 자원 3 새로운 변수 WORK 에 현재 상태에서 가용할 수 있는 자원 AVAIL 값 복사 자원 할당 받은 프로세스의 FINISH 값 false로 설정 프로세스가 종료되지 않았다는 의미 3. WORK 값을 할당 해 NEED 값을 할당 할 수 있는 프로세스 체크 p₂한테 자원 할당 후 p₂가 종료 된 후 반환 된 1, 5 값 WORK 값에 추가 4. WORK 값 4, 8을 이용해 NEED 값 할당 할 수 있는 프로세스 체크 p₁한테 자원 할당 후 p₁가 종료 된 후 반환 된 0, 2 값 WORK 값에 추가 5. WORK 값 4, 10을 이용해 NEED 값 할당 할 수 있는 프로세스 체크 p₃한테 자원 할당 후 p₃가 종료 된 후 반환 된 4, 1 값 WORK 값에 추가 6. 모든 프로세스 상태 FINISH = true 이므로 교착 상태가 아님을 판단함 p₁의 할당 자원 r₁ 0 ,r₂ 2, 요구 자원 r₁ 5, r₂ 6 p₂의 할당 자원 r₁ 1 ,r₂ 5, 요구 자원 r₁ 0, r₂ 3 p₃의 할당 자원 r₁ 4 ,r₂ 1, 요구 자원 r₁ 2, r₂ 9 r₁ 의 가용 가능 자원 3, r₂ 의 가용 가능 자원 3 새로운 변수 WORK 에 현재 상태에서 가용할 수 있는 자원 AVAIL 값 복사 자원 할당 받은 프로세스의 FINISH 값 false로 설정 프로세스가 종료되지 않았다는 의미 3. WORK 값을 할당 해 NEED 값을 할당 할 수 있는 프로세스 체크 p₂한테 자원 할당 후 p₂가 종료 된 후 반환 된 1, 5 값 WORK 값에 추가 4. WORK 값 4, 8을 이용해 NEED 값 할당 할 수 있는 프로세스 체크 할당 할 수 있는 프로세스 존재 하지 않음 → 교착 상태로 판단 5. FINISH 값이 false로 남아있는 프로세스에 대해 복구 작업 진행 boolean detect(상태 데이터) { \tWORK = AVAIL; \tif ( ALLOCᵢ != 0) FINISH[i] = false; \telse FINISH[i] = true; (i = 1, 2, ..., n) \tfor ( l = 1; l &lt;= n; l++ ) { \t\t\tfor(i=1; i&lt;=n; i++) \t\t\t\tif(FINISH[i]==false &amp;&amp; REQᵢ &lt;= WORK ) { \t\t\t\t\tWORK = WORK + ALLOCᵢ ; \t\t\t\t\tFINISH[i] = true; \t\t\t\t\tbreak; \t\t\t\t} \t\t\tif (i &gt; n) break; \t} \tif ( FINISH[i] == false인 i 존재) \t\treturn true; \telse return false; } 시간 복잡도 O(mn²) m: 자원 종류 n: 프로세스 수 알고리즘 수행 시점 즉시 받아들일 수 없는 자원 요구가 있을 때 정해진 시간 간격 CPU 효율이 일정 수준 이하로 떨어질 때 교착 상태 복구 교착 상태가 탐지 되면 복구 조치 복구의 주체 오퍼레이터 수작업으로 복구 운영체제 자동으로 복구 복구 방법 교착 상태 프로세스를 종료 교착 상태 프로세스가 할당 받은 자원을 해제 교착 상태 프로세스를 종료 모든 교착 상태 프로세스를 종료 단점 : 진행했던 내용에 대한 복원 비용 큼 사이클이 제거될 때까지 교착 상태 프로세스를 하나씩 종료 단점 : 종료 대상을 선택하기 위한 비용, 매 프로세스 종료 후 교착 상태 재 확인을 위한 비용 교착 상태 프로세스가 할당 받은 자원을 해제 사이클이 제거될 때까지 할당 된 자원을 단계적으로 선점하여 다른 프로세스들에 할당 프로세스와 자원 선택 기준 프로세스 진척도, 사용 중인 자원의 수 등 프로세스의 복귀 시점도 제반 요소를 고려하여 결정 기아 상태에 빠지지 않도록 프로세스 선택 시 복구 횟수 고려 정리 하기 교착 상태 회피는 프로세스의 자원 사용에 대한 사전 정보를 활용하여 교착 상태가 발생할 수 있는 불 안전 상태가 되는 것을 피하는 방법임 변형된 자원 할당 그래프에서 요구 간선을 할당 간선으로 바꾸어도 사이클이 생기지 않는 안전 상태일 경우에만 자원 요구를 수용함 은행원 알고리즘은 프로세스가 요구한 자원을 할당해 줄 경우에도 안전 순서 열이 존재하는지 검사하여 자원 요구의 수용 여부를 결정함 교착 상태 탐지 및 복구는 교착 상태가 발생 했는 가를 탐지한 후, 희생자를 선택하여 해당 프로세스를 중지 시키거나 자원을 선점하는 방법임 교착 상태 탐지 알고리즘은 현재 상태의 모든 자원 요구 량을 고려하여 교착 상태 여부를 확인함" }, { "title": "[데이터베이스 시스템] 7강 - SQL", "url": "/posts/knou-dbs-7/", "categories": "Database", "tags": "knou, database", "date": "2025-04-16 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '데이터베이스 시스템' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 데이터베이스에서 방대한 데이터를 효율적으로 활용하려면 단순한 데이터 조회를 넘어 복잡한 조건에 따른 검색, 여러 테이블의 데이터 결합, 재사용 가능한 결과 집합 생성 등의 고급 데이터 처리 능력이 필요함 만약 이러한 기능이 없다면 사용자는 비효율적으로 데이터를 개별 조회하고 수작업으로 결합하는 등 많은 시간을 소모하게 될 것임 따라서 중첩 질의, 조인 질의, 뷰와 같은 데이터 활용 기술을 익히는 것이 요구됨 중첩 질의, 조인 질의, 뷰의 개념과 필요성을 이해하고, 이를 활용하여 복합적인 데이터 검색과 가상의 테이블을 생성하는 방법을 학습함주요 용어 그룹 질의 특정 기준으로 레코드를 그룹화하고 각 레코드 그룹에 대해 집계 함수를 적용하는 질의 중첩 질의 SELECT문 내부에서 독립적으로 실행 가능한 또 다른 SELECT문이 내포되어 있는 질의 조인 질의 테이블 간의 관련성을 이용하여 두 개 이상의 테이블에서 데이터를 검색하는 질의 기법 뷰 데이터를 저장하고 있는 하나 이상의 테이블을 유도하여 생성하는 가상의 테이블 강의록중첩 질의의 이해중첩 질의의 개념 SELECT문 내부에서 독립적으로 실행 가능한 또 다른 SELECT문이 내포되어 있는 질의 일반적으로 내부 질의의 처리 결과를 외부 질의에서 재사용하여 처리하는 과정 중첩 질의의 종류 FROM절에서의 중첩 질의 활용 FROM절에서의 결과 집합을 SELECT문에서 재검색 WHERE절에서의 중첩 질의 활용 WHERE절에서의 결과 집합을 활용하여 외부 질의에서 레코드의 출력 여부를 결정 IN, NOT IN, EXISTS, NOT EXISTS사용 중첩 질의의 형식SELECT 컬럼1, 컬럼2, ..., 컬럼n FROM ( SELECT 컬럼1, 컬럼2, ..., 컬럼m FROM 테이블 WHERE 조건 ) WHERE 조건SELECT 컬럼1, 컬럼2, ..., 컬럼n FROM 테이블1 WHERE 컬럼i 연산자 ( SELECT 컬럼j FROM 테이블2 WHERE 조건 )중첩 질의의 사용 1 학과별 교수의 평균 연봉이 70,000,000 미만인 학과 중 가장 높은 평균 연봉을 출력하시오. 교수번호 교수이름 직위 소속학과 연봉 186432-760829 최우성 조교수 생활과학과 52000000 201547-634895 현경석 정교수 생활과학과 66000000 189414-790829 한용윤 조교수 법학과 45000000 191924-730620 이동휘 부교수 행정학과 51000000 194634-810228 김규식 정교수 컴퓨터과학과 70000000 194834-760517 정재화 부교수 컴퓨터과학과 53000000 201216-158465 정용제 조교수 국어국문학과 55000000 210315-549413 황지수 부교수 유아교육과 52000000 학과별 교수의 평균 연봉 먼저 구함 SELECT 소속학과, AVG(연봉) AS 평균연봉 FROM 교수 GROUP BY 소속학과 소속학과 평균연봉 국어국문학과 55000000.00 법학과 45000000.00 생활과학과 59000000.00 유아교육과 52000000.00 컴퓨터과학과 61500000.00 7천만원 미만 구하고 결과 중 가장 높은 연봉 출력 SELECT MAX(d.평균연봉) AS 평균연봉 FROM ( SELECT 소속학과, AVG(연봉) AS 평균연봉 FROM 교수 GROUP BY 소속학과 ) AS d WHERE d.평균연봉 &lt; 70000000 평균연봉 61500000.00 내부 질의 결과가 하나의 테이블로 도출 중첩 질의의 사용 2 직위가 ‘부교수’이고 이수 구분이 ‘교양’인 과목을 강의하는 교수의 이름과 소속학과를 출력하시오. 과목코드 과목명 학점 선수과목 이수구분 교수번호 COM11 컴퓨터의 이해 3   교양 … COM12 파이썬 프로그래밍 기초 3   교양 … COM24 자료구조 3 COM12 전공필수 … COM31 데이터베이스 시스템 3 COM24 전공필수 … COM34 알고리즘 3 COM24 일반선택 … COM44 클라우드 컴퓨팅 3   전공필수 … ECE24 놀이지도 3   전공필수 … ECE31 유아언어교육 3 ECE31 전공필수 … SELECT 교수번호 FROM 과목 WHERE 이수구분 = '교양' 교수번호 … … … SELECT A.교수이름, A.소속학과 FROM 교수 AS A WHERE A.직위 = '부교수' AND A.교수번호 IN ( SELECT B.교수번호 FROM 과목 B WHERE B.이수구분 = '교양' ) 교수이름 소속학과 정재화 컴퓨터과학과 ‘생활과학과’ 소속 학생 중 수강 신청을 하지 않은 학생의 학생 번호를 출력하시오 과목코드 학생번호 신청시각 KO03 201831-331215 2019-02-11 13:31:45 COM34 201831-331215 2020-02-20 13:54:22 COM24 201831-331215 2019-08-22 12:23:31 COM12 201831-331215 2019-08-21 23:25:25 LAW21 201834-021216 2016-02-11 08:21:22 KO03 201834-021216 2016-11-12 02:16:51 HE25 201834-021216 2017-08-01 01:24:54 생활과학과 한 학생의 학생 번호를 가져옴 SELECT 학생번호 FROM 전공 WHERE 학과이름 = '생활과학과' 학생번호 201926-880215 202031-354516 해당 학생 번호가 ‘수강’ 테이블에 있는지 조회 SELECT A.학생번호 FROM 전공 AS A WHERE A.학과이름 = '생활과학과' AND NOT EXISTS ( SELECT B.학생번호 FROM 수강 B WHERE A.학생번호 = B.학생번호 ) NOT EXISTS 검색 결과가 없으면 그 학생의 정보를 출력 내부 질의에 검색 결과가 없으면 True 조인 질의의 이해조인 질의 테이블 간의 관련성을 이용하여 두 개 이상의 테이블에서 데이터를 검색하는 질의 기법 두 개 이상의 테이블을 결합하여 하나의 결과 집합을 생성하는 방법 ER 모델링 및 정규화 기법으로 여러 테이블로 분리된 정보를 일시적으로 하나의 레코드로 통합 조인 질의의 종류 내부 조인(Inner Join) 교집합을 의미하며, 두 테이블에 공통적으로 존재하는 레코드를 결합 외부 조인(Outer Join) 합집합의 개념으로, 한 테이블에는 존재하지만 다른 테이블에는 존재하지 않는 레코드도 결과에 포함 내부 조인 두 개 이상의 테이블에서 조인 조건을 만족하는 레코드만 결합하여 출력 결과에 포함 시키는 연산 조인 조건은 WHERE절이 아닌 ON 절에 기록 ANSI SQL 표준과 사실 상의 표준인 Oracle 사가 제안한 조인 형식이 사용 SELECT 컬럼1, 컬럼2, ..., 컬럼m, FROM 테이블1 INNER JOIN 테이블2 ON 조인 조건1 [WHERE 조건] 내부 조인의 사용 1 나이가 30세 이상인 학생의 학생이름과 나이, 그리고 그 학생이 소유한 계좌의 계좌번호, 잔액을 출력하시오 학생이름 나이 학생번호 유관순 118 201834-021216 지정천 32 201926-880215 안창호 42 201931-781109 박은식 61 201934-080621 안중근 41 201934-790902 손병희 59 201978-610408 윤봉길 112 202031-816515 학생번호 잔액 201831-331215 800000 201834-021216 600000 201978-610408 400000 201931-781109 400000 201926-880215 300000 201934-790902 100000 201934-080621 300000 202034-596541 1200000 SELECT 학생이름, 나이, 학생번호 FROM 학생 WHERE 나이 &gt;= 30 학생이름 나이 학생번호 잔액 유관순 118 201834-021216 600000 지정천 32 201926-880215 300000 안창호 42 201931-781109 400000 박은식 61 201934-080621 300000 안중근 41 201934-790902 100000 손병희 59 201978-610408 400000 윤봉길 112 202031-816515 150000 SELECT 학생.학생이름, 학생.나이, 계좌.계좌번호, 계좌.잔액 FROM 학생 INNER JOIN 계좌 ON 학생.학생번호 = 계좌.학생번호 WHERE 학생.나이 &gt;= 30 학생이름 나이 학생번호 잔액 유관순 118 201834-021216 600000 지정천 32 201926-880215 300000 안창호 42 201931-781109 400000 박은식 61 201934-080621 300000 안중근 41 201934-790902 100000 손병희 59 201978-610408 400000 SELECT 학생.학생이름, 학생.나이, 계좌.계좌번호, 계좌.잔액 FROM 학생, 계좌 WHERE 학생.학생번호 = 계좌.학생번호 AND 학생.나이 &gt;= 30 학생이름 나이 학생번호 잔액 유관순 118 201834-021216 600000 지정천 32 201926-880215 300000 안창호 42 201931-781109 400000 박은식 61 201934-080621 300000 안중근 41 201934-790902 100000 손병희 59 201978-610408 400000 내부 조인의 사용 2 ‘컴퓨터과학과’소속의 교수가 강의하는 과목에 대해 과목별 수강하는 학생 수를 과목코드와 함께 출력하시오 SELECT * FROM 교수 INNER JOIN 과목 ON 교수.교수번호 = 과목.교수번호 INNER JOIN 수강 ON 과목.과목코드 = 수강.과목코드 SELECT * FROM 교수 INNER JOIN 과목 ON 교수.교수번호 = 과목.교수번호 INNER JOIN 수강 ON 과목.과목코드 = 수강.과목코드 WHERE 교수.소속학과 = '컴퓨터과학과' GROUP BY = 과목.과목코드 SELECT 과목.과목코드, COUNT(수강.학생번호) FROM 교수 INNER JOIN 과목 ON 교수.교수번호 = 과목.교수번호 INNER JOIN 수강 ON 과목.과목코드 = 수강.과목코드 WHERE 교수.소속학과 = '컴퓨터과학과' GROUP BY = 과목.과목코드 자연 조인 두 개 이상의 테이블을 하나의 테이블로 결합하는 내부 조인과 매우 유사한 기능 두 테이블에 동일한 이름의 컬럼에 대해 값이 같은 레코드를 결합하는 내부 조인 컬럼의 이름이 같으면, 컬럼의 이름이 같은 것끼리 붙는 형태 SELECT 컬럼1, 컬럼2, ..., 컬럼m FROM 테이블1 NATURAL JOIN 테이블2 [WHERE 조건]외부 조인의 개념 내부 조인(inner join)은 조인 조건에 일치하는 레코드만 결합하여 결과를 생성 조인 결과에 정보의 손실이 발생 외부 조인은 조인 조건에 맞지 않는 레코드도 질의의 결과에 포함 시키는 질의 외부 조인의 종류 왼쪽 외부 조인(left outer join) 오른쪽 외부 조인(right outer join) 완전 외부 조인(full outer join) 외부 조인 구문 형식SELECT 별칭1.컬럼1, 별칭1.컬럼2, ..., 별칭1.컬럼m, 별칭2.컬럼2, ..., 별칭2.컬럼n, FROM 테이블1 AS 별칭1 LEFT | RIGHT [OUTER] JOIN 테이블2 AS 별칭2 ON 별칭1.컬럼i = 별칭2.컬럼j [WHERE 절]외부 조인의 사용 학생의 학생번호, 학생이름과 그 학생이 수강신청한 과목의 과목코드, 신청시각을 출력하시오. 단 수강신청을 하지 않은 학생도 결과에 포함시키고 과목 코드를 기준으로 오름차순 정렬한다. 과목코드 학생번호 신청시각 COM11 201934-790902 2019-02-28 08:32:54 COM11 202026-590930 2019-02-20 16:00:21 COM11 202078-080621 2019-02-21 15:21:54 COM12 201831-331215 2019-08-21 23:25:25 COM12 201931-781109 2018-08-02 03:25:16 COM12 201978-610408 2015-02-24 10:25:40 SELECT A.학생번호, A.학생이름, B.과목코드, B.신청시각 FROM 학생 AS A LEFT OUTER JOIN 수강 2 AS B ON A.학생번호 = B.학생번호 ORDER BY B.과목코드 ASC 학생번호 학생이름 과목코드 신청시각 202031-354516 조정대 NULL NULL 201934-080621 박은식 NULL NULL 201934-790902 안중근 COM11 2019-02-28 08:32:54 202078-080621 강신영 COM11 2019-02-21 15:21:54 202026-590930 정용민 COM11 2019-02-20 16:00:21 201931-781109 안창호 COM12 2018-08-02 03:25:16 조건에 만족하지 않는 컬럼 값들은 NULL 로 채워짐 외부 조인의 실행 과정 학생 학생이름 학생번호 강신영 202078-080621 안중근 201934-790902 조정대 202031-354516 정용호 202034-596541 수강 학생번호 과목코드 202078-080621 COM11 201934-790902 COM11 201931-781109 COM12 202034-596541 COM24 조인 결과 학생이름 학생번호 과목코드 강신영 202078-080621 COM11 안중근 201934-790902 COM11 조정대 202031-354516 NULL 정용호 202034-596541 COM24 외부 조인이 LEFT일지 RIGHT 일지 파악할 것 수강 테이블이 앞에 위치한다면 RIGHT OUTER JOIN으로 변경셀프 조인 한 테이블이 자기 자신과 조인되는 질의 동일한 테이블에 대한 조인이므로 반드시 테이블 이름에 대한 별칭이 의무적으로 사용 SELECT 별칭1.컬럼1, 별칭1.컬럼2, ..., 별칭1.컬럼m, 별칭2.컬럼1, 별칭2.컬럼2, ..., 별칭2.컬럼n, FROM 테이블1 AS 별칭1 INNER|OUTER JOIN 테이블2 AS 별칭2 ON 조인조건 [WHERE절] 셀프 조인의 사용 과목의 과목코드, 과목명 그리고 그 과목의 선수과목의 과목코드, 과목명을 모두 출력하시오. 단, 선수과목이 없는 과목도 결과에 포함시킨다. 과목코드 과목명 학점 선수과목 이수구분 교수번호 COM11 컴퓨터의 이해 3   교양 … COM12 파이썬 프로그래밍 기초 3   교양 … COM24 자료구조 3 COM12 전공필수 … COM31 데이터베이스 시스템 3 COM24 전공필수 … COM34 알고리즘 3 COM24 일반선택 … COM44 클라우드 컴퓨팅 3   전공필수 … SELECT B.과목명, B.과목코드, A.과목명 AS 선수과목명, A.과목코드 AS 선수과목코드 \t\tFROM 과목 AS A RIGHT OUTER JOIN 과목 AS B \t\t ON A.과목코드 = B.선수과목코드 과목명 과목코드 선수과목명 선수과목코드 컴퓨터의 이해 COM11     파이썬 프로그래밍 기초 COM12     자료구조 COM24 인터넷과 정보사회 COM12 데이터베이스 시스템 COM31 자료구조 COM24 알고리즘 COM34 자료구조 COM24 클라우드 컴퓨팅 COM44     뷰의 사용뷰의 개념 데이터를 저장하고 있는 하나 이상의 테이블을 유도하여 생성하는 가상의 테이블(virtual table) 데이터 독립성 원본 테이블의 구조가 바뀌어도 뷰를 이용한 작업은 정의만 변경되어 응용 프로그램에 영향이 없음 실제 데이터를 저장하지 않고, 뷰 정의에 따라 질의가 실행될 때 데이터를 동적으로 생성 데이터 보안 사용자에게 원본 테이블의 일부 컬럼에 대한 접근을 허용하여 보안 효과를 향상 기본 테이블의 일부 컬럼이나 행만을 보여주는 효과를 통해 데이터 보안을 유지 다양한 구조의 테이블 사용 사용자의 요구 사항에 맞는 테이블의 구조를 제공 작업의 단순화 복잡한 질의문을 뷰로 단순화 데이터 무결성 WITH CHECK OPTION을 이용하여 뷰 생성에 위배되는 수정 작업을 거부 뷰의 생성 생성되는 뷰의 구조는 SELECT문의 결과로 결정 CREATE VIEW 뷰이름 AS ( SELECT 컬럼1, 컬럼2, ..., 컬럼n FROM 테이블 [WHERE 조건] ) [WITH CHECK OPTION] 뷰의 수정 및 삭제 뷰의 수정은 생성과 동일하게 새로운 SELECT문의 결과로 변경 ALTER VIEW 뷰이름 (컬럼1, 컬럼2, ..., 컬럼n) AS ( SELECT 컬럼1, 컬럼2, ..., 컬럼n FROM 테이블 [WHERE 조건] ) 뷰의 삭제는 일반적인 데이터베이스 객체 삭제와 동일 DROP VIEW 뷰이름 뷰 생성의 예 컴퓨터 과학과 소속의 학생정보와 학과이름 및 이수학점을 출력하는 ‘컴퓨터과학과_학생’ 뷰를 생성하시오 학생번호 학생이름 성별 생년월일 나이 전화번호 학과이름 이수학점 201831-331215 김마리아 여 1991-06-18 30 010-0000-0002 컴퓨터과학과 39 201934-790902 안중근 남 1979-09-02 42 010-0000-0006 컴퓨터과학과   202026-590930 정용민 남 2003-05-19 18 010-0000-0012 컴퓨터과학과 137 202031-816515 윤봉길 남 1908-06-21 113 010-0000-0009 컴퓨터과학과 12 202034-596541 정용호 남 2000-01-23 21 010-0000-0008 컴퓨터과학과 117 202078-080621 강신영 남 1991-06-26 30 010-0000-0011 컴퓨터과학과 96 SELECT 학생.*, 전공.전공, 전공.학과이름, 전공.이수학점 FROM 학생 NATURAL JOIN 전공 WHERE 전공.학과이름 = '컴퓨터과학과' CREATE VIEW 컴퓨터과학과_학생 AS ( SELECT 학생.*, 전공.전공, 전공.학과이름, 전공.이수학점 FROM 학생 NATURAL JOIN 전공 WHERE 전공.학과이름 = '컴퓨터과학과' ) 뷰를 이용한 데이터 검색 뷰는 가상의 테이블이므로 데이터 조작은 테이블 조작과 동일하게 수행 SELECT 컬럼1, ..., 컬럼n FROM 뷰이름 \t\tWHERE 조건 SELECT 컬럼1, ..., 컬럼n FROM 뷰이름 \t\tWHERE 조건 AND 뷰 정의 조건 뷰를 이용한 데이터 삽입 뷰에 대한 INSERT 문은 원본 테이블에서 실행 INSERT 문 실행 불가능한 경우 PRIMARY KEY, NOT NULL 등의 제약 사항이 위배되는 경우 삽입 불가능 원본 테이블에 존재하는 컬럼이지만 뷰에는 없는 컬럼에 삽입하는 경우 실행 불가능 조인 질의 또는 그룹 질의가 적용된 뷰는 데이터 삽입 및 수정이 불가능 WITH CHECK OPTION이 적용된 뷰는 위배되는 사항은 없지만 뷰에 맞지 않는 조건일 경우 실행 불가능 연습 문제 다음은 조인의 종류와 결과에 대한 다이어그램이다. (ㄴ)과 같은 형태의 조인을 무엇이라고 하는가? (단, A, B는 테이블을 나타낸다.) a. 내부 조인 주어진 다이어그램은 두 개의 테이블에서 연관성이 있는 레코드를 결합하여 출력할 때, 연관성의 범위를 나타냄 좌측부터 외부 조인, 내부 조인, 오른쪽 외부 조인을 의미함 강의 스키마를 참조하여 아래의 명령을 수행하기 위한 SQL 명령문으로 정확하게 작성된 것은? 강의번호 (PK) 강의이름 이수구분 교수번호 (FK) 선수강의 (FK) COM101 파이썬 프로그래밍 기초 교양 C01   COM301 데이터베이스 전공 C01 COM101 COM302 데이터베이스설계및구현 전공 C02 COM301 BSN103 경영학개론 교양 B01   BSN302 인적자원관리 전공 B02   선수강의가 있는 강의의 강의이름, 강의번호와 그 강의에 대한 선수강의의 강의이름을 출력하라 a. SELECT A.강의이름, A.강의번호, B.강의이름 FROM 강의 A INNER JOIN 강의 B ON A.선수강의 = B.강의번호 요청 된 질의 결과를 생성하기 위해서는 강의 정보와 선수 강의 정보가 필요함 따라서 테이블이 자기 자신과 조인하는 셀프 조인이 사용됨 셀프 조인은 반드시 테이블 이름에 대한 별칭이 요구 됨 또한 선수 강의가 있는 과목 정보만 출력하므로 내부 조인이 적용 됨 뷰를 통해 레코드 조작 시, 뷰의 정의된 조건에 맞지 않는 레코드에 대한 조작을 방지하는 옵션은? a. WITH CHECK OPTION WITH CHECK OPTION은 뷰를 통해 데이터 변경(INSERT, UPDATE, DELETE) 작업을 할 때, 뷰의 정의된 조건에 맞는 데이터만 변경하도록 제한하는 옵션임 정리 하기 중첩 질의는 SELECT문 내부에서 독립적으로 실행 가능한 또 다른 SELECT문이 내포되어있는 질의로, 일반적으로 내부 질의의 처리 결과를 외부 질의에서 재사용하는 과정으로 처리됨 FROM절과 WHERE절에 SELECT문을 내포시키는 형식이 있으며 중첩 질의를 위해 IN, EXISTS, NOT 연산자가 사용됨 조인은 테이블 간의 관련성을 이용하여 두 개 이상의 테이블에서 데이터를 검색하는 질의 기법으로, 종류로는 내부 조인, 자연 조인, 외부 조인(왼쪽, 오른쪽, 완전), 셀프 조인이 있음 뷰는 데이터를 저장하고 있는 하나 이상의 테이블을 유도하여 생성하는 가상의 테이블로, 데이터의 독립성, 데이터 보안, 작업 단순화, 데이터 무결성 등의 위해 사용함체크 포인트 다음 릴레이션 고객과 주문에 대한 완전 외부 조인 연산의 결과로 (가), (라)에 들어갈 내용은? 고객 고객ID 고객이름 주소 ok 홍길동 서울 pk 강감찬 경기 주문 주문번호 고객ID 주문제품 100 ok 운동화 101 ak 장갑 a. ok, NULL 뷰(VIew)의 장점이 아닌 것은? a. 뷰 자체로 인덱스를 가짐 뷰(View)의 장점 데이터 보안 용이 사용자 데이터 관리 용이 논리적 독립성 제공 " }, { "title": "[파이썬 프로그래밍 기초] 7강 - 반복 구조", "url": "/posts/knou-python-7/", "categories": "Language, Python", "tags": "knou, python", "date": "2025-04-14 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '파이썬 프로그래밍 기초' 강의를 개인 공부 목적으로 메모하였습니다. 학습 목표 반복 구조의 개념과 필요성을 설명할 수 있음 반복 구조 설계 전략을 통해 반복문을 작성할 수 있음 리스트의 개념에 대해 설명할 수 있음주요 용어 조건 제어 반복 참과 거짓 조건에 의해 반복 여부가 결정되는 반복 구조 계수 제어 반복 특정 계수만큼 반복 횟수가 정해진 반복 구조 인덱스 연산자 시퀀스 타입의 원소에 접근하는 연산자 중첩 반복 구조 반복 구조 내 다른 반복 구조를 내포한 형식 강의록반복 구조의 정의반복 구조의 개념 특정 영역의 명령문을 여러 번 실행하는 구조 반복 횟수를 조건에 따라 결정 loop, iterate, repeat 용어가 혼용 반복 출력 프로그램(while 문 미사용) ‘저는 파이썬을 잘 다룰 수 있습니다’를 5번 출력하는 프로그램을 작성하시오. # 메시지 저장 msg = \"저는 파이썬을 잘 다룰 수 있습니다.\" # 5번 반복 출력 (개선 전) print(msg) print(msg) print(msg) print(msg) print(msg) 반복 구조의 구문 형식 구문 형식 조건 제어 반복 (while) 구문 형식 계수 제어 반복 (for) 반복 구조의 실행 흐름 조건 제어 반복 흐름 반복-계속-조건을 검사함 조건이 True이면, 명령 블록을 실행함 다시 반복-계속 조건을 검사함 조건이 False가 될 때까지 2-3 단계를 반복함 조건이 False이면, 반복 구조를 종료함 반복 출력 프로그램 (while 사용) ‘저는 파이썬을 잘 다룰 수 있습니다’를 5번 출력하는 프로그램을 while을 사용하여 작성하시오. # 메시지 저장 msg = \"저는 파이썬을 잘 다룰 수 있습니다.\" # 5번 반복 출력 (while 사용) count = 1 while count &lt;= 5: print(msg) count = count + 1 # 추가하지않으면 무한 반복함 반복 구조 설계 전략 반복 되어야 하는 명령 블록을 작성 반복 되어야 하는 명령문을 다음과 같이 반복 구조로 작성 while True: 명령 블록 반복-계속-조건을 작성하고 반복 구조를 제어하기 위해 반복 제어 명령문을 추가 while 반복-계속-조건: 명령 블록 반복 제어 명령문 n까지 합 계산 프로그램(반복 구조 설계 전략 적용) 1부터 사용자가 입력한 값 n까지 합을 구하는 프로그램을 작성하시오 sum_value = sum_value + i while True: sum_value = sum_value + i # 초기값 설정 sum_value = 0 i = 1 # 사용자 입력 받기 last = int(input(\"어디까지 더할까요?: \")) # 입력값을 정수로 변환 # 합 계산 (while 사용) while i &lt;= last: # 종결 조건 sum_value = sum_value + i i = i + 1 # 결과 출력 print(f\"1부터 {last}까지의 합은 {sum_value}입니다.\") 반복 되어야 할 것이 무엇인가? 1번 명령문을 반복 구조 안에 작성 True 부분에 종결 조건을 작성하고, 반복 제어 명령문 추가 구구단 출력 프로그램 출력할 단을 입력 받아 해당 단의 구구단을 출력하는 프로그램을 작성하시오. # 단 입력 받기 base = int(input(\"출력할 단을 입력하세요: \")) # 구구단 출력 (while 사용) i = 1 while i &lt;= 9: # 종결 조건 작성 print(base, \"X\", i, \"=\", base * i) i = i + 1 리스트원뿔 계산 프로그램 개선 반지름은 10이고 높이가 1, 5, 14, 26, 31인 원뿔의 부피와 겉넓이를 각각 출력하시오. 원뿔 계산 프로그램을 여러 개의 높이 값에 대해 반복적으로 실행하는 것은 비효율적임 리스트의 개념 순서화 된 값의 집합체를 저장할 수 있는 데이터 타입 단일 식별자로 연속된 저장 공간 접근 수단 제공 개별 원소의 값을 수정, 추가, 삭제 가능 원소(element)의 나열을 저장할 수 있는 시퀀스 타입 중 하나 리스트, 세트, 투플, 딕셔너리 등 리스트의 구성 원소들의 순서를 표현 참조 변수 리스트 객체를 가리키는 변수 리스트 객체 여러 개의 값을 순서대로 담고 있는 실체 요소 (Element) 리스트 내부에 저장된 각각의 값 리스트의 생성 구문 형식 인용 부호 [ 와 ]를 사용하여 표현 [1, 4, 14, 26, 31] hei_list = [1, 4, 14, 26, 31] 원소는 콤마(,)로 나열 # 다양한 자료형을 포함하는 리스트 생성 body = [181, 78, \"dark brown\", \"black\"] 인덱스 연산자 시퀀스 타입의 원소에 접근하는 연산자 접근 연산자 [, ] 사용 원소에 부여된 인덱스 번호로 지칭 리스트의 각 요소는 0부터 시작하는 고유한 번호(인덱스)를 가짐 리스트변수[인덱스] 형식으로 특정 위치의 요소에 접근하거나 값을 변경할 수 있음 print(hei_list[2]) # 출력: 14 hei_list[4] = 45 print(hei_list) # 출력: [1, 5, 14, 26, 45] 계수 제어 반복의 사용 구문 형식 계수-제어 변수와 시퀀스 사용 반복 시 계수-제어-변수에 시퀀스의 원소 할당 for 루프는 리스트와 같은 시퀀스 자료형의 요소를 하나씩 순차적으로 변수에 할당하며 반복 함 # 리스트 생성 hei_list = [1, 4, 14, 26, 31] # 리스트의 각 요소를 순회하며 출력 for hei in hei_list: print(hei) 원뿔 계산 프로그램 개선 반지름은 10이고 높이가 1, 5, 14, 26, 31인 원뿔의 부피와 겉넓이를 각각 출력하시오. 높이 값들을 리스트에 저장하고, for 루프를 사용하여 각 높이에 대한 원뿔 계산을 반복 수행 rad = 10 hei_list = [1, 4, 14, 26, 31] # 리스트의 각 요소를 순회하며 출력 for hei in hei_list: # 부피 &amp; 겉넓이 계산 vol = 1 / 3 * 3.14 * rad ** 2 + 3.14 * rad * hei surf = 3.14 * rad ** 2 + 3.14 * rad * hei print(\"반지름\", rad, \"높이\", hei, \"원뿔\") print(\"원뿔의 부피는\", vol, \"입니다.\") print(\"원뿔의 겉넓이는\", surf, \"입니다.\") 반복 구조의 확장원뿔 계산 프로그램 개선 반지름과 높이가 (10, 1), (20, 5), (30, 14)인 원뿔의 부피와 겉넓이를 각각 출력하시오. 반지름들 사이에 나름의 규칙이 있는 경우 → 리스트 생성 자동화 리스트 생성 자동화 리스트 내 원소에 규칙성이 있는 경우 생성 자동화를 위해 함수 사용 가능 a부터 b보다 작은 값까지 k씩 증가 시켜 시퀀스 생성 range(start, stop, step) 연속된 숫자를 생성하는 객체를 만듬 start: 시작 숫자 (포함, 생략 시 기본값 0) stop: 끝 숫자 (미포함) step: 증가 간격 (생략 시 기본값 1) range 함수의 사용 1부터 99까지의 숫자를 생성 range(1, 100, 1) range(1, 100) 10부터 30까지 10씩 증가하는 숫자를 생성 rad_list = range(10, 40, 10) 반복 출력 프로그램 개선 (for 와 range 사용) ‘저는 파이썬을 잘 다룰 수 있습니다’를 5번 출력하는 프로그램을 작성하시오 # 메시지 저장 msg = \"저는 파이썬을 잘 다룰 수 있습니다.\" # 5번 반복 출력 for count in range(1, 6): # 1부터 5까지 반복 print(msg) 원뿔 계산 프로그램 개선 (for 와 range 활용) 반지름과 높이가 (10, 1), (20, 5), (30, 14)인 원뿔의 부피와 겉넓이를 각각 출력하시오. rad_list = range(10, 31, 10) hei_list = [1, 5, 14] for rad, hei in zip(rad_list, hei_list): vol = 1 / 3 * 3.14 * rad ** 2 + 3.14 * rad * hei surf = 3.14 * rad ** 2 + 3.14 * rad * hei print(\"반지름\", rad, \"높이\", hei, \"원뿔\") print(\"원뿔의 부피는\", vol, \"입니다.\") print(\"원뿔의 겉넓이는\", surf, \"입니다.\") zip 함수 여러 리스트의 값들을 하나씩 엮어서 가져옴 구구단 출력 프로그램 개선 (전체 구구단표 출력) 구구단 표 출력 중첩 반복 구조 반복 구조 내 다른 반복 구조를 내포한 형식 구문 형식 바깥쪽 반복이 한 번 실행될 때마다 안쪽 반복은 전체 사이클을 모두 실행함 중첩 반복 구조의 실행 흐름 바깥쪽 루프 시작 바깥쪽 루프 조건 검사 (True) 안쪽 루프 시작 안쪽 루프 조건 검사 (True) 안쪽 루프 코드 블록 실행 안쪽 루프 조건 다시 검사 False가 될 때까지 4-5 반복 안쪽 루프 종료 바깥쪽 루프 코드 블록 (안쪽 루프 이후 부분) 실행 (있다면) 바깥쪽 루프 조건 다시 검사 False가 될 때까지 3-8 반복 바깥쪽 루프 종료format 함수 데이터를 양식에 맞춰 형식화 문자열 내에서 값의 형식을 지정하여 표현할 때 사용 format(값, \"형식지정자\") 형태로 사용 가능함 형식 지정자 구성 [정렬방향][필드폭][데이터타입] 정렬 방향 &lt; (왼쪽 정렬), &gt; (오른쪽 정렬), ^ (가운데 정렬) 필드 폭 해당 값이 차지할 최소 너비 (칸 수) 데이터 타입 d (정수), s (문자열), f (실수) 등 format 함수의 사용 문자열 형식 문자 타입은 왼쪽 정렬이 기본 문자열 “구구단표”를 10칸 너비에 오른쪽 정렬하여 출력 정수 형식 정수 타입은 우측 정렬이 기본 정수 1234를 10칸 너비에 왼쪽 정렬하여 출력 구구단 출력 프로그램 개선 (중첩 반복 및 format 사용)# 구구단표 헤더 출력print(format(\"구구단표\", \"&gt;20s\")) # 제목 가운데 정렬 느낌으로# 표 머리 출력print(\"|\", end=\"\")for j in range(1, 10): print(\" \", j, end = \"\") # 각 숫자 헤더 4칸 오른쪽 정렬# 새로운 행 삽입print()print(\"-\" * 40) # 구분선# 구구단표 본문 출력for i in range(1, 10): # 단 (1단 ~ 9단) print(i, \"|\", end = \"\") # 단 표시 for j in range(1, 10): # 곱하는 수 (1 ~ 9) print(format(i * j, \"&gt;4d\"), end=\"\") # 결과값 4칸 오른쪽 정렬 print() # 다음 단으로 넘어갈 때 줄바꿈 줄바꿈 없이 연달아 같은 라인에 출력할 수 있게 하는 옵션 end 반복해야 할 구간 찾기 하나의 단 안에서 곱셈하는 구간 2~9단까지 반복 중첩 반복 구조의 공포 중첩 단계가 깊어질수록 반복 횟수가 기하급수적으로 증가하여 실행 시간이 매우 길어질 수 있음 # 3중첩 for 루프 (각 1000번 반복 시): 1000 * 1000 * 1000 = 1,000,000,000 (10억) 번의 내부 연산 수행 for i in range(1000): for j in range(1000): for k in range(1000): result = i * j * k # 10억 번 실행됨 연습 문제 계수 제어 반복 구조에서 특정 반복 횟수와 반복 시 계수의 값을 정하기 위해 사용하는 데이터 타입은? a. 시퀀스 다음과 같이 반복 구조 내부에 또 다른 반복 구조가 포함되어 실행 흐름을 만드는 구조를 무엇이라고 하는가?  a. 중첩 반복 구조 다음 코드의 출력 값으로 옳은 것은? for i in range(1, 11): print(i, end = \" \") a. 1 2 3 4 5 6 7 8 9 10 학습 정리 반복 구조란 동일한 명령문에 대해서 사용자가 지정한 횟수만큼 또는 조건을 만족하는 동안 동일한 코드를 반복하여 수행할 때 사용하는 구조임 whlie 문은 조건이 참(True)인 동안 while 문 블럭 내부의 명령문을 수행하며 조건이 거짓(False)이 될 때 while 문을 빠져나오는 조건 제어 반복 구조임 리스트는 순서화 된 값의 집합체를 저장할 수 있는 시퀀스 데이터 타입의 일종임 for 문은 리스트 등과 같은 시퀀스의 첫 번째 요소부터 마지막 요소까지 하나 씩 변수에 대입하여 블럭의 명령문을 수행하며 마지막 요소까지 수행한 후 종료하는 계수 제어 반복임 중첩 반복 구조는 하나의 외부 반복 구조에 여러 개의 내부 반복 구조가 중첩되어 사용되는 구조를 말하며, 외부 반복 구조가 매 반복될 때마다 내부 반복 구조에 재 진입하여 새롭게 실행됨" }, { "title": "[유비쿼터스 컴퓨팅 개론] 7강 - 블록 체인과 핀테크", "url": "/posts/knou-uqc-7/", "categories": "Computer Science, CS Theory", "tags": "knou, ubiquitous computing", "date": "2025-04-13 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정광식 교수님의 '유비쿼터스 컴퓨팅 개론' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 블록 체인을 기반으로 하는 가상 화폐 및 전자 결제 서비스는 가장 대표적인 분산 데이터 처리 사례이며, 기존 산업의 제품 및 서비스의 생산 · 소비 · 유통 · 관리 측면에서 다양한 변화를 가능하게 해 주고 있음 특히 금융 부문의 블록 체인 플랫폼은 피할 수 없는 미래 서비스 기술로 인정받고 있음 블록 체인의 개념과 정의, 블록 체인 플랫폼의 형태 및 합의 알고리즘을 알아보고 블록 체인의 구조에 대해서 이해함학습 목표 분산형 디지털 장부 기술을 대표하는 블록 체인의 정의 및 특징을 이해할 수 있음 다양한 블록 체인 플랫폼을 이해하고 장단점을 설명할 수 있음 블록 체인의 기술적 구조와 처리 기법(합의 알고리즘)을 이해할 수 있음강의록블록 체인의 정의블록 체인의 개념 기존 국가 중심의 화폐 및 결제 시스템은 아마존이나 알리 마켓 같이 국경의 한계를 벗어나 전 세계를 대상으로 하는 시장에는 적합하지 않았음 전자 화폐 혹은 암호 화폐에 대한 수요가 증가하였고, 이를 현실화하기 위한 많은 시도와 연구가 이루어졌음 블록 체인이 시장성과 대중성을 함께 지니게 된 것은 2008년 나카모토 사토시라는 가공의 인물이 발표한 “Bitcoin: A Peer-to-Peer Electronic Cash System” 이라는 논문을 통해 비트 코인이라는 전자 화폐를 처음 소개하였고, 2009년에는 “Bitcoin Core” 프로그램을 공개하였음 블록 체인 기술을 활용한 Bitcoin은 중앙 집중형 구조에서 벗어나서 Bitcoin 네트워크에 참여하는 모든 노드가 암호 화폐에 대한 데이터와 거래 기록을 소유하며, 발생하는 거래의 내용을 검증하고 합의함 분산형 시스템을 통한 안전한 화폐 거래 가능 블록 체인은 일정 시간마다 새로운 거래 내역을 담은 신규 블록이 생성되고 이에 대한 합의가 이루어지면 기존 블록에 연결되는 데이터 구조 계속적으로 이루어지는 개인과 개인 사이의 거래 정보를 블록 단위로 저장하고, 구성원들에게 전송된 해당 블록의 유효성이 검증되면 기존 블록 체인에 추가되는 방식으로 관리 됨 블록 체인에서 데이터는 연결 고리 형태의 분산 저장 환경에 저장되므로 이미 블록으로 연결되었다면 임의의 수정이 불가능하고 거래 기록은 모두에게 공개 됨 블록 체인은 중앙에서 전체를 통제하고 데이터를 중앙 서버에 저장하는 중앙 집중형 서버가 존재하지 않고 분산 P2P 네트워크 방식으로 운영 됨 네트워크에 참여하는 참여자가 모두 같은 블록 데이터를 가지게 하는 분산 합의 알고리즘을 기반으로 관리되고 운영 됨 네트워크 참여자는 다음과 같음 채굴자(miner) 네트워크 내에서 보상을 얻는 참여자 노드 일반 참여자 블록 체인 일부분의 데이터만 저장하는 라이트 노드가 있음 모든 네트워크 노드(참여자) 블록 체인에 대한 분산 합의에 참여하여 블록 체인의 데이터 순수성을 보장함 블록 체인을 기반으로 발생하는 모든 거래 정보 등의 데이터를 저장하고 저장된 데이터에 대한 합의 알고리즘에 참여함 블록 체인의 합의 알고리즘 기본적으로 모든 참여자가 보유한 거래 내용을 비교하고 확인함 블록 체인은 네트워크에 참여한 모든 참여자가 각자 가지고 있는 데이터를 이용하여 서로의 데이터를 검증하고 저장하기 때문에 임의적인 조작이 불가능함블록 체인 플랫폼의 특징 분산형 장부 관리 중앙 통제 기능을 갖고 있지 않음 거래 기록이 담긴 원장을 분산 된 형태로 관리하고 저장함 정부 기관이나 특정 조직과 같은 제 3자(관리자)에게 관리와 통제를 맡기지 않음 다수의 참여자가 직접 내용에 대한 검증, 승인, 합의에 참여함 모든 참여자에 분산 되어 저장된 블록은 과거의 블록과 연결되어 관리되므로 거래 데이터의 위조를 방지할 수 있음 자산과 그것들을 보유하는 존재를 연결함으로써 이중 이용을 방지하고 누구에게 양도 되었는 지를 정확하게 관리할 수 있음 중앙의 서버가 아닌 다수의 컴퓨터에서 같은 데이터를 분산 관리하여 어느 1개의 데이터가 상실되더라도 다른 참가자의 컴퓨터가 가동되고 있으면 시스템을 유지하는 것이 가능함 불변성 새롭게 생성된 블록은 선행 블록의 해시(암호)가 이용되기 때문에 블록 사이의 순서가 고정 됨 중간에 있는 특정 블록의 수정이나 삭제 작업을 위해서는 모든 참여자의 블록 내용을 모두 삭제하거나 수정해야 하기 때문에 블록에 기록 된 거래 데이터에 대한 삭제나 수정 작업은 불가능함 참여자가 많을수록 수정하거나 삭제해야 할 블록도 증가하므로 임의의 변경(해킹)이 불가능함 가용성 블록 체인 플랫폼의 모든 참여자는 분산 저장된 블록의 거래 데이터의 일부 노드에 문제가 발생하더라도 합의 검증을 통해 거래 데이터의 순수성이 유지되며 24시간 중단되지 않고 접근할 수 있음 전체 블록 체인 플랫폼에서 하나, 혹은 소수의 노드가 잘못되더라도 나머지 노드에 검증된 다른 거래 데이터가 존재하므로 블록 체인 서비스는 중단되지 않고 지속될 수 있음 투명성 새롭게 생성된 블록은 전체 참여자에게 동시에 공유되기 때문에 블록의 거래 데이터는 참여자들에게 공개되므로, 이중 이용을 방지할 수 있고 양도 및 거래도 정확하게 관리될 수 있음 블록 체인을 통해 참여자 간의 상호 검증이 가능하고 거래 데이터에 대한 투명성을 보장하면서도 참여자의 정보는 공개되지 않아 익명성도 함께 제공함 블록 체인의 유형과 구조블록 체인의 유형 블록 체인의 블록은 데이터를 저장하며, 헤더(header)와 몸체 부분(body)으로 구성 됨 비트 코인은 일정 시간마다 생성되는 거래 데이터의 단위를 블록(블록들의 순서는 해시 값으로 연결)이라 정의함 블록 체인 관련 알고리즘은 암호화 기술(Cryptography) 전자 서명(Digital Signature) 해시 함수(Hash Function) 등이 있음 분산 P2P 네트워크를 기반으로 다양한 응용 서비스를 제공할 수 있는 플랫폼을 제공함 해시 함수 입력 데이터를 일정한 길이의 해시 값으로 생성하는 기술이며, 데이터의 무결성 검증 및 메시지 인증에 사용 됨 전자 서명 작성자가 그 전자 문서를 작성하였다는 사실과 작성 내용이 송, 수신 과정에서 위 변조 되지 않았다는 것을 증명하는 기술 블록 체인은 참여자의 특성과 권한 범위, 참여자들의 네트워크 참여 방식과 활용에 따라 아래처럼 분류 됨 퍼블릭 블록 체인 프라이빗 블록 체인 하이브리드 블록 체인 컨소시엄 블록 체인 퍼블릭 블록 체인(Public Blockchain) 관리자나 권위 있는 조직의 승인 없이 조건을 갖춘 참여자는 누구나 참여할 수 있는 공개 된 블록 체인 플랫폼을 의미함 모든 참여자의 자유로운 거래 데이터 열람과 거래가 허용 됨 각 참여자들은 블록 체인에 저장된 데이터를 복사하고 저장할 수 있음 해시 연산을 통해 새로운 블록의 생성에 참여할 수 있음 참여자들은 언제든지 자유롭게 블록 체인 플랫폼에 참여하거나 탈퇴할 수 있음 작업 증명(Proof-of-Work), 지분 증명(Proof-of-Stake) 등 합의 알고리즘을 기반으로 분산 처리 방식의 거래가 이루어짐 다수의 참여자가 참여하기 때문에 고도화 된 암호화 검증이 필요 함 트랜잭션 처리 속도 및 데이터 처리 속도가 느려질 수 있음 충분한 크기의 블록 체인을 구성하지 못했을 경우 대규모 악성 봇넷을 블록 체인 네트워크에 가입시켜 데이터를 변경하는 51% 공격이 발생할 수 있음 비트코인, 이더리움 등 대표적인 암호 화폐가 퍼블릭 블록 체인의 유형에 속함 프라이빗 블록 체인(Private Blockchain) 승인 된 참여자만 참여할 수 있는 폐쇄형 블록체인 플랫폼임 블록 체인 네트워크에 참여자를 추가하기 위한 규칙과 규정을 만들고, 규칙과 규정에 따라 참여자에 대한 승인이 이루어지므로 참여자의 인원수에 대한 제한도 가능함 퍼블릭 블록 체인에 비해 트랜잭션 처리 속도 및 데이터 처리 속도가 빠름 네트워크 확장이 용이하여 사용자가 원하는 형태로 구축할 수 있음 블록 체인 내에서 접근을 컨트롤러 노드가 담당하기 때문에 신뢰성 문제가 발생할 수 있음 참여자가 블록을 직접 생성하고 관리하는 방식이기 때문에 참여자가 블록체인 시스템을 직접 관리하고자 하는 경우에 적합함 컨소시엄 블록 체인(Consortium Blockchain) 같은 목적을 갖는 참여자가 컨소시엄(블록 체인 네트워크)을 구성하여 블록을 생성할 수 있는 연합형 블록 체인임 승인된 참여자로 구성되므로 프라이빗 블록 체인으로 분류될 수도 있지만, 각 신뢰성을 갖춘 참여자들이 퍼블릭 블록 체인을 구성할 수 있어 하이브리드 블록 체인으로 분류될 수도 있음 분산형 네트워크를 유지하면서 제한 된 참여를 통해 보안을 강화할 수 있음 퍼블릭 블록 체인에서 제기된 느린 데이터 처리 속도와 네트워크 확장성의 문제도 해소해 줌 네트워크에서 향상 된 사용자 정의 및 자원 제어 기능을 제공함 퍼블릭 블록 체인에 비해 안전하고 높은 확장성을 제공할 수 있음 신뢰 받는 참여자가 감염될 경우, 일부 네트워크 전체에 문제가 발생하여 핵심 노드에 대한 추가적인 보안 정책이 필요함 하이브리드 블록 체인(Hybrid Blockchain) 퍼블릭 블록 체인과 프라이빗 블록 체인의 단점은 보완하고 장점을 활용하려는 혼합된 모델임 투명성, 불변성, 탈 중앙화 등 퍼블릭 블록 체인의 중요 기능을 제공함 프라이빗 블록 체인과 유사하게 블록 체인 네트워크를 구성하려는 목적에 따라 규칙을 변경할 수 있음 네트워크에 참여한 사용자의 정보를 외부에서 확인할 수 없는 익명성을 제공하기 때문에 회사나 기관의 정보가 유출되는 것을 방지할 수 있음 권한을 가진 노드가 퍼블릭 블록 체인에서 트랜잭션을 쉽게 검증할 수 있으나 노드의 투명성을 보장하지 못하고, 내부 노드에 대한 검증이 없어 보안에 취약할 수 있음 블록 체인의 구조 블록 체인의 블록은 각 블록 체인 플랫폼에 따라 구조적으로 다름 블록 체인을 유지하고 서비스를 제공하기 위해 공통적으로 가지고 있는 블록의 구조와 데이터가 있음 새롭게 생성된 블록은 선행 블록에 대한 해시 값을 포함하고 있고 선행 블록은 그 자신의 선행 블록에 대한 해시 값을 포함함 블록 데이터를 통해 블록의 연결성이 만들어지고, 기존 거래 데이터에 대한 블록 체인의 안정성이 확보되며, 블록은 계속적으로 연결된 체인 구조를 가지게 됨 각각의 블록은 선행 블록에 대한 해시 값을 통해 블록 체인의 링크 구조를 유지함 제네시스 블록(genesis block) 블록 체인에서의 첫 번째 블록 블록에는 거래나 부모 블록으로 이어지는 해시 값 등의 정보가 저장됨 블록의 구조는 다음과 같음 필드 필드 크기(바이트) 내용 블록 크기(Block Size) 4 다음 필드부터 블록 끝까지의 데이터 크기(바이트) 블록 헤더(Block Header) 80 블록 헤더 정보 트랜잭션 카운터(Transaction Counter) 1 ~ 9 블록에 포함된 트랜잭션의 수 트랜잭션(Transactions) 4 가변적 크기의 트랜잭션 목록 블록 헤더의 구조는 다음과 같음 필드 필드 크기(바이트) 내용 버전(Version) 4 소프트웨어 혹은 프로토콜 버전 정보 부모 블록 해시(Previous Block Hash) 32 부모 블록의 해시값 머클 루트(Merkle Root) 32 머클 트리 루트의 해시값 생성 시간(Timestamp) 4 블록을 생성한 시간(Unix time) 난이도(Difficulty Target) 4 블록을 생성할 때 작업증명의 난이도 논스(Nonce) 4 작업 증명에서 사용하는 카운터 블록 체인 플랫폼에서 특정 블록을 찾기 위해서는 식별자가 필요함 블록의 식별자는 블록 해시 값과 블록 높이 값으로 정의됨 블록 해시 값 블록 헤더를 암호화 알고리즘인 SHA-256 알고리즘을 이용하여 얻어낸 해시 값임 블록 높이 블록 체인에서의 블록의 위치를 의미함 제니시스 블록의 블록 높이 값은 0임 후행 블록이 덧붙을 때마다 1씩 증가함 블록 체인의 블록은 일반적으로 1MB의 크기이며, 길이는 계속적으로 증가하고 있음 과거의 모든 블록을 저장하거나 관리하는 것은 많은 컴퓨팅 자원의 부하를 발생 시킴 만일 과거의 모든 블록을 포함한다면 블록 체인의 크기는 매우 커질 것임 참여자가 스마트폰이나 태블릿 컴퓨터를 사용한다면 저장 용량이 부족하여 모든 블록을 저장할 수 없게 됨 저장 용량을 고려하여 트랜잭션을 직접 저장하는 블록은 저장하지 않고 블록 헤더만 저장하는 노드를 SPV(Simple Payment Verification node) 노드라고 함 과거의 모든 블록에 저장 된 트랜잭션을 저장하는 전체 블록 체인을 풀블록 체인(Full Blockchain)이라 함 풀 블록 체인을 저장하는 노드를 풀 노드(Full Node)라고 함블록 체인의 합의 알고리즘 블록 체인의 참여자들은 생성 된 트랜잭션을 검증하여 블록을 생성, 공유, 저장함 트랜잭션의 검증 방법으로 합의 알고리즘(Consensus Algorithm)을 사용함 블록 체인에서 사용하는 일반적인 합의 알고리즘 작업 증명 합의 알고리즘 지분 증명 합의 알고리즘 프랙티컬 비잔틴 장애 허용 합의 알고리즘 작업 증명 합의 알고리즘 Proof-of-Wok 특정 해시 값을 만드는 입력 값을 찾아내기 어렵다는 점을 이용함 블록 체인 참여자들이 특정 범위를 만족하는 해시 값을 만드는 Nonce 값을 무작위 대입하여 찾아냄 Nonce 값을 찾아낸 참여자가 Nonce 값과 거래 데이터를 포함하는 블록을 생성함 블록의 거래 데이터가 검증을 받은 후 블록으로 생성되기까지 시간이 오래 걸리기 때문에 1초 당 트랜잭션 처리 수(TPS; Transaction per Second)가 낮음 블록 체인의 작업 증명 합의에 참여하는 전체 컴퓨팅 자원의 51% 이상을 가진 참여자들이 동시에 공격을 받게 되면 위조 된 거래 데이터가 블록으로 생성 될 수 있음 지분 증명 합의 알고리즘 Proof-of-Stake 많은 지분을 가진 참여자가 블록 검증에 더 많은 영향력을 행사할 수 있도록 함 작업 증명 합의 알고리즘에 비해 훨씬 적은 연산 량이 요구되고, 비교적 높은 TPS를 가짐 작업 증명 합의 알고리즘과 비슷하게 블록 체인에 존재하는 지분의 51% 이상을 소유하는 참여자들이 공격을 받게 되면 위조 된 데이터가 블록으로 생성될 수 있음 프랙티컬 비잔틴 장애 허용 합의 알고리즘 PBFT; Practical Byzantine Fault Tolerance 블록 체인 참여자가 발생 된 트랜잭션에 대해 각자 검증함 검증 결과에 대해 참여자의 3분의 2 이상이 동의하면 그 트랜잭션을 신뢰할 수 있다고 결정하고 블록을 생성하여 저장함 모든 참여자가 블록을 검증하고 그 결과를 공유하기 때문에 노드가 많아질수록 통신량이 급격히 증가하고 TPS가 감소하게 됨 블록 체인과 핀테크블록 체인 적용 분야 블록 체인 플랫폼과 이를 기반으로 하는 가상 화폐 및 전자 결제 서비스는 기존 산업의 제품 및 서비스의 생산, 소비, 유통, 관리 측면에서 다양한 변화를 선도하고 있음 적용 분야 측면 금융, 제조, 유통 등과 같은 산업 전반에 걸쳐 파생 효과를 보여주고 있음 업종이나 민간, 공공에 대한 제한이 없이 대부분의 사회 영역에 걸쳐 적용될 것으로 전망되고 있음 블록 체인 금융 부분 금융 부분의 블록 체인 기술 적용은 가장 많은 파생 서비스를 만들어내고 있음 현재 블록 체인 기반의 정보 통신 서비스 중에서 기존의 정보 통신 서비스와 차별화 되는 가장 큰 특징은 여러 기업과 기관들이 컨소시엄 형태의 블록 체인 기술을 이용한 솔루션을 개발하려는 것임 블록 체인 솔루션 개발에 대한 컨소시엄 형태의 접근은 금융 서비스 Bass(Blockchain-as-a-Service) 형태의 솔루션 보험 컨소시엄 등이 있음 블록 체인 공공 분야 공공 분야에서는 전자 공문서의 관리, 전자 투표, 개별 사용자 인증 등과 같은 분야에서 적용되고 있음 블록 체인 기술은 분산 장부 기술(DLT; Distributed Ledger Technology)로서 안전성과 효율성을 인정 받으려 그 범위를 넓히고 있으며, 가상 화폐 뿐만 아니라 사물 인터넷, 전자 서명과 인증, 물류 등의 다방면에 걸쳐 적용되고 있음정리 하기 블록 체인은 일정 시간마다 새로운 거래 내역을 담은 신규 블록이 생성되고, 이에 대한 합의가 이루어지면 기존 블록에 연결(chain)되는 데이터 구조임 핀테크는 ’금융’과 ‘기술’이 결합한 서비스 또는 그런 서비스를 하는 회사를 가리키는 말임연습 문제 블록 체인의 특징이 아닌 것은  무엇인가? a. 자동성 블록 체인의 특징 분산형 장부 관리 투명성 가용성 승인된 참여자만 참여할 수 있는 폐쇄형 블록 체인 플랫폼은 무엇인가? a. 프라이빗 블록체인 다음 빈칸에 알맞은 것은 무엇인가? 블록체인 플랫폼에서 특정 블록을 찾기 위해서는 식별자가 필요하며, 블록의 식별자는 (   )과 (   )으로 정의된다. a. 블록 해시 값, 블록 높이 값 정리 하기 블록 체인 블록 체인은 일정 시간마다 새로운 거래 내역을 담은 신규 블록이 생성되고 이에 대한 합의가 이루어지면 기존 블록에 연결되는 데이터 구조 계속적으로 이루어지는 개인과 개인 사이의 거래 정보를 블록 단위로 저장하고, 구성원들에게 전송된 해당 블록의 유효성이 검증되면 기존 블록 체인에 추가되는 방식으로 관리됨 네트워크 참여자 채굴자(miner) 네트워크 내에서 보상을 얻는 참여자 노드 일반 참여자 블록 체인 일부분의 데이터만 저장하는 라이트 노드 블록 체인 플랫폼의 특징 분산형 장부 관리 불변성 가용성 투명성 블록 체인은 블록 체인의 블록은 데이터를 저장하며, 헤더(header)와 몸체 부분(body)으로 구성 됨 각각의 블록은 선행 블록에 대한 해시 값을 통해 블록 체인의 링크 구조를 유지함 블록의 식별자는 블록 해시 값(블록 헤더를 암호화 알고리즘인 SHA-256 알고리즘을 이용하여 얻어 낸 해시 값)과 블록 높이 값(블록 체인에서 블록의 위치)으로 정의됨 블록 체인은 참여자의 특성과 권한 범위, 참여자들의 네트워크 참여 방식과 활용에 따라 분류됨 퍼블릭 블록 체인 프라이빗 블록 체인 하이브리드 블록 체인 컨소시엄 블록 체인 블록 체인에서 사용하는 일반적인 합의 알고리즘 작업 증명 합의 알고리즘 지분 증명 합의 알고리즘 프랙티컬비잔틴 장애 허용 합의 알고리즘 " }, { "title": "[유비쿼터스 컴퓨팅 개론] 6강 - 유비쿼터스 네트워크", "url": "/posts/knou-uqc-6/", "categories": "Computer Science, CS Theory", "tags": "knou, ubiquitous computing", "date": "2025-04-13 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정광식 교수님의 '유비쿼터스 컴퓨팅 개론' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 정보화 사회에서 네트워크는 원활한 정보 전달이 이루어지기 위한 핵심 기반 기술에 해당되며, 유비쿼터스 사회에서도 당연히 네트워크는 중요한 역할을 수행함 인간과 컴퓨터 간의 통신이 주를 이루던 정보화 사회에도 네트워크의 역할이 매우 중요하였지만, 사물까지 연결해야 하는 유비쿼터스 시대에 네트워크는 없어서는 안 되는 매우 중요한 기술 요소가 됨 유비쿼터스 네트워크의 개념 및 구조를 익히고, 향후 발전 방향에 대해 공부함학습 목표 유비쿼터스 사회에서 어떤 네트워크 기술 요소가 필요한 이유를 유비쿼터스 사회의 전체적인 시스템을 통해서 이해함 유비쿼터스 컴퓨팅과 유비쿼터스 네트워크 개념의 차이를 명확히 이해함 유비쿼터스 시대에 다양한 서비스를 제공하기 위한 네트워크 기술의 진화 방향을 이해함강의록유비쿼터스 네트워크유비쿼터스 네트워크의 개념 유비쿼터스 컴퓨팅 산업의 기반 요소 컴퓨팅 장치의 성능의 향상 및 다양한 기능 수행 가능 컴퓨팅 장치의 소형화 및 가격 하락을 통한 대중화 전 세계 어느 곳에서도 연결 가능한 유 · 무선 통신망 유비쿼터스 네트워크 기술 컴퓨터 뿐만 아니라 다양한 종류의 단말이 네트워크에 상시 접속되어, 누구든지 시간과 장소의 제약 없이 네트워크를 활용하여 다양한 서비스를 제공 받을 수 있는 환경 또는 이를 가능하게 하는 기술 언제, 어디서나, 어떠한 통신 단말기든, 어느 통신망을 통해서든 원하는 서비스를 받을 수 있는 5Any(Anytime, Anywhere, Anynetwork, Anydevice, Anyservice) 등작을 요구하는 응용 프로그램 및 서비스를 지원하기 위한 네트워크 유비쿼터스 네트워크는 사람 대 사람, 사람 대 사물, 사물 대 사물 사이의 통신을 지원 사람 대 사람 통신 사람이 접속 되어 있는 컴퓨터나 스마트폰 등과 같은 기기를 이용한 통신을 말함 사람 대 사물 통신 사람이 데이터 수집이나 헬스 케어 등의 특정 서비스를 이용하기 위해 사물과 통신하는 것을 의미함 사물 대 사물 통신 사람이 관여하지 않아도 한 사물이 다른 사물과 정보를 주고 받는 통신을 의미함 유비쿼터스 네트워킹을 위한 구조적 모델 차세대 네트워크(NGN)에서 유비쿼터스 네트워크를 지원한다는 것은 어떤 사물과도 연결 가능해야 하며, 유비쿼터스 서비스 및 응용 프로그램을 구동하기 위해 인터넷과의 연결이 지원되어야 함을 의미함 상황 인식 서비스가 끊김 없이 원할하게 지원되어야 하고, 멀티 네트워킹 기능 및 네트워크 상의 종단 연결성이 지원되어야 함 최종 사용자(End-User) 기능 연결과 협력을 위한 최종 사용자 측면의 기능을 나타냄 정보 수집, 처리, 저장 등 통신 외의 다양한 기능도 포함 됨 사물의 유형에 따라 추가적 기능을 제공하기 위해 사물들 사이에 협력하는 기능이 필요함 물리적인 사물과 관련된 데이터를 찾아서 처리하기 위해 사물에 부여 된 유일한 식별자를 필요로 함 차세대 네트워크 전송 층 사물이 갖는 각기 다른 규격의 직접 통신이나 데이터 교환 방법에 대해 전송 층에 각 단말의 다양한 통신 방식과 다른 독립적인 방식으로 정보를 주고 받을 수 있는 기능을 제공 전송 층은 사물과 응용 프로그램 사이에서 사물과 주어진 응용 프로그램 간에 메시지 교환(다른 형식의 메소드 호출, 서비스 요청, 응답, 알림 메시지 등)을 전송하고 번역함 전송 층은 사물의 목록을 유지하고 주소 매핑을 실시함 차세대 네트워크 서비스 층 사물의 수행 환경과 상황 정보는 통신하는 단말이나 사용자의 이동, 실행 환경의 변화 등 여러 통신 환경 변화에 따라 영향을 받기 때문에 각 사물은 예측할 수 없는 실행 상황에도 대처할 수 있어야 함 네이밍(naming) 서비스처럼 네트워크 곳곳에 분포 된 각각의 데이터 저장 시스템에 의해 요청된 정보를 찾기 위해 지역적으로 데이터 저장소를 필요로 함 서비스 층은 전송 층과 상호 작용 중에도 현재의 상황 파악을 위한 모니터링 기능을 제공함 차세대 네트워크 서비스 층(NGN Service Stratum)은 예측할 수 없는 상황에서 실행 가능성 및 확장성을 제공할 뿐만 아니라 보안 기능도 제공함 유비쿼터스 네트워킹 응용 프로그램 수집한 데이터를 가공하여 의미 있는 정보를 생성 여러 사물들이 사전에 수집한 데이터는 의미 있는 정보로 변환되어 여러 사용자의 응용 프로그램에 제공됨 사물에 대한 IdM(Identification Mannagement) 기능과 관리 기능 최종 사용자 측면과 차세대 네트워크 서비스/전송 층을 모두 필요하며, 사물 대 사물 통신 지원에 필요함 차세대 네트워크(NGN) 어떤 특정한 기술을 의미하기보다는 네트워크의 전반적인 진화 방향으로서 궁극적으로는 하나의 통합 망으로 보다 다양하고 고도화된 서비스를 제공하는 것을 의미함 미국에서 사용하는 차세대 네트워크(NGN)란 기존 망들이 가지고 있는 단점과 한계 점을 극복하여 보다 고도화 된 통신 서비스를 제공할 수 있는 통신 인프라를 가리킴 NGN은 기구축된 모든 망을 단계적으로 차세대 망으로 교체하여 통합된 망으로의 발전을 의미광대역 통합망(BcN) 우리나라에서는 광 대역 통합 망(BcN)을 주로 사용하며, 유 · 무선 및 통신 방송이 융합되는 정보 통신 환경에서 품질이 보장되는 광 대역 멀티미디어 서비스를 언제, 어디서나 끊김 없이 이용할 수 있는 차세대 정보 통신 망으로 정의하였음 우리나라의 BcN은 유선 사업자들이 주도하는 차세대 기반 망과 무선 사업자들이 주축이 되는 통합 인터넷 프로토콜(All IP) 망의 구축을 통해 처음부터 융합된 망으로 시작하고 고도화를 통해 차세대 네트워크로 발전시킨다는 의미 일반 전화 교환 망(PSTN: Public Switched Telephone Network), 비 동기 전송 방식(ATM: Asynchronous Transfer Mode), 프레임 릴레이(FR: Frame Relay), 전용 망, 무선 통신 망 등 모든 통신 네트워크를 패킷 기반의 공통 망으로 통합해 망 구축 비용 및 운용 비용을 절감하고 보다 유연하고 개방적인 네트워크 솔루션과 다양한 응용을 제공 BcN은 데이터 통신에만 국한되던 패킷 전송 기술을 다양한 형태의 통신 서비스들에 모두 적용할 수 있는 통신망이라고 할 수 있으며, 융합화와 패킷화가 주요 특징임 BcN의 통합 망적 특성은 음성과 데이터, 영상 등을 동시에 수용하고, 인터넷 전화, 멀티미디어 메시지 등과 같은 다양한 부가 서비스를 효율적으로 제공 분리되어 왔던 유선과 무선 망을 All IP기반의 BcN망으로 통합함으로써 유 · 무선 망간의 장벽을 낮추어 개방화를 유도함과 동시에 망의 기능을 높여서 서비스 품질(QoS: Quality of Service)을 충족시키는 것을 가능하게 함 BcN을 이용하여 사용자는 언제, 어디서든지 원하는 단말을 사용하여 통신망 종류에 무관하게 통신, 방송, 인터넷이 융합 된 품질 보장 형 광대 역 멀티미디어 서비스를 끊김 없이 안전하게 이용할 수 있음 BcN은 유 · 무선 통합, 음성 · 데이터 통합, 통신 · 방송 융합 형의 멀티미디어 서비스를 위한 서비스 통합 네트워크임사물 대 사물 통신 유비쿼터스 환경에서 주목받고 있는 사물 대 사물 통신(M2M: Machine-to-Machine)을 지원하기 위한 네트워크 환경 사물(objects)이란 네트워크에 연결 된 사용자나 다양한 개체를 의미하며, 원격 모니터링 장비, 각종 센서 및 시스템 등과 같이 우리 주변에 존재하는 모든 것이 대상임 사용자의 단말기 및 웨어러블 기기, RFID 센서, 다양한 목적의 디바이스, 콘텐츠, 응용 프로그램, 차량 등 모든 형태가 사물이 됨 우리 주변의 여러 사물들이 네트워크에 연결되고, 종단간 연결 성장을 통해 독립적으로 통신함 유비쿼터스 네트워크에서 고려되는 세 가지 유형의 사물 고정 사물(Fixed Objects) 이동이 없는 사물 이동 사물(Mobile Objects) 한 장소에서 다른 장소로 이동 중인 사물 논리적 사물(Logical Objects) 서버 상의 응용 프로그램이나 콘텐츠 같은 객체로 연결성 제공을 위한 개체 사물은 집, 빌딩과 같은 고정 환경에서 동작할 수도 있고, 차량과 같은 이동 환경일 수도 있음 유 · 무선 인터페이스를 통해 차세대 네트워크(NGN)에 연결되어 상호 통신을 수행할 수 있음사물 인터넷사물 인터넷 각종 사물에 컴퓨터(프로세서와 통신 모듈)를 내장하여 인터넷에 연결할 수 있는 기술 모든 종류의 사물들이 서로 연결되어 통신이 가능함을 의미 IoT는 사물(센서), 네트워크, 데이터, 서비스의 융합 사물에 설치된 센서를 이용하여 데이터의 수집, 네트워크를 통해 수집한 데이터들의 전송, 수집 된 데이터를 가공하는 기술 사람들이 제어하지 않더라도 스스로 자율적으로 동작하면서 필요한 정보를 공유할 수 있음 새로운 서비스를 가능하게 하는 네트워크 (IoT) ChatGPT 질문 2 : 챕터 2광식: 사물 인터넷의 특징을 정리해줘GPT: MEMS(마이크로 전기 기계 시스템)는 작고 복잡한 기계 및 전기 시스템을 작은 칩에 통합하는 기술입니다. 이 기술은 다양한 응용 분야에서 혁신적인 솔루션을 제공하고 사물 인터넷(Internet of Things, IoT)의 주요 특징은 다음과 같습니다:1. 연결성: 사물 인터넷은 다양한 장치들을 인터넷에 연결하여 데이터를 주고받을 수 있는 기능을 제공합니다. 이를 통해 사물들 간의 상호작용이 가능해지며, 데이터를 실시간으로 수집하고 분석할 수 있습니다.2. 센서와 액추에이터: 사물인터넷은 센서를 통해 환경 데이터를 수집하고, 액추에이터를 통해 환경에 영향을 줄 수 있습니다. 이를 통해 스마트 홈, 스마트 시티, 산업 자동화 등 다양한 응용 분야에서 활용됩니다.3. 데이터 수집과 분석: 사물 인터넷은 대규모의 데이터를 수집하고 분석하여 실시간으로 상황을 모니터링하고 예측할 수 있습니다. 이를 통해 효율성을 높이고 비용을 절감할 수 있습니다.4. 자동화와 자율적인 의사 결정: 사물 인터넷은 자동화된 시스템을 구축하여 인간의 개입 없이 작업을 수행할 수 있습니다. 또한 수집된 데이터를 기반으로 자동화된 의사 결정을 내릴 수 있어서 생산성을 향상시킵니다.5. 보안과 프라이버시: 대규모의 연결된 장치들은 보안과 프라이버시 문제에 민감합니다. 사물인터넷은 이러한 문제에 대한 적절한 보안 및 프라이버시 대책을 마련해야 합니다.이러한 특징들은 사물 인터넷이 혁신적인 기술로서 다양한 산업 분야에서 적용되고 있음을 보여줍니다.사물 인터넷에서 사물의 의미 IoT에서 사물은 주로 네트워크에 연결 된 다양한 디바이스 장치를 의미하며, 임의의 소형 처리 장치(컴퓨터)가 부착 된 일종의 임베디드 시스템 예를 들면, 스마트폰이나 태블릿과 같은 모바일 기기, 웨어러블 기기, 자동차, TV나 냉장고와 같은 가전 제품, CCTV, 드론 등 거의 모든 물체가 사물이 될 수 있음사물 인터넷에서 사물의 의미 사물에 부착된 디바이스(소형 처리 장치, 컴퓨터)는 주변 상황을 인지하고 필요한 데이터를 수집할 수 있는 센서, 수집한 데이터를 처리하거나 저장할 수 있는 처리 장치 및 저장 공간, 네트워크와 연결하여 데이터를 주고받을 수 있는 통신 모듈, 그리고 자체 전원으로 구성되어 있음IoT에서 사물 대 사물 통신을 위한 일반적인 요구 사항 사물 대 사물 통신을 위한 통신 매체는 언제, 어디서나, 원하는 서비스를 받을 수 있도록 항상 통신이 가능하도록 해야 함 사물이 어느 정도 지능적으로 동작한다면, 일부 데이터 처리 기능이 네트워크의 가장자리 쪽에서 수행될 수 있어서 전체 시스템에서 서버의 부하를 줄일 수 있음 네트워크 구성 요소는 모든 종류의 사물에 설치 가능하도록 충분히 작아야 함사물 대 사물 통신을 위한 일반적인 요구 사항 사물은 제한된 일부 처리 능력만 갖춘 경우가 많으므로, 불필요한 부하는 제거하고 통신 계층은 최적화된 경량 프로토콜이 적합함 사물의 실행 환경을 동적으로 설정하기 위해 자동화, 자가 환경 설정, 네트워크 적응 기능이 제공 되어야 함 통신 범위 안에 진입하는 사물과 통신하기 위해서는 자동 발견 기능이 요구됨 사물은 네트워크에 연결될 때 필요한 모든 설정 값을 얻을 수 있어야 함 자동화 된 사물 사이에 끊김 없는 통신이 가능하도록 이동성 관리가 요구 됨 네트워크 크기는 네트워크와 연결된 사물의 수만큼 증가 됨 점점 더 많은 통신 사물을 포함할 수 있도록 확장성이 요구 됨 각 통신 사물은 서로 종단 간 연결성을 위해 고유한 식별 값을 갖도록 권장 됨 ex) IPv6 주소 프로그래밍 플랫폼은 응용 프로그램 개발을 빠르고 쉽게 할 수 있도록 적절한 지원을 제공해야 함 필요한 수준의 QoS(Quality of Service)와 QoE(Quality of Experience)가 제공되어야 함 특히 중요한 사물은 적절한 때에 정확하게 처리되어야 함 통신 오류의 발견 기능 및 발견 즉시 수정할 수 있어야 함 M2M과 IoT 사물 통신이라고 불리는 M2M은 21세기 초에 정립된 개념으로 모든 사물에 통신 기능을 부여하여 지능적으로 정보를 수집하고, 상호 전달하는 기술 IoT는 인간과 사물, 서비스 등 분산 된 구성 요소 간에 인위적인 개입 없이 상호 협력하여 센싱, 네트워킹, 정보 교환 및 처리 등의 지능적 관계를 형성하는 사물 공간 연결망 연결의 대상이 인간에서 사물, 공간, 지능에 이르기까지 광범위하게 확장됨 정보의 수집도 직접 입력에서 센싱(sensing)의 개념으로 변화함IoT의 주요 기술 요소 본래 사물들은 기본적으로 주변 환경을 인식하고 적절한 데이터를 수집하여 부분적으로 처리하고, 이를 네트워크를 통해 서버에 전달할 수 있어야 함 하부에 위치한 다양한 목적의 사물들은 주변 환경으로부터 데이터를 수집하여 전달하고 있으며, 이러한 사물들로부터 데이터를 전달 받아서 효율적으로 처리하기위한 플랫폼, 그리고 수집 된 데이터를 이용하여 서비스를 제공하는 응용 프로그램으로 구분할 수 있음 IoT의 3대 주요 기술은 센싱, 유 · 무선 네트워크, IoT 서비스 인터페이스 기술로 구분할 수 있음 사물 식별 기술 기존의 네트워크 단말을 대신하는 RFID(Radio Frequency Identification, 무선 인식), 센서, 스마트 카드 같은 새로운 형태의 장치에 대한 식별 기능 Connecting to Anything을 지원하기 위한 상세한 기술적 고려 사항은 다음과 같음 사물의 식별 사물의 위치 찾기/추적 네이밍과 어드레싱에 의해 차세대 네트워크(NGN)에 연결성 제공 사물 대 사물 통신을 위해 유비쿼터스 네트워킹에서 종단 점 위치한 사물에 대한 정보는 네트워크에서 식별 될 수 있음 사물의 신원(identity)은 일정 시간이 지나도 변하지 않으며, 또한 특정 종단 시스템에 영향을 받지 않음 유비쿼터스 네트워킹 환경에서 종단 간 연결성을 제공하기 위해 모든 사물의 식별은 중요함 유비쿼터스 네트워킹에서 식별자는 대상 사물을 식별하고 사물 대 사물 통신을 가능하게 함 전체 네트워크 환경에서 유일한 식별자는 사물의 추적, 접속 제어, 보호 등의 기능을 활용하는 여러 응용 프로그램에 필수적인 기능임 데이터 처리 및 관리 기능 IoT 관련 기반 기술이 발전하고 이를 응용한 다양한 서비스가 가능해짐에 따라 생성되고 처리되어야 할 데이터의 종류나 양이 엄청나게 증가하고 있음 3V: 더욱 많이(Volume), 더욱 빠르게(Velocity), 더욱 다양하게(Variety) IoT에서 수집한 데이터를 정보를 가공하고, 분석하여 가치를 창출하는 데이터 분석 기술이 필요함 분석 알고리즘의 고도화, 머신 러닝 및 딥 러닝과 같은 기술을 적용하려는 시도가 활발하게 진행되고 있음 서비스의 종류에 따라 실시간으로 환경 변화를 감지하고 분석할 수 있는 기술과 감지된 상황 변화 정보를 제한 된 시간 내에 분석하고 처리할 수 있는 기술이 필요함 이러한 문제를 해결하기 위해 향후 클라우드 시스템을 적극 활용할 것으로 전망되며, 데이터베이스, 데이터 스토리지 기술, 오픈 소스 기술 등도 활발하게 연구될 것임 여러 사물이 수집한 다양한 빅 데이터의 분산 처리 능력도 중요한 요소가 될 것임 IoT 통합 플랫폼 기능 IoT의 미래 서비스 시장은 대규모 사물과 대용량 데이터를 효율적으로 처리할 수 있는 개방형 사물 인터넷 플랫폼을 기반으로 크게 확산될 것으로 예측됨 IoT 플랫폼의 주요 기능 이기종 센서들을 식별한 후 연결하는 기능 각 사물에 대한 제어 기능 대규모 센서들로부터 수집 된 데이터를 효율적으로 저장하고 관리하는 기능 수집 된 대용량 데이터를 효율적으로 검색, 분석하는 기능 웹을 통한 개방형 서비스 제공 기능 보안 기능 많은 수의 다양한 사물들의 연결, 수집 된 정보를 서버에 전달, 분석 결과를 이용하여 서비스를 제공하는 과정 중에서 각 과정에서 외부의 악의적인 공격에 의해 불의의 사고가 발생할 확률이 높음 이에 따라, IoT에서의 보안 기술이 더욱 중요하게 됨 IoT의 주요 응용 분야 보건·의료 분야에 적용되어 원격 진료와 웨어러블 컴퓨터가 만들어졌고, 전력 분야에 적용되어 스마트 그리드(Smart Grid), 교통 분야에 적용되어 커넥티드카(Connected Car) 및 지능형 교통 시스템(ITS)으로 발전하였음 제조업의 생산 공정에 도입되면 스마트 팩토리(Smart Factory), 즉 첨단 생산 관리 시스템을 구축할 수 있음 로테크(low-tech)산업으로 인식되어 온 농수산식품산업에도 ICT(Information &amp; Communication Technology)가 적용되어 스마트 농장, 식물 공장이나 스마트 푸드 시스템 등 고부가 가치의 새로운 사업 영역을 창출하고 있음 응용 분야 주요 기능 에너지 신 재생 에너지원, 전력 망, 전력과 에너지 소비를 지속적으로 측정하여 배전 회사와 소비자에게 제공하는 동시에 적절히 수요와 공급의 균형을 맞추도록 하는 분산 지능형 통합 시스템 교통/ 운송 사용자가 더 안전하고 더 편리하게 이용할 수 있도록 서로 다른 형태의 운송 수단 및 교통 체계를 관리하는 혁신적인 서비스를 제공하는 응용 기술 제조업 전 생산 공정에서 필요한 정보를 필요한 시점에 좀 더 유용한 형태로 가공하여 취합할 수 있도록 하는 실시간 통합 처리 시스템 의료 진보 된 응용 기기(모바일/스마트 장치, 센서, 액츄에이터 등)를 통해 환자와 의료진에게 의료 서비스에 대한 접근성을 향상 시키는 공공 및 개인 의료 체계 구축 공공 시민의 안전과 관련된 정보를 제공하고 한 차원 높은 공공 서비스를 제공할 수 있도록 실시간 정보 체계 구축 고객 서비스 구매에서 엔터테인먼트에 이르기까지 기술과 개인 삶이 상호 작용할 수 있는 개인 맞춤형 응용 서비스 제공 건축/ 주거 스마트폰이나 모바일 장치를 통해 원격으로 전등, 난방, 가전 기기 등을 조절할 수 있는 건물과 관련된 응용 시스템 인공지능 기술이 성숙되면서 IoT 분야에도 빠르게 적용되고 있으며, 이를 지능형 사물 인터넷(AIoT)이라고 함 ICT 분야 기술 로드맵 등을 살펴보면, 향후 IoT는 주변 상황 정보를 수집하여 분석하고 예측한 후, 판단까지 할 수 있는 지능화 된 서비스를 자율적으로 제공할 수 있는 융복합 기술로 예상하고 있음 IoT의 연결형, 지능형, 자율형 서비스를 고도화 하기 위해 인공 지능 기술이 널리 활용될 것으로 예상됨정리 하기 유비쿼터스 네트워크 기술은 컴퓨터 뿐만 아니라 다양한 종류의 단말기가 네트워크에 상시 접속 되어, 누구든지 시간과 장소의 제약 없이 네트워크를 활용하여 다양한 서비스를 제공 받을 수 있는 환경 또는 이를 가능하게 하는 기술을 의미함 사물 인터넷이란 사물에 통신 및 처리 기능을 내장하여 인터넷에 연결할 수 있는 기술을 의미함연습 문제 유비쿼터스 네트워킹을 위한 구조적 모델에서 사물의 수행 환경과 상황 정보는 통신하는 단말이나 사용자의 이동, 실행 환경의 변화 등 여러 통신 환경 변화에 따라 영향을 받기 때문에 각 사물은 예측할 수 없는 실행 상황에도 대처하는 계층은 무엇인가? a. 차세대 네트워크 서비스 층 사물 인터넷에서 서버 상의 콘텐츠 같은 객체의 사물 유형은 무엇인가? a. 논리적 사물 위 지문의 빈칸에 알맞은 것은 무엇인가? 하부에 위치한 다양한 목적의 ( )들은 주변 환경으로부터 데이터를 수집하여 전달하고 있으며, 이러한 사물들로부터 데이터를 전달받아서 효율적으로 처리하기 위한 ( ), 그리고 수집된 데이터를 이용하여 서비스를 제공하는 ( )으로 구분할 수 있다. a. 사물, 플랫폼, 응용 프로그램 정리 하기 유비쿼터스 네트워크 기술 PC 뿐만 아니라 모든 단말기가 네트워크에 항상 접속 되어, 누구든지 시간과 장소의 제약 없이 네트워크를 활용한 다양한 서비스를 제공 받을 수 있는 환경 또는 이를 가능하게 하는 기술 유비쿼터스 네트워킹을 위한 구조적 모델 유비쿼터스 네트워크 최종 사용자(End-User) 기능 최종 사용자 기능은 연결과 협력을 위한 최종 사용자 측면의 기능 유비쿼터스 네트워크 차세대 네트워크 전송 층(NGN Transport Stratum) 전송 계층에 각 단말의 다양한 통신 방식과 독립적인 방식으로 정보를 주고받을 수 있는 기능 유비쿼터스 네트워크 차세대 네트워크 서비스 층(NGN Service Stratum) 서비스 층은 전송 층과 상호작용 중에도 현재 상황을 파악하기 위한 모니터링 기능 유비쿼터스 네트워크 응용 프로그램 유비쿼터스 네트워킹 응용프로그램은 수집한 데이터를 이용하고 가공하여 의미 있는 정보를 생성하는 역할 광대역 통합망 (BcN) 유선 사업자들이 주도하는 차세대 기반 망과 무선 사업자들이 주축이 되는 통합 인터넷 프로토콜 망의 구축을 통하여 처음부터 융합된 망으로 시작한 후 단계적인 고도화를 통해 차세대 네트워크로 발전함 사물 인터넷에서의 사물 유형 고정 사물(Fixed Objects) 이동이 없는 사물 이동 사물(Mobile Objects) 한 장소에서 다른 장소로 이동 중인 사물 논리적 사물(Logical Objects) 서버 상의 콘텐츠 같은 객체로 연결성 제공 및 서비스를 위한 객체 사물 인터넷 (IoT ; Internet of Things) 각종 사물에 컴퓨터(프로세서와 통신 모듈)를 내장하여 인터넷에 연결할 수 있는 기술 모든 종류의 사물들이 서로 연결되어 통신이 가능함을 의미 IoT는 사물(센서), 네트워크, 데이터, 서비스의 융합 " }, { "title": "[Java 프로그래밍] 7강 - 패키지와 예외 처리", "url": "/posts/knou-java-7/", "categories": "Language, Java", "tags": "knou, java", "date": "2025-04-13 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김희천 교수님의 'Java 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 패키지는 관련이 있는 클래스나 인터페이스의 묶음으로, 계층 구조로 이루어진 클래스나 인터페이스의 라이브러리임 예외는 실행 중에 발생하는 경미한 오류이며, 예외 처리를 통해 정상 상황으로 복구 될 수 있음 패키지를 정의하고 사용하는 방법과 예외 처리 개념을 이해하고 활용할 수 방법을 익히도록 함학습 목표 사용자 패키지 정의할 수 있음 정의된 패키지를 사용하여 프로그램 작성할 수 있음 예외의 종류 설명할 수 있음 예외 처리 코드 작성할 수 있음강의록패키지패키지 관련이 있는 클래스와 인터페이스의 묶음 클래스와 인터페이스는 패키지의 멤버로 존재 패키지는 클래스와 인터페이스의 .class 파일이 저장된 폴더 전체적으로 패키지는 계층 구조로 이루어짐 패키지(폴더와 유사) 단위로 계층 적으로 분류됨 패키지의 용도 클래스를 쉽게 찾아 사용하기 위해 클래스의 이름 충돌을 피하기 위해 import graphics.Rectangle import java.awt.Rectangle 클래스의 접근 범위를 제어하기 위해 시스템 패키지 JDK가 제공하는 클래스 라이브러리 JDK와 함께 설치됨 클래스 파일들은 기능에 따라 패키지로 묶여 분류됨 과거에는 jar 파일로 압축되어 있었음 ex) rt.jar 최근 버전에는 모듈 단위로 분산 되어 저장되어 있음 C:\\Program Files\\Java\\jdk-21\\lib\\src.zip 에서 소스를 확인할 수도 있음 시스템 패키지의 사용 가장 기본이 되는 최 상위 시스템 패키지는 java패키지 대부분 시스템 패키지는 java.으로 시작 Java 프로그램에서 상위 패키지와 하위 패키지의 구분을 위해 도트(.)를 사용 ex) java.lang, java.io, java.nio.file, java.util, java.util.stream등 Java 언어에서 가장 기본적 클래스는 java.lang패키지에 존재 프로그램에서 클래스를 사용할 때는 java.io.IOException과 같이 완전한 이름으로 표현하는 것이 원칙임 사용자 정의 패키지패키지 정의package com.vehicle;public class Car { String szType = \"승용차\";} 컴파일 결과로 Car.class 생성 Car.class는 com.vehicle패키지에 저장 com.vehicle의 위치 컴파일 할 때 -d 옵션 사용하여 지정함 ex) javac Car.java -d D:\\javaClasses 이 경우 D:\\javaClasses\\com\\vehicle\\Car.class 이클립스 에서는 작업공간\\프로젝트폴더\\bin\\com\\vehicle\\Car.class Eclipse에서 사용자 패키지 정의하기 메뉴 File → New → Package 선택 패키지에 해당하는 폴더가 만들어짐 생성된 패키지에서 클래스를 만들면 됨 또는 메뉴 File → New → Class 선택하여 클래스 이름과 함께 패키지 이름을 함께 입력함 패키지와 클래스의 사용 다른 패키지에 존재하는 public클래스를 사용하려면 기본적으로 패키지 경로를 포함한 완전한 클래스 이름을 사용해야함 프로그램에서 여러번 사용한다면 import구문 사용하는 게 좋음 ex) graphics.Rectangel myRect = new graphics.Rectangle(); java.util.Scanner s = new java.util.Scanner(System.in); import java.util.Scanner; public class Main { public static void main(String args[]) { Scanner s = new Scanner(System.in); } } import문 1개 클래스 또는 패키지에 있는 클래스 전체를 import할 수 있음 import 패키지 이름.클래스 이름; import 패키지 이름.*; import구문은 소스 코드 맨 앞에 위치함 단, package구문이 있다면 그 다음에 위치함 프로그램에서 패키지 경로를 생략하고, 이름만 가지고 클래스나 인터페이스를 사용할 수 있게 함 Java 프로그램에서 import java.lang.*;구문은 자동 포함됨패키지의 사용과 접근 제어 아래 프로그램에서 package구문이 없다면 패키지 접근 수준의 Car 클래스 사용 불가 // package com.vehicle; import com.vehicle.*; class MyCar extends Car { // 오류 발생 } class MyBus extends Bus { // 기본 패키지에 MyBus 클래스 생성 } public class PackageTest { public static void main(String args[]) { Bus bus = new Bus(); Car car = new Car(); // 오류 발생 } } package com.vehicle; class Car { } package com.vehicle; public class Bus extends Car { } 클래스 찾기 컴파일하거나 실행할 때, 필요한 클래스(A)를 찾아야함 컴파일러가 A.class가 위치한 경로 또는 A.class를 포함하고 있는 jar 파일의 존재를 알아야 함 JVM은 기본 패키지나 확장 패키지 외에 사용자 클래스도 찾을 수 있음 이때 방법이 필요함 컴파일러는 환경 변수 CLASSPATH에 지정된 경로에서 사용자 클래스를 찾을 수 있음 환경 변수 CLASSPATH CLASSPATH의 경로는 jar 파일을 포함할 수 있음 ex) 프로그램에서 graphics.Circle클래스를 사용하는 경우 CLASSPATH = 경로;a.jar 라고 가정 이때, 경로\\graphics\\Circle.class 또는 a.jar에 \\graphics\\Circle.class가 있어야 함 이클립스에서는 프로젝트 폴더 → Properties → Java Build Path → Libraries → Classpath에서 추가함 예외와 예외 처리예외와 에러 에러(Error)는 실행 중 발생하는 심각한 오류로 더 이상의 실행이 불가함 예외(Exception)는 경미한 오류로 복구 가능함 예외 발생이란 정상적 실행 흐름을 벗어난 예외적 사건이 발생함을 의미 예외 발생과 처리 프로그램 실행 중에 예외 상황이 발생하면,예외 처리 코드에 예외 객체를 생성하여 던짐(throw) 적당한 예외 처리 코드(exception handler)가 있으면 예외 객체를 잡아(catch) 처리한 뒤, 프로그램은 계속 수행 됨 예외 처리 코드가 없으면, 오류 메시지가 출력 되면서 프로그램이 즉시 비정상적으로 종료 됨 예외 객체는 Exception클래스(또는 하위 클래스)로 표현되며 예외 발생 정보를 가지고 있음 예외 클래스의 계층 구조 Exception클래스는 Throwable클래스의 자식 클래스 toString(), printStackTrace()메소드 등을 상속 받음 Unchecked Exception 예외 처리 코드 강제성 없음 Checked Exception 반드시 예외 처리 코드 필요 예외 처리 예외가 발생했을 때 이 상황을 바로 잡아 계속 수행하도록 하는 것 예외 발생 시, Exception 객체를 생성하고 throw함 throw new MyException(); throw 된 예외 객체를 예외 처리 코드가 catch하여 예외를 처리함 예외 발생과 처리 checked Exception 예외가 발생할 수 있는 경우, 반드시 명시적인 예외 처리가 필요함 예외 처리 코드가 없으면 컴파일 오류 RuntimeException예외의 경우, 예외 처리를 안 해도 됨 프로그램을 정확하게 작성하지 않은 경우 발생 됨 ArithmeticException, NullpointerException, IndexOutOfBoundsException등 예외 처리 방법 직접 처리 예외가 발생한 곳에서 예외 객체를 잡아서 처리하는 것 try-catch구문 또는 try-catch-finally구문 사용하여 예외를 처리함 일반 코드와 예외 처리가 분리되어 가독성이 좋아짐 간접 처리(예외의 전파) 예외 발생 가능성이 있는 메소드의 선언에서 괄호 다음에 throws예외 클래스를 사용 해당 메소드는 예외를 발생 시킬 수 있는 메소드 그 메소드를 호출한 메소드에게 예외 처리를 전달 또는 위임하는 것 호출한 메소드로 예외를 전파함 예외의 직접 처리 try-catch-finally구문 try { } catch(ExceotionType1 ex1) { } catch(ExceotionType2 ex2) { } finally { } 예외 객체를 throw하는 문장 또는 예외 발생 가능성이 있는 메소드의 호출 부분을 try블록에 둠 처리하려는 예외 종류에 따라 catch블록을 작성 catch블록은 1개의 예외 유형 인자를 가지는 메소드와 유사 여러 예외 유형을 분리해서 처리하려면 catch 블록도 여럿이 됨 finally블록은 필요에 따라 작성하며 생략 가능 try-catch-finally구문의 실행 실행 중에 예외가 발생하면 try블록은 즉시 종료되고 catch블록이 실행됨 catch블록이 여럿이면, catch블록의 매개 변수와 예외 클래스를 비교하여 적합한(발생된 예외 자료형과 일치하거나 상위 유형) 하나만 실행 상위와 하위 유형 예외를 처리하는 catch블록이 모두 있다면, 하위 유형 예외를 처리하는 블록이 먼저 나와야 함 try블록에서 예외가 발생하지 않으면 catch블록은 실행 되지 않음 finally블록은 예외 발생과 무관하게 항상 실행 됨 할당 받아 사용했던 리소스를 반환하기 위해 즉, 리소스를 close()하는 문장을 finally블록 내에 둠 ex) try블록에서 open()했던 파일을 close()하는 코드를 finally블록에 둠 예외 처리 프로그램 예public class Main { public static void main(String[] args) { try { // 예외가 발생할 수 있는 코드 블록 int[] numbers = { 1, 2, 3 }; System.out.println(numbers[4]); // 배열 인덱스 범위를 초과하여 예외 발생 int result = 10 / 0; // ArithmeticException 발생 System.out.println(\"결과: \" + result); } catch (ArrayIndexOutOfBoundsException e) { // ArrayIndexOutOfBoundsException 처리 System.out.println(\"배열 인덱스가 잘못되었습니다.\"); } catch (ArithmeticException e) { // ArithmeticException 처리 System.out.println(\"0으로 나눌 수 없습니다.\"); } System.out.println(\"프로그램이 정상 종료됩니다.\"); }}// 배열 인덱스가 잘못되었습니다.// 프로그램이 정상 종료됩니다.try-with-resources구문 리소스 객체의 선언이 있는 try블록을 가짐 try (리소스 생성 구문) { } catch (ExceptionType ex) { } 리소스의 유형은 AutoCloseable인터페이스를 구현한 클래스 이때 리소스는 사용 후 close()호출을 통해 반환 되어야 함 파일, 네트워크 연결, 데이터베이스 연결 등 외부 자원을 사용하는 경우 사용함 try-with-resource구문을 사용하려면 리소스의 자동 반환을 보장함 즉, finally블록에서 리소스를 close()하지 않아도 됨 try-with-resource구문을 사용한 코드 import java.io.*; public class Test { public static void main(String[] args) { try (BufferedReader br = new BufferedReader(new FileReader(\"file.txt\"))) { String line; while ((line = br.readLine()) != null) { System.out.println(line); } } catch (IOException e) { e.printStackTrace(); } } } try-with-resource구문을 사용하지 않은 코드 BufferedReader br = null; try { br = new BufferedReader(new FileReader(\"file.txt\")); String line; while ((line = br.readLine()) != null) { System.out.println(line); } } catch (IOException e) { e.printStackTrace(); } finally { try { if (br != null) br.close(); } catch (IOException ex) { ex.printStackTrace(); } } 예외의 간접 처리 예외가 발생할 가능성이 있는 코드를 가진 메소드를 호출하는 쪽에 예외 처리를 위임하는 것 예외의 전파 예외 발생 코드의 예외 처리를 위해 try-catch 블록을 사용하지 않고, 대신 메소드 선언 부에서 발생 시킬 수 있는 예외 유형을 표시함 즉, 메소드 선언에서 괄호 다음에 throws예외 유형을 사용 class CharInput { int nInput; public char getInput() throws IOException { nInput = System.in.read(); //예외 발생 가능 return (char) nInput; } } 메소드 선언에서 throws절이 표시 된 메소드의 호출은 예외 처리가 필요함 try { c = obj.getInput(); } catch (IOException ex) { } 예외(checked Exception)를 발생 시킬 수 있는 메소드의 예 FileInputStream클래스의 생성자 public FileInputStream(String name) throws FileNotFoundException InputStream(또는 Reader) 클래스의 메소드 public int read() throws IOException 위와 같은 메소드를 호출할 때는 반드시 예외 처리가 필요함 예외 처리 프로그램의 예 예외 처리 프로그램 1 import java.io.*; public class Main { public static void main(String args[]) { int b = 0; try { b = System.in.read(); // IOException을 발생 시킬 수 있는 메소드기 때문에 예외 처리 필요 } catch (IOException ex) { System.out.println(ex); } System.out.println((char) b); } } public abstract int read() throws IOException 예외 처리 프로그램 2 import java.io.*; class CharInput { int nInput = 0; public char getInput() throws IOException { // 예외 간접 처리로 예외 전파 nInput = System.in.read(); return (char)nInput; } } public class ExceptionTest4 { public static void main(String args[]) { CharInput charInput = new CharInput(); try { System.out.println(charInput.getInput()); // getInput 메소드 호출하여 예외 처리 필요 } catch (IOException ex) { System.out.println(ex); } } } 사용자 정의 예외 사용자가 직접 예외 클래스를 작성할 수 있음 일반적으로 Exception클래스 상속 받음 throw구문을 사용하여, 필요할 때 예외 객체를 던질 수 있음 class MyException extends Exception { public MyException() { super(); } public String toString() { return \"MyException\"; } } class MyExceptionTest { public void testFunc(int x) throws MyException { if (x &gt; 10) throw new MyException(); // 예외 객체 생성 -&gt; 예외 발생 } } 학습 정리 Java의 패키지는 관련이 있는 클래스와 인터페이스의 묶음이며 계층 구조로 구성됨 다른 패키지에 있는 클래스를 사용할 때는 import구문을 사용하는 것이 편리함 Java 프로그램에서 필요한 클래스나 패키지는 환경 변수 CLASSPATH에 포함되어 있는 경로 상에서 찾을 수 있어야 함 Java 프로그램의 실행 도중 심각하지는 않지만 정상적 흐름을 벗어난 비정상적 상황이 발생할 수 있으며 예외라 부름 checked Exception에 속하는 예외가 발생할 수 있는 경우, 반드시 예외 처리 구문 작성해야 함 예외의 직접 처리를 위해 try-catch구문을 사용하고, 예외를 전파하려면 메소드 선언에 throws예외 유형을 표시 함연습 문제 Client 클래스를 myprogram.game패키지에 위치시키려고 한다. Client 클래스를 정의하는 소스 파일의 맨 위에 포함시켜야 코드는 무엇인가? a. package myprogram.game; 밑줄 부분에 들어가야 할 내용은 무엇인가? public char getInput() /*_____*/ { int nInput = System.in.read(); return (char)nInput; } a. throws IOException 프로그램 상에 클래스의 완전한 이름인 java.util.Scanner로 표시하지 않고, 단순히 클래스 이름 Scanner만으로 표시하기 위해서 소스 파일의 맨 위에 작성해야 코드는 무엇인가? a. import java.util.Scanner; import java.util.*; " }, { "title": "[운영 체제] 6강 - 교착 상태", "url": "/posts/knou-os-6/", "categories": "OS, Operating System", "tags": "knou, os", "date": "2025-04-12 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김진욱 교수님의 '운영 체제' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 병행 프로세스들은 컴퓨터 시스템의 제한된 자원을 사용하기 위해 서로 경쟁할 수 있음 만일 어떤 프로세스가 사용하고자 하는 자원을 다른 프로세스가 온전히 점유하고 있다면 그 프로세스는 대기해야 함 이렇게 요구와 점유 및 이에 따른 대기 상태가 서로 꼬리를 물고 있게 되면, 이러한 관계에 포함된 프로세스들은 더 이상 진행하지 못하게 되는 상태인 교착 상태에 빠질 수 있음 운영체제는 이러한 교착 상태를 예방하거나 제거함으로써 프로세스의 동작이 원활하게 이루어지도록 해야 함 교착 상태의 개념과 특성을 살펴보고, 교착 상태를 다루는 여러 기법 중 교착 상태를 예방하는 방법에 대해 알아봄학습 목표 교착 상태의 개념을 설명할 수 있음 교착 상태가 발생하기 위한 필요 조건을 설명할 수 있음 자원 할당 그래프의 개념을 설명할 수 있음 교착 상태를 예방하는 방법을 설명할 수 있음강의록교착 상태의 개요프로세스의 자원 사용 절차 요구 → 사용 → 해제 요구 과정에서 가용한 자원이 없으면 자원을 획득할 때까지 대기 교착 상태(deadlock) 여러 개의 프로세스가 서로 상대방의 작업이 끝나기만 기다리고 있어 어느 쪽도 영원히 진행하지 못하는 상태교착 상태와 기아 상태의 차이 교착 상태 영원히 멈춰 있는 상태 기아 상태 현재도 멈춰있고 당분간 멈춰있지만 분명히 해소될 가능성이 있는 상태 교착 상태의 특성교착 상태의 필요 조건 네 가지 조건이 동시에 만족 될 때 교착 상태 발생 가능 상호 배제 점유 대기 비선점 환형 대기 상호 배제(mutual exclusion) 조건 프로세스가 자원에 대한 배타적인 통제권을 요구 적어도 하나 이상의 자원은 여러 프로세스에 의해 동시에 사용될 수 없음 다른 프로세스가 점유한 자원이 필요하면 반드시 대기점유 대기(hold and wait) 조건 프로세스가 이미 한 자원을 할당 받아 점유하고 있는 상황에 다른 프로세스가 점유하고 있는 또 다른 자원을 요구하여 해제 되기를 기다리는 상황비선점(no preemption) 조건 프로세스 할당 된 자원은 그 프로세스가 사용을 마치고 스스로 반환하기 전에는 해제되지 않음 할당 된 자원은 타의에 의해서 해제 되지 않음환형 대기(circular wait) 조건 프로세스의 자원 점유 및 점유 된 자원의 요구 관계가 환형을 이루며 대기하는 상황자원 할당 그래프 G = (V, E) V 정점의 집합 V = P ∪ R P = {p₁, p₂, …, pₙ} n개의 프로세스 R = {r₁, r₂, …, rₘ} m개의 자원 E 방향 있는 간선의 집합 E = Q ∪ S Q = { (pᵢ, rⱼ) pᵢ ∈ P, rⱼ∈ R } 프로세스 pᵢ가 자원 rⱼ를 요구 S = { (rⱼ, pᵢ) : rⱼ∈ R, pᵢ ∈ P } 자원 rⱼ가 프로세스 pᵢ에 할당 자원 할당 그래프 예 정점의 집합 V = P ∪ R 프로세스 집합 P = {p₁, p₂, p₃} 자원 집합 R = {r₁, r₂, r₃} 방향 있는 간선의 E = Q ∪ S 요구 간선 집합 Q = { (p₁, r₁) } 할당 간선 집합 S = { (r₁, p₁), (r₂, p₂), (r₃, p₃) } 자원 할당 그래프의 변화 p₂가 r₃을 요구하는 경우 요구 간선(p₂, r₃) 추가 가용한 단위 자원 존재하면 할당 간선 (r₃, p₂)로 바꿈 자원 할당 그래프 교착 상태의 필요 조건 표현 상호 배제 하나의 할당 간선 점유 대기 한 프로세스에 할당 간선과 요구 간선 연결 비선점 요구 간선 환형 대기 사이클(cycle) 사이클 없음 교착 상태 없음 사이클 있음 교착 상태 발생 가능 ex) 교착 상태 예 ex) 교착 상태 아닌 예 교착 상태의 처리 기법 교착 상태 예방 교착 상태의 네 가지 필요 조건이 동시에 만족 되는 것을 피하여 교착 상태가 발생하지 않도록 하는 방법 교착 상태 회피 프로세스에 필요한 자원의 최대 량에 대한 정보를 이용하여 교착 상태가 발생하지 않도록 하는 방법 교착 상태 탐지 및 복구 교착 상태의 발생 여부를 조사하여 발생한 경우에는 적절한 조치를 취해 정상 상태로 복구하는 방법 교착 상태 예방상호 배제 조건 제거 공유할 수 있는 자원 상호 배제 필요 없음 ex) 읽기 전용 파일 공유할 수 없는 자원 반드시 상호 배제 필요 ex) 프린터 상호 배제 조건 제거로 교착 상태 예방은 불가능 점유 대기 조건 제거 자원을 점유했을 때 대기하지 않아야 함 프로세스가 앞으로 필요한 모든 자원을 처음에 한꺼번에 요구하여 할당 받음 자원 이용률 낮아짐, 기아 상태 가능 대기할 때 자원을 점유하고 있지 않아야 함 새로운 자원을 요구할 때 할당 받았던 자원을 모두 해제 점유 도중 해제할 수 없는 자원에는 적용 불가 비선점 조건 제거 선점이 가능하도록 해야 함 자원의 특성에 따라 불가능한 경우 존재 ex) 프린터 다른 프로세스가 대기할 가능성 줄이기 점유 대기 상황이 발생하면 할당 받았던 자원을 모두 해제 프린터 같은 자원에는 적용 불가 환형 대기 조건 제거 모든 자원에 일련 번호를 지정 함수 f:R → N (R: 자원 집합, N: 자연수 집합) rᵢ ≠ rⱼ이면 f(rᵢ) ≠ f(rⱼ) 방법 1 프로세스는 자원을 요구할 때 일련 번호 기준으로 항상 오름차순이 되도록 요구 가장 최근에 할당 받은 자원이 rᵢ이면 다음에 요구할 자원rⱼ는 f(rᵢ) &lt; f(rⱼ) 만족 방법 2 프로세스가 자원을 요구할 때 그보다 일련번호가 작은 자원만 점유하도록 함 자원 rⱼ 요구하려면 점유 중인 자원 중 f(rⱼ) ≤ f(rᵢ) 인 rᵢ는 모두 해제 점유 대기 중인 프로세스는 점유 중인 자원의 일련 번호보다 대기 중인 자원의 일련 번호가 큼 환형 대기 발생 불가능 프로세스마다 요구 순서가 다를 수 있어 자원의 일련 번호 설정이 어려움 요구 순서가 일련번호 오름차순을 못 지키면 점유 자원 해제 필요하나 적용 불가한 자원 존재정리 하기 교착 상태는 여러 개의 프로세스가 서로 상대방의 작업이 끝나기만 기다리고 있기 때문에 결과적으로 어느 쪽도 영원히 진행하지 못하는 상태임 교착 상태의 네 가지 필요조건은 상호 배제, 점유 대기, 비선점, 환형 대기로, 이 조건들이 모두 만족 될 경우 교착 상태가 발생할 수 있음 자원 할당 그래프는 프로세스와 자원 사이에 요구와 할당 관계를 나타내는 그래프로, 사이클의 존재 유무를 통해 교착 상태의 발생 가능성을 확인할 수 있음 교착 상태를 처리하는 기법에는 교착 상태 예방, 교착 상태 회피, 교착 상태 탐지 및 복구가 있음 교착 상태 예방은 교착 상태의 네 가지 필요조건 중 어느 하나라도 발생할 수 없도록 막는 방법임" }, { "title": "[데이터베이스 시스템] 6강 - SQL", "url": "/posts/knou-dbs-6/", "categories": "Database", "tags": "knou, database", "date": "2025-04-12 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '데이터베이스 시스템' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 2차원 구조의 테이블에서 사용자가 다양한 유형의 검색 결과를 얻을 수 있도록 SQL은 SELECT문에 다양한 기능을 내포하고 있음 SELECT문은 산술, 논리 연산자 뿐만 아니라 관계형 데이터베이스에서만 사용 가능한 특수 연산자까지 사용자의 복잡한 요구를 표현할 수 있는 기능을 제공함 SELECT문은 함수 및 집계 함수를 사용한 질의를 통해 보다 복잡한 유형의 질의를 처리할 수 있는 형식을 지원함 SELECT문을 통해 향상된 질의 결과를 생성할 수 있는 산술, 논리, 비교 연산자와 특수 연산자 그리고 다양한 종류의 함수 및 집계 함수의 사용 방법에 대하여 알아봄주요 용어 조건 질의문 산술 연산식, 함수 등을 사용하여 표현한 조건을 WHERE 절에 기술하여 조건을 만족하는 레코드만 검색하는 SELECT문 ORDER BY 검색 결과를 특정 컬럼에 대해 오름차순 또는 내림차순으로 정렬 특수 연산자 범위 포함 여부, 부분 일치 여부, 포함 여부 등 관계형 데이터베이스에서만 사용되도록 고안된 연산자 함수 특정 목적을 수행하도록 사전에 정의된 연산 및 기능을 수행한 후 결과 값을 반환하는 명령어 집합 강의록데이터 정렬과 특수 연산자SELECT명령어 한 개 이상의 테이블에서 주어진 조건에 만족하는 레코드를 출력하는 명령문 관계 대수의 셀렉트, 프로젝트, 조인, 카티션 프로덕트 연산자의 기능을 모두 포함하는 명령문 필수 절인 SELECT절 장막 부가적인 목적으로 사용하는 절을 혼합하여 검색 기능을 구체화 SELECT의 구문형식SELECT [DISTINCT] 컬럼1, 컬럼2, ..., 컬럼n FROM 테이블1, [INNER JOIN | OUTER JOIN 테이블2, INNER JOIN | OUTER JOIN ON 조인 조건식1, 테이블3, INNER JOIN | OUTER JOIN 테이블m, ON 조인 조건식n] [WHERE 조건식 [중첩 질의]] [GROUP BY 컬럼1, 컬럼2, ..., 컬럼y [HAVING 조건]] [ORDER BY 컬럼1 [ASC | DESC], ..., 컬럼z [ASC | DESC]]데이터의 정렬 ORDER BY 절을 사용 `SELECT`문 형식 ORDER BY 컬럼1 [ASC | DESC], ..., 컬럼n [ASC | DESC] 검색 결과를 특정 컬럼에 대해 오름차순 또는 내림차순으로 정렬 오름차순: ASC 내림차순: DESC 모두 생략 시 오름차순 기준 데이터 정렬의 사용 학번의 계좌 잔액을 잔액 기준으로 각각 오름차순, 내림차순으로 정렬하시오. 학생번호 계좌번호 잔액 201831-331215 123434-222222 800000 201834-021216 123434-111111 600000 201926-880215 123434-555555 300000 201931-781109 123434-444444 400000 201934-080621 123434-777777 300000 201934-790902 123434-666666 100000 202034-596541 123434-888888 1200000 202031-816515 123434-999999 150000 202031-354516 123435-111111 1000000 202078-080621 123435-222222 500000 202026-590930 123435-333333 450000 SELECT * FROM 계좌 \tORDER BY 잔액 ASC 학생번호 계좌번호 잔액 201934-790902 123434-666666 100000 202031-816515 123434-999999 150000 201926-880215 123434-555555 300000 201934-080621 123434-777777 300000 201931-781109 123434-444444 400000 202026-590930 123435-333333 450000 202078-080621 123435-222222 500000 201834-021216 123434-111111 600000 201831-331215 123434-222222 800000 202031-354516 123435-111111 1000000 202034-596541 123434-888888 1200000 SELECT * FROM 계좌 \tORDER BY 잔액 DESC 학생번호 계좌번호 잔액 202034-596541 123434-888888 1200000 202031-354516 123435-111111 1000000 201831-331215 123434-222222 800000 201834-021216 123434-111111 600000 202078-080621 123435-222222 500000 202026-590930 123435-333333 450000 201931-781109 123434-444444 400000 201926-880215 123434-555555 300000 201934-080621 123434-777777 300000 202031-816515 123434-999999 150000 201934-790902 123434-666666 100000 수강 정보를 ‘학생번호’ 기분으로 1차 오름차순으로 정렬하고 ‘과목코드’를 기준으로 2차 내림차순으로 정렬하시오 과목코드 학생번호 신청시각 KO03 201831-331215 2019-02-11 13:31:45 COM34 201831-331215 2020-02-20 13:54:22 COM24 201831-331215 2019-08-22 12:23:31 COM12 201831-331215 2019-08-21 23:25:25 LAW21 201834-021216 2016-02-11 08:21:22 KO03 201834-021216 2016-11-12 02:16:51 HE25 201834-021216 2017-08-01 01:24:54 COM34 201834-021216 2018-08-12 02:07:18 HE31 201926-880215 2020-02-02 06:22:16 HE25 201926-880215 2020-02-02 06:21:33 SELECT * FROM 수강 \tORDER BY 학생번호 ASC, 과목코드 DESC 과목코드 학생번호 신청시각 COM11 201934-790902 2019-02-28 08:32:54 COM11 202026-590930 2019-02-20 16:00:21 COM11 202078-080621 2019-02-21 15:21:54 COM12 201831-331215 2019-08-21 23:25:25 COM12 201931-781109 2018-08-02 03:25:16 COM12 201978-610408 2015-02-24 10:25:40 COM12 202026-590930 2019-02-20 16:00:21 COM12 202031-816515 2019-02-07 02:44:33 COM12 202034-596541 2019-02-20 16:00:21 COM12 202078-080621 2019-02-21 15:21:54 특수 연산자 범위, 부분 일치 여부, 포함 여부 등 RDBMS에서 사용되도록 고안된 연산자 종류 사용 예 의미 BETWEEN 컬럼명 BETWEEN V₁ AND V₂ 컬럼값이 V₁ ~ V₂ 사이에 존재하는지 검사 LIKE 컬럼명 LIKE ‘V₁%’ V₁으로 시작하는 문자열 검사   컬럼명 LIKE ‘%V₁’ V₁으로 끝나는 문자열 검사   컬럼명 LIKE ‘%V₁%’ V₁이 문자열 내에 존재하는지 검사   컬럼명 LIKE ‘V₁_’ V₁뒤에 한 문자만 일치하는지 검사 IN 컬럼명 IN (V₁, … , Vₙ) 컬럼값이 V₁, V₂, …, Vₙ 중 하나와 일치하는지 검사 특수 연산자의 사용 잔액이 20만원 이상 40만원 이하인 계좌의 계좌번호, 잔액, 학생번호를 출력하시오. 계좌번호 잔액 학생번호 123434-222222 800000 201831-331215 123434-111111 600000 201834-021216 123434-555555 300000 201926-880215 123434-444444 400000 201931-781109 123434-777777 300000 201934-080621 123434-666666 100000 201934-790902 123434-888888 1200000 202034-596541 123434-999999 150000 202031-816515 123435-111111 1000000 202031-354516 123435-222222 500000 202078-080621 123435-333333 450000 202026-590930 123434-333333 400000 201978-610408 SELECT 계좌번호, 잔액, 학생번호 FROM 계좌 WHERE 잔액 BETWEEN 200000 AND 400000 계좌번호 잔액 학생번호 123434-555555 300000 201926-880215 123434-444444 400000 201931-781109 123434-777777 300000 201934-080621 123434-333333 400000 201978-610408 SELECT 계좌번호, 잔액, 학생번호 FROM 계좌 WHERE 잔액 &gt;= 200000 AND 잔액 &lt;= 400000 계좌번호 잔액 학생번호 123434-555555 300000 201926-880215 123434-444444 400000 201931-781109 123434-777777 300000 201934-080621 123434-333333 400000 201978-610408 과목 코드가 ‘COM’으로 시작하는 과목의 과목코드, 과목명, 이수구분을 출력하시오. 과목코드 과목명 학점 선수과목 이수구분 교수번호 COM11 컴퓨터의이해 3   교양 … COM12 파이썬 프로그래밍 기초 3   교양 … COM24 자료구조 3 COM12 전공필수 … COM31 데이터베이스 시스템 3 COM24 전공필수 … COM34 알고리즘 3 COM24 일반선택 … COM44 클라우드 컴퓨팅 3   전공필수 … ECE24 놀이지도 3   전공필수 … ECE31 유아언어교육 3 ECE31 전공필수 … HE14 패션과문화 3   일반선택 … HE25 인체생리학 3   전공필수 … HE31 임상영양학 3 HE25 전공필수 … SELECT 과목코드, 과목명, 이수구분 FROM 과목 WHERE 과목코드 = 'COM' 과목코드 과목명 이수구분       SELECT 과목코드, 과목명, 이수구분 FROM 과목 \tWHERE 과목코드 LIKE 'COM%' 과목코드 과목명 이수구분 COM11 컴퓨터의이해 교양 COM12 파이썬 프로그래밍 기초 교양 COM24 자료구조 전공필수 COM31 데이터베이스 시스템 전공필수 COM34 알고리즘 일반선택 COM44 클라우드 컴퓨팅 전공필수 소속학과가 ‘컴퓨터과학과’, ‘행정학과’, ‘법학과’인 교수의 교수이름, 직위, 소속학과를 출력하시오 교수번호 교수이름 직위 소속학과 연봉 186432-760829 최우성 조교수 생활학과 52000000 189414-790829 한용운 조교수 법학과 45000000 191924-730620 이동휘 부교수 행정학과 51000000 194634-810228 김규식 정교수 컴퓨터학과 70000000 194834-760517 정재화 부교수 컴퓨터학과 53000000 201216-158465 정용제 조교수 국어국문학과 55000000 201547-634895 현경석 정교수 생활학과 66000000 210315-549413 황지수 부교수 유아교육과 52000000 SELECT 교수 이름, 직위, 소속학과 FROM 교수 \tWHERE 소속학과 IN ('컴퓨터과학과', '행정학과', '법학과') 교수이름 직위 소속학과 한용운 조교수 법학과 이동휘 부교수 행정학과 김규식 정교수 컴퓨터학과 정재화 부교수 컴퓨터학과 집합 연산자 테이블은 집합, 레코드는 집합에 포함된 원소 집합 이론에서의 이진 연산 합집합: UNION, UNION ALL 교집합: INTERSECT 차집합: EXCEPT 집합 연산자 사용 조건 테이블 R과 S의 차수 및 각 컬럼의 도메인이 일치 교집합 및 차집합은 지원하지 않는 상용 DBMS가 있어 NOT IN등의 연산자를 사용하여 우회집합 연산자의 사용 과목 테이블에서 ‘컴퓨터의 이해’를 강의하는 교수와 ‘데이터베이스 시스템’을 강의하는 교수의 교수번호를 출력하시오. 과목코드 과목명 학점 선수과목 이수구분 교수번호 COM11 컴퓨터의이해 3   교양 … COM12 파이썬 프로그래밍 기초 3   교양 … COM24 자료구조 3 COM12 전공필수 … COM31 데이터베이스 시스템 3 COM24 전공필수 … COM34 알고리즘 3 COM24 일반선택 … COM44 클라우드 컴퓨팅 3   전공필수 … ECE24 놀이지도 3   전공필수 … SELECT 교수번호 FROM 과목 WHERE 과목명 = '컴퓨터의 이해' UNION SELECT 교수번호 FROM 과목 WHERE 과목명 = '데이터베이스 시스템' 교수번호 192634-810228 194834-760517 두 SELECT모두 교수 번호 추출 결합하려는 두 SELECT절의 순서와 도메인이 동일해야 함 함수의 사용함수의 개념 특정 목적을 수행하도록 사전에 정의된 연산 및 기능을 수행한 후 결과 값을 반환하는 명령어 집합 고도의 데이터 조작을 지원하고 SQL문 작성의 편의성을 유지 선언적 언어 특성 상 표현 불가능한 데이터 조작을 프로그래밍 언어적 특성을 맞춘 확장된 언어를 사용 PL/SQL, TransactSQL, SQL Procedural 등 DBMS는 검색 결과가 사용자에게 어떤 형태로 사용되도록 여러 데이터 타입에 대한 다양한 사전 정의 함수를 제공숫자 함수 삼각 함수, 상수, 올림과 버림, 난수 등의 숫자 데이터 타입에 적용할 수 있는 계산을 위한 함수 종류 사용 예 의미 ABS() ABS(X) X의 절대 값을 반환 SIN(), COS()등 SIN(X)등 X의 삼각함수 값을 반환 CEILING(), FLOOR() CEILING(X), FLOOR(X) X의 보다 크지(작지) 않은 최소(최대)의 정수 LN() LN(X) 자연 로그 lnX의 값을 반환 PI() PI() 원주율(π) 값을 반환 POWER() POWER(X, Y) 거듭 제곱 X^Y 값을 반환 RAND() RAND() 0과 1 사이의 임의의 값을 반환 ROUND() ROUND(X[, Y]) X의 Y번째 소수점 위치의 수를 반올림한 값을 반환 SQRT() SQRT(X) X의 제곱근의 값을 반환 TRUNCATE() TRUNCATE(X, Y) X의 Y번째 소수점 이하를 버림한 값을 반환 숫자 함수의 사용 졸업까지 8학기가 소요된다고 가정할 때, 각 학과의 학생이 평균적으로 이수해야 하는 학점을 계산하여 학과이름과 함께 출력하시오. 단, 평균 학점의 소수점 이하의 값은 버림하시오. 학과이름 단과대학 주소 전화번호 졸업학점 국어국문학과 인문과학대학 … 02-3668-4550 120 법학과 사회과학대학 … 02-3668-4590 130 생활과학과 자연과학대학 … 02-3668-4640 125 유아교육과 교육대학대학 … 02-3668-4670 125 컴퓨터과학과 자연과학대학 … 02-3668-4650 130 행정학과 사회과학대학 … 02-3668-4600 120 영어영문학과 인문과학대학 … 02-3668-4510 135 농학과 자연과학대학 … 02-3668-4600 140 SELECT 학과이름, 졸업학점 / 8, TRUNCATE(졸업학점/8, 0) FROM 학과 학과이름 졸업학점 / 8 TRUNCATE(졸업학점/8, 0) 국어국문학과 15.0 15 법학과 16.25 16 생활과학과 15.625 15 유아교육과 15.625 15 컴퓨터과학과 16.25 16 행정학과 15.0 15 영어영문학과 16.875 16 농학과 17.5 17 문자 함수 문자열 조작 및 문자 형식 변환 등의 문자와 관련된 다양한 연산을 지원하는 함수 종류 사용 예 의미 CHAR_LENGTH() CHAR_LENGTH(X) X의 글자수를 반환 (한글도 1글자로 계산) CONCAT() CONCAT(X, Y) X와 Y 문자열을 결합 LOWER() LOWER(X) X의 문자를 모두 소문자로 변환 UPPER() UPPER(X) X의 문자를 모두 대문자로 변환 SUBSTRING() SUBSTRING(X, A, B) X의 A번째 문자부터 B개의 문자열을 반환 TRIM()/LTRIM()/ RTRIM() TRIM(X)/LTRIM(X)/ RTRIM(X) 양쪽/왼쪽/오른쪽 공백 문자를 제거하고 반환 문자 함수의 사용 학생의 학생번호, 학생이름, 성별, 생년월일을 출력하시오. 단 학생번호는 앞 6자리만 출력하고 성별 뒤에는 ‘성’을 붙이시오. 학생번호 학생이름 성별 생년월일 나이 전화번호 201831-331215 김마리아 여 1991-06-18 29 010-0000-0002 201834-021216 유관순 여 1902-12-16 118 010-0000-0001 201926-880215 지청천 여 1988-02-15 32 010-0000-0005 201931-781109 안창호 남 1978-11-09 42 010-0000-0004 201934-080621 박은식 여 1959-09-30 61 010-0000-0007 201934-790902 안중근 남 1979-09-02 41 010-0000-0006 SELECT SUBSTRING(학생번호, 1, 6), 학생이름, CONCAT(성별, '성') \tFROM 학생 SUBSTRING(학생번호, 1, 6) 학생이름 CONCAT(성별, ‘성’) 201831 김마리아 여성 201834 유관순 여성 201926 지청천 여성 201931 안창호 남성 201934 박은식 여성 201934 안중근 남성 날짜 함수 날짜 및 시간 데이터 타입에 적용되어 산술 연산 및 시간 형 변환 등의 조작을 위한 함수 종류 사용 예 의미 ADDDATE() ADDDATE(X, INTERVAL Y 단위) X에 Y 단위의 시간을 더한 날짜를 반환 ADDTIME() ADDTIME(X, Y) X에 Y 시각을 더한 날짜를 반환 CURDATE(), CURRENT_DATE() CURDATE(), CURRENT_DATE() 현재 날짜를 반환 CURTIME(), CURRENT_TIME() CURTIME(), CURRENT_TIME() 현재 시간을 반환 DATE() DATE(X) X에서 날짜(년, 월, 일)을 반환 YEAR() YEAR(X) X에서 년 값을 반환 날짜 함수의 사용 수강신청 시작일 ‘2020년 2월 8일 00시 00분 00초’를 기준으로 15일 이내에 수강 신청된 수강 데이터의 학생번호, 과목코드, 신청시각을 출력하시오. 과목코드 학생번호 신청시각 COM11 201934-790902 2019-02-28 08:32:54 COM11 202026-590930 2019-02-20 16:00:21 COM11 202078-080621 2019-02-21 15:21:54 COM12 201831-331215 2019-08-21 23:25:25 COM12 201931-781109 2018-08-02 03:25:16 COM12 201978-610408 2015-02-24 10:25:40 COM12 202026-590930 2019-02-20 16:00:21 COM12 202031-816515 2019-02-07 02:44:33 SELECT 학생번호, 과목코드, 신청시각 FROM 수강 WHERE TIMESTAMPDIFF(DAY, 신청시각, '2020-2-8-00:00:00') &lt; 15 학생번호 과목코드 신청시각 202026-590930 COM24 2020-02-17 22:15:34 202034-596541 COM24 2020-02-17 22:15:30 201831-331215 COM34 2020-02-20 13:54:22 202026-590930 COM34 2020-02-22 11:45:55 202034-596541 COM34 2020-02-22 11:45:55 201926-880215 COM44 2020-02-02 06:21:55 202026-590930 HE14 2020-02-21 22:51:43 201934-790902 HE25 2020-02-11 21:35:44 그룹 질의문집계 함수 특정 칼럼에 집계 함수를 통해 다양한 통계 연산을 수행할 수 있는 기능 SELECT절 또는 HAVING절에 기술 집계 함수의 종류 COUNT 칼럼에 있는 값들의 개수 SUM 칼럼에 있는 값들의 합 AVG 칼럼에 있는 값들의 평균 MAX 칼럼에서 가장 큰 값 MIN 칼럼에서 가장 작은 값 집계 함수의 사용 단과대학의 총 수를 출력하시오 학과이름 단과대학 주소 전화번호 졸업학점 국어국문학과 인문과학대학 … 02-3668-4550 120 법학과 사회과학대학 … 02-3668-4590 130 생활과학과 자연과학대학 … 02-3668-4640 125 유아교육과 교육과학대학 … 02-3668-4670 125 컴퓨터과학과 자연과학대학 … 02-3668-4650 130 행정학과 사회과학대학 … 02-3668-4600 120 영어영문학과 인문과학대학 … 02-3668-4510 135 자연과학대학 자연과학대학 … 02-3668-4600 140 SELECT COUNT(단과대학) FROM 학과 COUNT(단과대학) 8 SELECT COUNT(DISTINCT 단과대학) FROM 학과 COUNT(DISTINCT 단과대학) 4 SELECT COUNT(DISTINCT 단과대학) AS 단과대학수 FROM 학과 단과대학수 4 그룹 질의 특정 기준으로 레코드를 그룹화하고 각 레코드 그룹에 대해 집계 함수를 적용하는 질의 `SELECT`문 형식 GROUP BY 컬럼 SELECT절에 그룹의 기준과 집계 함수 이외의 컬럼은 포함 불가능 그룹 질의의 사용 소속학과별 교수의 수를 출력하시오 교수번호 교수이름 직위 소속학과 연봉 186432-760829 최우성 조교수 생활과학과 52000000 201547-634895 현경석 정교수 생활과학과 66000000 189414-790829 한용윤 조교수 법학과 45000000 191924-730620 이동휘 부교수 행정학과 51000000 194634-810228 김규식 정교수 컴퓨터과학과 70000000 194834-760517 정재화 부교수 컴퓨터과학과 53000000 201216-158465 정용제 조교수 국어국문학과 55000000 210315-549413 황지수 부교수 유아교육과 52000000 SELECT 소속학과, COUNT(*) AS 교수수 FROM 교수 GROUP BY 소속학과 소속학과 교수수 생활과학과 2 법학과 1 행정학과 1 컴퓨터과학과 2 국어국문학과 1 유아교육과 1 SELECT 소속학과, COUNT(*) AS 교수수, 교수이름 -- 칼럼의 원자성 위배하기 때문에 사용 불가능 FROM 교수 GROUP BY 소속학과 소속학과 교수수 교수이름 생활과학과 2 최우성, 현경석 법학과 1 한용윤 행정학과 1 이동휘 컴퓨터과학과 2 김규식, 정재화 국어국문학과 1 정용제 유아교육과 1 황지수 조건 그룹 질의 그룹 질의의 결과 레코드에 대해 출력 조건을 기술하는 질의 `SELECT`문 형식 GROUP BY 칼럼 HAVING 조건 조건에 대한 기술 WHERE 레코드에 대한 조건을 기술 HAVING 집계 결과 레코드에 대한 조건을 기술 조건 그룹 질의의 사용 2개 이상의 전공을 신청한 학생의 학생 번호와 신청 전공수를 출력하시오 학생번호 학과이름 이수학점 201831-331215 국어국문학과 9 201831-331215 컴퓨터과학과 39 201834-021216 국어국문학과 81 201926-880215 생활과학과 48 201931-781109 유아교육과 93 201934-790902 유아교육과 87 201978-610408 법학과 87 SELECT 학생번호, COUNT(*) AS 신청_전공수 \tFROM 강좌 \tGROUP BY 학생번호 학생번호 신청_전공수 201831-331215 2 201834-021216 1 201926-880215 1 201931-781109 1 201934-790902 1 201978-610408 2 SELECT 학생번호, COUNT(*) AS 신청_전공수 \tFROM 강좌 \tGROUP BY 학생번호 \t\tHAVING 신청_전공수 &gt;= 2 학생번호 신청_전공수 201831-331215 2 201978-610408 2 202026-590930 2 어떤 기준으로 GROUP BY수행할 지 학생 번호 COUNT의 조건은 어떻게 명시할지 WHERE절 아닌 HAVING절 연습 문제 다음의 고객 테이블에서 아래의 SQL의 실행 결과로 올바른 것은? 고객 테이블 고객번호(PK) 고객이름 직장주소 연락처 C540 홍길동 서울시 종로구 1234 C101 김영희 서울시 종로구 5678 C211 신채호 광주시 광산구 1111 C343 이희영 부산시 북구 2222 C425 박상진 경기도 광주시 3333 C551 나철 대구시 달서구 5555 SELECT 고객이름, 직장주소 FROM 고객 WHERE 직장주소 LIKE '%광주%' a. 고객이름 직장주소 신채호 광주시 광산구 박상진 경기도 광주시 LIKE연산자는 관계형 DBMS을 위해 만들어진 특수 연산자로, 부분 일치하는 컬럼을 검색하는데 사용 됨 %광주%는 문자열 내부에 ‘광주’가 존재하는지 검사하는 표현이므로 ‘광주’가 어느 위치에 있어도 결과에 포함 됨 다음의 고객 테이블에서 아래의 SQL의 실행 결과로 올바른 것은? 고객 테이블 고객번호(PK) 고객이름 직장주소 연락처 C540 홍길동 서울시 종로구 1234 C101 김영희 서울시 종로구 5678 C211 신채호 광주시 광산구 1111 C343 이희영 부산시 북구 2222 C425 박상진 경기도 광주시 3333 C551 나철 대구시 달서구 5555 SELECT 고객이름, 연락처 FROM 고객 WHERE CHAR_LENGTH(고객이름) = 2 a. 고객이름 직장주소 나철 5555 CHAR_LENGTH()함수는 컬럼 값의 글자수를 반환하는 함수 WHERE 절에서 CHAR_LENGTH(고객이름) = 2는 고객이름이 두 글자인 컬럼을 찾는 조건을 표현하므로 결과에 이름이 외자인 고객만 출력 됨 다음의 고객 테이블에서 아래의 SQL의 실행 결과로 올바른 것은? 고객 테이블 고객번호(PK) 고객이름 직장주소 연락처 C540 홍길동 서울시 종로구 1234 C101 김영희 서울시 종로구 5678 C211 신채호 광주시 광산구 1111 C343 이희영 부산시 북구 2222 C425 박상진 경기도 광주시 3333 C551 나철 대구시 달서구 5555 SELECT 직장주소, COUNT(*), 연락처 FROM 고객 GROUP BY 직장주소 a. 오류 발생 GROUP BY절은 특정 기준 컬럼을 대상으로 레코드를 그룹화하고 집계 함수를 적용하는 질의 기법임 이때 SELECT절에는 SELECT절에 그룹의 기준과 집계 함수 이외의 컬럼은 포함 불가능함 주어진 SQL에서는 그룹의 기준과 집계 함수에 포함되지 않는 ‘연락처’ 컬럼이 나열되어 있으므로 실행 시 오류가 발생함 정리 하기 ORDER BY절은 검색 결과를 특정 컬럼에 대해 오름차순 또는 내림차순으로 정렬함 오름차순은 ASC, 내림차순은 DESC키워드를 컬럼과 기술하여 정렬의 순서를 결정함 BETWEEN, IN, LIKE는 관계형 데이터베이스에서만 사용되도록 고안된 연산자로 범위, 부분 일치, 포함 여부 조건을 기술하기 위해 사용 됨 특정 목적을 수행하도록 사전에 정의된 연산 및 기능을 수행한 후 결과 값을 반환하는 명령어 집합인 함수를 이용하여 보다 정교하게 데이터 검색 결과를 만들 수 있음 그룹 질의는 특정 기준으로 레코드를 그룹 화하고 각 레코드 그룹에 대해 집계 함수를 적용하는 질의임 집계 함수로는 COUNT, SUM, AVG, MIN, MAX가 있음 그룹 질의 후 처리 결과에 대한 조건을 제시하기 위해 HAVING절을 사용함 체크 포인트 다음 BETWEEN연산의 의미와 동일한 것은? SELECT * FROM 성적 WHERE (점수 BETWEEN 90 AND 95) AND 학과 = '컴퓨터과학과' a. 점수 &gt;= 90 AND 점수 &lt;= 95 다음과 같은 student 테이블의 스키마가 주어졌을 때, 주어진 요구에 대한 SQL 질의어로 옳은 것은? student(studno, name, grade, score, deptno) (단, studno는 학번, name은 학생 이름, grade는 학년, score는 성적, deptno는 학생이 속한 학과 번호를 의미하며, studno는 기본키이다) student 테이블에서 학과 번호가 100번 이상인 학과들의 평균 성적 검색 a. SELECT deptno, AVG(score) FROM student WHERE deptno &gt;= 100 GROUP BY deptno " }, { "title": "[파이썬 프로그래밍 기초] 6강 - 선택 구조", "url": "/posts/knou-python-6/", "categories": "Language, Python", "tags": "knou, python", "date": "2025-04-11 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '파이썬 프로그래밍 기초' 강의를 개인 공부 목적으로 메모하였습니다. 학습 목표 선택 구조를 설명할 수 있음 비교 연산자와 논리 연산자를 사용하여 불리언 식을 작성할 수 있음주요 용어 선택 구조 특정 영역 내의 명령문에 대한 실행 여부를 판단에 따라 결정하는 구조 불리언 타입 논리 값인 참(True)과 거짓(False)의 값만 표현할 수 있는 데이터 타입 불리언 식 비교 연산자를 사용하여 결과가 불리언 타입으로 생성되는 표현 식 논리 연산자 두 개의 논리 값(불리언 식)을 연산하여 참 또는 거짓을 결과로 얻는 연산자 강의록선택 구조선택 구조의 개념 특정 영역 내의 명령문에 대한 실행 여부를 판단에 따라 결정하는 구조 실행 여부는 조건에 따라 결정 선택 구조의 구문 형식 구문 형식 들여 쓰기는 코드 블록을 표현 특정 동작을 수행하는 한 라인 이상의 명령문의 집합 스페이스 4칸 권고(PEP-8) 선택 구조의 실행 흐름불리언 식 비교 연산자를 사용하여 결과가 불리언 타입으로 생성되는 표현 식 연산자 수학적 표현 의미 &lt; &lt; 작음 &lt;= ≤ 작거나 같음 &gt; &gt; 큼 &gt;= ≥ 크거나 같음 == = 같음 != ≠ 같지 않음 불리언 타입 논리 값인 참(True)과 거짓(False)의 값만 표현할 수 있는 데이터 타입 True 또는 False 예약어를 사용하여 표현 비교 연산자를 사용한 표현 식의 결과로 생성 3 &gt; 6 light_on = 3 &gt; 6 suf == vol isStop = suf == vol 원뿔 계산 프로그램 개선 사용자가 반지름 값에 음수를 입력하면? # 반지름 사용자 입력 rad = int(input(\"반지름을 입력하세요: \")) # 높이 사용자 입력 hei = int(input(\"높이를 입력하세요: \")) # 부피 &amp; 겉넓이 계산 vol = 1/3 * 3.14 * rad ** 2 * hei suf = 3.14 * rad ** 2 + 3.14 * rad * hei print(\"원뿔의 부피는\", vol, \"입니다.\") print(\"원뿔의 겉넓이는\", suf, \"입니다.\") 논리 연산자논리 연산자의 개념 두 개의 논리 값(불리언 식)을 연산하여 참 또는 거짓을 결과로 얻는 연산자 참, 거짓을 구별할 수 있는 명제를 대상으로 명제의 집합을 위해 고안한 연산자 두 개의 피연산자를 갖는 이항 연산자 and(논리곱), or(논리합), not(논리부정) 연산자 사용 왼쪽에서 오른쪽의 방향으로 결합 and 두 논리 값이 모두 True 일 때 True이고 어느 하나 False일 경우 False를 반환 진리표 b1 b2 b1 and b2 False False False False True False True False False True True True temp &gt;= 27 and fruit == \"apple\" rad &gt; 0 and hei &gt; 0 or 두 논리 값이 모두 False 일 때 False이고 어느 하나 True일 경우 True를 반환 진리표 b1 b2 b1 or b2 False False False False True True True False True True True True temp &gt;= 27 or fruit == \"apple\" rad &gt; 0 or hei &gt; 0 not 단항 연산자로 논리 값을 반전하여 False는 True로, True는 False로 반환 진리표 b1 Not b1 False True True False not temp &gt;= 21 단락 평가 short-circuit evaluation 첫 번째 논리 값 만으로 전체 연산 결과가 판별 가능할 때 두 번째 논리 값은 확인(평가)하지 않는 기법 temp &gt;= 27 and season == \"summer\" temp &gt;= 27 or season == \"summer\" 원뿔 계산 프로그램 개선 사용자가 높이에 음수를 입력하면? # 반지름 사용자 입력 rad = int(input(\"반지름을 입력하세요: \")) # 높이 사용자 입력 hei = int(input(\"높이를 입력하세요: \")) if (rad &gt; 0): # 부피 &amp; 겉넓이 계산 vol = 1/3 * 3.14 * rad ** 2 * hei suf = 3.14 * rad ** 2 + 3.14 * rad * hei print(\"원뿔의 부피는\", vol, \"입니다.\") print(\"원뿔의 겉넓이는\", suf, \"입니다.\") 선택 구조의 확장원뿔 계산 프로그램 문제 사용자가 반지름과 높이 값에 양수를 입력할 경우 부피 겉넓이 출력 # 반지름 사용자 입력 rad = int(input(\"반지름을 입력하세요: \")) # 높이 사용자 입력 hei = int(input(\"높이를 입력하세요: \")) if (rad &gt; 0 and hei &gt; 0): # 부피 &amp; 겉넓이 계산 vol = 1/3 * 3.14 * rad ** 2 * hei suf = 3.14 * rad ** 2 + 3.14 * rad * hei print(\"원뿔의 부피는\", vol, \"입니다.\") print(\"원뿔의 겉넓이는\", suf, \"입니다.\") 이분 선택 구조의 구문 형식# 반지름 사용자 입력rad = int(input(\"반지름을 입력하세요: \"))# 높이 사용자 입력hei = int(input(\"높이를 입력하세요: \"))if (rad &gt; 0 and hei &gt; 0): # 부피 &amp; 겉넓이 계산 vol = 1/3 * 3.14 * rad ** 2 * hei suf = 3.14 * rad ** 2 + 3.14 * rad * hei print(\"원뿔의 부피는\", vol, \"입니다.\") print(\"원뿔의 겉넓이는\", suf, \"입니다.\")else: print(\"반지름과 높이에 양수를 입력해주세요\")다분 선택 구조의 구문 형식 구문 형식 다분 선택 구조의 실행 흐름가장 큰 수를 찾는 프로그램 세 수 A, B, C를 입력 받고 그 중 가장 큰 수를 출력하는 프로그램 내장 함수 사용 # A, B, C 사용자 입력 A = int(input(\"A 입력: \")) B = int(input(\"B 입력: \")) C = int(input(\"C 입력: \")) # A, B, C 중 가장 큰 수 출력 max(A, B, C) 직접 함수 만들어 사용 # A, B, C 사용자 입력 A = int(input(\"A 입력: \")) B = int(input(\"B 입력: \")) C = int(input(\"C 입력: \")) # A, B, C 중 가장 큰 수 출력 if A &gt; B: # 바깥쪽 if문 진입 -&gt; True if A &gt; C: # 안쪽 if문 블록 진입 -&gt; 조건 판별 print(A) else: print(C) else: # # 바깥쪽 if문 진입 -&gt; Flase if B &gt; C: # 여기서 판별 print(B) else: print(C) 중첩 선택 구조의 구문 형식 구문 형식 중첩 선택 구조의 실행 흐름연습 문제 파이썬에서 명령어의 논리적 집합인 명령 블록을 표현하기 위한 방법은? a. 들여 쓰기 다음은 온도(temp)가 0 이하일 경우 “겨울입니다.”를 출력하는 프로그램의 일부이다. 밑줄 친 빈 칸에 들어갈 명령문은? temp = int(input(\"온도를 입력하세요: \")) # _____________ print(\"겨울입니다.\") a. if temp &lt;= 0: 다음은 사용자가 입력한 수가 3과 5의 공배수일 경우 “3과 5의 공배수입니다”를, 아닐 경우 “3과 5의 공배수가 아닙니다.”를 출력하는 프로그램일 일부이다. 밑줄 친 빈칸에 들어갈 연산자는? guess = int(input(\"숫자를 입력하세요: \")) if guess % 3 == 0 ______ guess% 5 == 0: # 빈칸 print(\"3과 5의 공배수입니다.\") else print(\"3과 5의 공배수가 아닙니다.\") a. and 학습 정리 선택 구조란 특정 영역 내의 명령문에 대한 실행 여부를 조건에 따라 판단하여 결정하는 구조임 선택 구조의 실행 여부를 표현하는 조건은 참(True)과 거짓(False)으로 결정되는 불리언 식을 사용하며, 불리언 식은 비교 연산자를 사용하여 결과가 불리언 타입으로 생성되는 표현 식임 불리언 타입은 논리 값인 참(True)과 거짓(False)의 값만 표현할 수 있는 데이터 타입임 논리 연산자는 두 개의 논리 값(불리언 식)을 연산하여 참 또는 거짓을 결과로 얻는 연산자임 단락 평가란 첫 번째 논리 값 만으로 전체 연산 결과가 판별 가능할 때 두 번째 논리 값은 확인(평가)하지 않는 기법임 if, elif, else 명령어를 사용하여 이분 또는 다분 선택 구조로 확장할 수 있음 중첩 선택 구조는 한 선택 구조 내부에 또 다른 선택 구조를 내포하는 구조임" }, { "title": "[Java 프로그래밍] 6강 - 제네릭과 람다식", "url": "/posts/knou-java-6/", "categories": "Language, Java", "tags": "knou, java", "date": "2025-04-10 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김희천 교수님의 'Java 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 제네릭은 프로그램의 재사용성을 높여주고 소스 코드 컴파일 할 때 자료형 검사를 엄격하게 수행해 실행 오류를 최소화하기 위한 기법임 람다식은 매개 변수를 갖는 코드 블록으로 익명 클래스의 객체를 생성하는 부분을 수식화한 것임 제네릭과 람다식을 활용하는 방법을 익힘학습 목표 제네릭 클래스를 정의할 수 있음 제네릭 메소드의 정의와 사용법을 설명할 수 있음 정의된 제네릭 타입이나 메소드를 사용할 수 있음 람다 식의 활용 방법을 설명할 수 있음 표준 함수형 인터페이스를 활용할 수 있음강의록제네릭 타입제네릭의 의미 제네릭 클래스, 제네릭 인터페이스, 제네릭 메소드 클래스, 인터페이스, 메소드를 정의할 때 타입 매개 변수(타입 파라미터)를 선언하고 사용할 수 있음 자바 프로그램의 재사용성을 높이고 오류를 줄이는 방법 제네릭의 장점 여러 유형에 걸쳐 동작하는 일반화된 클래스나 메소드를 정의할 수 있음 자료형을 한정함으로써 컴파일 시점에 자료형 검사가 가능 실행 오류를 찾아 고치는 것은 어렵기 때문 cast(형변환) 연산자의 사용이 불필요 제네릭의 사용 ArrayList클래스는 List인터페이스를 구현한 클래스 class ArrayList&lt;E&gt; implements List&lt;E&gt; { public boolean add(E e) { } public E get(int index) { } public E remove(int index) { } } List인터페이스 순서가 있는 원소들의 집단을 관리하기 위한 컬렉션 인터페이스 public class Main { public static void main(String args[]) { List list1 = new ArrayList(); // Object 유형 list1.add(\"hello\"); // hello 문자열이 object 유형으로 형변환 되어 추가 String s1 = (String) list1.get(0); // object 유형으로 반환 되어 강제 형변환(다운캐스팅) 필요 List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); // 타입 명시 list2.add(\"hello\"); String s2 = list2.get(0); //형변환이 필요 없음 } } 제네릭 클래스 클래스 정의에서 타입 파라미터를 선언 클래스를 사용할 때는 타입을 명시해야 함 타입 파라미터는 참조형만 가능함 필드의 자료형, 메소드 반환형, 인자의 자료형으로 사용할 수 있음 컴파일 할 때, 명확한 타입 검사 수행할 수 있음 메소드 호출 시 인자의 유형이 맞는지 메소드 호출의 결과를 사용할 때 유형이 맞는지 자료형 매개 변수로 가지는 클래스와 인터페이스를 제네릭 타입이라함제네릭 클래스의 정의 문법 접근제어자 class 클래스이름&lt;T1, T2, ... &gt; { } 클래스 정의에서 클래스 이름의 오른편, 각 괄호 &lt;&gt; 안에 타입 파라미터를 표시함 콤마(,)로 구분하여 여러 개의 타입 파라미터를 지정할 수 있음 타입 파라미터는 타입을 전달 받기 위한 것 타입 파라미터의 이름은 관례적으로 E(element), K(key), V(value), N(number), T(이외) 등을 사용 제네릭 클래스의 예 일반 클래스 class Data { private Object object; // java의 클래스 계층 구조에서 가장 상위 구조 public void set(Object object) { this.object = object; // 데이터 필드 세팅 } public Object get() { return object; } } 제네릭 클래스 // Data 클래스의 제너릭 버전 class Data&lt;T&gt; { // 타입 파라미터 호출 private T t; // 데이터 필드의 자료형으로 타입 파라미터 사용 public void set(T t) { this.t = t; // 인자의 자료형으로 타입 파라미터 사용 } public T get() { return t; // 메소드 반환형으로 타입 파라미터 사용 } } 제네릭 클래스의 필요성 제네릭 타입과 자료형 검사 제네릭 타입을 사용하지 않으면 컴파일 시점에서 오류를 검출하지 못함 의미가 명확하면 생성자 호출 시, 괄호만 사용할 수 있음 Data&lt;String&gt; d = new Data&lt;&gt;(); public class Main { public static void main(String args[]) { Data data = new Data(); Integer i = Integer.valueOf(20); data.set(i); // 컴파일 오류 없음 String s = (String) data.get(); // 실행 오류 } } public class Main { public static void main(String args[]) { Data&lt;String&gt; data = new Data&lt;&gt;(); Integer i = Integer.valueOf(20); // data.set(i); // 컴파일 오류 String s = data.get(); } } 제네릭 인터페이스를 구현하는 제네릭 클래스 2개의 타입 매개 변수(K,V)를 가지는 제네릭 인터페이스 interface Pair&lt;K, V&gt; { // 타입 매개 변수 2개 존재 public K getKey(); public V getValue(); } class OrderedPair &lt;K, V&gt; implements Pair &lt;K, V&gt; { // 제네릭 클래스 정의 private K key; private V value; public OrderedPair(K key, V value) { this.key = key; this.value = value; } public K getKey() { return key; } public V getValue() { return value; } } public class Main { public static void main(String args[]) { Pair&lt;String, Integer&gt; p1; p1 = new OrderedPair&lt;&gt; (\"Even\", 8); // new OrderedPair &lt;String, Integer&gt; Pair&lt;String, String&gt; p2; p2 = new OrderedPair&lt;&gt; (\"hello\", \"java\"); } } 제네릭 타입을 상속/구현하는 일반 클래스 제네릭 인터페이스를 구현하는 일반 클래스 클래스를 정의할 때 제네릭 인터페이스의 &lt;&gt;안에 실제 자료형을 지정 class MyPair implements Pair&lt;String, Integer&gt; { private String key; private Integer value; public MyPair(String key, Integer value) { this.key = key; this.value = value; } public String getKey() { return key; } public Integer getValue() { return value; } } public class Main { public static void main(String args[]) { MyPair mp = new MyPair(\"test\", 1); } } RAW 타입 타입 매개 변수 없이 사용되는 제네릭 타입 제네릭 타입이지만 일반 타입처럼 사용하는 경우 타입 매개 변수를 Object로 처리함 ex) Data data = new Data(\"hello\"); 이때 Data는 제네릭 타입 Data의 raw 타입 class Data&lt;T&gt; { private T t; public Data(T t) { this.t = t; } public void set(T t) { this.t = t; } public T get() { return t; } } 제네릭 메소드와 타입 제한제네릭 메소드 자료형을 매개 변수로 가지는 메소드 하나의 메소드 정의로 여러 유형의 데이터를 처리할 때 유용함 메소드 정의에서 반환형 왼편에 각 괄호 &lt;&gt; 안에 타입 매개 변수를 표시 타입 매개 변수를 메소드의 반환형이나 메소드 매개 변수의 자료형, 지역 변수의 자료형으로 사용할 수 있음 public static &lt;T&gt; T getLast(T[] a) { return a[a.length-1]; // 배열의 마지막 원소 리턴 } public &lt;T&gt; void swap(T[] array, int i, int j) { T temp = array[i]; array[i] = array[j]; // 배열에서 두 개의 객체를 교환 array[j] = temp; } 인스턴스 메소드와 static메소드 모두 제네릭 메소드로 정의 가능 제네릭 메소드를 호출할 때, 타입을 명시하지 않아도 됨 전달되는 인자에 의해 타입의 추론이 가능함 class Util { public static &lt;K, V&gt; boolean compare(Pair&lt;K, V&gt; p1, Pair&lt;K, V&gt; p2) { return p1.getKey().equals(p2.getKey()) &amp;&amp; p1.getValue().equals(p2.getValue()); } } public class Main { public static void main(String args[]) { Pair&lt;Integer, String&gt; p1 = new OrderedPair&lt;&gt;(1, \"apple\"); Pair&lt;Integer, String&gt; p2 = new OrderedPair&lt;&gt;(2, \"pear\"); boolean same = Util.&lt;Integer, String&gt;compare(p1, p2); // &lt;Integer, String&gt; 생략 가능 System.out.println(same); } } 제네릭의 타입 제한 제네릭 클래스/제네릭 인터페이스/제네릭 메소드를 정의할 때 적용 가능한 자료형에 제한을 두는 것 &lt;T extends Number&gt;와 같이 하면 T를 상한으로 정할 수 있음 T에 주어지는 자료형은 Number의 서브 클래스여야 함 class Data&lt;T extends Number&gt; { private T t; public Data() { } public Data(T t) { this.t = t; } public void set(T t) { this.t = t; } public T get() { return t; } } public class Main { public static void main(String args[]) { Data&lt;Integer&gt; data = new Data&lt;&gt;(20); // Integer는 Number의 자식 유형 System.out.println(data.get()); Data&lt;String&gt; data2 = new Data&lt;&gt;(\"Hello\"); //오류 } } 제네릭 타입과 형변환 상속 관계가 있어야 상위/하위 자료형의 관계가 존재함 Integer나 Double은 Number의 자식 클래스 그러나 Data&lt;Number&gt;와 Data&lt;Integer&gt;사이는 상속 관계가 없음 class Data&lt;T&gt; { } class FormattedData&lt;T&gt; extends Data&lt;T&gt; { // 상속 관계 } public class Main { public static void main(String args[]) { Data&lt;Number&gt; data1 = new Data&lt;Number&gt;(); data1.set(Integer.valueOf(10)); // OK data1.set(Double.valueOf(10.1)); // OK // Data&lt;Number&gt; data2 = new Data&lt;Integer&gt;(); // 컴파일 오류(Data&lt;Integer&gt; -&gt; Data&lt;Number&gt; 형변환 불가) Data&lt;Integer&gt; data3 = new FormattedData&lt;Integer&gt;(); // OK } } 제네릭 타입 사용 시 유의 사항 기본 자료형은 타입 매개 변수로 지정 불가 Data&lt;int&gt; d = new Data&lt;&gt;(); //오류 타입 매개 변수로 객체 생성 불가 class Data &lt;T&gt; { private t1 = new T(); //오류 } 타입 매개 변수의 타입으로 static 데이터 필드 선언 불가 class Data &lt;T&gt; { private static T t2; //오류 } 제네릭 타입의 배열 선언 불가 Data&lt;Integer&gt;[] arrayOfData; //오류 람다식람다식 인터페이스를 구현하는 익명 클래스의 객체 생성 부분을 수식화 한 것 구현할 것이 1개의 추상 메소드뿐인 경우 간단히 표현할 수 있음 Runnable runnable = new Runnable() { // Runnable 인터페이스를 구현하는 익명 클래스 정의 후 객체 생성을 수식화 public void run() { } }; 람다식 구문 메소드 매개 변수의 괄호, 화살표, 메소드 몸체로 표현 인터페이스 객체변수 = (매개 변수목록) → { 실행문 목록 } Runnable runnable = () -&gt; {}; 람다식 기본 문법 익명 구현 클래스의 객체 생성 부분만 람다식으로 표현함 익명 서브 클래스의 객체 생성은 람다식이 될 수 없음 이 때 인터페이스에는 추상 메소드가 1개만 존재해야 함 2개 이상의 추상 메소드를 포함하는 인터페이스는 사용 불가 람다 식의 결과 타입을 타깃 타입이라고 함 1개의 추상 메소드를 포함하는 인터페이스를 함수적 인터페이스라 함 메소드가 1개 뿐이므로 메소드 이름 생략할 수 있음 람다식은 이름 없는 메소드 선언과 유사함 람다식 기본 문법 인터페이스 객체 변수 = (매개 변수 목록) → { 실행문 목록 }; 매개 변수 목록에서 자료형은 인터페이스(타킷 타입) 정의에서 알 수 있으므로 자료형을 생략하고 변수 이름만 사용 가능 (int i ) -&gt; (i) -&gt; 매개 변수가 1개면 괄호도 생략 가능하며 이때 변수 이름 하나만 남음 (i) -&gt; i -&gt; 매개 변수를 가지지 않으면 괄호만 남음 화살표 사용 실행문 목록에서 실행문이 1개이면 중괄호 생략 가능 i -&gt; { 실행문1 } i -&gt; 실행문1 Runnable runnable = () -&gt; System.out.println(\"my thread\"); 단, 실행문이 return문 뿐이라면 return과 (수식 다음의) 세미콜론, 중괄호를 동시에 생략 해야 하고 1개의 수식만 적어야 함 i -&gt; { return 1; } i -&gt; 1 f1 = (a, b) -&gt; { return a + b; }; f2 = (a, b) -&gt; a + b; 람다식의 사용 예 람다식 사용 예제 1 interface Addable { // 인터페이스 int add(int a, int b); // 추상 메소드 } public class Main { public static void main(String[] args) { // 익명 구현 클래스의 객체 생성 Addable ad1 = new Addable() { public int add(int a, int b) { // 추상 메소드 구현 return (a + b); } }; System.out.println(ad1.add(100, 200)); // 매개 변수 목록과 return문을 가진 람다식 Addable ad2 = (int a, int b) -&gt; { // add 메소드 정의 return (a + b); }; System.out.println(ad2.add(10, 20)); //간단한 람다식 Addable ad3 = (a, b) -&gt; (a + b); System.out.println(ad3.add(1, 2)); } } // 출력 결과 // 300 // 30 // 3 람다식 사용 예제 2 interface MyInterface1 { public void method(int a, int b); } interface MyInterface2 { public void method(int a); } public class Main { public static void main(String args[]) { MyInterface1 f1, f2, f3; MyInterface2 f4, f5; f1 = (int a, int b) -&gt; { System.out.println(a + b); // MyInterface1 인터페이스의 추상 메소드 method 정의 }; f1.method(3, 4); f2 = (a, b) -&gt; { System.out.println(a + b); }; f2.method(5, 6); f3 = (a, b) -&gt; System.out.println(a + b); f3.method(7, 8); f4 = (int a) -&gt; { System.out.println(a); }; f4.method(9); f5 = a -&gt; System.out.println(a); f5.method(10); } } // 7 // 11 // 15 // 9 // 10 람다식의 활용 함수형 인터페이스(function interface) 1개의 추상 메소드만 가지는 단순한 인터페이스를 함수형 인터페이스라 함 패키지 java.util.function에서 표준 함수형 인터페이스가 제네릭 인터페이스로 제공 됨 함수형 인터페이스를 구현하는 클래스를 정의할 때, 익명 클래스 정의를 활용할 수 있으나 람다식이 효율적 ex) 표준 함수형 인터페이스의 예 Consumer&lt;T&gt;는 void accept(T t)를 가짐 Supplier&lt;T&gt;는 T get()메소드를 가짐 Function&lt;T, R&gt;은 R apply(T t)를 가짐 함수형 인터페이스와 람다식 함수형 인터페이스와 람다식 사용 public class Main { public static void main(String args[]) { Thread thd = new Thread(() -&gt; System.out.println(\"my thread\")); thd.start(); } } // my thread import java.util.function.*; public class Main { public static void main(String args[]) { Supplier&lt;Integer&gt; rand = () -&gt; { Integer r = (int) (Math.random() * 10); return r; }; int a = rand.get(); System.out.println(a); } } 학습 정리 자료형을 매개 변수로 가지는 클래스와 인터페이스를 제네릭 타입이라고 함 제네릭 클래스를 사용할 때 제공되는 타입 파라미터는 필드의 자료형, 메소드의 반환형, 메소드에서 인자의 자료형으로 사용될 수 있음 자료형을 매개 변수로 가지는 메소드를 제네릭 메소드라고 함 제네릭을 활용하면 컴파일 시점에 명확한 자료형 검사를 수행할 수 있음 함수형 인터페이스를 구현하는 클래스의 객체를 생성할 때 람다 식을 사용하는 것이 효율적임 람다 식의 결과 타입에 해당하는 인터페이스를 람다 식의 타깃 타입이라고 함연습 문제 다음과 같은 제네릭 클래스가 있다고 가정하자. 보기에서 문법적으로 오류가 있는 것은? class Data&lt;T&gt;{ private T t; public void set(T t) { this.t = t; } public T get() { return t; } } a. Data &lt;int&gt; d = new Data &lt;&gt;(); 제너릭 클래스의 문법적으로 올바른 사용법 Data&lt;Integer&gt;d = new Data&lt;&gt;(); Data&lt;String&gt;d = new Data&lt;String&gt;(); Data d = new Data(); 다음과 같은 인터페이스가 있다고 가정할 때, 보기에서 람다식 사용이 잘못된 것은? interface Addable { int add(int a, int b); } a. Addable ad = (int a, int b) -&gt; return (a + b); 람다식의 올바른 사용법 Addable ad = (int a, int b) -&gt; { return (a + b); }; Addable ad = (int a, int b) -&gt; a + b; Addable ad = (a, b) -&gt; (a + b); Java에서 제공되는 표준 함수형 인터페이스 중 Supplier&lt;T&gt;에서 선언된 추상 메소드의 이름과 형식은 각각 무엇인가? a. T get() " }, { "title": "[유비쿼터스 컴퓨팅 개론] 5강 - 디바이스 기술 - 나노 기술 및 차세대 전지", "url": "/posts/knou-uqc-5/", "categories": "Computer Science, CS Theory", "tags": "knou, ubiquitous computing", "date": "2025-04-08 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정광식 교수님의 '유비쿼터스 컴퓨팅 개론' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 유비쿼터스 환경에서는 다양한 응용 서비스 개발이 가능한데, 각 응용의 요구 사항에 따라 다양한 장비가 사용되어야 함 이러한 장비를 개발하기 위해서는 여러 세부 기술들이 개발되고 적용되어야 하는데, 이 중 나노 기술 및 전지 기술에 대하여 공부함학습 목표 미래 산업 혁명을 이끌어갈 주요 분야로 인식되는 나노 기술의 개념을 이해할 수 있음 사회 전반에 영향을 미칠 나노 기술의 산업적 · 경제적 중요성을 이해할 수 있음 나노 기술의 발전 과정과 학제 간 연구가 필요한 나노 기술의 특징을 이해할 수 있음 전지의 원리와 차세대 전지의 발전 방향에 대해 이해할 수 있음강의록나노 기술나노 기술 (NT: Nano Technology) 개요 물질의 특성을 나노 스케일에서 규명하고 제어하는 기술 원자나 분자를 적절하게 결합시켜 새로운 미세한 구조를 만들어 내어 기존 물질을 변형하거나 새로운 물질을 창출하는 것을 가능하게 하는 초 미세 기술 나노미터(nm) 크기의 원자나 분자를 조작하여 물질의 구조나 배열을 제어함으로써 나노 특유의 특이성을 이용한 새로운 기능이나 우수한 특성을 발현해 내는 기술을 총칭 함 10억 분의 1(10⁻⁹)을 나타내는 단위로 난쟁이를 뜻하는 고대 그리스어 나노스(nanos)에서 유래 하였음 1nm는 10억 분의 1m이며, 이는 머리카락 굵기의 약 8만 분의 1, 수소 원자 10개를 나란히 늘어놓은 정도에 해당 됨 일반적으로 100nm 이하 크기를 가지는 물질은 중력에 의한 물리학보다는 양자역학에 따라 다른 특성을 가짐 입자의 질량이 너무 작아서 중력의 영향은 덜 받고, 상대적으로 넓은 표면적으로 인하여 흡착력이 커지게 됨 나노 기술에 대한 정의는 국가 별, 기관 별로 약간씩 상이한데, 미국의 경우 원자, 분자, 초분자 수준 등의 표현을 함께 사용함 기술의 핵심은 원자, 분자 크기의 물질을 움직여 근본적으로 새로운 특성을 가진 구조물을 만드는 기술 나노 기술은 나노미터(nm) 크기일 때 새로 나타나는 물리적·화학적·기계적·전자적 특성을 살펴보면 다음과 같음챗GPT 질문 1: 챕터 1- 광식: 안녕~! 챗GPT~- GPT: 안녕하세요 정광식 교수님~- 광식: 나노기술의 MEMS와의 차이점을 정리해줘~- 나노기술(Nanotechnology)과 MEMS(Micro-Electro-Mechanical Systems)는 둘 다 미세한 규모의 기술이지만, 목적과 적용 영역에서 차이가 있습니다.1. 크기와 스케일: - 나노기술: 주로 나노미터(10⁻⁹ 미터) 스케일의 소재 및 구조물을 다루는 기술로, 원자와 분자 수준에서의 조작을 다룹니다. - MEMS: 미크로미터(10⁻⁶ 미터) 스케일의 기계적, 전기적, 광학적 장치 및 시스템을 개발하는 기술로, 작은 전자 및 기계 시스템을 다룹니다.2. 적용분야: - 나노기술: 전자공학, 재료 과학, 의학, 에너지, 환경 등 다양한 분야에 적용됩니다. 나노물질의 제조, 나노전자소자, 바이오센서, 나노의학 등에 활용됩니다. - MEMS: 센서, 액추에이터, 광학장치, 생체 응용 기기 등 다양한 기계적, 전기적, 광학적 장치와 시스템을 포함한 여러 분야에 적용됩니다.3. 구조 및 제조 방법: - 나노기술: 주로 화학적, 물리적 기술을 사용하여 원자 및 분자 수준에서 소재를 조작하고 제조합니다. 나노 리소그래피, 분자 셀프 어셈블리, 나노 인쇄 등이 사용됩니다. - MEMS: 주로 전통적인 반도체 제조 공정을 기반으로 합니다. 주로 실리콘을 기본 재료로 사용하고, 마스크 리소그래피, 에칭, 증착 등의 공정을 사용하여 미세한 기계장치를 만듭니다.4. 응용 및 기능: - 나노기술: 주로 나노물질의 특성을 활용하여 새로운 소재, 전자소자, 의학적 응용물 등을 개발합니다. - MEMS: 미세 기계시스템을 사용하여 센서, 액추에이터, 소형화된 기계시스템 등을 개발합니다.요약하자면 나노기술은 주로 원자 및 분자 수준의 소재 조작과 소자 제조에 중점을 둔 반면, MEMS는 미세 기계시스템의 제조와 응용에 중점을 둡니다.두 기술은 서로 보완적이며 다양한 기술과 분야에 적용됩니다.나노 기술의 특성 광학적 특성 나노 영역에서는 크기에 따라 색깔이 변함 금(Au)의 경우, 일반적으로는 황금색을 띠지만, 20nm 이하가 되면 빨간색으로 변하며, 크기가 조금만 변해도 색깔이 달리 보임 화학적 특성 모든 물질은 큰 덩어리를 작은 덩어리로 쪼개면 물질 전체의 표면적이 급격히 커지며, 이로 인해 나노 물질은 독특한 특성을 나타냄 예를 들어, 광 촉매 입자 크기가 20nm 이하이고 형광등이나 백열등에서 발생되는 약한 자외선을 받으면 살균력, 자가 세척력, 김 서림 방지 효과를 나타내기 때문에 그 활용도가 커짐 기계적 특성 다결정질 재료의 입자는 각 입자마다 기본적인 배열은 같으나 방향이 다르고 입자와 입자 사이에 존재하는 단위 면적 당 입계가 많을수록 강한 기계적 성질을 가지는 경향이 있음 나노 물질은 특정 크기에서 강도가 급격히 증가하는 현상을 보이기도 하여, 일반적으로 크기가 작을수록 강하다는 일반 상식이 통하지 않음 다만 다른 물질과 결합할 경우 기계적 강도가 증가하는 것으로 볼 때, 나노 입자의 기계적 성질이 우수하다고 판단할 수 있음 전자적 성질 전자적인 성질을 띠는 반도체, 자성 금속, 나노 입자들은 크기가 10~100nm 정도로 작아지면 자기적인 성질이 최대가 되는 것으로 알려져 있음 자기적인 성질을 극대화 할 수 있는 크기의 자성 금속 나노 입자를 작고 균일한 크기로 배열할 때, 이 입자 하나하나가 각각 한 개의 비트를 표현할 수 있고 따라서 향후 차세대 기억 소자로 활용될 수 있음 기존 소재들은 대개 큰 덩어리 형태를 나열하여 제작하고 있는데, 어느 수준 이하로 그 크기를 소형화하는 것이 쉽지 않음 이에 반해 나노 기술은 더 작은 원자, 분자 수준에서 구조물과 소자를 제어하고자 함 나노 기술은 나노 크기에서 근본 성질과 현상을 제어하기 때문에 거의 모든 분야에서 적용 가능함나노 기술을 연구하기 위한 기술적 접근 방식 방식 기술 특성 접근 방법 비고 하향식 (top-down) 나노미터 수준의 가공을 통해 나노미터 크기의 구조체를 인공적으로 형성하는 기술 거시적 → 미시적 기술 · 경제적 문제점 해결 필요   ex) 박막이나 벌크 형태의 물질을 패터닝이나 식각 기술을 통해 나노 물질로 형성하는 방식     상향식 (bottom-up) 물질의 최소 단위인 원자나 분자를 자유자재로 조작하여 원하는 기능의 구조체를 형성하는 기술 미시적 → 거시적 경제적 측면에서는 유리, 과학 기술적 해결 과제 많음 하향식 거시적 관점에서 미시적인 관점으로 접근하는 연구 방식 나노 미터 수준의 가공을 통해 나노미터 크기의 구조체를 인공적으로 형성하는 기술임 상향식 미시적인 관점에서 거시적인 관점으로 접근하는 연구 방식 물질의 최소 단위인 원자나 분자를 자유자재로 조작하여 원하는 기능, 구조체를 형성하는 기술임 나노 기술의 역사 나노 기술에 대한 연구가 활발하게 진행된 계기는 1981년 스위스에서 주사터널링 현미경(STM)을 개발한 것을 들 수 있음 주사 터널링 현미경, 원자력 반발 현미경(AFM), 근접장 투과 현미경(SNOM) 등이 개발되면서 나노 구조나 단일 분자의 특성을 측정하고 조절할 수 있게 된 것이 현재의 나노 기술 발전에 커다란 영향을 미쳤음 급격하게 주목을 받은 것은 2000년 1월, 미국의 나노 기술 주도 계획(NNI) 사업과 관련한 클린턴 대통령의 연설(”강철의 열배 강도를 가지지만 무게가 몇 배 작은 물질을 만든다면, 국회 도서관의 모든 정보를 각설탕 크기의 소자에 저장할 수 있다면, 몇개의 세포로 이루어진 종양을 감지할 수 있다면”)과 같은 나노 기술의 미래에 대한 가정을 통해 나노 기술의 비전을 제시한 바 있음나노 기술의 특징 일반적으로 물질을 제조 또는 합성하는 방식은 크게 두 가지로 구분할 수 있음 첫째(기존 방법) 구성 성분의 조성을 변화 시키거나 결정 구조 등 물질의 구조를 변형 시키는 방식임 둘째(나노 기술) 물질의 크기를 변화 시킴으로써 새로운 물질을 제조 또는 합성하는 것임 나노 기술은 바로 크기를 변화 시킴에 따라 새로운 특성을 나타내는 새로운 물질을 만들어 내는 기술 기존의 기술 분야들을 횡적으로 연결할 수 있는, 즉 학문 간의 경계를 허물어트리는 학제간 연구 분야 재료, 전자, 에너지, 우주 항공, 의학 등 거의 모든 산업 분야에 응용이 가능하여 높은 경제적 파급성 기술적 측면 나노 수준의 새로운 원천 기술의 개발과 신물질 합성을 통한 산업적 적용이 가능하고, 또한 기술 간 상호 협력의 필요성으로 인해 학문간 · 기술간 융합화를 유도함 경제적 측면 기술 집약적인 신 산업의 창출로 고부가가치 전략 품목의 새로운 개척과 선점을 가능하게 함 나노 기술의 활용 분야 나노 기술은 혁신적 소재 · 부품, 시스템 제조 등 제조 업체 기술 혁신을 불러 올 수 있는 핵심 기술 관련 된 주요 연구 분야(정보/전자, 에너지, 환경, 바이오 등 타 분야)와 융합 기술 개발 이에 따라 나노 소자, 나노 소재, 나노 바이오, 나노 에너지 · 환경, 나노 공정 · 측정 · 장비, 나노 안전성 분야에 대한 많은 연구가 진행되고 있음 나노 소자 고성능, 휴대성, 저전력 소비, 고속 정보 처리 능력을 확보하기 위한 신소재/신구조 기반 미래 IT 소자 구현 나노 소재 초경량/고강도/고특성 등 기존 소재의 한계를 극복할 수 있도록 나노 기반 소재 개발을 통해 정보/전자, 에너지, 의료/환경 등 타 산업과의 융합 촉진 나노 바이오 나노 진단/나노 치료제/인공 촉각 기술 등 인간 중심의 기술 개발을 통해 건강하고 쾌적한 삶을 누릴 수 있도록 기술의 융복합 확대 추진 나노 에너지 · 환경 에너지 변환/저장 기술 등 나노 융합 에너지 · 환경 기술의 혁신적 성능 개선을 통한 지속 가능한 고도화 사회 구현 나노 공정 · 측정 · 장비 나노 박막/나노 패터닝/측정 분석 기술 등 창조적 나노 공정 · 측정 · 장비 기술 개발을 통해 신개념 나노 장비 시장 개척 나노 안정성 나노 물질의 잠재적 위해성 문제에 대응하기 위해 노출 평가/평가 기법/위해성 평가 등 인간 및 생태계에 미치는 영향을 평가하고 위해성을 저감할 수 있는 기술 개발 향후 나노 기술이 발전하면, 슈퍼컴퓨터보다 더 강력한 양자 컴퓨터 시대도 앞당겨지고, 양자 컴퓨터 시대가 되면 나노 기술은 더욱 더 발전할 것으로 예상 됨 Global Nanomaterial Market에 따르면 세계 나노 소재 시장은 2021년 약 21조 원에서 2031년 약 84조 원으로 연 평균 14.6% 성장할 것으로 전망 됨차세대 전지차세대 전지 개요 전기 · 전자 · IT 기술을 응용한 스마트폰, 노트북, 태블릿 PC와 같은 소형 휴대 기기 수요가 증가하고 있음 환경 및 에너지 문제에 대처하기 위해 에너지 저장 시스템(ESS: Energy Storage Systems)과 하이브리드 자동차/전기 자동차도 대중화되고 있음 이에 따라 이러한 기기의 구동에 꼭 필요한 에너지원인 차세대 전지에 대한 관심도 커지고 있음 현재 주로 사용되는 휴대용 2차 전지는 용량에 한계가 있어 소형화, 고용량, 고성능이 요구되는 휴대 기기에 활용하기에는 완전하지 못함 경제 성장과 생활 수준의 향상에 따른 에너지 수요는 기하수급적으로 증가하지만, 대부분의 국가에서는 여전히 화석 에너지에 대한 의존도가 높음전지 분류 화학 전지 화학 반응을 통해 전기를 발생 1차 전지, 2차 전지, 연료 전지로 구분함 물질 간의 화학 반응을 통해 전기 에너지를 발생 시키거나, 전기 에너지로 화학 반응을 발생 시킬 수 있는 장치임 1차 전지는 방전이 되면 재사용이 불가능하지만, 2차 전지는 전기 에너지를 화학 에너지로 저장할 수 있어야 재 충전이 가능함 2차 전지에서 재료 물질에 따라 초기 납축 전지로부터 Ni-Cd 전지, Ni-MH 전지, 리튬 이온 전지 등이 있음 최근에는 높은 에너지 밀도와 긴 수명으로 인하여 리튬 이온 전지가 모바일 기기나 전기 자동차 ESS 등에 널리 활용되고 있음 물리 전지 화학 반응 없이 물리적 에너지를 에너지원으로 함 물질의 물리적 변화에 의해 발생하는 에너지를 전기 에너지로 변환하는 전지 발전 원리에 따라 태양 전지, 원자력 전지, 열 전기 발전형 전지, 열 전자 발전형 전지 등이 있음 예를 들어, 빛 에너지가 전기로 바뀌는 광기전 효과를 이용하면, 태양으로부터 전기를 생성하는 것이 가능하며 이를 태양 전지라고 함 화학 전지와 물리 전지의 중간 범위에 속하는 것이 초고용량 커패시터임 초고용량 커페시터는 초기에는 매모리 백업용의 틈새 시장으로 출발했으나, 전기 화학적 특성을 향상시켜 점차 고출력 · 고에너지 밀도가 요구되는 분야의 전지로 자리 매김하고 있음차세대 2차 전지 화학 전지 1차 전지 한 번 쓰면 재사용이 불가능함 2차 전지 충전을 통해 지속적인 사용이 가능함 연료 전지 충전이 아닌 연료를 공급함으로써 지속적인 전기 생산이 가능함 2차 전지는 화학 에너지와 전기 에너지 간의 상호 변환이 가역적이어서 충전과 방전을 반복할 수 있어서 활용 범위가 큼 차세대 2차 전지 기술은 화학, 물리, 전기, 전자, 재료, 금속 등 여러 분야의 기술이 집약된 첨단 기술 제품임 광범위한 응용 기술이 필요하며, 학문적 이론과 연구 실험이 계속 뒷받침되어야만 고용량 · 고 성능화를 달성할 수 있음 산업적으로는 전방 산업인 완제품과, 후방 산업인 부품 · 소재 산업 사이의 중간 산업으로 인식하고 있으며, 폭넓은 산업 연관 효과를 증대 시키면서 독자적인 판매도 가능한 산업임 국가적으로는 중요 기간 산업인 에너지 산업으로 간주됨 하지만 한정된 에너지원을 이용하여 에너지 효율을 최적화할 수 있는 차세대 전력 망인 스마트 그리드 시스템, 태양광이나 풍력과 같은 신재생 에너지 생산에 따른 균일한 전력 제공이나 거대 규모의 에너지 저장원의 필요성도 증대되고 있음 그 외에도 고용량, 고출력(급속 충전), 안정성, 저비용의 특성을 가지는 차세대 전지에 대한 연구도 활발하게 진행되고 있음 전고체 배터리 (SSB: Solid State Battery) 고체로 전해질을 구현하여 온도 변화나 외부 충격에 강하고 저비용, 고용량 배터리로 활용될 수 있을 것으로 예상하고 있음 리튬 금속 배터리, 리튬 황 배터리도 에너지 밀도를 높일 수 있는 후보 기술로 연구되고 있음 하지만 모든 기술적 수요를 동시에 만족 시킬 수 있는 차세대 2차 전지 시스템은 아직은 가능하지 않음초 고용량 커패시터 1990년대까지는 전자 부품으로 분류되었으나, 2000년 산업 자원 부에서 산업 기술 분류 체계를 개정하면서 차세대 전지 분야로 분류되기 시작함 산업 기술 분류 체계에서 초 고용량 커패시터를 2차 전지와 구분한 이유는 초고용량 커패시터가 기존의 2차 전지보다는 콘덴서 부문에서 기술적 근본을 가지고 있기 때문임 콘덴서 부품과 비교해 볼 때 초고용량 커패시터는 크기나 기능 면에서 상당히 개선되었지만, 이전과 유사한 분야에 주로 활용되고 있기 때문임 주로 형성될 것으로 전망되는 산업 분야는 전자 · 정보 기기, 수송 기계, 전력 저장 및 특수 용 제품 분야임 전자 · 정보 기기 고에너지 밀도형이 개발되어 산업의 중추를 맡을 것임 수송 기계 중대형 및 무인 기반 시스템을 주축으로 산업이 형성될 것으로 예상됨 전력 저장 및 특수 용도 제품 수송 기계 분야와 비슷한 경향으로 전개될 것임 수송 기계 분야 고에너지 밀도형과 고출력형이 동시에 주요 산업 군으로 구성됨 전력 저장 고출력형만으로 충분할 것으로 예상됨 고에너지 밀도형은 틈새 시장을 형성할 것임연료 전지 연료 전지는 다양한 에너지원을 이용하여 전기를 생성하는 발전기의 일종임 주 연료는 수소, 메탄올, 천연가스 등이 주로 고려되고 있음 이전의 발전기는 원료를 연소 시켜 생성된 열에너지를 엔진이나 터빈으로 이용하여 전기 에너지로 변환 시키는데, 여러 차례 에너지 변환 과정을 거치므로 효율성이 낮은 단점이 있었음 연료 전지는 연료로부터 전기 에너지를 생산하므로 기술이 성숙한다면 훨씬 효율성을 높일 수 있음 통상적으로 연료 전지는 전해질의 종류에 따라 인산형(PAFC: Phosphoric Acid Fuel Cell), 용융탄산염형(MCFC: Molten Carbonate Fuel Cell), 고체산화물형(SOFC: Solid Oxide Fuel Cell), 알칼리성(AFC: Alkaline Fuel Cell) 및 고체고분자형(PEMFC: Polymer Electrolyte Fuel Cell) 으로 분류함 환경 친화적 에너지인 수소도 석유 경제를 대체할 수 있는 주요 에너지원으로 활발하게 연구되고 있음 수소 연료 전지는 추출한 수소를 공기 중 산소와 반응 시켜 전기 에너지를 생성함 산화 환원 반응을 이용하여 전기 에너지를 생성하므로 에너지 효율이 높다는 장점이 있음 수소 연료 전지는 선박, 자동차, 건설 기계 등 다양한 분야에서 에너지원으로 활용되고 있음 수소 대신 액상 메탄올을 전지 스택(Stack)에 직접 공급하는 직접 메탄올 형(DMFC: Direct Methanol Fuel Cell)이 휴대용으로 집중 연구 · 개발되고 있음 용량과 안전성이 상충 관계에 있는 상용 리튬 이온 전지의 경우 에너지 용량 증가가 기술적으로 한계에 다다른 반면, 2차 전지에 대한 수요는 비약적으로 증가하고 있음 고출력 이동 전원에 대한 시장의 신규 수요도 높고 시장성도 좋으며, 이런 과정에서 휴대용 연료 전지가 좋은 평가를 받고 있음 부하 변화에 대한 신속한 응답을 특성으로 하고 반복적인 온/오프 구동이 가능하다는 것은 휴대용 연료 전지가 수송용 연료 전지를 극소형화한 형태로 볼 수 있음 구동 원리나 기술적 접근 방식은 거의 동일함정리 하기 나노 기술은 물질을 원자 혹은 분자 수준에서 조작하고 제어할 수 있는 기술임 2차 전지로 리튬 이온 전지가 주로 사용되고 있으며, 초 고용량 커패시터나 연료 전지 연구 진행 중임연습 문제 나노 기술의 특징이 아닌 것은 무엇인가 ?  a. 기술의 핵심은 기존의 구조물들을 융합하여 구조물을 만드는 기술 나노 기술의 특징 물질의 특성을 나노 스케일에서 규명하고 제어하는 기술 원자나 분자를 적절하게 결합시켜 새로운 미세한 구조를 만들어내어 기존 물질을 변형하거나 새로운 물질을 창출하는 것을 가능하게 하는 초 미세 기술 입자의 질량이 너무 작아서 중력의 영향은 덜 받고, 상대적으로 넓은 표면적으로 인하여 흡착력이 커지게 됨 화학 전지에 속하지 않는 것은? a. 태양 전지 화학 전지에 속하는 것 Ni-Cd 전지 Ni-MH 전지 리튬 이온 전지 나노미터 수준의 가공을 통해 나노미터 크기의 구조체를 인공적으로 형성하는 나노 기술의 접근 기술은 ?  a. 하향식 접근 방식 정리 하기 나노 기술의 정의 원자나 분자를 적절하게 결합시켜 새로운 미세한 구조를 만들어내어 기존 물질을 변형하거나 새로운 물질을 창출하는 것을 가능하게 하는 초 미세 기술 나노 기술의 특징 나노 수준의 새로운 원천 기술의 개발과 신 물질 합성을 통한 산업적 적용이 가능하며, 학문 간, 기술 간 급격한 융합 화를 유도함 나노 기술의 활용 분야 나노 소재, 나노 소자, 나노 바이오, 나노 에너지·환경, 나노 공정·측정·장비, 나노 안전성 전지의 분류 화학 반응을 통해 전기를 발생 시키는 화학 전지와 물리적 반응을 통해 전기를 발생 시키는 물리 전지 초 고용량 커패시터 기존의 2차 전지보다는 콘덴서 부품에서 기술적 근원을 가지고 있으며, 초 고용량 커패시터로넘어오면서 기존 콘덴서 부품과 비교해 볼 때 사용처 등에서 유사한 흐름을 유지하였으므로 2차 전지와 구분됨 연료 전지 수소와 산소의 반응을 통해 전기와 열, 물을 생산하는 고효율 무공해 전기 화학 장치로서 반응 물을 공급하는 한 지속적인 전력 생산이 가능한 일종의 발전기 " }, { "title": "[데이터 정보 처리 입문] 7강 - 엑셀을 이용한 데이터 처리 2", "url": "/posts/knou-dip-7/", "categories": "Data Science, Data Analysis", "tags": "knou, data information processing", "date": "2025-04-07 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김성수, 이기재 교수님의 '데이터 정보 처리 입문' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 엑셀의 다양한 함수 기능을 활용하면 어려운 계산도 손 쉽게 할 수 있고, 데이터 분석 도구를 활용하면 기술 통계 량을 쉽게 구할 수 있음 엑셀의 연산자, 엑셀 함수의 기능과 형식 IF 함수 활용 방법 등에 대해서 공부함 엑셀의 데이터 분석 도구를 활용하여 데이터에 대한 기초적인 데이터 분석 방법에 대해서 공부함학습 목표 엑셀의 연산자를 활용할 수 있음 엑셀 함수의 기능과 형식을 설명할 수 있음 엑셀 함수를 사용하여 계산할 수 있음 엑셀을 활용하여 데이터를 분석할 수 있음주요 용어 케이스(case) 특정 조사 단위로부터 얻어진 정보의 집합체를 말함 변수(variable) 각 조사 단위로부터 측정 된 개별적인 속성들 상대 참조 행 이름이나 열 이름만을 사용하여 셀을 참조하는 방법 A1, B2, A1:F1 등 절대 참조 참조하는 셀이나 셀 범위를 표시할 때 “$“를 사용하여 참조하는 방법 $A$1, $B$2, $A$1:$F$1 등 혼합 참조 행 이름이나 열 이름의 한 쪽에만 “$”를 사용하여 참조하는 방법 $A1, B$2, A$1:F$1 등 IF문 주어진 조건을 평가하여 참인 경우와 거짓인 경우에 어떤 값을 표시하는 엑셀 함수 문 기술 통계량(descriptive statistics) 데이터의 전반적인 분포 형태와 특성을 쉽게 파악하기 위한 목적으로 데이터를 정리,요약하는 방법을 말함 강의록함수 사용법엑셀의 연산자 엑셀에서는 함수를 사용하여 데이터를 분석하고, 워크 시트 값에 대하여 산술 연산, 비교 연산, 문자 연산, 참조 연산 등을 수행 연산자의 종류 산술 연산자, 비교 연산자, 문자 연산자, 참조 연산자 등 연산자의 종류 산술 연산자 + 더하기 - 빼기 / 나누기 * 곱셈 ^ 거듭 제곱, 지수 비교 연산자 = 같다 &gt; 크다 &lt; 작다 &gt;= 크거나 같다 &lt;= 작거나 같다 &lt;&gt; 같지 않다 문자 연산자 &amp; 두 값을 연결하여 하나의 문자열 값 산출 참조 연산자 셀 범위를 참조하는 방식을 지정함 : 콜론 범위 연산자 두 셀 참조 사이의 모든 셀을 포함하는 하나의 참조 영역을 만듬 ex) =SUM(A1:A10) (A1부터 A10까지 모든 셀의 합계) , 쉼표 합집합 연산자 여러 개의 셀 참조를 하나의 참조 영역으로 결합함 ex) =SUM(A1:A3, B1:B5) (A1:A3 범위와 B1:B5 범위에 있는 모든 셀의 합계) 공백 교집합 연산자 두 참조 영역에 공통적으로 포함되는 셀들의 참조 영역을 만듬 ex) =SUM(A1:A6 A5:A10) (A1:A6 범위와 A5:A10 범위의 교집합인 A5:A6 셀들의 합계) 함수 사용 방법 함수의 기능 값, 셀 참조, 함수 등을 사용하여 새로운 값을 생성함 일반적인 함수의 형식 함수 식은 등호(=)로 시작, =함수이름(인수1, 인수2, ..., 인수n) 형식 ex) =AVERAGE(A1:B3) (A1부터 B3까지 범위의 평균 계산) ex) 함수 사용 숫자를 직접 인수로 사용 =SUM(2, 3, 4, 5, 5) (결과: 19) 셀 또는 셀 범위에 대한 참조 영역을 인수로 사용 가능 =SUM(A1:A5) (A1부터 A5 셀까지의 합계 계산) 셀 참조 방법 엑셀 수식에서 다른 셀의 값을 사용하기 위해 셀 주소를 참조하는 방식 상대 참조 (Relative Reference) 수식을 복사하여 다른 셀에 붙여 넣으면, 참조하는 셀 주소가 복사 된 위치에 따라 상대적으로 변경 됨 행 이름이나 열 이름만을 사용하여 셀 참조 ex) A1, D3, =AVERAGE(A2:G2) 절대 참조 (Absolute Reference): 수식을 복사하여 다른 셀에 붙여 넣어도 참조하는 셀 주소가 변경되지 않고 고정됨 참조하는 셀이나 셀 범위를 표시할 때 $ 표시 사용 ex) $A$1, $D$3, =AVERAGE($A$2:$G$2) 혼합 참조 (Mixed Reference): 열 또는 행 중 하나만 절대 참조로 고정하고 다른 하나는 상대 참조로 남겨둠 행 이름이나 열 이름의 고정하려는 부분에만 $ 표시하여 참조 ex) $A1 (열 A는 고정, 행 번호는 상대적 변경), D$3 (열 D는 상대적 변경, 행 3은 고정), =AVERAGE($A2:$G2) (열 A와 G는 고정, 행 2는 상대적 변경) 함수 사용 예: 평균 계산 성적 데이터에 대해서 각 사람의 평균 점수를 구하는 과정 먼저 D1 셀에 ‘평균’이라고 입력하고, D2 셀에 커서를 위치한 후, 수식 입력줄에 =AVERAGE(B2:C2)를 입력 엑셀의 채우기 기능 사용: 나머지 사람은 채우기 기능 이용 함수 사용 예: IF문 사용 통계학 점수가 60점 이상이면 ‘합격’, 60점 미만이면 ‘불합격’으로 표시 IF문은 주어진 조건을 평가하여 참인 경우와 거짓인 경우에 다른 값 표시 구문: IF(주어진 조건, value if true, value if false) 주어진 조건 TRUE 또는 FALSE로 판정될 수 있는 값이나 식 (조건) value_if_true 주어진 조건이 참일 때 얻게 되는 결과 값 value_if_false 주어진 조건이 거짓일 때 얻게 되는 결과 값 E1 셀에 변수명으로 ‘합격여부’라고 입력하고, E2셀에 =IF(B2&lt;60, \"불합격\", \"합격\") 라고 입력 나머지 셀은 채우기 기능을 이용하여 쉽게 처리할 수 있음함수 마법사의 이용 함수 마법사를 이용해서 과목 별 평균 점수를 구하는 예 계산 된 함수 값이 입력될 셀 선택 함수 마법사를 클릭하여 대화 상자 이용 함수의 인수로 사용될 셀의 범위를 직접 마우스로 드래그하여 설정 올바르게 인수가 지정 되었는 가를 검토하여 확인 선택 자주 사용하는 엑셀 함수들 AVERAG 함수 인수의 산술 평균을 구함 ex) =AVERAGE(B2:B30) =AVERAGE(number1, number2, number3, …) VAR 함수 표본 자료의 표본 분산을 구함 ex) =VAR.S(B2:B30) =VAR(number1, number2, number3, …) STDEV 함수 표본 자료의 표준 편차를 구함 ex) =STDEV.S(B2:B30) =STDEV(number1, number2, number3, …) MEDIAN 함수 인수의 중앙 값을 구함 ex) =MEDIAN(B2:B30) =MEDIAN(number1, number2, number3, …) MAX 함수 데이터의 최대 값을 구함 ex) =MAX(B2:B30) =MAX(number1, number2, number3, …) MIN 함수 데이터의 최소 값을 구함 ex) =MIN(B2:B30) =MIN(number1, number2, number3, …) 엑셀을 사용한 데이터 처리 예데이터에 대한 통계 분석 기술 통계 량 (Descriptive Statistics) 데이터의 전반적인 분포 형태와 특성을 쉽게 파악하기 위한 목적으로 데이터를 정리, 요약한 수치 [데이터] 탭의 [분석] 그룹의 [데이터 분석]을 이용함 엑셀에서 제공하는 데이터 분석 도구 분산 분석(ANOVA), 상관 분석, 기술 통계법, 이동 평균법, 지수 평활법, 히스토그램, 난수 생성, 순위와 백분율, 회귀 분석, t-검정, 표본 추출 등 거의 모든 기초적인 통계 분석 가능 [데이터] 탭에서 [분석] 그룹에서 [데이터 분석]이 나타나지 않는 경우 데이터 분석 도구 활성화 [파일] 탭 → [옵션] → [추가 기능] → 하단의 ‘관리:’ 드롭다운에서 ‘Excel 추가 기능’ 선택 후 [이동] 클릭 → ‘분석 도구’ 체크 → [확인] 활성화되면 [데이터] 탭의 [분석] 그룹에 [데이터 분석] 메뉴가 나타남 기술 통계량 구하는 예 [데이터] 탭 → [분석] 그룹 → [데이터 분석] 선택 [통계 데이터 분석] 대화 상자에서 ‘기술 통계법’ 선택 → [확인] [기술 통계법] 대화 상자 설정 → 입력 범위, 첫번째 행을 이름표로 사용, 요약 통계량 선택 입력 범위 분석할 데이터가 있는 셀 범위를 지정 첫째 행 이름표 사용 입력 범위에 변수 이름(제목)이 포함된 경우 체크 출력 옵션 결과를 표시할 위치(새 워크 시트, 현재 시트의 특정 셀 등)를 선택 요약 통계량 반드시 체크 기술 통계 량 결과를 출력하는 옵션 결과 확인 실습: 성적 데이터 상대 참조, 절대 참조, 혼합 참조 이용 AVERAGE 문을 이용한 평균 계산 IF 문을 이용한 ‘합격’, ‘불합격’ 판정 [데이터 분석]을 이용한 기술 통계 분석 연습 문제 엑셀에서 B2셀의 값이 60보다 작으면 “불합격”, 60이상이면 “합격”을 D2셀에 표시하고자 한다. 적합한 엑셀 함수 사용은? a. =IF(B2&lt;60, \"불합격\", \"합격\") B2와 C2 셀에 데이터를 입력한 후 두 값의 평균 점수를 구하고자 한다. 적합한 수식 입력은? a. =AVERAGE(B2:C2) 학생들 30명에 대한 통계학 점수와 수학 점수 자료를 다음과 같이 입력하였다. 물음에 답하시오. 데이터를 입력한 후 그림과 같이 각 케이스에 대하여 평균 점수를 구하고자 한다. (A) 부분에 적합한 수식 입력은? a. =AVERAGE(B2:C2) 학생들 30명에 대한 통계학 점수와 수학 점수 자료를 다음과 같이 입력하였다. 물음에 답하시오. D2 셀에 =IF(SUM(B2:C2)&gt;=130, \"합격\", \"불합격\")를 입력하였을 때 그 결과는?  a. 합격 학생들 30명에 대한 통계학 점수와 수학 점수 자료를 다음과 같이 입력하였다. 물음에 답하시오. D2 셀에 =$B$2+$C$2를 입력한 후 드래그 &amp; 드롭 기능을 이용하여 D11 셀까지 채워 넣었다. 이 때 D3 셀의 결과는? a. 136 " }, { "title": "[데이터 정보 처리 입문] 6강 - 엑셀을 이용한 데이터 처리", "url": "/posts/knou-dip-6/", "categories": "Data Science, Data Analysis", "tags": "knou, data information processing", "date": "2025-04-07 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김성수, 이기재 교수님의 '데이터 정보 처리 입문' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 엑셀은 대차 대조표, 성적표 작성, 고객 관리 등과 같이 행과 열로 구성된 데이터에 대한 분석에 유용하게 활용되고 있는 대표적인 스프레드시트로 데이터 분석, 그래프 표현, 데이터베이스 관리 도구 등 다양한 기능을 갖고 있음 엑셀의 주요 기능과 기본 용어에 대해서 살펴보고, 데이터의 입력, 데이터의 이동과 복사, 저장과 출력 방법 등의 기초 활용 법에 대해서 실습과 함께 살펴봄학습 목표 엑셀의 주요 기능을 제시할 수 있음 엑셀의 기본 용어를 설명할 수 있음 데이터의 입력 과정을 이해할 수 있음 데이터의 이동과 복사, 저장과 출력 방법을 설명할 수 있음주요 용어 케이스(case) 특정 조사 단위로부터 얻어진 정보의 집합체를 말함 변수(variable) 각 조사 단위로부터 측정 된 개별적인 속성들 셀(cell) 워크 시트에서 데이터가 입력되는 열과 행이 만나는 지점을 말함 각 셀은 A1(A와 1이 만나는 위치라는 뜻)처럼 셀이 속한 행과 열의 위치에 따라서 셀 주소를 갖음 워크 시트(worksheet) 데이터가 입력되고 계산된 결과들이 표시되는 부분임 워크 시트에서 열은 ABC…로 표시되어 있고, 행은 123…으로 표시 됨 통합 문서(workbook) 데이터 입력이나 분석 작업을 하여 그 결과를 저장하는 하나의 파일을 의미함 수식 입력 줄 활성 셀(선택된 셀)의 정보를 보여주고, 데이터를 입력하거나 수정할 수 있으며, 계산을 위해서 수식을 입력할 수 있음 강의록엑셀이란 무엇인가?스프레드시트 프로그램의 기본적인 기능 기본적으로 대차 대조 표, 성적표 작성, 고객 관리, 재고 관리 등과 같은 행과 열로 구성된 데이터에 대한 분석에 유용함 사용자가 수식을 정의하여 사용할 수 있고, 엑셀 함수를 활용한 분석 가능 다양한 서식을 통해 알기 쉽고 보기 좋은 보고서 작성 가능데이터의 통계 분석 기능 다양한 통계 분석 도구는 데이터의 분석에 쉽게 활용 연립 방정식 풀이 및 최적화 문제 해결 기능 등의 활용 실제 업무 상의 여러 문제들을 효과적으로 해결 그래프 표현 기능 원 그래프, 막대 그래프, 꺾은 선 그래프 등 다양한 그래프를 손쉽게 작성할 수 있음 데이터 분석 결과와 함께 알맞은 그래프를 제시하는 것이 효과적임데이터 베이스 관리 도구 기능 정렬 및 자동 필터, 보고서 작성 등의 작업을 편리하게 할 수 있음 피벗 테이블 기능을 활용하여 데이터를 손쉽게 정리, 요약 가능엑셀 기초 활용엑셀의 시작과 끝 엑셀의 시작 작업 표시줄 [시작] → 단추 [Excel] 엑셀의 종료 [파일] 메뉴 → [닫기] 클릭 제목 표시 줄의 오른쪽에 있는 닫기 단추를 클릭 엑셀의 기본 용어 파일 메뉴 새 통합 문서, 통합 문서 열기, 저장, 인쇄, 닫기, 프로그램 종료 등의 작업 명령 제공 제목 표시 줄 현재 사용 중인 통합 문서의 이름이 나타남 리본 메뉴 리본 메뉴 탭 파일, 홈, 삽입, 페이지 레이아웃, 수식, 데이터, 검토, 보기 탭으로 구성 그룹 각 리본 메뉴 탭의 명령이 기능 별로 그룹핑 워크 시트 (worksheet) 데이터를 입력하고 계산 결과가 표시되며, 열은 ABC…로, 행은 123…으로 표시 셀(cell) 열과 행이 만나는 칸 활성 셀 현재 선택된 셀로 두꺼운 테두리로 표시됨 셀 참조 각 셀은 열과 행의 조합으로 주소를 가짐 ex) C열 5행 셀은 C5가 주소가 됨 수식 입력 줄 활성 셀(선택된 셀)의 정보를 보여주고, 데이터를 입력하거나 수정할 수 있으며, 함수 식을 입력할 수 있음 워크 시트 탭(worksheet tab) 워크 시트의 아래 부분에 위치하며, 각 워크 시트의 이름을 지정할 수 있음 필요한 워크 시트 이름을 클릭하여 이동 상태 표시 줄 엑셀 초기 화면의 가장 아래 줄로 엑셀의 현재 상태를 표시함 엑셀 리본 메뉴 메뉴와 도구 모음 역할을 대신함 리본 메뉴의 구성: 그룹, 대화 상자 확장 단추 [삽입] 탭의 리본 메뉴 워크 시트에 삽입할 수 있는 피벗 테이블, 표, 그림이나 차트 등을 넣을 수 있는 명령이 나타남 통합 문서와 워크 시트 통합 문서(workbook) 데이터 입력이나 분석 작업을 하여 그 결과를 저장하는 하나의 파일 여러 개의 워크 시트로 구성(Sheet1, Sheet2, Sheet3 등 또는 명칭 부여 가능) 워크 시트(worksheet) 행과 열의 구조를 갖는 많은 셀로 구성된 작업 공간으로 통합 문서의 일부 통합 문서가 한 권의 책, 워크 시트는 한 페이지에 해당 열은 A,B,…,AA,BB,…,XFD까지 16,384개이고, 행은 1부터 1,048,576까지 가능 데이터의 입력 데이터의 예 번호 통계학 수학 1 71 65 2 63 58 3 74 88 4 65 87 5 86 92 6 87 80 7 84 79 8 77 70 9 85 77 10 59 45 11 61 66 12 73 72 13 68 64 14 81 78 15 53 40 데이터 관련 기본 용어 변수 조사 단위로부터 측정 되는 속성 케이스 조사 단위에 대한 정보의 집합체 변수명 변수의 이름 워크 시트에서 직접 데이터를 입력하는 경우 입력한 셀을 선택한 다음 데이터를 입력하고 Enter키를 누름 이미 만들어진 텍스트 파일을 불러오는 경우 성적 데이터 텍스트 파일 만들기 성적 데이터를 한글 2018을 이용해서 성적데이터.txt라는 텍스트 파일로 저장 엑셀에서 불러오기 절차 파일(F) 메뉴에서 열기(O) 선택 텍스트 마법사 대화 상자 절차 따르기 파일을 클릭하여 열기를 선택한 후 불러올 테스트 파일이 위치한 곳과 파일 이름을 지정함 파일 형식을 텍스트 파일로 지정하면 텍스트 파일을 찾는데 편리함 텍스트 마법사 대화 상자에서 전체 3단계의 절차를 밟으면 작성된 텍스트 파일을 워크 시트에 불러 올 수 있음 결과 화면 확인 데이터의 이동과 복사 원하는 영역 선택 방법 단일 셀의 선택 마우스나 키보드를 사용하여 원하는 셀로 이동하여 마우스를 클릭 이웃한 여러 개의 셀들의 선택 원하는 범위의 시작 셀에서 드래그 &amp; 드롭 시작 셀에서 마지막 셀까지 범위가 직사각형으로 선택 여러 개의 이웃하지 않은 셀들의 선택 이웃하지 않은 복수의 셀은 Ctrl키를 누른 상태에서 마우스로 원하는 만큼을 선택함 전체 행이나 열의 선택 행 머리글이나 열 머리글을 마우스로 클릭 행, 열의 삽입과 삭제 행 머리글이나 열 머리글을 마우스로 클릭하여 선택한 후 마우스의 오른쪽 단추를 눌러서 [삽입]이나 [삭제] 명령을 선택함 통합 문서의 저장과 출력 방법 저장 방법 데이터를 입력하거나 수정하는 과정에 틈틈이 저장하는 것이 안전 빠른 실행 도구 모음의 저장 단추를 클릭 출력 방법 파일 단추를 클릭하여 [미리 보기] 또는 [인쇄]를 선택 함수 사용법엑셀의 연산자 엑셀에서는 함수를 사용하여 워크 시트 데이터를 분석하고, 워크 시트 값에 대하여 산술 연산, 비교 연산, 문자 연산, 참조 연산 등을 수행 연산자의 종류 산술 연산자, 비교 연산자, 문자 연산자, 참조 연산자 등 산술 연산자 + (더하기), - (빼기), / (나누기), * (곱셈), ^ (지수) 비교 연산자 = (같다), &gt; (크다), &lt; (작다), &gt;= (크거나 같다), &lt;= (작거나 같다), &lt;&gt; (같지 않다) 문자 연산자 &amp; (두 값을 연결하여 하나의 문자 값 산출) 참조 연산자 : (범위) =SUM(A1:A10) , (합집합) =SUM(A1:A3, B1:B5) 공백 (교집합) =SUM(A1:A6 A5:A10) 함수 사용 방법 함수의 기능 값, 셀 참조, 함수 등을 사용하여 새로운 값을 생성함 일반적인 함수의 형식 함수 식은 등호(=)로 시작, =함수이름(인수,인수,…,인수) 형식 ex) =AVERAGE(A1:B3) 함수 사용 예 숫자를 인수로 사용 =sum(2,3,4,5,5) 셀이나 셀 범위에 대한 참조 영역을 인수로 사용 가능 =sum(A1:A5) 셀 참조 방법 상대 참조 행 이름이나 열 이름 만을 사용하여 셀 참조 ex) A1, D3, =AVERAGE(A2:G2) 절대 참조 참조하는 셀이나 셀 범위를 표시할 때 $ 표시 사용 ex) $A$1, $D$3, =AVERAGE($A$2:$G$2) 혼합 참조 행 이름이나 열 이름의 한쪽에만 $ 표시하여 참조 ex) $A1, D$3, =AVERAGE($A2:$G2) 실습: 성적 데이터 함수 사용 방법 상대 참조, 절대 참조, 혼합 참조 이용 연습 문제 다음은 엑셀에 대한 함수 사용 방법에 대한 설명이다. 옳은 설명끼리 짝 지어진 것은? 가. 값, 셀 참조, 함수 등을 사용하여 새로운 값을 생성한다. 나. 함수식은 등호(=)로 시작한다. 다. 엑셀에서 함수 이름은 대문자로만 입력해야 한다. a. 가, 나 엑셀에 대한 함수 사용 방법 값, 셀 참조, 함수 등을 사용하여 새로운 값을 생성한다. 함수식은 등호(=)로 시작한다. 다음은 엑셀의 통합 문서(workbook)와 워크 시트(worksheet)에 대한 내용이다. 잘못된 것은? a. 워크 시트는 항상 고정된 이름을 가지며, 한번 정해지면 바꿀 수 없다. 엑셀의 통합 문서(workbook)와 워크 시트(worksheet)에 대한 옳은 내용 통합 문서는 데이터 입력이나 분석 작업을 하여 그 결과를  저장하는 하나의 파일을 의미한다. 통합 문서는 워크 시트(worksheet), 차트 시트(chart sheet), 매크로 시트(macro sheet)를 포함한다. 통합 문서를 한 권의 책에 비유한다면 하나의 워크 시트는 한 페이지를 의미한다. 다음 중 엑셀의 중요한 기능이라고 할 수 없는 것은? a. 인터넷 검색 기능을 가지고 있다. 엑셀의 중요한 기능 그래프 표현 기능을 가지고 있다. 통계 분석 기능을 가지고 있다. 데이터베이스의 관리 도구 기능을 가지고 있다. 데이터를 입력한 후 이웃하지 않은 셀들을 선택하고자 한다. 올바른 방법은? a. CTRL 키를 누른 상태에서 마우스로 원하는 셀들을 선택한다. 선택된 셀의 정보를 보여주고, 데이터를 입력하거나 수정할 수 있으며, 계산을 위해서 수식을 입력할 수 있는 부분을 무엇이라 하는가? a. 수식 입력 줄 " }, { "title": "[데이터 정보 처리 입문] 5강 - 문서 작성", "url": "/posts/knou-dip-5/", "categories": "Data Science, Data Analysis", "tags": "knou, data information processing", "date": "2025-04-07 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김성수, 이기재 교수님의 '데이터 정보 처리 입문' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 문서를 작성한다거나, 보고서를 작성하는 데 있어서 널리 이용되고 있는 한글 2018 사용법을 공부함 한글 2018은 한글, 영문 및 기타 다양한 문자를 이용한 문서 작성, 문자 변환 기능, 표 만들기 기능 등 다양한 문서 작성에 필요한 대부분의 기능을 제공하고 있음 한글 2018을 사용하여 효율적인 문서를 작성하는데 필요한 기능을 살펴봄학습 목표 한글 2018의 기초 사용법을 이해할 수 있음 한글 2018을 이용한 문서 작성 방법을 설명할 수 있음 한글 2018을 이용한 표 작성 방법을 이해할 수 있음 한글 수식 편집기 사용 방법을 설명할 수 있음주요 용어 서식 도구 모음 문서를 작성하면서 글꼴이나 글자크기, 글자 모양, 문단모양, 또는 스타일을 지정할 수 있는 기능을 모아놓은 것 문단 정렬 방식 문단을 구성하는 단어들을 문단의 폭에 맞게 배치하는 방법으로 양쪽 정렬, 왼쪽 정렬, 오른쪽 정렬, 가운데 정렬, 배분 정렬, 나눔 정렬 중에 하나를 선택할 수 있음 다단 편집 신문이나 잡지 등에서 단행본과는 달리 하나의 쪽을 세로 방향으로 공간을 나누어 각 공간마다 글을 배치한 것 각주, 미주 문서를 작성할 때 전문적인 용어에 대한 추가적인 설명이 필요한 경우에 사용되며, 각주는 낱말이 있는 페이지의 아래쪽에 추가 설명이 위치하며, 미주는 문서의 맨 마지막에 추가 설명이 위치함 강의록한글 2018 기초 사용법한글 문서창 한글 문서창의 구성 제목 막대, 메뉴 막대, 기본 도구 막대, 서식 도구 막대, 눈금자 등으로 구성 제목 막대에는 지금 열려있는 문서의 이름과 저장된 위치가 나타남 기본 도구 모음 아이콘 새 글 문서 열기 저장하기 인쇄 미리 보기 되돌리기 다시 실행 서식 도구 모음 문서를 작성하면서 글꼴이나 글자 크기, 글자 모양, 문단 모양 또는 스타일을 지정할 수 있는 기능을 모아 놓은 것 아이콘이나 드롭 다운 목록의 형태로 구성되어 있어 대화 상자를 사용하지 않고 바로 조절할 수 있음 서식 도구 모음 항목 스타일 언어 대표 글꼴 글자 크기 진하게 기울임 밑줄 취소 선 글자 색 양쪽 정렬 왼쪽 정렬 가운데 정렬 오른쪽 정렬 배분 정렬 나눔 정렬 줄 간격 새로운 문서 작성 한글 2018을 시작한 후 [파일] - [새문서(N)] 메뉴 선택 자판의 [Space Bar]는 한 칸을 띄울 때, 다음 줄로 이동할 때는 [Enter] 키 이용 글자 지우기 [Delete] 키, [Back Space] 키 이용 문서 작성 후 저장 [파일] - [저장하기] (또는 [다른 이름으로 저장하기]) 선택 블록을 지정하여 여러 줄 지우기 지우고자 하는 내용의 처음에 커서를 놓고 마우스의 왼쪽 버튼을 눌러 원하는 곳까지 끌어줌 선택된 범위가 검은색으로 표시됨 (‘블록‘이라고 함) 블록을 잡은 후 [Delete] 키로 한꺼번에 삭제 지우기 취소는 [편집] - [되돌리기]나 기본 도구 모음의 되돌리기 아이콘을 이용 복구문자 변환 한글 글자 판을 영문으로 바꾸기 [도구] - [글자판] - [글자판 바꾸기] 또는 왼쪽 [Shift] 키와 [Space Bar] 키를 동시에 누름 또는 자판에서 [한/영] 키를 이용 영문 입력 시 [Caps Lock] 키로 대소문자 구분 한자 입력 먼저 한글로 입력하고 [입력] - [한자 입력] - [한자로 변환] 또는 [F9] 키 이용 한글 2018에서는 한 글자씩 변환과 단어 변환 지원 단축 키 Alt+N, Alt+O, Alt+S, Ctrl+X, Ctrl+C, Ctrl+V 등 메뉴 모음이나 기본 도구 모음을 이용하지 않고 명령의 실행을 도와주는 단축 키로 해당하는 단축 키를 누르면 원하는 명령이 수행 ex) 새로운 문서 창을 불러오는 경우 [파일] - [새 문서]를 이용하는 것 대신 Alt+N이라는 단축키를 이용 문자 표 이용 특수 문자 전화기 모양 그림이나, 로마자, 원 문자 등과 같이 일반적인 문자 이외의 그림이나 기호를 특수 문자라 함 특수 문자를 문서에 넣으려면 [입력] - [문자표]를 선택 또는 단축키 [Ctrl] + [F10]키를 누름 ex) ☎ 모양 입력 문자 영역에 ‘전각 기호 (일반)’으로 선택하고 역 삼각형 버튼(▼) 클릭하여 ☎ 선택 단어 검색, 변환 단어 검색, 변환 기능 특정 단어가 사용된 곳을 찾거나 그 단어를 다른 단어로 바꿀 때는 찾기나 찾아 바꾸기 기능 이용 [편집] - [찾기]나 기본 도구 모음의 찾기를 이용 특정 문자를 찾아 다른 단어로 바꾸려고 하는 경우에는 [편집] - [찾아 바꾸기]를 이용 문서 저장 문서 저장 방법 [파일] - [저장하기]나 기본 도구 모음의 저장하기 아이콘을 이용 만약 현재 편집 중인 문서를 다른 이름이나 다른 형식으로 저장하고자 하는 경우 [파일] - [다른 이름으로 저장]으로 저장 한글 종료 종료 방법 여러 개의 문서가 열려 있을 때 그 중 하나의 문서 창을 닫고자 하는 경우 [파일] - [문서 닫기] 또는 우측 상단의 X 표시 클릭 한글 작업을 마치고자 하는 경우엔 [파일] - [끝] 클릭 문서의 편집 및 인쇄블록 지정 블록 설정 문서를 복사하거나 이동하기 위해서는 먼저 블록 설정 블록 설정은 마우스로 끌거나, F3 또는 F4 키 이용 F3 키는 마우스를 이용하는 것과 마찬가지로 줄 단위로 블록 설정 F4 키는 칸 단위 블록을 지정할 때 이용 문서 전체를 블록으로 잡고자 하는 경우에는 [편집] - [모두 선택] 이용 블록 이동 또는 복사 블록 설정 부분 이동 블록 설정 내용을 다른 곳으로 옮기려면 [편집] - [오려두기] (Ctrl + X) 한 후, 원하는 위치에서 [편집] - [붙이기] (Ctrl + V) 실행 블록 설정 부분 복사 블록을 설정한 후 [편집] - [복사하기] (Ctrl + C)를 한 후, 원하는 위치에서 [편집] - [붙이기] (Ctrl + V) 실행 글자 서식 변경 글꼴 변경 신명조, 굴림체, 궁서체 등의 글자 모양을 글꼴이라고 함 원하는 범위를 블록으로 설정한 후 메뉴 [서식]이나 오른쪽 마우스를 클릭하여 나타난 빠른 메뉴에서 [글자 모양]을 클릭하면 글자 모양 대화상자가 나옴 대화 상자의 ‘글꼴’에서 원하는 글꼴 지정 글자 모양 대화 상자의 내용 장평 글자의 가로와 세로의 비율로 표시되며, 글자 크기에 대한 퍼센트 값으로 표시 일반적인 경우가 100%로 적용 됨 자간 글자와 글자 사이의 간격으로 글자 폭에 대한 비율로 표시 문단 모양 문단 모양 대화 상자 서식을 지정할 부분을 블록 설정한 후 [서식] - [문단 모양]을 눌러 대화 상자 활성화 정렬 방식 문단을 구성하는 단어들을 문단의 폭에 맞게 배치하는 방법을 말함 양쪽 정렬, 왼쪽 정렬, 오른쪽 정렬, 가운데 정렬, 배분 정렬, 나눔 정렬 중 하나 선택 여백 제본 여백 이외에 문단의 폭을 결정하는 요인 들여쓰기 문단의 첫 번째 줄을 오른쪽으로 밀어 쓰는 것 내어쓰기 문단의 첫 번째 줄을 왼쪽으로 당겨서 빼어 쓰는 것 간격 줄 간격 문단을 구성하는 줄과 줄 사이의 간격 글자에 따라 자동으로 변화되는 퍼센트(%) 단위로 설정하며 각 줄에서 가장 큰 글자의 크기를 100%로 보고, 글자의 가장 윗 부분에서 다음 줄 글자의 가장 윗 부분까지의 간격을 %로 표시 0~500% 사이에서 변경 문단 간격 문단 위 간격과 아래 간격이 있으며 문단 사이의 간격을 지정 줄 나눔 기준 문단 안의 한 낱말이 오른쪽 여백에 걸릴 때 나누는 기준 한글 ‘글자’나 ‘어절’ 단위로 정렬 가능 영문 ‘단어’나 ‘하이픈’, ‘글자’ 단위로 정렬 한글과 영문이 섞여 있는 문장에서 한글은 ‘글자’ 단위로 영문은 ‘단어’ 단위로 정렬하는 것이 바람직 함 최소 공백 (25 ~ 100%) 낱말 사이의 빈칸 간격을 일정한 범위까지 줄임으로써 줄 끝에 걸린 낱말이 다음 줄로 넘어가지 않도록 자리를 확보해주며 값이 작을수록 낱말 간격이 좁아짐 그림 삽입 [입력] - [그림] 선택 후 그림 넣기 대화 상자에서 그림 파일을 지정한 후 [열기] 클릭 그림을 삽입하고자 하는 위치에서 원하는 크기만큼 마우스를 끌어 주어 그림 삽입 다단 편집 문서에서 세로 방향으로 공간을 나누어 각 공간마다 글을 배치하는 것 [쪽] - [단] - [다단 설정] 선택 후 다단 대화상자에서 단 종류, 단 개수, 너비 및 간격 등을 설정 쪽 나누기 다단 나누기를 한 경우, 하나의 단(쪽)이 채워지지 않으면 다음 단(쪽)으로 넘어가지 않음 이럴 때 강제로 쪽(단)을 넘겨 다음으로 넘어가도록 하는 것 쪽 나누기를 하고자 하는 곳에 커서를 두고 [쪽] - [쪽 나누기]선택각주와 미주 각주와 미주 전문적인 용어에 대한 추가적인 설명을 목적으로 함 각주 낱말이 있는 페이지의 아래쪽에 설명이 옴 미주 문서의 맨 마지막에 설명이 옴 각주 설정 각주를 넣고자 하는 단어의 오른쪽에 커서를 놓고 [입력] - [주석] - [각주] 선택 후 각주 설명 입력 미주 설정 원하는 위치에서 [입력] - [주석] - [미주] 선택 후 미주 설명 입력 인쇄하기 [파일] - [편집 용지]에서 원하는 형태의 용지 지정 [파일] - [미리보기] 로 확인 후 [파일] - [인쇄] 를 선택하여 인쇄 미리 보기는 인쇄하고자 하는 내용이 어떻게 출력 될 지를 보여줌표 작성표 작성 [입력] - [표] - [표 만들기] 선택 후 줄 수와 칸 수를 지정한 후 [만들기] 클릭 표를 삽입하기 원하는 위치에서 원하는 크기가 되도록 마우스로 조정 기존의 내용을 표로 만들기 ex) 표로 구분된 텍스트를 표로 변환 표로 바꿀 문자열을 블록으로 지정 후 [입력] - [표] - [문자열을 표로]을 이용하여 쉼표를 중심으로 분리하도록 설정 표를 일반 글자로 취급 표의 가장자리에 마우스를 이동하여 마우스 모양이 사각형 화살표 모양으로 변화할 때 오른쪽 마우스를 클릭하여 [개체 속성] 메뉴 선택 ‘표/셀 속성’ 대화 상자의 [기본] 탭에서 글자처럼 취급에 체크하고 [설정] 셀 크기 변경 [F5] 키를 눌러 크기를 변경할 셀을 선택 현재 셀의 크기 만을 바꾸기 위해서는 [Shift]키를 누른 상태에서 방향 키(→, ←, ↑, ↓)를 이용 줄이나 칸 전체의 크기를 바꾸고자 하는 경우에는 [Ctrl]키를 누른 상태에서 방향 키를 사용 전체 표의 크기는 변하지 않고 단지 줄/칸을 변경하고자 하는 경우 [Alt]키를 누른 상태에서 방향 키를 사용불필요한 줄, 칸 지우기 지우려는 칸이나 줄에 있는 셀 안에 커서를 위치하거나 또는 [F5] 키를 눌러 셀 블록을 설정 [입력] - [표] - [줄/칸 지우기] 선택새로운 줄이나 칸을 삽입 [F5] 키를 눌러 셀 블록 설정 후 [표] - [줄/칸 추가하기] 선택 삽입할 항목을 설정한 후 셀을 기준으로 방향을 지정하고 [넣기]를 클릭표 만들기 예제 :실습 표 작성 줄 수는 7, 칸 수는 4인 표를 만든 후 자료 입력 줄이나 칸 간격을 조절 배경 색 지정 배경 색을 지정할 부분(셀)을 블록으로 설정 [입력] - [표] - [셀 테두리/배경] 을 선택 [셀 테두리/배경] 대화 상자에서 [배경] 탭, ‘색’, ‘면 색’ 선택 색상 팔레트에서 원하는 배경 색 선택 선 모양 바꾸기 선 모양을 변경하고자 하는 셀을 블록 설정 [표] - [셀 테두리/배경] 선택 [셀 테두리/배경] 대화 상자의 [테두리] 탭에서 선 모양을 바꿀 위치와 선 종류 설정 한글 2018의 수식 편집 [입력] - [수식] 또는 기본 도구 모음의 수식 아이콘 이용 → 수식 편집 창 활성화 Ctrl + NM(Ctrl 키를 누른 채로 N과 M을 누름)도 동일한 기능 수식 입력 ex) x^3 - 2x^2 + 3 = 7 입력 지수 형태 아이콘 선택 후 수식 입력 창의 { }^{ }에 x와 3을 순서대로 입력하여 수식 전체를 입력한 후 ‘넣기’ 클릭 ex) 9^4 + 3√197 수식 입력 9^4 은 지수 입력 아이콘 이용 3√197은 제곱근 입력 아이콘 이용 연습 문제 한글 2018의 수식편집기창을 이용하여 다음 수식을 작성하고자 한다. 수식c편집창의 다음 (           ) 안의 a, b 에 적합한 것은? f(x) = ( a ) { 1, &amp; 0 leq x leq 1 ( b ) 0, &amp; 아닐 ~때 } a. a=cases, b=# 다음은 한글 2018 사용법에 대한 설명이다. 옳은 설명을 모두 고른 것은? Ⅰ. 복사나 이동을 위한 블록 지정에서 F3는 칸 단위 블록 설정, F4는 줄 단위 블록을 지정할 수 있다. Ⅱ. 신문이나 잡지 등에서 사용되고 있는 다단 편집의 기능은 제공하고 있다. Ⅲ. 그림을 삽입하여 문서를 작성할 수 있다. a. Ⅱ, Ⅲ 다음은 한글 2018 사용법에서 한자 변환에 대한 설명이다. 옳은 설명을 모두 고른 것은?  Ⅰ. 한자로 된 단어를 입력하고자 하는 경우는 먼저 한글로 해당 단어를 입력하고 [입력] - [한자로 변화]을 이용하여 변환한다. Ⅱ. [F5] 키를 이용하면 [입력] - [한자 입력]을 대신할 수 있다. Ⅲ. 두 글자 이상의 단어는 [F3] 키로 블록으로 잡아 한자로 변환시킬 수 있다. a. Ⅰ, Ⅲ 다음 괄호 안에 알맞은 용어로 짝 지어진 것은? 문서를 작성하다 보면 전문적인 용어에 대한 추가적인 설명이 필요한 경우가 있다. 이 때 이용할 수 있는 것이 ( ㉠ )와(과) ( ㉡ )이다. ( ㉠ )는(은) 낱말이 있는 페이지의 아래쪽에 추가 설명이 위치하며, ( ㉡ )는(은) 문서의 맨 마지막에 온다는 점에서 차이가 있다. a. ㉠ : 각주  ㉡ : 미주 수식편집기창을 이용하여 다음 수식을 작성하고자 한다. 수식편집창의 다음 (           ) 안의 ㉠, ㉡, ㉢에 적합한 것은?  ( ㉠ )^2 ~ ( ㉡ ) =~ sum {( 관측도수 - 기대도수 )^2 } ( ㉢ ) 기대도수 # ( ㉡ ) =~ sum { ( f_{i`j`} - {hat f}_{i`j`} )^2 } ( ㉢ ) {hat f}_{i`j`}} a. ㉠ : chi,   ㉡ : &amp;,  ㉢ : over " }, { "title": "[운영 체제] 5강 - 병행 프로세스", "url": "/posts/knou-os-5/", "categories": "OS, Operating System", "tags": "knou, os", "date": "2025-04-06 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김진욱 교수님의 '운영 체제' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 병행 프로세스 중 협력 프로세스에서 발생할 수 있는 구체적인 문제로 생산자-소비자 문제와 판독기-기록기 문제가 있음 협력 프로세스 사이에는 데이터를 공유하기 위해 통신이 필수인데, 이 과정에서도 다양한 문제가 발생할 수 있음 생산자-소비자 문제, 판독기-기록기 문제의 예를 통해 협력 프로세스의 일반적 구현 방법을 학습함 병행 프로세스 사이의 통신을 위한 방법에 대해 논리적 측면에서 살펴봄학습 목표 생산자-소비자 문제를 알아보고, 세마포어를 이용하여 해결할 수 있음 판독기-기록기 문제를 알아보고, 세마포어를 이용하여 해결할 수 있음 프로세스 간 통신을 위한 논리적 구조를 설명할 수 있음강의록생산자-소비자 문제생산자-소비자 문제 정의 두 협력 프로세스 사이에 버퍼를 두고 생산자와 소비자의 상황을 다루는 문제 생산자 데이터를 넣는 프로세스 소비자 데이터를 꺼내는 프로세스 생산자-소비자 문제 조건 버퍼에 여러 프로세스가 동시에 접근할 수 없음 버퍼에 데이터를 넣는 동안에는 데이터를 꺼낼 수 없음 버퍼에서 데이터를 꺼내는 동안에는 데이터를 넣을 수 없음 상호 배제 필요 버퍼의 크기가 유한 (유한 버퍼 문제) 버퍼가 가득 찬 경우 생산자는 대기해야 함 버퍼가 빈 경우 소비자는 대기해야 함 동기화 필요 세마포어를 이용한 해결 상호 배제: 세마포어 mutex (초깃 값 1) P(mutex) 세마포어 변수 S의 값을 1 감소 시킴 만약 S 값이 0보다 작아지면 해당 프로세스는 S 값이 0 이상이 될 때까지 대기(block) V(mutex) 세마포어 변수 S의 값을 1 증가 시킴 만약 이 증가로 인해 S 값이 0보다 커지면 대기 중인 프로세스 중 하나를 깨움 생산자의 코드 While (true) { 데이터를 생산 \t P(mutex);\t// 진입 영역 버퍼에 데이터를 넣음 // 임계 영역 V(mutex); // 해제 영역 } 소비자의 코드 While(true) { P(mutex); // 진입 영역 버퍼에서 데이터를 꺼냄 // 임계 영역 V(mutex); // 해제 영역 데이터를 소비 } 버퍼가 가득 찬 경우 동기화: 세마포어 empty(초깃 값 n) n 버퍼 크기 생산자의 코드 While (true) { 데이터를 생산 P(empty); // 버퍼에 빈 공간이 있는지 확인 P(mutex); // 버퍼 접근 권한 획득 (다른 프로세스 접근 금지) 버퍼에 데이터를 넣음 V(mutex); } 소비자의 코드 While(true) { P(mutex); 버퍼에서 데이터를 꺼냄 V(mutex); V(empty); // 빈 공간이 생겼음을 알림 데이터를 소비 } 버퍼가 빈 경우 동기화: 세마포어 full(초깃 값 0) 생산자의 코드 While (true) { 데이터를 생산 P(empty); P(mutex); 버퍼에 데이터를 넣음 V(mutex); V(full); // 버퍼에 데이터가 채워졌음을 알림 } 소비자의 코드 While(true) { P(full); // 버퍼에 데이터가 있는지 확인 P(mutex); 버퍼에서 데이터를 꺼냄 V(mutex); V(empty); 데이터를 소비 } 3개의 세마포어: mutex(초깃 값 1), empty(초깃 값 n), full(초깃 값 0) mutex 상호 배제를 위한 이진 세마포어 (초깃 값 1) 버퍼 자체에 동시에 접근하는 것을 막음 empty 비어있는 버퍼 슬롯의 개수를 나타내는 계수 세마포어 (초깃 값 n, n=버퍼 크기) full 채워진 버퍼 슬롯의 개수를 나타내는 계수 세마포어 (초깃 값 0) 판독기-기록기 문제판독기-기록기 문제 정의 여러 협력 프로세스 사이에 공유 자원을 두고 판독기와 기록기의 상황을 다루는 문제 판독기(Reader) 데이터를 읽는 프로세스 기록기(Writer) 데이터를 쓰는 프로세스 판독기-기록기 문제 조건 하나의 기록기가 공유 자원에 데이터를 쓰는 중에는 다른 기록기나 판독기는 공유 자원에 접근할 수 없음 공유 자원에 데이터를 쓰는 동안에는 누구도 접근할 수 없음 (기록기 배타적 접근) 공유 자원에서 데이터를 읽는 동안에는 데이터를 쓸 수 없음 (판독 중 기록 불가) 상호 배제 필요 여러 판독기는 동시에 공유 자원에서 데이터를 읽을 수 있음 판독기가 읽는 중 새로운 판독기 읽기 시도 → 가능 판독기가 읽는 중 기록기 대기 → 새로운 판독기 읽기 시도 → 가능/불가능 제1 판독기 - 기록기 문제 판독기가 공유 자원에 접근 중이라면 기록기보다 판독기에 우선 순위를 줌 즉, 새로운 판독기는 즉시 공유 자원에 접근 가능 문제점 기록기의 기아 상태 유발 가능 세마포어를 이용한 해결(판독기 우선) 상호 배제: 세마포어 wrt (초깃값 1) 기록기의 코드 P(wrt); 공유자원에 쓰기 V(wrt); 판독기의 코드 P(wrt); 공유자원에서 읽기 V(wrt); 문제점 판독기 간 병행성 없음 한 번에 하나의 판독기만 가능 판독기 우선 : 일반 변수 rcount(초깃 값 0), 세마포어 mutex(초깃 값 1) 2개의 세마포어 wrt(초깃 값 1), mutex(초깃 값 1), 일반 변수 rcount(초깃 값 0) P(wrt); // 공유 자원에 쓰기 V(wrt); 판독기의 코드 P(mutex); // rcount 보호 임계 영역 rcount = rcount + 1; // 읽으려는 판독기의 개수 표현 if (rcount == 1) P(wrt); // 판독기가 이미 읽고 있는 상황이면 P연산자 바이패스 가능 V(mutex); 공유자원에서 읽기 P(mutex); // rcount 보호 임계 영역 rcount = rcount - 1; if (rcount == 0) V(wrt); // 마지막 판독기가 쓰기 허용 V(mutex); 문제점 기록기 기아 상태 발생 가능 판독기가 계속 들어오면 기록기 영원히 대기 제2 판독기 - 기록기 문제 판독기가 공유 자원에 접근 중이라면 판독기보다 기록기에 우선 순위를 줌 즉, 대기 중인 기록기가 있다면 새로운 판독기는 공유 자원에 접근 불가능 문제점 판독기의 병행성이 떨어짐 판독기의 기아 상태 유발 가능 세마포어를 이용한 해결(기록기 우선) 5개의 세마포어 rd(초깃 값 1), wrt(초깃 값 1), mutex1(초깃 값 1), mutex2(초깃 값 1), mutex3(초깃 값 1) 기록기의 코드 P(mutex2); // wcount 보호 wcount = wcount + 1; if (wcount == 1) P(rd); // 첫 기록기가 판독 금지 V(mutex2); P(wrt); // 쓰기 작업 자체 보호 공유자원에 쓰기 V(wrt); P(mutex2); // wcount 보호 wcount = wcount - 1; if (wcount == 0) V(rd); // 마지막 기록기가 판독 허용 V(mutex2); 판독기의 코드 P(mutex3); // 판독기 진입 경쟁 관리 P(rd); // 기록기가 없을 때만 진입 허용 P(mutex1); // rcount 보호 rcount = rcount + 1; if (rcount == 1) P(wrt); // 첫 판독기가 쓰기 금지 V(mutex1); V(rd); V(mutex3); 공유자원에서 읽기 P(mutex1); // rcount 보호 rcount = rcount - 1; if (rcount == 0) V(wrt); // 마지막 판독기가 쓰기 허용 V(mutex1); 프로세스 간 통신프로세스 간 통신 (IPC) Inter-Process Communication 병행 프로세스가 데이터를 서로 공유하는 방법 공유 메모리 방법 메시지 전달 방법 하나의 운영 체제에서 두 방법 함께 사용 가능공유 메모리 방법 협력 프로세스가 동일한 변수를 사용 동일한 변수 : 공유 자원인 메모리 공간 사용 ex) 생산자-소비자 문제의 유한 버퍼 판독기-기록기 문제의 공유 자원 대량 데이터 교환 고속 통신 가능 통신 상 발생 가능 문제 해결 응용 프로그래머 메시지 전달 방법 협력 프로세스가 메세지를 주고 받음 시스템 호출 send(), receive() 사용 소량 데이터 교환에 적합 인자 값으로 데이터 전달 통신 상 발생 가능 문제 해결 운영 체제 메세지 전달 방법의 논리적 구조 통신 링크 메시지가 지나다니는 통로 통신 링크의 구현 형태 연결 대상 두 프로세스, 셋 이상 프로세스 두 프로세스 사이 링크 개수 하나, 둘 이상 방향성 단방향 , 양방향 용량 무한, 유한, 0 통신 링크의 용량 무한 송신자는 대기 없음 유한 송신자는 큐가 가득 차면 대기 0 송신자는 수신자가 메시지를 받을 수 있을 때까지 대기 직접 통신 두 프로세스가 직접 서로를 지정하여 메세지 전달 송수신 시 명시적으로 상대방 프로세스 지정 send(B, message) 프로세스 B에게 메시지를 보냄 receive(A, message) 프로세스 A로부터 메시지를 받음 오직 하나의 통신 링크가 자동 설정 하나의 통신 링크는 오직 두 프로세스 사이에만 연관 통신 링크는 양방향 대칭형 주소 지정 비대칭 주소 지정 수신자가 여러 송신자와 통신 링크를 갖는 경우 사용 간접 통신 프로세스 사이에 둔 우편함을 통해 메세지 전달 send(X, message) 우편함 X에 메시지를 보냄 receive(X, message) 우편함 X에서 메시지를 받음 같은 우편함을 이용하는 경우 통신 링크 설정 여러 우편함을 이용하면 여러 개의 통신 링크 존재 하나의 통신 링크가 여러 프로세스와 연관 가능 통신 링크는 단방향 또는 양방향 우편함이 수신 프로세스에 소속 수신자 하나 통신 링크는 단방향 수신 프로세스가 종료하면 우편함도 사라짐 우편함이 운영 체제에 소속 수신자 여럿 한순간에 하나의 수신자만 가능 운영 체제가 수신자 관리 통신 링크는 양방향 정리 하기 생산자-소비자 문제는 상호 배제와 동기화가 필요한 문제로 세마포어를 이용하여 구현할 수 있음 판독기-기록기 문제는 기록기는 상호 배제가 필요하나 판독기는 상황에 따라 다른 처리가 필요한 문제로 세마포어를 이용하여 구현할 수 있음 판독기-기록기 문제는 특정 상황에서 판독기에 우선순위를 주는 형태의 문제와 기록기에 우선순위를 주는 형태의 문제로 정의할 수 있음 프로세스 간 통신 방법에는 공유 메모리 방법과 메시지 전달 방법이 있음 공유 메모리 방법은 협력 프로세스가 공유 메모리를 이용하는 동일한 변수를 사용함으로써 데이터를 서로 공유하는 방법임 메시지 전달 방법은 협력 프로세스가 메시지를 주고받으면서 데이터를 서로 공유하는 방법임 메시지 전달 방법에는 송신자와 수신자가 직접 서로를 지정하여 메시지를 주고받는 직접 통신 방법과 우편함을 통하여 메시지를 주고받는 간접 통신 방법이 있음" }, { "title": "[데이터베이스 시스템] 5강 - SQL", "url": "/posts/knou-dbs-5/", "categories": "Database", "tags": "knou, database", "date": "2025-04-06 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '데이터베이스 시스템' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 DBMS의 기능은 데이터의 저장 및 관리에 그치지 않고 사용자의 요청에 따라 데이터의 입력, 수정, 삭제 및 필요 데이터를 신속히 제공하는 것까지 포함함 SQL은 데이터 정의 언어를 통해 데이터를 저장하고 유지할 수 있는 데이터베이스 객체를 관리하는 기능을 제공할 뿐만 아니라 데이터 조작 언어를 통해 데이터베이스 객체에 데이터를 생성, 수정, 삭제 및 검색할 수 있는 기능을 제공 함 데이터 조작 언어를 통해 데이터를 사용할 수 있는 방법과 다양한 조건을 만족하는 데이터를 검색하는 방법에 대하여 학습 함주요 용어 DML 정의된 테이블에 레코드를 삽입·수정·삭제 및 검색하는데 사용되는 명령어의 집합 SELECT 셀렉션, 프로젝션, 조인, 카티션 프로덕트 연산자 등 관계 대수의 기능을 포함하고 있는 명령문 DISTINCT SELECT 문을 통해 검색된 결과에서 특정 컬럼의 중복된 데이터를 제거하는 키워드 조건 SELECT 문 산술 연산 식, 함수 등을 사용하여 표현한 조건을 WHERE 절에 기술하여 조건을 만족하는 레코드만 선택적으로 검색하는 SELECT 문 강의록데이터의 삽입데이터 조작 언어(DML)의 개념 데이터 정의 언어(DDL)로 정의된 데이터베이스 내의 데이터에 대해 여러 연산을 수행하기 위한 명령어의 집합 사용자에게 데이터베이스에 저장된 데이터를 처리할 수 있게 하는 일체의 도구를 제공 정의된 테이블 등에 레코드를 삽입(INSERT), 수정(UPDATE), 삭제(DELETE) 및 검색(SELECT)하는 데 사용되는 SQL 명령어들의 집합 데이터 조작 언어는 실행 즉시 반영되는 영구적 변경을 위한 명령어 집합이 아니며 복구가 가능 DDL과의 큰 차이점 명령어의 종류 CRUD를 위한 SQL 명령어의 종류 작업 (CRUD) SQL 명령어 설명 Create INSERT 테이블 스키마에 적합한 레코드를 삽입 Update UPDATE 테이블에서 조건을 만족하는 특정 레코드의 컬럼 값을 수정 Delete DELETE 테이블에 조건을 만족하는 특정 레코드를 삭제 Read SELECT 조건을 만족하는 레코드를 테이블에서 검색 INSERT명령어 테이블에 새로운 레코드(행)를 삽입하는 명령어 모든 컬럼 또는 부분 컬럼에 대한 값을 입력 NOT NULL제약 조건이 있는 컬럼은 반드시 컬럼 값을 입력 문자와 날짜 값은 따옴표(')로 처리 모든 컬럼 값 순서대로 입력 INSERT INTO 테이블_이름 VALUES (값1, 값2, ..., 값n); 모든 컬럼 값에 해당하는 값들이 values()있을 경우에 사용 values()내 값들이 나열된 순서와 테이블에 정의된 컬럼 순서가 반드시 일치해야 함 특정 컬럼 값 입력 INSERT INTO 테이블_이름 (컬럼1, 컬럼2, ..., 컬럼m) VALUES (값1, 값2, ..., 값m); INSERT문의 사용 학과이름 ‘영어영문학과’, 단과대학 ‘인문과학대학’, 주소 ‘http://eng.knou.ac.kr’, 전화번호 ‘02-3668-4510’, 졸업학점 135인 레코드를 학과 테이블에 삽입하시오 학과이름 단과대학 주소 전화번호 졸업학점 국어국문학과 인문과학대학 … 02-3668-4550 120 법학과 사회과학대학 … 02-3668-4590 130 생활과학과 자연과학대학 … 02-3668-4640 125 유아교육과 교육학과대학 … 02-3668-4670 125 컴퓨터학과 자연과학대학 … 02-3668-4650 130 행정학과 사회과학대학 … 02-3668-4600 120 INSERT INTO 학과 VALUES ('영어영문학과', '인문과학대학', 'http://eng.knou.ac.kr', '02-3668-4510', 135); 학과이름 단과대학 주소 전화번호 졸업학점 국어국문학과 인문과학대학 … 02-3668-4550 120 법학과 사회과학대학 … 02-3668-4590 130 생활과학과 자연과학대학 … 02-3668-4640 125 유아교육과 교육학과대학 … 02-3668-4670 125 컴퓨터학과 자연과학대학 … 02-3668-4650 130 행정학과 사회과학대학 … 02-3668-4600 120 영어영문학과 인문과학대학 … 02-3668-4510 135 단과대학 ‘자연과학대학’, 학과이름 ‘농학과’, 졸업학점 140, 전화번호 ‘02-3668-4600’인 레코드를 학과 테이블에 삽입하시오 학과이름 단과대학 주소 전화번호 졸업학점 국어국문학과 인문과학대학 … 02-3668-4550 120 법학과 사회과학대학 … 02-3668-4590 130 생활과학과 자연과학대학 … 02-3668-4640 125 유아교육과 교육학과대학 … 02-3668-4670 125 컴퓨터학과 자연과학대학 … 02-3668-4650 130 행정학과 사회과학대학 … 02-3668-4600 120 영어영문학과 인문과학대학 … 02-3668-4510 135 INSERT INTO 학과 (단과대학, 학과이름, 졸업학점, 전화번호) VALUES ('자연과학대학', '농학과', 140, '02-3668-4600'); 학과이름 단과대학 주소 전화번호 졸업학점 국어국문학과 인문과학대학 … 02-3668-4550 120 법학과 사회과학대학 … 02-3668-4590 130 생활과학과 자연과학대학 … 02-3668-4640 125 유아교육과 교육학과대학 … 02-3668-4670 125 컴퓨터학과 자연과학대학 … 02-3668-4650 130 행정학과 사회과학대학 … 02-3668-4600 120 영어영문학과 인문과학대학 … 02-3668-4510 135 농학과 자연과학대학 … 02-3668-4600 140 주소 값은 null로 유지 됨 INSERT문의 활용 컴퓨터 과학과 소속의 교수를 교수 테이블과 동일한 스키마를 갖는 IT 전공 교수 테이블에 삽입하시오 교수 교수번호 교수이름 직위 소속학과 연봉 186432-760829 최우성 조교수 생활학과 52000000 189414-790829 한용운 조교수 법학과 45000000 191924-730620 이동휘 부교수 행정학과 51000000 194634-810228 김규식 정교수 컴퓨터학과 70000000 194834-760517 정재화 부교수 컴퓨터학과 53000000 IT전공교수 교수번호 교수이름 직위 소속학과 연봉 194634-810228 김규식 정교수 컴퓨터학과 70000000 194834-760517 정재화 부교수 컴퓨터학과 53000000 레코드의 값들을 다른 테이블의 레코드로 삽입 가능 테이블에서 검색의 결과를 새로운 레코드로 삽입 시 사용 가능 INSERT INTO 테이블이름₁ (컬럼₁, 컬럼₂, ..., 컬럼ₘ) SELECT 컬럼₁, 컬럼₂, ..., 컬럼ₘ FROM 테이블이름₂ WHERE 검색조건; -- '교수' 테이블에서 '컴퓨터과학과' 소속 교수 정보를 검색하여 'IT전공교수' 테이블에 새로운 레코드로 삽입 INSERT INTO IT전공교수 (교수번호, 교수이름, 직위, 소속학과, 연봉) SELECT 교수번호, 교수이름, 직위, 소속학과, 연봉 FROM 교수 WHERE 소속학과 = '컴퓨터과학과'; sql도 가독성을 고려하면 좋음 values뒤 값들은 콤마(,)로 구분 문자는 반드시 ‘‘(따옴표) 처리 필요 숫자는 int 값이므로 ‘‘(따옴표) 필요 없음데이터의 수정과 삭제UPDATE명령어 조건을 만족하는 레코드의 특정 컬럼 값을 수정 UPDATE 테이블_이름 SET 컬럼₁ = 값₁[, 컬럼₂ = 값₂, ..., 컬럼ₙ = 값ₙ] WHERE 조건; UPDATE 테이블_이름 SET 컬럼₁ = 수식₁[, 컬럼₂ = 수식₂, ..., 컬럼ₙ = 수식ₙ] WHERE 조건; WHERE절을 사용하여 수정할 레코드를 특정 WHERE절을 생략하면 테이블의 모든 레코드 값이 변경 됨 특정 레코드의 컬럼 값을 삭제하려면 UPDATE문을 사용 column 값을 null로 UPDATE SET UPDATE명령어의 사용 학과 이름이 ‘농학과’인 레코드의 주소 컬럼 값을 ‘http://agri.knou.ac.kr’로 수정하시오 학과이름 단과대학 주소 전화번호 졸업학점 국어국문학과 인문과학대학 … 02-3668-4550 120 법학과 사회과학대학 … 02-3668-4590 130 생활과학과 자연과학대학 … 02-3668-4640 125 유아교육과 교육학과대학 … 02-3668-4670 125 컴퓨터학과 자연과학대학 … 02-3668-4650 130 행정학과 사회과학대학 … 02-3668-4600 120 영어영문학과 인문과학대학 … 02-3668-4510 135 농학과 자연과학대학 … 02-3668-4600 140 UPDATE 학과 SET 주소 = 'http://agri.knou.ac.kr' WHERE 학과이름 = '농학과'; 학과이름 단과대학 주소 전화번호 졸업학점 국어국문학과 인문과학대학 … 02-3668-4550 120 법학과 사회과학대학 … 02-3668-4590 130 생활과학과 자연과학대학 … 02-3668-4640 125 유아교육과 교육학과대학 … 02-3668-4670 125 컴퓨터학과 자연과학대학 … 02-3668-4650 130 행정학과 사회과학대학 … 02-3668-4600 120 영어영문학과 인문과학대학 … 02-3668-4510 135 농학과 자연과학대학 http://agri.knou.ac.kr 02-3668-4600 140 학과 테이블에서 ‘생활과학과’의 전화번호와 졸업학점을 ‘02-3668-4641’과 130으로 수정하시오 학과이름 단과대학 주소 전화번호 졸업학점 국어국문학과 인문과학대학 … 02-3668-4550 120 법학과 사회과학대학 … 02-3668-4590 130 생활과학과 자연과학대학 … 02-3668-4640 125 유아교육과 교육학과대학 … 02-3668-4670 125 컴퓨터학과 자연과학대학 … 02-3668-4650 130 행정학과 사회과학대학 … 02-3668-4600 120 영어영문학과 인문과학대학 … 02-3668-4510 135 농학과 자연과학대학 … 02-3668-4600 140 UPDATE 학과 SET 전화번호 = '02-3668-4641', 졸업학점 = 130 WHERE 학과이름 = '생활과학과' 학과이름 단과대학 주소 전화번호 졸업학점 국어국문학과 인문과학대학 … 02-3668-4550 120 법학과 사회과학대학 … 02-3668-4590 130 생활과학과 자연과학대학 … 02-3668-4641 130 유아교육과 교육학과대학 … 02-3668-4670 125 컴퓨터학과 자연과학대학 … 02-3668-4650 130 행정학과 사회과학대학 … 02-3668-4600 120 영어영문학과 인문과학대학 … 02-3668-4510 135 농학과 자연과학대학 … 02-3668-4600 140 잔액이 500,000원 이상인 학생 계좌에 2% 이자를 지급하시오 학생번호 계좌번호 잔액 201831-331215 123434-222222 800000 201834-021216 123434-111111 600000 201978-610408 123434-333333 400000 201931-781109 123434-444444 400000 201926-880215 123434-555555 300000 201934-790902 123434-666666 100000 201934-080621 123434-777777 300000 202034-596541 123434-888888 1200000 202031-816515 123434-999999 150000 202031-354516 123435-111111 1000000 202078-080621 123435-222222 500000 202026-590930 123435-333333 450000 UPDATE 계좌 SET 잔액 = 잔액 + 잔액 * 0.02 WHERE 잔액 &gt;= 500000; 학생번호 계좌번호 잔액 201831-331215 123434-222222 816000 201834-021216 123434-111111 612000 201978-610408 123434-333333 400000 201931-781109 123434-444444 400000 201926-880215 123434-555555 300000 201934-790902 123434-666666 100000 201934-080621 123434-777777 300000 202034-596541 123434-888888 1224000 202031-816515 123434-999999 150000 202031-354516 123435-111111 1020000 202078-080621 123435-222222 510000 202026-590930 123435-333333 450000 WHERE절을 사용하지 않을 경우 테이블 내 모든 레코드의 잔액 값이 변경 됨 DELETE문 조건에 일치하는 레코드의 집합을 테이블에서 삭제할 때 사용하는 명령어 DELETE FROM 테이블_이름 \tWHERE 조건; WHERE절을 사용하여 삭제할 레코드를 특정 WHERE절을 생략하면 테이블의 모든 레코드가 삭제 됨 정보의 삭제는 레코드 단위 DELETE문의 사용 소속학과가 ‘유아교육과’인 교수의 레코드를 삭제하라. DELETE FROM 교수 \tWHERE 소속학과 = '유아교육과'; 모든 강의 레코드를 삭제하시오 DELETE FROM 강의 테이블 구조는 그대로 두고 데이터만 삭제 함 테이블 구조까지 완전히 삭제하려면 DROP TABLE명령어를 사용해야 함 WHERE절 확인 WHERE절이 없는 UPDATE및 DELETE문은 전체 테이블을 대상으로 실행 잔액이 500,000원 이상인 학생 계좌에 2% 이자를 지급하시오 UPDATE 계좌 \tSET 잔액 = 잔액 + 잔액 * 0.02 \tWHERE 잔액 &gt;= 500000; 소속학과가 ‘유아교육과’인 교수의 레코드를 삭제하라. DELETE FROM 교수 \tWHERE 소속학과 = '유아교육과'; 데이터의 검색SELECT명령어 DBMS의 가장 큰 기능인 저장, 관리, 검색 한 개 이상의 테이블에서 주어진 조건에 만족하는 레코드로 출력하는 명령어 원하는 데이터를 검색(조회)하는 데 사용하는 가장 기본적이고 중요한 명령어 이미 존재하는 데이터 값을 가져온다는 점이 특징 관계 대수의 셀렉션, 프로젝션, 조인, 카티션 프로덕트 연산자의 기능을 모두 포함하는 명령문 필수 절인 SELECT절과 부가적인 목적으로 사용하는 절을 혼합하여 검색 기능을 구체화 SELECT의 구문 형식[DISTINCT] 컬럼₁, 컬럼₂, ..., 컬럼ₙFROM 테이블₁ [INNER JOIN | OUTER JOIN 테이블₂, INNER JOIN | OUTER JOIN ON 조인 조건식₁ 테이블₃ ..., INNER JOIN | OUTER JOIN 테이블ₘ ON 조인 조건식ₙ][WHERE 조건식 [중첩질의]][GROUP BY 컬럼₁, 컬럼₂, ..., 컬럼ᵧ [HAVING 조건]][ORDER BY 컬럼₁ [ASC | DESC], ... , 컬럼𝓏 [ASC | DESC]] SELECT절 결과에 포함되는 컬럼을 지정 FROM절 질의를 적용할 테이블을 지정 ON절 조인 조건을 지정 WHERE절 검색 대상 레코드의 조건을 지정 GROUP BY절 레코드를 그룹화 하기 위한 그룹 조건을 지정 특정 컬럼을 기준으로 그룹화 함 HAVING절 GROUP BY절이 적용된 결과에 대한 조건을 지정 ORDER BY절 검색 결과의 정렬 기준을 지정 결과를 특정 컬럼 기준으로 정렬 ASC: 오름차순 DESC: 내림차순 단순 SELECT문 레코드를 제한하지 않고 전체 테이블을 검색하는 SELECT문 WHERE절이 없는 질의문 DISTINCT키워드를 통해 중복 제거 가능 물리적인 값으로 구성된 테이블은 추상적인 개념의 릴레이션과 달리 중복이 발생할 수도 있음 특정 컬럼만 검색 SELECT [DISTINCT] 컬럼₁, 컬럼₂, ..., 컬럼ₙ FROM 테이블 모든 컬럼 검색 SELECT * FROM 테이블 단순 SELECT문의 사용 교수 테이블에서 ‘소속학과’ 컬럼을 선택하여 출력하시오 SELECT 소속학과 FROM 교수 | 교수번호 | 교수이름 | 직위 | 소속학과 | 연봉 | |—|—|—|—|—| | 186432-760829 | 최우성 | 조교수 | 생활학과 | 52000000 | | 189414-790829 | 한용운 | 조교수 | 법학과 | 45000000 | | 191924-730620 | 이동휘 | 부교수 | 행정학과 | 51000000 | | 194634-810228 | 김규식 | 정교수 | 컴퓨터학과 | 70000000 | | 194834-760517 | 정재화 | 부교수 | 컴퓨터학과 | 53000000 | | 201216-158465 | 정용제 | 조교수 | 국어국문학과 | 55000000 | | 201547-634895 | 현경석 | 정교수 | 생활학과 | 66000000 | | 210315-549413 | 황지수 | 부교수 | 유아교육과 | 52000000 | 소속학과 생활학과 법학과 행정학과 컴퓨터학과 컴퓨터학과 국어국문학과 생활학과 유아교육과 SELECT DISTINCT 소속학과 FROM 교수 소속학과 생활학과 법학과 행정학과 컴퓨터학과 국어국문학과 유아교육과 조건 SELECT문 산술 연산식, 함수 등을 사용하여 표현한 조건을 WHERE절에 기술하여 조건을 만족하는 레코드만 선택적으로 검색하는 SELECT문 산술 연산자 비교 연산자 논리 연산자 WHERE절은 UPDATE, DELETE문 등 조건을 기술하여 선택적으로 레코드에 적용하는 명령문에서 동일하게 사용조건 표현 연산자 산술 연산자 컬럼값 또는 상수와의 산술 연산을 위한 연산자 DIV, /, -, MOD(%), +, * 비교 연산자 컬럼 값과 상수의 크기를 비교하는 연산자 =, &lt;&gt;, (!=), &gt;, &gt;=, &lt;, &lt;= 논리 연산자 두 개 이상의 조건이 기술되는 질의 문에서 조건 식 간의 관계를 정의하는 연산자 AND, OR, NOT 조건 SELECT문의 사용 이수구분 ‘전공필수’인 과목의 과목명, 학점, 선수과목을 출력하시오 SELECT 과목명, 학점, 선수과목 FROM 과목 \tWHERE 이수구분 = '전공필수' 이수 구분이 전공필수 인 조건을 어떻게 표시할지 세 컬럼들만 표시하려면 어떻게 명시 해야 할지 남학생 중 2000년 이전에 태어난 학생의 학생번호, 학생이름, 성별, 나이, 전화번호를 출력하시오 학생번호 학생이름 성별 생년월일 나이 전화번호 201831-331215 김마리아 여 1991-06-18 29 010-0000-0002 201834-021216 유관순 여 1902-12-16 118 010-0000-0001 201926-880215 지청천 여 1988-02-15 32 010-0000-0005 201931-781109 안창호 남 1978-11-09 42 010-0000-0004 201934-080621 박은식 여 1959-09-30 61 010-0000-0007 201934-790902 안중근 남 1979-09-02 41 010-0000-0006 SELECT 학생번호, 학생이름, 성별, 나이, 전화번호 FROM 학생 \tWHERE 성별 = '남' AND 생년월일 &lt; '2000-1-1' 학생번호 학생이름 성별 나이 전화번호 201931-781109 안창호 남 42 010-0000-0004 201934-790902 안중근 남 41 010-0000-0006 201978-610408 손병희 남 59 010-0000-0003 202031-816515 윤봉길 남 112 010-0000-0009 202078-080621 강신영 남 29 010-0000-0011 연습 문제 다음과 같은 구조의 고객 테이블에 고객번호 ‘C540’, 연락처 ‘1234’, 직장주소 ‘서울시 종로구’, 고객이름 ‘홍길동’인 새로운 고객 레코드를 삽입하는 INSERT문으로 올바른 것은? (단, 입력하는 값의 순서는 변경하지 않는다.) 고객 고객번호(PK) 고객이름 직장주소 연락처         a. INSERT INTO 고객(고객번호, 연락처, 직장주소, 고객이름) VALUES ('C540', '1234', '서울시 종로구', '홍길동') 새로운 레코드 삽입은 INSERT INTO 문을 사용하며, 부분 컬럼에 대한 컬럼 값을 삽입하거나 테이블의 컬럼 순서와 다른 순서로 컬럼 값을 삽입하는 경우, 테이블 이름에 컬럼 값에 해당하는 컬럼 이름을 병기 해야 함 다음 SQL 구문의 (      )안에 필요한 단어는? UPDATE 테이블 이름 ( ) 필드 = 식 [,필드 = 식].... [WHERE 술어]; a. SET UPDATE문은 테이블 내에 특정 조건을 만족하는 레코드의 값을 변경하는 명령문으로, UPDATE 테이블 이름 SET 필드 및 값 리스트 WHERE 조건 형식을 따름 다음 SQL 구문에서 (      )안에 알맞은 것은? DELETE ( ) 테이블 [WHERE 조건]; a. FROM DELETE문은 FROM절에 기술된 테이블에 포함된 레코드를 WHERE절에서 기술되는 조건에 따라 삭제하는 명령을 수행 함 다음의 고객 테이블에서 아래의 SQL의 실행 결과로 올바른 것은? 고객 고객번호(PK) 고객이름 직장주소 연락처 C540 홍길동 서울시 종로구 1234 C101 김영희 서울시 종로구 5678 C211 신채호 광주시 광산구 1111 C343 이희영 부산시 북구 2222 SELECT DISTINCT 직장 주소 FROM 고객 a. 직장주소 서울시 종로구 광주시 광산구 부산시 북구 SELECT절은 출력될 컬럼을 결정하며, DISTINCT키워드가 적용되면 중복된 컬럼 값은 제거되어 출력 됨 정리 하기 데이터 조작 언어에는 INSERT, UPDATE, DELETE, SELECT명령어가 포함 됨 각각의 명령어는 테이블에 새로운 레코드를 삽입, 수정, 삭제 및 검색하는 기능을 수행 함 INSERT문은 테이블의 스키마에 맞춰 일부 또는 전체 컬럼을 대상으로 데이터를 삽입하는 명령문임 UPDATE는 WHERE절에 기술되는 조건을 만족하는 레코드를 대상으로 SET절을 사용하여 특정 컬럼의 값을 수정하는 명령어 임 DELETE는 WHERE절에 기술되는 조건을 만족하는 레코드를 삭제 함 레코드 삭제로 테이블의 제약 조건이 위배되는 경우 DELETE명령은 거부 됨 SELECT문은 테이블에서 다양한 형태로 데이터를 검색하기 위해 사용 됨 WHERE절에 산술, 비교, 논리 연산자를 사용하여 검색 조건을 기술하고 조건을 만족하는 레코드를 선택할 수 있음 단순 질의 문은 레코드를 제한하지 않고 전체 또는 일부 컬럼을 테이블에서 검색하는 SELECT문으로 WHERE절이 없는 질의 문 임 조건 질의 문은 산술 연산 식, 함수 등을 사용하여 표현한 조건을 WHERE 절에 기술하여 조건을 만족하는 레코드만 검색하는 SELECT문임체크 포인트 SQL의 논리 연산자가 아닌 것은? a. XOR SQL의 논리 연산자 어떤 조건과 다른 조건을 결합할 때 어떤 방식으로 결합할 지에 대한 연산자 AND OR NOT 다음 SQL 문에서 빈칸에 들어갈 내용으로 옳은 것은? UPDATE 교수 \t( ) 직위 = '정교수' WHERE 교수번호 = '194834-760517' a. SET " }, { "title": "[파이썬 프로그래밍 기초] 5강 - 순차 구조", "url": "/posts/knou-python-5/", "categories": "Language, Python", "tags": "knou, python", "date": "2025-04-05 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '파이썬 프로그래밍 기초' 강의를 개인 공부 목적으로 메모하였습니다. 학습 목표 제어 구조의 종류를 나열할 수 있음 순차 구조의 특징을 설명할 수 있음 프로그래밍 에러의 종류를 설명할 수 있음주요 용어 제어 구조 프로그램의 실행 흐름을 결정하는 구조 순차 구조 실행의 흐름을 주어지는 명령의 위치적 흐름에 따라 수행하는 구조 프로그래밍 에러 설계 미숙, 결함 또는 문법 오류로 프로그램이 의도한 대로 결과를 생성하지 못하는 문제 상황 데이터 타입 변환 한 데이터의 타입을 다른 데이터 타입으로 전환하는 과정 강의록제어 구조의 이해제품 생산 공정구조적 프로그래밍 패러다임 절차적 프로그래밍 패러다임의 하위 개념 goto 문을 사용하지 않고 프로그램을 3가지 제어 구조만으로 구성하는 프로그래밍 패러다임 순차(sequence) 구조 선택(selection) 구조 반복(iteration) 구조 프로그램 실행 흐름이 간결하고 작은 규모로 조직화하기 쉬움순차 구조 실행의 흐름을 주어지는 명령의 위치적 흐름에 따라 수행하는 구조 명령 라인 위에서 아래로 흐르는 가장 직관적인 구조 일단 첫 단계를 시작하면 마지막 단계까지 수행 ex) 설계 → 생산 → 조립 선택 구조 특정 영역 내의 명령문에 대한 실행 여부를 프로그램 실행 과정 중 결정하는 구조 실행 여부는 조건에 따라 결정 ex) 검사 → (정상? 배송 : 불량? 재생) 반복 구조 특정 영역의 명령문을 여러 번 재실행하는 구조 반복 횟수를 조건에 따라 결정 ex) (조건 만족?) 설계 → … → 배송 순차 구조 실행의 흐름을 주어지는 명령의 위치적 흐름에 따라 수행하는 구조 명령 라인 위에서 아래로 흐르는 가장 직관적인 구조 일단 첫 단계를 시작하면 마지막 단계까지 수행 ex) 설계 → 생산 → 조립 삼각형 출력 하기 다음과 같이 삼각형 모양으로 *을 출력하는 프로그램을 작성하시오. print(\" *\") print(\" ***\") print(\" *****\") print(\"*******\") 원뿔 계산 프로그램 개선 사용자로부터 반지름과 높이를 입력 받고 계산 사용자 입력 input 사용자로부터 데이터를 입력받는 함수 입력 데이터를 문자 데이터 타입으로 반환 함수의 파라미터는 입력 안내문의 목적으로 사용 rad = input() rad = input(\"반지름을 입력하세요:\") # 입력 대기 후 입력값 반환 원뿔 계산 프로그램 개선 1 사용자로부터 반지름과 높이를 입력 받고 계산 # 반지름 사용자 입력 rad = input(\"반지름을 입력하세요:\") # 높이 사용자 입력 hei = input(\"높이를 입력하세요:\") # 부피 계산 (TypeError 발생: 문자열 연산 불가) vol = 1/3 * 3.14 * rad ** 2 * hei print(vol) 부피 = 1/3 * π * r² * h 겉넓이 = π * r² + π * r * h프로그래밍 에러 설계 미숙, 결함 또는 문법 오류로 프로그램이 의도한 대로 결과를 생성하지 못하는 문제 구문 오류 (Syntax Error) 문법 체계에 적합하지 않는 명령문 입력 시 발생 실행 오류 (Runtime Error) 논리적으로 실행 불가능한 명령문 작성 시 발생 의미 오류 (Semantic Error) 의미적으로 잘못 해석되는 명령문 작성 시 발생 데이터 타입 변환 데이터 타입을 다른 타입으로 전환해야 함 문자열 타입으로 변환 str 함수 정수 타입으로 변환 int 함수 소수 타입으로 변환 float 함수 rad = int(input(\"반지름을 입력하세요\"))# 문자열 30을 정수 30으로 변환rad = int(\"30\")# input으로 받은 문자열을 정수로 변환rad = input(\"반지름을 입력하세요\")rad = int(rad)# 한 줄로 작성rad = int(input(\"반지름을 입력하세요\"))원뿔 계산 프로그램 개선 2 사용자로부터 반지름과 높이를 입력 받고 계산 # 반지름 사용자 입력 (정수로 변환) rad = int(input(\"반지름을 입력하세요:\")) # 높이 사용자 입력 (정수로 변환) hei = int(input(\"높이를 입력하세요:\")) # 부피 &amp; 겉넓이 계산 vol = 1/3 * 3.14 * rad ** 2 * hei suf = 3.14 * rad ** 2 + 3.14 * rad * hei # 결과 출력 print(vol) print(suf) print 함수의 확장 여러 개의 데이터를 단일 함수로 출력 가능 콤마(,)로 파라미터를 구분하여 입력 데이터 사이에 공백 (기본 값)이 자동으로 추가 sep 옵션을 변경하여 공백 변경 가능print(\"원뿔의 부피는 \", vol, \"입니다.\", sep=\"\")원뿔 계산 프로그램 개선 3 print 함수는 여러 개의 데이터를 출력 가능 # 반지름 사용자 입력 (정수로 변환) rad = int(input(\"반지름을 입력하세요:\")) # 높이 사용자 입력 (정수로 변환) hei = int(input(\"높이를 입력하세요:\")) # 부피 &amp; 겉넓이 계산 vol = 1/3 * 3.14 * rad ** 2 * hei suf = 3.14 * rad ** 2 + 3.14 * rad * hei # 결과 출력 print(vol) print(suf) 연습 문제 다음은 어떤 제어 구조에 대한 설명인가? 특정 영역 내의 명령문에 대한 실행 여부를 프로그램 실행 과정 중 조건에 따라 결정하는 구조 a. 선택 구조 number 변수에 저장되어 있는 정수를 사용하여 “상자에사과가n개들어있습니다.”라는 메시지를 출력하려고 한다. 올바른 명령문은? (단, n은 number 변수에 저장된 정수를 의미한다.) a. print(\"상자에\", \"사과가\", number, \"개\", 들어있습니다.\", sep=\"\") ‘논리적으로 실행 불가능한 명령문 작성 시 발생’ 오류를 무엇이라고 하는가? a. 실행 오류 학습 정리 파이썬은 구조적 프로그래밍 패러다임을 지원하며 goto 문을 사용하지 않고 프로그램을 구성할 수 있는 순차, 선택, 반복 구조를 제공함 순차 구조는 실행의 흐름을 주어지는 명령의 위치적 흐름에 따라 수행하는 구조 선택 구조는 특정 영역 내의 명령문에 대한 실행 여부를 프로그램 실행 과정 중 조건에 따라 결정하는 구조 반복 구조는 특정 영역의 명령문을 조건에 따라 여러 번 재실행하는 구조 input 함수는 사용자로부터 데이터를 입력 받아, 문자 데이터 타입으로 반환 프로그래밍 에러는 설계 미숙, 결함 또는 문법 오류로 프로그램이 의도한 대로 결과를 생성하지 못하는 현상이며 구문 오류, 실행 오류, 의미 오류로 구분 됨 데이터 타입을 다른 데이터 타입으로 전환하기 위해 str, int, float 함수를 사용함 print 함수는 여러 개의 데이터를 단일 print 함수로 출력 가능하며, 콤마(,)로 파라미터를 구분하여 입력함" }, { "title": "[Java 프로그래밍] 5강 - 인터페이스와 다형성", "url": "/posts/knou-java-5/", "categories": "Language, Java", "tags": "knou, java", "date": "2025-04-05 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김희천 교수님의 'Java 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 객체 지향 개념을 적절히 활용하여 클래스를 정의하려면 상속, 메소드 재정의, 메소드 오버로딩, 인터페이스의 구현, 다형성의 활용법 등을 숙지해야 함 유사 객체들의 공통 행위 양식을 정의하기 위한 인터페이스 개념을 이해하고 다형성을 활용한 객체 지향 프로그래밍 기법을 익히도록 함학습 목표 추상 클래스의 의미를 설명할 수 있음 인터페이스의 선언과 사용법을 설명할 수 있음 다형성을 활용하는 프로그램을 작성할 수 있음 열거 자료형과 익명 클래스의 용도를 설명할 수 있음 내부 클래스의 의미를 설명할 수 있음강의록추상 클래스와 인터페이스추상 메소드 메소드 선언에 abstract키워드를 사용 몸체의 구현이 없는 형식만 존재하는 메소드 반환형, 메소드 이름과 인자에 관한 선언만 존재 자식 클래스에 상속될 때, 몸체의 구현이 필요함 상반된 의미의 final과 함께 사용 불가 추상 메소드는 추상 클래스 또는 인터페이스에서 선언되어야 함 abstract public class Shape { // 모양이 정해지지 않았기 때문에 면적 계산 불가 abstract public double getArea(); // 추상 메소드 } 추상 클래스 클래스 정의에 abstract키워드 사용 추상 메소드를 포함할 수 있음 데이터 필드나 일반 메소드를 포함할 수 있음 객체 생성을 할 수 없음 구체적이지 못한 불완전한 클래스라는 의미 ex) Shape이 추상 클래스라 가정 Shape s = new Shape(\"red\"); // 컴파일 오류 발생 추상 클래스의 사용 의미적으로 유사한 클래스(자식 클래스)를 묶고자 할 때 사용 공통으로 사용할 데이터 필드와 메소드를 추상 클래스에서 정의 추상 클래스는 불완전한 클래스 기능적으로 구현하기 어려운 메소드가 존재 추상 클래스는 자식 클래스로 상속되어 사용됨 자식 클래스에서 추상 메소드를 구현해야 함 그러면 자식 클래스는 객체 생성이 가능 자식 클래스가 추상 메소드를 구현하지 않으면 계속해서 자식 클래스도 추상 클래스이어야 함 추상 클래스는 일반 클래스와 인터페이스의 중간적 성격을 가짐인터페이스 100% 추상적 클래스 인터페이스의 모든 메소드가 추상 메소드(public abstract) 몸체 없이 구현되어야 할 메소드의 형식만 정의해 둠 단, default 인스턴스 메소드와 static메소드는 몸체를 구현함 모든 메소드의 기본 접근 제어자는 public 데이터 필드는 클래스 상수만 가능 public static final 참조형이며 직접적 객체 생성 불가 인터페이스의 이름은 보통 형용사 Runnable Serializable Comparable 인터페이스의 정의 문법은 클래스 정의와 유사함 정의할 때 키워드 class 대신에 interface를 사용 abstract는 생략하는 것이 일반적임 메소드의 접근 제어자는 기본적으로(생략하더라도) public abstract임 몸체가 없으며, 반환형, 이름, 매개변수 목록만 표시 default 인스턴트 메소드와 static메소드도 가능 이 경우 몸체 구현해야 함 기본적으로(생략하더라도) 접근 제어자는 public임 데이터 필드는 항상(생략 가능) public static final임 클래스 상수만 가능함 인터페이스의 사용 추상 클래스와 마찬가지로 자식 클래스에 상속(구현)되어 사용됨 인터페이스를 상속(부모 인터페이스를 구현)받은 자식 클래스는 모든 추상 메소드를 구현해주어야함 의미적으로는 관련이 없으나 기능적으로 유사한 클래스들을 묶을 때 인터페이스를 사용할 수 있음 ex) 대소 비교가 가능한 클래스(사각형, 사람…) 인터페이스를 상속 받아 자식 인터페이스를 정의할 수 있음 인터페이스의 상속(또는 확장) interface Comparable&lt;T&gt; { //다른 객체와 크기를 비교하는 메서드 boolean isLargerThan(T o);}class Box implements Comparable&lt;Box&gt; { private int length, width, height; public boolean isLargerThan(Box otherBox) { }}인터페이스의 상속 자식 인터페이스가 부모 인터페이스를 상속 받는 경우 기존 인터페이스를 상속 받아 인터페이스를 정의할 때, 키워드 extends사용 interface 자식 인터페이스 extends 부모 인터페이스 { } 여러 부모 인터페이스를 상속 받는 다중 상속 가능 interface SuperInterface { public void func1(); public void func2(); } interface SubInterface extends SuperInterface { public void func3(); } 인터페이스의 구현 자식 클래스가 부모 인터페이스를 상속 받는(구현 하는) 경우 자식은 부모가 나열한 기능(추상 메소드)을 구현해야 함 구현을 통해 클래스를 정의할 때 implements를 사용 class 자식클래스 extends 부모클래스 implements 부모인터페이스1, 부모인터페이스2 { } interface Movable { void add(double dx, double dy); void sub(double dx, double dy); } interface Scalable { void mul(double s); void div(double s); } class Point implements Movable, Scalable { @Override public void add(double dx, double dy) { } @Override public void sub(double dx, double dy) { } @Override public void mul(double s) { } @Override public void div(double s) { } } 인터페이스의 구현의 예interface Figure { double getArea();}class Triangle implements Figure { private double height, width; public Triangle(double h, double w) { height = h; width = w; } public double getArea() { return height * width * 0.5; }}public class Main { public static void main(String args[]) { Triangle t = new Triangle(3.0, 4.0); System.out.println(t.getArea()); }}// 6.0디폴트 메소드 인터페이스에서 선언하는 메소드에 기본 구현(몸체)을 넣을 수 있음 자식 클래스에서 상속 받을 때, 디폴트 메소드를 그대로 사용할 수 있음 메소드 선언 시 default를 사용하고 몸체를 구현해 줌 인터페이스에 새 메소드를 추가할 때, 기존 코드(클래스 정의)의 수정을 피하기 위함 단순히 추상 메소드가 추가된다면, 이전 인터페이스를 구현한 클래스를 수정해야 함 interface DoIt { void doSomething(); // 추상 메소드 int doSomethingElse(String s); // 추상 메소드 // 아래를 새로 추가한다면? default boolean didItWork(int i, String s) { return true; } } 추상 클래스, 인터페이스, 클래스의 형변환 인터페이스와 클래스는 모두 사용자 정의형 extends와 implements에 따라 상위/하위 자료형(부모/자식) 관계가 설정 됨 상위 유형의 변수는 하위 객체의 참조 값을 가질 수 있음 상위 유형의 변수가 가리키는 객체의 실제 유형에 따라 수행되는 메소드가 결정됨(동적 바인딩) 실행 중 메소드 호출 시, 변수의 선언 유형으로 정하지 않음 SuperClass super = new SubClass(); // 자동 형 변환 upcasting super.method(); // method()를 SubClass에서 찾음 컴파일할 때는 method()가 sup의 선언 유형에 정의되어 있는지 확인함 다형성다형성 유사하지만 다양한 형상이나 다양한 기능을 가진다는 뜻 한 부모에서 나온 두 자식 객체는 비슷하지만 다름 하나의 클래스에서 오버로딩된 메소드들은 유사하지만 조금씩 다른 기능을 수행함 자식 클래스에서 재정의된 메소드는 부모의 것과 유사하지만 다른 기능을 수행함 다형성과 형변환 형변환 상속 관계에 있는 클래스 간에는 타입 변환이 가능함 전혀 다른 두 클래스 간에는 타입 변환이 금지됨 자식(하위) 클래스에서 부모(상위) 클래스로의 형 변환은 문제 없음 업캐스팅이라 하며 자동으로 형 변환 가능함 참조형 변수는 같은 유형 또는 자식 유형의 객체를 참조할 수 있음 Animal animal = (Animal) new Dog(); // 하위 객체 참조 다형성의 활용 효과 코드의 유연성과 재 사용성 동적 바인딩을 통해 실제 유형을 명시적으로 다룰 필요가 없음 다형성과 오버라이딩 클래스의 다형성 부모 클래스로부터 상속받은 메소드를 자식 클래스에서 오버라이딩할 수 있음 부모와 자식에서 같은 이름의 메소드가 다른 기능을 수행 메소드 이름, 매개 변수, 반환형은 같으나 몸체의 구현이 다름 서로 다른 자식 간에도 같은 이름의 메소드가 다른 기능을 수행 인터페이스의 다형성 자식 클래스들에서 상위 인터페이스의 메소드를 다르게 구현함 클래스 상속과 다형성 사용 예시 ex) class A { public void func() { System.out.println(\"A\"); } } class B extends A { public void func() { System.out.println(\"B\"); } } class C extends B { public void func() { System.out.println(\"C\"); } } public class Main { public static void main(String args[]) { A a = new B(); a.func(); // B 클래스의 func 메소드 호출 a = new C(); a.func(); // C 클래스의 func 메소드 호출 } } // B // C ex) class Employee { int nSalary; String szDept = null; public void doJob() { System.out.println(\"Do something\"); } } class Sales extends Employee { public Sales() { szDept = \"Sales Dept\"; } public void doJob() { System.out.println(\"Do sales\"); } } class Development extends Employee { public Development() { szDept = \"Sales Dept\"; } public void doJob() { System.out.println(\"Do development\"); } } public class Main { public static void main(String args[]) { Employee emp1, emp2; // 클래스 객체 변수 정의 emp1 = new Sales(); emp2 = new Development(); emp1.doJob(); // Employee의 doJob 메소드 존재 확인 후 Sales 클래스의 doJob 메소드 호출 emp2.doJob(); // Development 클래스의 doJob 메소드 호출 } } // Do sales // Do development 열거 자료형열거형 미리 정의된 상수 값의 집합을 만들기 위한 자료형 enum을 사용하여 정의 열거형으로 선언된 변수에는 미리 지정된 값만 대입 가능 상수 값을 배열로 리턴하는 static메소드인 values()를 제공 enum Day { // Enum 유형 Day SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY } public class Main { public static void main(String[] args) { Day day = Day.MONDAY;\t\t\t for (Day d : Day.values()) { System.out.println(d); // 각 원소 출력 } } } 열거형 정의 하기 열거형 정의에 필드와 메소드를 포함할 수 있음 상수 선언이 필드나 메소드보다 먼저 정의되어야 하며 이때 세미콜론(;)으로 끝나야 함 열거형에서 상수 값은 마치 하나의 객체와 같음 열거형이름.상수값의 형식을 사용 열거형이름.상수값은 그 자체가 열거형의 인스턴스 생성자는 열거형과 같은 이름을 가지며 접근 제어자는 생략 또는 private이어야 함 열거형의 생성자는 열거형 상수(객체)에 대한 초기화를 수행함 생성자는 상수가 사용될 때 한꺼번에 자동 호출 됨 열거형 사용 enum BaseballTeam { LG(40, 30), SS(30, 40), KT(20, 50),\tSK(35, 35), NC(55, 15); // 상수 값 선언 private final int win; // 데이터 필드 선언 private final int lose; private BaseballTeam(int win, int\tlose) { // 생성자 this.win = win; this.lose = lose; } public double winsRate() { return (win * 100.0) / (win + lose); } } public class Main { public static void main(String args[]) { BaseballTeam bt = BaseballTeam.LG; System.out.println(bt.winsRate()); } } // 57.142857142857146 익명 클래스익명 클래스 일회성으로 1개의 객체를 생성하기 위한 클래스 익명 클래스 정의와 동시에 객체 생성할 수 있음 부모 클래스를 상속 받거나 인터페이스를 구현하도록, 익명 클래스를 정의함 익명 클래스의 정의 방법 아래에서 중괄호가 익명 클래스의 몸체가 됨 부모 클래스를 상속 받는 (익명 서브 클래스) 객체를 생성할 때 new 슈퍼클래스 () { } // 슈퍼클래스의 자식 객체 생성 인터페이스를 구현 하는 (익명 구현 클래스) 자식 객체를 생성할 때 new 인터페이스 () { } // 인터페이스를 구현하는 자식 객체 생성 익명 서브 클래스의 객체 생성public class Main { public static void main(String args[]) { CSuper sub = new CSuper() { // CSuper를 상속 받는 익명 클래스 정의 후 객체 생성 public int b = 20; public void method1() { System.out.println(\"sub1\"); } public void method3() { System.out.println(\"sub3\"); } }; sub.method1(); // CSuper를 상속 받는 하위 클래스의 객체를 가리킴 sub.method2(); // CSuper를 상속 받는 하위 클래스의 객체에 method2가 없어 부모 클래스에서 호출 System.out.println(sub.a); // sub의 선언 유형인 CSuper에서 데이터 필드 호출 // sub.method3(); 컴파일 오류 // System.out.println(sub.b); 컴파일 오류}}class CSuper { public int a = 10; public void method1() { System.out.println(\"super1\"); } public void method2() { System.out.println(\"super2\"); }}// sub1// super2// 10익명 구현 클래스의 객체 생성interface MyInterface { public void method(); // 추상 메소드}public class Main { public static void main(String args[]) { MyInterface sub = new MyInterface() { public void method() { System.out.println(\"sub1\"); } }; sub.method(); }}// sub1중첩 클래스중첩 클래스 외부 클래스 정의 내부에서 정의된 또 다른 클래스 내부(inner) 클래스라고 하며, 외부(outer) 클래스의 멤버가 됨 논리적 그룹화를 위한 것 내부 클래스는 보통의 클래스와 다르게 private또는 protected클래스가 될 수 있음 일반적으로 내부 클래스는 외부 클래스의 필드와 관련된 작업을 처리 non-static 중첩 클래스 외부 클래스의 객체가 생성된 이후 사용 가능 외부 클래스의 객체와 연관 객체 생성 방법은 외부클래스객체변수.new 내부 클래스() 메소드는 this 외에 외부 클래스 객체의 참조(외부클래스.this)를 가지고 있음 외부 클래스의 모든 멤버에 접근할 수 있음 static 중첩 클래스 외부 클래스의 객체 생성과 무관하게 사용 가능 외부 클래스의 정적 멤버에 접근할 수 있음 중첩 클래스에서 같은 이름의 필드 참조하기class OuterClass { public int x = 0; class InnerClass { public int x = 1; void methodInnerClass(int x) { System.out.println(\"x = \" + x); System.out.println(\"this.x = \" + this.x); System.out.println(\"OuterClass.this.x = \" + OuterClass.this.x); } }}public class Main { public static void main(String args[]) { OuterClass oc = new OuterClass(); OuterClass.InnerClass ic = oc.new InnerClass(); ic.methodInnerClass(2); }}// x = 2// this.x = 1// OuterClass.this.x = 0내부 클래스의 사용import java.util.Iterator;/** * 배열의 짝수 인덱스 요소들을 반복적으로 접근하기 위한 반복자 패턴 구현 */public class NestedClassTest { // 배열의 크기를 상수로 정의 private final static int SIZE = 15; // 데이터를 저장할 배열 선언 private int[] data = new int[SIZE]; /** * 배열을 초기화하여 인덱스 값을 배열 요소에 저장 */ public NestedClassTest() { for (int i = 0; i &lt; SIZE; i++) data[i] = i; } /** * 짝수 인덱스 요소들을 출력하는 메서드 * 내부 클래스인 EvenIterator를 생성하여 짝수 인덱스의 요소들에 접근 */ public void printEven() { // 내부 클래스의 인스턴스 생성 EvenIterator iterator = this.new EvenIterator(); // 반복자를 사용하여 다음 요소가 있는 동안 반복 while (iterator.hasNext()) System.out.print(iterator.next() + \" \"); System.out.println(); } /** * 짝수 인덱스 요소에만 접근하기 위한 내부 클래스(Inner Class) * 외부 클래스의 private 멤버(data 배열)에 직접 접근 가능 */ private class EvenIterator implements Iterator&lt;Integer&gt; { // 다음 접근할 인덱스를 저장 (0부터 시작) private int nextIndex = 0; /** * 다음 요소가 있는지 확인하는 메서드 * 접근할 수 있는 요소가 남아있으면 true, 그렇지 않으면 false 반환 */ public boolean hasNext() { return (nextIndex &lt;= SIZE - 1); } /** * 다음 요소를 반환하고 내부 인덱스를 2 증가시키는 메서드 * 2씩 증가시켜 짝수 인덱스만 접근 */ public Integer next() { // 현재 인덱스 위치의 데이터를 Integer 객체로 변환 Integer ret = Integer.valueOf(data[nextIndex]); // 다음 짝수 인덱스를 가리키도록 2 증가 nextIndex += 2; return ret; } } public static void main(String args[]) { // NestedClassTest 객체 생성 NestedClassTest nc = new NestedClassTest(); // 짝수 인덱스 요소들 출력 (0, 2, 4, 6, 8, 10, 12, 14의 값) nc.printEven(); }}// 0 2 4 6 8 10 12 14학습 정리 몸체가 없는 메소드를 추상 메소드라고 하며, 추상 클래스 또는 인터페이스에 포함될 수 있음 인터페이스는 추상 메소드로만 구성됨 단, default 인스턴스 메소드와 static메소드는 몸체가 있어야 함 의미적으로 유사한 클래스를 묶을 때는 추상 클래스로, 기능적으로 유사한 클래스를 묶을 때는 인터페이스를 사용함 다형성은 메소드 오버라이딩과 오버로딩, 클래스 간 상속과 형변환, 인터페이스의 구현과 형변환, 메소드 동적 바인딩을 통해 구현될 수 있음 열거 자료형은 여러 상수 값을 미리 정의하기 위한 자료형이며, 각 상수 값은 하나의 객체와 같음 익명 클래스는 이름이 없는 클래스로, 일회성으로 상속 또는 구현을 통해 자식 객체를 생성하는 용도로만 사용되는 클래스를 의미 함연습 문제 다음 프로그램을 실행했을 때 예상되는 출력은? class A { public void func() { System.out.print(\"a\"); } } class B extends A { public void func() { System.out.print(\"b\"); } } class C extends B { } public class PolymorphTest{ public static void main(String args[]) { A a = new C(); a.func(); } } a. B 밑줄 친 ㄱ에 ㄴ에 들어갈 키워드는 순서대로 무엇인가? interface Able { } interface B /** ㄱ **/ Able { } class C /** ㄴ **/ Able { } a. implements, extends 밑줄 친 부분의 의미를 정확히 설명하시오. 단, CSuper는 클래스 이름이다. CSuper sub = new CSuper() { } ; a. CSuper 클래스를 상속받는 익명 클래스를 정의하고, 동시에 익명 클래스의 객체를 생성한다. " }, { "title": "[데이터베이스 시스템] 4강 - SQL", "url": "/posts/knou-dbs-4/", "categories": "Database", "tags": "knou, database", "date": "2025-04-05 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '데이터베이스 시스템' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 DBMS의 데이터 관리 기능이 우수하다 하더라도 DBMS에 데이터 요청을 명확한 전달하고 결과를 받을 수 있는 방법이 없다면 DBMS의 높은 활용도를 기대할 수 없음 사용자와 DBMS 간 의사 소통할 수 있는 효율적인 명령 체계가 무엇보다도 중요함 데이터베이스 언어의 정의와 역할에 대하여 살펴보고 문법 체계가 자연어와 유사하여 관계형 DBMS에 국제 표준으로 사용되고 있는 SQL과 SQL의 데이터 정의 기능에 대하여 학습함주요 용어 SQL 관계 대수에 기초하여 RDBMS의 데이터 관리를 위해 설계된 언어 DDL 데이터베이스 객체를 생성, 삭제 또는 구조를 수정하는 명령어의 집합 스키마 한 조직의 데이터베이스 시스템의 운영에 필요한 테이블, 인덱스, 뷰 등의 데이터베이스 객체의 집합 테이블 데이터를 저장하기 위한 2차원 표 형태의 구조 강의록데이터베이스 언어의 이해데이터베이스 사용의 의미 데이터 사용 계층 학적, 성적, 수강 애플리케이션을 통해 각 업무(학적, 성적, 수강)를 처리 함 데이터 관리 계층 이러한 애플리케이션들은 DBMS(데이터베이스 관리 시스템)를 통해 상호 작용 함 데이터 저장 계층 DBMS는 디스크에 저장된 학적 파일, 성적 파일, 수강 파일 등의 데이터를 관리함 SQL의 개념 SQL (Structured Query Language) 관계 대수(Relational Algebra)에 기초하여 RDBMS의 데이터 관리를 위해 1970년대 초 IBM에서 설계 1986년 ANSI, 1987년 ISO에서 표준으로 제정 SQL-86, SQL-89, SQL-92, SQL:1999, SQL:2003, SQL:2008 상용 DBMS의 특성에 맞게 국제 표준을 확장한 독자적 SQL 버전 존재 SQL의 특징 비절차적(선언형) 언어, 필요한 데이터만 기술 인간의 언어와 매우 유사하고 간단, 명료 SQL의 구성 데이터 정의 언어 (DDL: Data Definition Language) 데이터베이스 내의 객체(테이블, 인덱스, 뷰 등)를 생성(CREATE) 및 삭제(DROP)하고 그 구조를 조작(ALTER)하는 명령어 집합 데이터가 준수해야 하는 제약 조건을 기술 데이터 조작 언어 (DML: Data Manipulation Language) DDL에 의해 정의된 테이블에 데이터를 조작(삽입, 검색, 수정, 삭제)하는 명령어의 집합 데이터에 대한 CRUD (Create, Read, Update, Delete) 명령을 포함 데이터 제어 언어 (DCL: Data Control Language) DBMS의 동작, 접근 권한 등을 관리하는 SQL 명령어의 집합 데이터베이스 접근 권한 부여/회수, 트랜잭션 관리 등 ex) GRANT, REVOKE, COMMIT, ROLLBACK 데이터 정의 언어 (DDL)데이터 정의 언어의 개념 데이터베이스 객체(Object)를 생성, 삭제 또는 구조를 수정하는 명령어의 집합 데이터베이스 객체의 종류 데이터 저장 관련: 스키마(데이터베이스), 테이블, 인덱스, 뷰 데이터 조작 관련: 트리거, 프로시저, 함수 등 데이터 정의 명령어의 종류 명령어 설명 CREATE 객체 생성 ALTER 객체 수정 DROP 객체 삭제 데이터 정의 언어의 구문 형식 명령어 객체 종류 설명 CREATE TABLE 테이블 생성 CREATE INDEX 인덱스 생성 CREATE VIEW 뷰 생성 CREATE SCHEMA 스키마 생성 ALTER TABLE 테이블 변경 DROP TABLE 테이블 삭제 DROP INDEX 인덱스 삭제 DROP VIEW 뷰 삭제 DROP SCHEMA 스키마 삭제 스키마 정의 스키마(Schema) = 데이터베이스(Database) 개념적으로 동일하게 사용될 수 있음 한 조직의 데이터베이스 시스템 운영에 필요한 테이블, 인덱스, 뷰 등 데이터베이스 객체들의 집합 스키마 관리 구문 형식 스키마 생성 CREATE SCHEMA 스키마_이름; -- 또는 CREATE DATABASE 스키마_이름; 스키마 삭제 DROP SCHEMA 스키마_이름; -- 또는 DROP DATABASE 스키마_이름; 릴레이션과 테이블 RDBMS의 기본적 데이터 저장 구조 2차원 형태의 저장 구조인 점에서 유사 릴레이션 데이터를 구성하는 추상적인 개념 집합론에 기반한 여러 속성을 갖는 레코드의 집합 레코드의 순서가 없으며 중복된 레코드가 존재하지 않음 테이블 물리적으로 데이터를 저장하는 구체적인 개념 레코드의 순서가 존재 가능 키 제약에 따라 중복된 레코드가 존재 가능 테이블 정의 (CREATE TABLE) 새로운 2차원 형태의 테이블을 생성 테이블 생성 기본 구문 CREATE TABLE 테이블_이름 ( 속성명1 데이터_타입 [속성_레벨_제약조건], 속성명2 데이터_타입 [속성_레벨_제약조건], ... [테이블_레벨_제약조건1], [테이블_레벨_제약조건2], ... ); 테이블 생성의 예 교수번호 교수이름 직위 소속학과 연봉 186432-760829 최우성 조교수 생활과학과 52000000 189414-790829 한용운 조교수 법학과 45000000 191924-730620 이동휘 부교수 행정학과 51000000 194634-810228 김규식 정교수 컴퓨터과학과 70000000 194834-760517 정재화 부교수 컴퓨터과학과 53000000 CREATE TABLE 교수 ( 교수번호 CHAR(13), 교수이름 CHAR(30), 직위 CHAR(10), 소속학과 CHAR(50), 연봉 INT);데이터 타입의 개념 컬럼이 가질 수 있는 값의 범위, 즉 도메인을 결정 테이블의 각 속성(열)에 저장될 데이터의 종류를 지정 프로그래밍 언어에서의 변수를 생성 시 사용하는 데이터 타입의 사용 목적과 방법이 매우 유사 기본 데이터 타입 문자 CHAR(n) VARCHAR(n) TEXT 숫자 INT FLOAT DOUBLE DECIMAL(m, n) 날짜/시간 DATE TIME DATETIME TIMESTAMP 정수 데이터 타입 TINYINT 1바이트 정수(-128 ~ 127) ex) 나이, 학년 등의 크기가 작은 정수 SMALLINT 2바이트 정수(-32768 ~ 32767) ex) 물품 번호, 인원 등 중간 크기의 정수 INT 4바이트 정수(약 -20억 ~ 20억) ex) 물품의 금액, 전화 번호 등의 일반 크기의 정수 BIGINT 8바이트 정수(-약 9000경 ~ 9000경) ex) 계좌의 잔고, 천문학적인 크기의 정수 실수형 데이터 타입 부동 소수형 FLOAT 4바이트 크기 부동 소수 FLOAT(P) 소수점 이하 P개 자리의 부동 소수 DOUBLE 8바이트 크기 부동 소수 고정 소수형 DECIMAL(M, N) 전체 M자리, 소수점 이하 N자리의 소수를 저장 ex) DECIMAL(5, 2)는 -999.99 ~ 999.99 NUMERIC DECIMAL과 유사 날짜 및 시간 데이터 타입 날짜 데이터 타입 DATE YYYY-MM-DD 형식의 시간 YEAR YYYY 형식의 연도 시간 데이터 타입 TIME HH:MIl:SS 형식의 시간 날짜 및 시간 데이터 타입 DATETIME YYYY-MM-DD HH:MIl:SS 형식의 날짜 및 시간 TIMESTAMP DATETIME과 유사 유닉스 시간 기반 1970년 ~ 2038년 표현 가능 DBMS 서버의 시간대에 따라 시간 변경 문자 데이터 타입 CHAR(N) 최대 길이가 N인 고정 길이 문자열 VARCHAR(N) 최대 길이가 N인 가변 길이 문자열 ex) DATABASE 문자열 저장 시 TEXT 길이가 최대 2 ~ 4GB인 가변 길이 문자열 CLOB(Character Large OBject) 수백 MB ~ 수 GB의 데이터 저장을 위한 타입 레코드 단위가 아닌 별도의 저장 공간을 부여하는 외부 저장 방식 ENUM 유한 개의 문자열 집합 중 하나의 값을 선택 효율적인 저장 및 처리를 위해 내부적으로 숫자로 저장 성별 : ENUM('남', '여') 혈액형 : ENUM('A', 'B', 'O', 'AB) CHAR와 VARCHAR테이블 정의 예제 학생(Student) 테이블 생성: CREATE TABLE 학생 ( 학번 CHAR(8) NOT NULL PRIMARY KEY, -- 기본키, NULL 불가 이름 VARCHAR(20) NOT NULL, -- NULL 불가 학년 INT, 학과 VARCHAR(30), 주소 VARCHAR(100) DEFAULT '미기입', -- 기본값 설정 생년월일 DATE ); 과목(Course) 테이블 생성: CREATE TABLE 과목 ( 과목번호 CHAR(4) NOT NULL, 과목명 VARCHAR(50) NOT NULL, 학점 INT CHECK (학점 &gt;= 1 AND 학점 &lt;= 4), -- CHECK 제약조건 담당교수 VARCHAR(20), PRIMARY KEY (과목번호) -- 테이블 레벨 기본키 지정 ); 수강(Enrollment) 테이블 생성: CREATE TABLE 수강 ( 학번 CHAR(8) NOT NULL, 과목번호 CHAR(4) NOT NULL, 수강년도 INT NOT NULL, 학기 INT NOT NULL CHECK (학기 IN (1, 2)), -- CHECK 제약조건 (1 또는 2만 가능) 성적 CHAR(2), PRIMARY KEY (학번, 과목번호, 수강년도, 학기), -- 복합 기본키 FOREIGN KEY (학번) REFERENCES 학생(학번), -- 외래키 (학생 테이블 참조) FOREIGN KEY (과목번호) REFERENCES 과목(과목번호) -- 외래키 (과목 테이블 참조) ); 제약 조건 테이블에 존재하는 데이터를 무결하고 세밀하게 관리하기 위한 목적으로 사용 데이터베이스에 저장되는 데이터의 무결성(Integrity)을 보장하기 위한 규칙 잘못된 데이터가 입력되거나 수정되는 것을 방지 DBMS는 테이블 조작 시 테이블에 정의 된 제약 조건을 만족 시키는지 지속적으로 검사 레코드의 입력, 수정, 삭제 요청 시 정의 된 제약 조건의 준수 여부를 검사한 후 실행 데이터의 일관성과 무결성 훼손을 방지 DBMS는 적용하려는 제약의 유형에 따라 다양한 제약 조건을 지원제약 조건의 종류 PRIMARY KEY 기본키 지정 테이블에서 각 튜플(행)을 고유하게 식별하는 속성(들) UNIQUE와 NOT NULL 특성 자동으로 NOT NULL과 UNIQUE속성을 가짐 FOREIGN KEY 외래키 지정 참조 컬럼 정의 한 테이블의 속성(들)이 다른 테이블의 기본 키를 참조하도록 하여 테이블 간의 관계를 정의하고, 참조 무결성을 보장 NOT NULL NULL이 될 수 없는 컬럼에 지정 UNIQUE 동일한 컬럼 값을 가질 수 없음을 지정 해당 속성(들)의 값이 테이블 내에서 고유해야 함을 보장 AUTO_INCREMENT 레코드가 추가될 때 자동적으로 속성 값이 1부터 1씩 증가되어 입력 CHECK 컬럼 값이 특정 조건 준수 여부 지정 ex) 성별은 ‘남’ 또는 ‘여’만 가능, 학점은 1에서 4 사이 제약 조건의 사용 교수번호 교수이름 직위 소속학과 연봉 186432-760829 최우성 조교수 생활과학과 52000000 189414-790829 한용운 조교수 법학과 45000000 191924-730620 이동휘 부교수 행정학과 51000000 194634-810228 김규식 정교수 컴퓨터학과 70000000 194834-760517 정재화 부교수 컴퓨터학과 53000000 CREATE TABLE 교수 ( 교수번호 CHAR(13) NOT NULL, 교수이름 CHAR(30) NOT NULL, 직위 ENUM('조교수', '부교수', '정교수'), 소속학과 CHAR(50) NOT NULL, 연봉 INT NOT NULL, PRIMARY KEY(교수번호), FOREIGN KEY (소속학과) REFERENCES 학과(학과이름));제약 조건의 응용CREATE TABLE 개인구매회원 ( 회원번호 INT AUTO_INCREMENT, 이름 CHAR(10) NOT NULL, ID CHAR(20) UNIQUE, 비밀번호 VARCHAR(30) NOT NULL, 이메일 VARCHAR(100) NOT NULL, 통신사 CHAR(10) NOT NULL CHECK (통신사 IN ('SKT', 'KT', 'LGT')), 휴대폰번호 CHAR(11) NOT NULL, SMS수신 CHAR(1) DEFAULT 'N', 이메일수신 CHAR(1) DEFAULT 'N', PRIMARY KEY(회원번호)); 제약 조건 정의 방법 속성 레벨(Column Level) 제약 조건 속성을 정의할 때 함께 기술 형식 속성명 데이터_타입 [CONSTRAINT 제약조건_이름] 제약조건_유형 ex) 학번 CHAR(8) CONSTRAINT PK_학생 PRIMARY KEY 테이블 레벨(Table Level) 제약 조건 모든 속성 정의 후에 별도로 기술 주로 복합키(여러 속성으로 구성된 키)나 외래키, CHECK 제약조건 정의 시 사용 형식 [CONSTRAINT 제약조건_이름] 제약조건_유형 (대상_속성_리스트) ex) CONSTRAINT PK_수강 PRIMARY KEY (학번, 과목번호, 수강년도, 학기) CONSTRAINT FK_수강_학생 FOREIGN KEY (학번) REFERENCES 학생(학번) 테이블 수정 (ALTER TABLE)ALTER TABLE 테이블이름 [ADD COLUMN 컬럼 데이타타입 [제약조건]] [DROP COLUMN 컬럼이름] [CHANGE COLUMN 수정전컬럼 수정후컬럼] [MODIFY COLUMN 컬럼 데이타타입] CREATE문에 의해 생성된 테이블에 컬럼을 추가, 수정(이름, 데이터 타입, 제약 조건) 또는 삭제 이미 생성된 테이블의 구조(속성, 제약 조건 등)를 변경할 때 사용 컬럼 삭제 또는 컬럼의 데이터 타입 수정 시 데이터에 대한 소실이 발생하므로 많은 주의가 요구 새로운 칼럼 추가 ALTER TABLE 테이블_이름 ADD COLUMN 칼럼명 데이터_타입 [제약조건]; ex) 학생 테이블에 ‘연락처’ 속성(VARCHAR(15)) 추가 ALTER TABLE 학생 ADD COLUMN 연락처 VARCHAR(15); 기존 속성 삭제 ALTER TABLE 테이블_이름 DROP COLUMN 칼럼명; ex) 과목 테이블에서 ‘담당 교수’ 속성 삭제 ALTER TABLE 과목 DROP COLUMN 담당교수; 칼럼 정의 변경 ALTER TABLE 테이블_이름 ALTER COLUMN 칼럼명 TYPE 새로운_데이터_타입; ALTER TABLE 테이블_이름 ALTER COLUMN 칼럼명 SET DEFAULT 새로운_기본값; ALTER TABLE 테이블_이름 ALTER COLUMN 칼럼명 DROP DEFAULT; ALTER TABLE 테이블_이름 ALTER COLUMN 칼럼명 SET NOT NULL; ALTER TABLE 테이블_이름 ALTER COLUMN 칼럼명 DROP NOT NULL; 제약 조건 추가 ALTER TABLE 테이블_이름 ADD CONSTRAINT 제약조건_이름 제약조건_유형 (대상_칼럼); ex) 학생 테이블의 ‘학년’ 속성에 1 ~ 4 사이 값만 허용하는 CHECK 제약 조건 추가 ALTER TABLE 학생 ADD CONSTRAINT CK_학년 CHECK (학년 &gt;= 1 AND 학년 &lt;= 4); 제약 조건 삭제 ALTER TABLE 테이블_이름 DROP CONSTRAINT 제약조건_이름; 테이블 수정 질의의 사용 교수 테이블에서 전공 칼럼을 추가하시오 ALTER TABLE 교수 ADD COLUMN 전공 VARCHAR(100); 교수번호 교수이름 직위 소속학과 연봉 전공 186432-760829 최우성 조교수 생활과학과 52000000 NULL 189414-790829 한용운 조교수 법학과 45000000 NULL 191924-730620 이동휘 부교수 행정학과 51000000 NULL 194634-810228 김규식 정교수 컴퓨터학과 70000000 NULL 194834-760517 정재화 부교수 컴퓨터학과 53000000 NULL 교수 테이블에서 ‘직위’ 컬럼을 삭제하시오 ALTER TABLE 교수 DROP COLUMN 직위; 교수번호 교수이름 소속학과 연봉 186432-760829 최우성 생활과학과 52000000 189414-790829 한용운 법학과 45000000 191924-730620 이동휘 행정학과 51000000 194634-810228 김규식 컴퓨터학과 70000000 194834-760517 정재화 컴퓨터학과 53000000 테이블 삭제 (DROP TABLE) 존재하는 테이블을 스키마에서 삭제 삭제 된 테이블에 저장 된 모든 데이터가 소실, 복구가 불가능한 연산이므로 각별한 주의가 요구 테이블의 구조 정의와 해당 테이블에 저장된 모든 데이터를 영구적으로 삭제 기본 구문 DROP TABLE 테이블_이름 [CASCADE | RESTRICT]; CASCADE 해당 테이블을 참조하는 다른 테이블의 외래 키 제약 조건 등 종속된 객체들을 함께 삭제 RESTRICT 해당 테이블을 참조하는 다른 객체가 있을 경우 삭제를 수행하지 않음 ex) 교수 테이블을 삭제하시오 DROP TABLE 교수 ex) -- 수강 테이블 삭제 (참조하는 다른 객체가 없다면 성공) DROP TABLE 수강; -- 학생 테이블 삭제 (학생 테이블을 참조하는 외래키가 있을 경우 CASCADE 옵션으로 함께 삭제 시도) DROP TABLE 학생 CASCADE; 연습 문제 DDL명령에서 릴레이션의 변경을 위한 명령은? a. ALTER TABLE CRATE TABLE에 의해 생성된 테이블의 구조를 변경하기 위한 SQL문은 ALTER TABLE 테이블 이름으로 시작 됨 새로운 컬럼이나 제약조건 등을 추가/제거/삭제할 수 있음 다음 요청을 수행하기 위한 SQL문으로 올바른 것은? 학생 테이블에서 '외모' 컬럼을 삭제하시오 a. ALTER TABLE 학생 DROP 외모 컬럼을 추가하거나 제거하는 것은 삭제가 아닌 테이블의 구조를 변경하는 것으로 ALTER 문을 사용함 ALTER TABLE 구문을 사용하고 변경 작업 중 컬럼 삭제를 의미하는 DROP 절을 덧붙여서 ALTER TABLE 학생 DROP 외모와 같이 완성함 다음 중 테이블 정의 시 ‘동일한 컬럼 값을 가질 수 없음을 지정’하는 제약 조건은? a. UNIQUE SQL은 데이터 일관성과 무결성을 위해 테이블 정의 시 데이터에 대한 조건을 제약 조건으로 기술할 수 있으며 이 중 UNIQUE는 서로 다른 레코드가 UNIQUE로 지정된 컬럼에 대해 동일한 값을 가질 수 없는 조건을 생성함 정리 하기 구조화된 질의 언어(structured query language)라는 의미의 SQL은 사람과 DBMS 간의 의사소통을 위한 대표적인 DBMS 언어임 SQL에는 데이터 정의 언어와 데이터 조작 언어로 구성되며, 이 외에도 DBMS를 관리하기 위한 다양한 기능을 지원함 데이터 정의 언어(DDL)는 데이터베이스, 테이블, 뷰, 인덱스 등의 데이터베이스 객체를 정의하는 데 이용됨 CREATE, ALTER, DROP명령어를 사용하여 데이터베이스 객체를 생성, 수정, 추가할 수 있음 스키마는 데이터베이스와 동일한 의미로 사용되며 한 조직의 데이터베이스 시스템의 운영에 필요한 테이블, 인덱스, 뷰 등의 데이터베이스 객체의 집합을 의미 함 CREATE TABLE문을 사용하여 테이블의 컬럼 정의 시 컬럼이 가질 수 있는 값의 범위를 데이터 타입을 지정하며 문자, 숫자, 날짜에 대한 여러 데이터 타입을 제공 함 ALTER TABLE문은 컬럼의 추가 및 삭제, 데이터 타입 변경 등 테이블 수정을 지시 함 DROP TABLE문은 테이블의 삭제를 지시 함 테이블 정의 시 데이터의 일관성과 무결성 유지를 위해 데이터가 가져야 하는 다양한 제약 조건을 기술할 수 있으며, 종류로는 PRIMARY KEY, FOREIGN KEY, NOT NULL, UNIQUE, CHECK, AUTO INCREMENT, DEFAULT등이 있음체크 포인트 SQL에서 스키마(schema), 도메인(domain), 테이블(table), 뷰(view), 인덱스(index)를 정의하거나 변경 또는 삭제할 때 사용하는 언어는? a. DDL(Data Definition Language) 데이터베이스 객체 조작하기 위한 언어 아래의 DML, DCL, DDL이 잘못 짝 지어진 것은? a. DDL : INSERT DDL : CREATE, ALTHER, DROP DML : UPDATE DCL : ROLLBACK DCL : GRANT " }, { "title": "[데이터 정보 처리 입문] 4강 - 통계 정보의 검색 및 활용 2", "url": "/posts/knou-dip-4/", "categories": "Data Science, Data Analysis", "tags": "knou, data information processing", "date": "2025-04-02 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김성수, 이기재 교수님의 '데이터 정보 처리 입문' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 데이터의 특성을 요약할 때 기본적으로 이용되는 기술통계량과 그래프들을 알아보고, 웹을 활용한 데이터분석 예를 알아봄학습 목표 기술 통계량을 이해할 수 있음 연속인 자료에 이용되는 통계 그래프를 설명할 수 있음 웹을 활용하여 기술 통계량을 구하고, 통계 그래프를 그려볼 수 있음강의록연속형 자료의 정리중심 측도: 평균 중심 위치의 측도 평균, 중앙 값, 최빈 값 등이 있으며, 가장 많이 사용되는 것은 평균(mean)임 평균 정의 관측한 자료의 값들을 X₁, X₂, … Xₙ이라 할 때, 다음과 같이 정의 됨 표본 평균 x̄ = n / X₁ + X₂ + … + Xₙ = n / ΣXᵢ x̄는 엑스 바(bar)라고 읽음 평균은 어느 한 자료 값이 다른 값들보다 아주 크거나 작은 특이 값(outlier; 이상치)의 영향을 많이 받음 ex) 자료: 5, 4, 7, 6, 8, 10, 11, 0, 7, 18인 경우 평균 x̄ 10 / 5 + 4 + … + 7 + 18 = 10 / 76 = 7.6 자료: 5, 4, 7, 6, 8, 10, 11, 0, 7, 18, 100인 경우 평균 x̄ 11 / 5 + 4 + … + 7 + 18 + 100 = 11 / 176 = 16 R 코드 aval = c(5, 4, 7, 6, 8, 10, 11, 0, 7, 18) sum(aval) mean(aval) [1] 7.6 중심 측도: 절사 평균 절사 평균(trimmed mean) 표본에서 가장 작은 값 일부와 가장 큰 값 일부를 제외하고 계산된 평균 10% 절사 평균은 표본에서 가장 작은 값 10%와 가장 큰 값 10%를 제외하고 계산된 평균을 말함 절사 평균은 특이치(outlier)의 영향을 덜 받는 효과 ex) 자료: 5, 4, 7, 6, 8, 10, 11, 0, 7, 18 인 경우 자료를 크기 순 정렬: 0, 4, 5, 6, 7, 7, 8, 10, 11, 18 10% 절사 평균 x̄ .₁₀ = 8 / 4 + 5 + 6 + 7 + 7 + 8 + 10 + 11 = 7.25 20% 절사 평균 x̄ .₂₀ = 6 / 5 + 6 + 7 + 7 + 8 + 10 = 7.1667 R 코드 aval = c(5, 4, 7, 6, 8, 10, 11, 0, 7, 18) mean(aval) [1] 7.6 mean(aval, trim = 0.10) # 양 끝 10%씩 제외 [1] 7.25 mean(aval, trim = 0.20) # 양 끝 20%씩 제외 [1] 7.166667 median(aval) # 중앙 값 [1] 7 중심 측도: 중앙 값 중앙 값(median) 자료를 크기 순서로 나열했을 때 중앙에 놓이는 값 자료의 수를 n이라 할 때, (n + 1)/2 번째의 값을 중앙 값으로 함 n이 홀수 (n + 1) / 2 번째 값 n이 짝수 (n / 2)번째 값과 (n / 2 + 1)번째 값의 평균 ex) 자료: 5, 4, 7, 6, 8, 10, 11, 0, 7, 12, 13, 18, 14 인 경우 (n=13) 크기 순 정렬: 0, 4, 5, 6, 7, 7, 8, 10, 11, 12, 13, 14, 18 중앙 값 위치: (13 + 1) / 2 = 7, 7번째 값 = 8 자료: 5, 4, 7, 6, 8, 10, 11, 0, 7, 12, 13, 18, 14, 20 인 경우 (n=14) 크기 순 정렬: 0, 4, 5, 6, 7, 7, 8, 10, 11, 12, 13, 14, 18, 20 중앙 값 위치: (14 + 1) / 2 = 7.5 = 7번째와 8번째 값의 평균 값 (8 + 10) / 2 = 9 자료: 5, 4, 7, 6, 8, 10, 11, 0, 9, 14 (n=10), 평균=7.4 자료 순서 : 0, 4, 5, 6, 7, 8, 9, 10, 11, 14 중앙 값 : (10 + 1) / 2 = 5.5번째 = 5번째와 6번째 값의 평균 = (7 + 8) / 2 = 7.5 자료: 5, 4, 7, 6, 8, 10, 11, 0, 9, 14, 100 (n=11), 평균=15.82 자료 순서 : 0, 4, 5, 6, 7, 8, 9, 10, 11, 14, 100 중앙 값 : (11 + 1) / 2 = 6번째 값 = 8 R 코드 aval = c(5, 4, 7, 6, 8, 10, 11, 0, 9, 14, 100) median(aval) 중심 측도: 최빈 값(mode) 최빈 값 자료 중 가장 빈도가 많은 값 이산형 자료일 경우 도수 분포 표만 살펴보면 쉽게 구할 수 있음 연속형 자료일 경우 자료를 몇 개의 계급 구간으로 나누어 가장 도수가 높은 계급의 중간 값을 최빈값으로 정하기도 함 ex) 자료: 13, 18, 13, 16, 14, 21, 13 : mode = 13 산포도 측도 산포도의 측도(measure of dispersion) 자료가 흩어진 정도를 수치로 측정하는 것 대표적인 산포도의 측도 분산 및 표준 편차 이외에도 변동 계수, 범위, 사분위수 범위 등이 이용됨 산포도 측도: 분산, 표준 편차 분산(variance) 각 자료 값과 평균과의 거리를 제곱하여 합한 후 이를 자료의 수로 나눈 측도 표본 분산 s² = n -1 / Σ(xᵢ + x̄)² 자료가 평균에서 많이 흩어져 있으면 분산이 커지고, 평균 주위에 몰려 있으면 분산이 작게 됨 표준 편차(standard deviation) 분산의 제곱근 표본 표준 편차 s = √s² 산포도 측도: 변동 계수, 범위 변동 계수(coefficient of variation): CV = x̄ / s * 100 자료의 개수나 측정 단위가 다른 두 개 이상의 자료에 대한 표준 편차를 비교하는 것은 무의미함 이러한 경우에 사용하는 측도가 표준 편차를 평균으로 나눈 표준화 된 표준 편차인 변동 계수(coefficient of variation)를 사용 변이 계수라고도 함 범위(Range) 최대 값 – 최소 값 범위는 계산하기가 간편 하나 극 단점이 있을 경우 올바른 산포의 측도가 되지 못함 산포도 측도: 사분위수 범위 p% 백분위수(percentile) 자료를 작은 값부터 큰 값까지 순서대로 늘어놓았을 때 p% 번째 자료를 말함 제 1 사분위수 (1st quartile, Q₁ 으로 표시): 백분위 수 중 25% 백분위수 제 2 사분위수 (2nd quartile, Q₂ 으로 표시, 중앙 값): 백분위 수 중 50% 백분위수 제 3 사분위수 (3rd quartile, Q₃ 으로 표시): 백분위 수 중 75% 백분위수 사분위수 범위(IQR; Interquartile Range) 제 3 사분위수와 제 1 사분위수의 차이 \tIQR = Q₃ - Q₁ 중앙 값을 중심으로 50%의 자료가 포함되는 범위이며, 특이 값의 영향을 덜 받음 산포도 측도 R을 이용한 계산 aval = c(5, 4, 7, 6, 8, 10, 11, 0, 7, 18) # 표준 편차 sd(aval) # 4.788876 # 사분위수 범위 (IQR) IQR(aval) # 4.25 # Q3(9.50) - Q1(5.25) = 4.25 # 요약 통계량 (최소값, Q1, 중앙값, 평균, Q3, 최대값) summary(aval) # Min. 1st Qu. Median Mean 3rd Qu. Max. # 0.00 5.25 7.00 7.60 9.50 18.00 # 특정 백분위수 계산 (Q1, Q2, Q3) quantile(aval, probs = c(0.25, 0.5, 0.75)) # 25% 50% 75% # 5.25 7.00 9.50 연속형 자료의 그래프연속형 자료의 그래프: 히스토그램 (Histogram) 히스토그램 (Histogram) 연속인 자료를 일정한 계급으로 나누어 각 계급에 속한 도수들을 정리한 도수 분포 표를 이용하는 작성한 그래프 히스토그램은 연속인 자료의 분포를 살펴볼 때 이용되는 그래프로서 많은 양의 자료에 적합 대칭성, 집중도 등 R을 이용한 계산 # 정규분포 따르는 난수 200개 생성 a = rnorm(200) # 히스토그램 그리기 (빨간색으로) hist(a, col=\"RED\") 연속형 자료의 그래프: 줄기-잎 그림 (Stem-and-Leaf Plot) 줄기-잎 그림 (Stem-and-Leaf Plot) 분포의 대략적인 형태를 살펴보기 위하여 작성되는 그래프로 군집의 존재 여부, 집중도가 높은 구간, 대칭성의 여부, 자료의 범위 및 산포, 특이 값의 존재 여부 등을 파악하는데 이용됨 원자료의 정보를 유지하면서 분포를 보여줌 자료의 값을 ‘줄기(stem)’와 ‘잎(leaf)’으로 나누어 표현하는 그래프 보통 큰 자릿수를 줄기로, 마지막 자릿수를 잎으로 사용 ex) 점수 자료 54 57 55 23 51 64 90 51 52 43 15 10 82 74 54 78 37 73 52 48 41 33 52 30 41 51 18 39 46 28 53 44 46 56 28 58 29 58 67 35 25 38 61 53 23 73 69 47 41 45 77 56 89 28 54 99 10 43 35 24 21 23 67 14 53 # \"c:/data/dataintro/score.txt\" 경로에서 데이터를 읽어옴 score = scan(\"c:/data/dataintro/score.txt\") stem(score) # The decimal point is 1 digit(s) to the right of the | # 1 | 00458 # 10, 10, 14, 15, 18 # 2 | 1333458889 # 21, 23, 23, 23, 24, 25, 28, 28, 28, 29 # 3 | 0355789 # 30, 33, 35, 35, 37, 38, 39 # 4 | 11133456678 # 41, 41, 41, 43, 43, 44, 45, 46, 46, 47, 48 # 5 | 111222333444566788 # 51, 51, 51, 52, 52, 52, 53, 53, 53, 54, 54, 54, 55, 56, 56, 57, 58, 58 # 6 | 14779 # 61, 64, 67, 67, 69 # 7 | 33478 # 73, 73, 74, 77, 78 # 8 | 29 # 82, 89 # 9 | 09 # 90, 99 연속형 자료의 그래프: 상자 그림 (Box Plot) 다섯 숫자 요약 (Five-number summary) 자료의 분포를 요약하는 5가지 값 최소 값, 제 1 사분위수( Q₁), 중앙값, 제 3 사분위수(Q₃), 최대 값 상자 그림 (Box Plot) 다섯 숫자 요약을 특이 값과 함께 그래프로 표현한 것으로서 분포의 상태, 특이 값의 유무, 여러 집단의 수치 자료를 비교하고자 할 때 유용하게 이용됨 상자 그림 그리는 방법 다섯 숫자 요약을 구함 제 1 사분위수, 제 3 사분위수에 해당하는 수직선 상의 위치에 네모 상자의 양 끝이 오게 하고 상자 내의 중앙 값에 해당되는 위치에 가로지르는 막대 표시를 함 안울타리(inner fence)값을 구함 IFₗ = Q₁ - 1.5 * IQR IFᵤ = SQ₃ - 1.5 * IQR 단, IQR = Q₃ - Q₁ 안울타리의 안쪽에 있으면서 경계에 가장 가까운 인접 값(adjacent value, AV)를 찾아 상자의 양 끝을 연결 함 안울타리 바깥에 있는 자료 점을 특이 값으로 간주하고 “o” 또는 “*” 표시를 함 R score = scan(\"c:/data/dataintro/score.txt\") # 줄기-잎 그림 (참고용) stem(score) # The decimal point is 1 digit(s) to the right of the | # 1 | 00458 # 2 | 1333458889 # 3 | 0355789 # 4 | 11133456678 # 5 | 111222333444566788 # 6 | 14779 # 7 | 33478 # 8 | 29 # 9 | 09 # 요약 통계량 summary(score) # Min. 1st Qu. Median Mean 3rd Qu. Max. # 10.00 33.00 48.00 47.45 57.00 99.00 # 상자 그림 그리기 boxplot(score) 웹 데이터 분석웹 데이터 분석 웹의 활성화 웹을 이용한 데이터 분석 방법의 발전 통계 교육 효과 증대 그래프를 이용한 데이터의 이해 효과 Free StatPages.net StatPages.net 데이터 분석, 통계적 방법, 전자 교재, 통계 강의 등 다양한 내용 ex) StatPages.net의 “Interactive Stats”을 이용하여 다음 점수 자료의 히스토그램을 그리고, 기술 통계량을 구해보자. 히스토그램 그리기 줄기-잎 그림 및 기술통계량 구하기 Interactivate Interactivate 확률, 통계, 그래프 등을 대화형으로 제공해주는 사이트 히스토그램, 파이 차트, 산점도, 줄기-잎 그림 등의 다양한 통계 그래프 ex) 상자 그림 그리기 eStat eStat 초,중,고,대 교육용 통계 패키지 (크롬에 최적화) 교육 현장에서 통계 분석 및 시각화를 쉽게 수행할 수 있도록 다양한 기능을 제공 연습 문제 다음 중 표본 평균을 구하는 공식은? a. 자료의 개수나 측정 단위가 다른 두 개 이상의 자료에 대한 표본 집단 간의 상대적인 산포를 비교할 때 이용되는 측도로, 두 집단의 단위가 다르거나, 단위는 같지만 평균의 차이가 클 때 두 그룹의 산포를 비교하는 데 유용하게 이용되는 측도는? a. 변동 계수 탐색적 자료 분석의 관점에서 살펴볼 때 한 묶음의 자료를 정리하는 숫자로서 다섯 숫자 요약이란 다음 중 무엇인가? a. 최소값, 최대값, 중앙값, 제 1 사분위수, 제 3 사분위수 조사된 자료가 다음과 같다. 중앙값은? 22 5 21 16 18 20 23 24 32 490 36 a. 22 다음 중 표본 분산을 구하는 공식은? a. " }, { "title": "[운영 체제] 4강 - 병행 프로세스", "url": "/posts/knou-os-4/", "categories": "OS, Operating System", "tags": "knou, os", "date": "2025-04-01 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김진욱 교수님의 '운영 체제' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 최근에는 여러 프로세스가 단순히 순차 처리가 아닌 병행 처리될 필요가 많음 음악 파일을 배경 음악으로 재생하며 동영상도 틀어 놓고 문서 작업을 하는 경우, 운영 체제는 이들을 병행으로 처리해야 함 특히 이렇게 병행 처리되는 프로세스가 서로 유기적으로 상호 작용하며 동작하는 경우에는 해결해야 할 다양한 문제가 존재함 병행 프로세스의 기본 개념과 함께 상호 배제와 동기화 문제를 알아보고 이를 해결하기 위해 제공되는 장치들에 대해 학습함학습 목표 병행성과 병행 프로세스의 개념을 설명할 수 있음 병행성 문제를 설명할 수 있음 세마 포어의 개념을 설명할 수 있음강의록병행 프로세스의 개요병행성과 병행 프로세스 병행성 (concurrency) 여러 개의 프로세스 또는 쓰레드가 동시 수행되는 시스템의 특성 병행 프로세스 동시 수행되는 여러 개의 프로세스 또는 쓰레드 병행 프로세스의 실행 형태 1개의 CPU 인터리빙 형식 여러 개의 CPU 병렬 처리 형식 멀티프로세서 시스템에서의 메모리 구조에 따라 강 결합 시스템 (공유 메모리 구조) 약 결합 시스템 (분산 메모리 구조) 프로세스 간의 관계 독립 프로세스 수행 중인 다른 프로세스에 영향을 주지도 받지도 않음 데이터 및 상태를 다른 프로세스와 공유하지 않음 프로세스의 실행 결정적: 실행 결과는 입력에 의해서만 결정됨 재생 가능: 같은 입력에 대해 항상 동일한 실행 결과 협력 프로세스 수행 중인 다른 프로세스와 영향을 주고 받음 데이터 및 상태를 다른 프로세스와 공유 프로세스의 실행: 비 결정적: 실행 결과는 실행 순서에 좌우됨 재생 불가능: 같은 입력에 대해 항상 동일한 실행 결과를 보장하지 못함 병행성 문제병행성 문제 협력 프로세스인 경우 발생 가능한 문제 상호 배제 동기화 통신 상호 배제 2개 이상의 프로세스가 동시에 임계 영역을 수행하지 못하도록 하는 것 임계 영역 2개 이상의 프로세스가 동시에 사용하면 안 되는 공유 자원을 액세스하는 프로그램 코드 영역 동기화 2개 이상의 프로세스에 대한 처리 순서를 결정하는 것 프로세스 동기화 상호 배제 임계 영역에 대한 동기화 문제 통신 프로세스들이 데이터를 공유하기 위해 반드시 필요 프로세스 간 통신 (IPC) 통신 방법 하나의 변수 사용 메시지를 서로 주고받음 세마포어세마포어(semaphore) 상호 배제와 동기화 문제를 해결하기 위한 도구 Dijkstra가 제안 정수형 공용 변수 저장 값: 사용 가능한 자원의 수 또는 잠김이나 풀림의 상태 상황에 맞춰 0 이상인 정수로 초기화 두 기본 연산 p와 v에 의해서만 사용됨 기본 연산: 인터럽트되지 않고 하나의 단위로 처리됨 연산 P 검사, 감소 시키려는 시도 void P(semaphore s) { if (s &gt; 0) s--; else 현재 프로세스를 대기시킴; } 연산 V 증가 void V(semaphore s) { if (대기 중인 프로세스 없음) s++; else 대기 중인 프로세스 1개 진행; } 세마 포어마다 대기 큐 필요상호 배제 해결 상호 배제를 위한 일반적인 요구 사항 한 프로세스가 임계 영역 수행 중 다른 프로세스는 임계 영역에 진입해서는 안 됨 임계 영역 수행 중이던 프로세스가 임계 영역 벗어남 누군가 하나는 임계 영역을 새로이 수행할 수 있어야 함 임계 영역 진입 못하고 대기하는 프로세스 적절한 시간 내에 임계 영역 수행을 시작할 수 있어야 함 상호 배제를 위한 임계 영역 주변의 코드 영역 진입 영역 임계 영역에 대한 수행을 해도 되는지 체크 해제 영역 다른 프로세스가 임계 영역 수행을 시작할 수 있도록 함 세마 포어 이용 세마포어 mutex 초깃값은 1 진입 영역 P(mutex) 해제 영역 V(mutex) 대기 큐는 FIFO로 동작 세마포어 sync 초깃 값은 0 상호 배제 해결 예 프로세스 A가 P의 mutex를 확인 mutex가 1이므로 임계 영역 진입 후 mutex 값 1 감소 시킴 프로세스 B가 P의 mutex를 확인 mutex 값이 0이므로 대기 큐에서 대기 프로세스 c가 P의 mutex를 확인 mutex 값이 0이므로 대기 큐에서 대기 프로세스 A가 V의 mutex를 확인 mutex 값이 0이고 대기 큐에 프로세스가 있으므로 대기 큐에 있는 B를 임계 영역에 진입 시킴 프로세스 B가 V의 mutex를 확인 mutex 값이 0이고 대기 큐에 프로세스가 있으므로 대기 큐에 있는 C를 임계 영역에 진입 시킴 프로세스 C가 V의 mutex를 확인 mutex 값이 0이고 대기 큐에 프로세스가 없으므로 mutex 값 1 증가 시킴 동기화 해결 상황 프로세스 A가 코드 S1을 수행한 후 프로세스 B가 코드 S2를 수행하도록 동기화 세마포어 sync 초깃 값은 0 정상 처리 시 동기화 해결 프로세스 A가 S1을 처리 후 V 연산자 실행 대기 하는 프로세스가 없으므로 sync 값 1 증가 시킴 프로세스 B가 S2 처리 전 P 연산자 실행 sync 값이 0보다 크므로 1 감소 시키고 S2 처리 정상적이지 않은 처리 동기화 해결 프로세스 B가 먼저 S2 처리 전 P 연산자 실행 sync 값이 0이기 때문에 대기 큐에서 프로세스 B 대기 시킴 프로세스 A가 S1 처리 후 V 연산자 실행 대기하는 프로세스가 있으므로 프로세스 B를 깨워 처리함 정리 하기 병행성은 여러 개의 프로세스 또는 쓰레드가 동시에 수행되는 시스템의 특성을 의미하고, 동시에 수행되는 여러 개의 프로세스 또는 쓰레드를 병행 프로세스라고 함 병행 프로세스는 프로세스 간의 관계에 따라 독립 프로세스 또는 협력 프로세스임 협력 프로세스는 병행성과 관련하여 상호 배제, 동기화, 통신과 관련한 다양한 문제가 발생할 수 있음 임계 영역은 2개 이상의 프로세스가 동시에 사용하면 안 되는 공유 자원을 액세스하는 프로그램 코드 영역을 의미함 상호 배제는 2개 이상의 프로세스가 동시에 임계 영역을 수행하지 못하도록 하는 것임 동기화는 2개 이상의 프로세스에 대한 처리 순서를 결정하는 것임 세마포어는 상호 배제와 동기화 문제를 해결하기 위한 정수형 공용 변수로, 2개의 기본 연산 P와 V에 의해서만 사용될 수 있음" }, { "title": "[파이썬 프로그래밍 기초] 4강 - 파이썬 시작하기", "url": "/posts/knou-python-4/", "categories": "Language, Python", "tags": "knou, python", "date": "2025-03-31 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '파이썬 프로그래밍 기초' 강의를 개인 공부 목적으로 메모하였습니다. 학습 목표 함수의 개념을 바탕으로 함수를 사용할 수 있음 변수에 값을 할당할 수 있음 산술 연산자의 종류와 의미를 설명할 수 있음주요 용어 함수 특정 작업을 수행하는 코드의 집합으로 함수의 이름만으로 실행할 수 있는 단위 변수 처리할 데이터와 처리된 결과를 임시적 저장하는 공간 산술 연산자 피연산자(operand)에 대해 지정된 산술 연산을 지시하는 기호 내장 함수 별도의 라이브러리 없이 파이썬 인터프리터에서 기본적으로 지원하는 함수 강의록프로그래밍 기초숫자와 문자 숫자 3.14592 53000000 정수 (integer) 소수점이 없는 숫자 실수 (floating point) 소수점이 포함되는 숫자 문자 \"Hello World!\" 유니코드 (unicode) 기반 문자 또는 문자열 유니코드 전 세계의 모든 문자들을 표현하기 위해 가변길이의 4byte로 문자를 표현하는 코드 체계 인용 부호 \" 또는 ' 를 사용하여 표현 문자가 하나이든, 여러 개이든 파이썬에서는 모두가 문자 타입 기본 연산자와 표현 식 피연산자와 연산자를 이용한 표현 식은 파이썬 인터프리터에 의해 자동 계산 | 연산자 | 기능 | | — | — | | + | 더하기 | | - | 빼기 | | * | 곱하기 | | / | 나누기 | | ** | 지수 (거듭 제곱) | 2 * (7 + 15) 2 ** 10 * 5 \"computure\" + \"science\" 함수 (function) 특정 작업을 수행하는 코드의 집합으로 함수의 이름 만으로 실행할 수 있는 단위 print 함수 화면에 데이터를 출력하는 작업 함수의 기본 구조 함수의 실행들여 쓰기 파이썬은 들여 쓰기에 의존적인 언어 타 프로그래밍 언어에서는 가독성 향상 목적 파이썬에서 코드의 논리적 집합인 블록을 표현 들여쓰기는 스페이스 4 칸을 권장 (PEP 8) 블록 중첩 시 추가적인 4 칸 들여쓰기 삽입 print(\"Hello World!\") print(\"Python is fun\") # 잘못된 예시 print(\"Hello World!\") \t\tprint(\"Python is fun\") 문서화 주석 (comment) 사용 가독성 증대로 개발 속도 향상, 유지 보수 용이 주석의 종류 한 라인 주석에 # 을 사용 여러 라인 주석에 \"\"\" 또는 ''' 3개를 연달아 사용 # 성적 계산 print((4.5 * 2 + 4.0 * 3) / (130 - 66)) 데이터 저장원뿔의 부피 &amp; 겉넓이 계산 프로그램 원뿔의 부피 &amp; 겉넓이 계산 알고리즘 print(1 / 3 * 3.14 * 20 ** 2 * 30) # 반지름 20, 높이 30 print(3.14 * 20 ** 2 + 3.14 * 20 * 30) # 부피 출력 # 겉넓이 출력 부피 = 1/3 * π * r^2 * h 겉넓이 = π * r^2 + π * r * h 변수 (variable) 명령형 패러다임 언어의 특징 처리할 데이터와 처리된 결과를 임시적으로 저장 변수의 값을 변경하는 할당 연산자 (=) 를 이용 오른쪽에 있는 값을 왼쪽에 집어 넣으라는 의미 20이 저장된 칸은 rad라는 이름으로 접근 가능 값의 할당 프로그램이 실행되는 과정에서 처리되는 값이 어떤 행위 (입력, 연산 등) 에 따라 그 값이 변할 수 있는 메모리 내의 저장 공간 지정 식별자, 저장 공간, 값으로 구성 rad = 20 # 20 (값) 이 rad (식별자) 라는 저장 공간에 할당됨 식별자 프로그램 내부에 정의된 객체 (변수, 함수 등) 의 이름 문자, 숫자, 밑줄로 구성 문자 또는 밑줄로만 시작 가능 예약어와 동일할 수 없음 길이 제한이 없음 # 올바른 예시 volume, Surface, _50, x, y, __name # 잘못된 예시 $D$, 1-a, 2023y, else, class, r+h, 77#R 어떤 저장 공간을 어떤 명칭으로 통칭하기 위한 목적으로 사용 고유하게 만들어야하는 저장 공간 예약어 (reserved word) 파이썬 인터프리터에 의해 이미 문법적인 용도로 사용되어 식별자로 사용이 불가능한 단어 False await else import pass None break except in True class finally is return and continue for lambda try as def global not with async elif if yield raise or 변수의 사용# 반지름, 높이 값 할당rad = 20hei = 30# 부피 출력print(1 / 3 * 3.14 * rad * rad * hei)# 겉넓이 출력print(3.14 * rad * rad + 3.14 * rad * hei)산술 연산자산술 연산자의 정의 피연산자 (operand) 에 대해 지정된 산술 연산을 지시하는 기호 단항 연산자 (unary operator) 이항 연산자 (binary operator) 특수 산술 연산자 프로그래밍 언어에서만 사용되는 연산 또는 부호 5 / 2 5 // 2 25 % 7 number % 2 8.4 % 0.9 정수 나눗셈 연산자 (//) 모듈로 연산자 (%) 연산자 우선순위 표현 식에 사용된 여러 연산자의 연산 순서를 결정 avg = 1 // 3 * 3.14 * 20 ** 2 * (30 + 20 % 10) 괄호 내부의 수식 지수 (**) 연산자 곱셈, 실수 나눗셈, 정수 나눗셈, 나머지 연산자 왼쪽에서 오른쪽 순서로 적용 덧셈, 뺄셈 연산자 왼쪽에서 오른쪽 순서로 적용 할당 연산자파이썬 내장 함수 파이썬 인터프리터에서 기본적으로 지원하는 함수 별도의 모듈이나 패키지 없이 사용 가능 max(2, 3, 4) min(2, 3, 4) round(3.4) pow(2, 3) abs(-3) round(3.141592) 연습 문제 다음과 같은 실행 결과를 얻기 위한 파이썬 코드로 올바른 것은? 'Computer science is the best' 'Our goal is to predict the future' a. print(\"Computer science is the best\") print(\"Our goal is to predict the future\") 다음 중 식별자로 사용할 수 없는 것은? a. 270mm 다음 프로그램의 실행 결과로 올바른 것은? a. 0 학습 정리 파이썬은 히도 판로쉼(Guido van Rossum)에 의해 1991년 분산 운영 체제(아메바)의 시스템 관리를 위한 쉘 스크립팅 언어로 개발됨 피연산자와 기본 연산자(+, -, *, /, \\\\)를 이용한 표현 식은 파이썬 인터프리터에 의해 자동 계산 됨 특정 작업을 수행하는 코드의 집합으로 함수의 이름 만으로 실행할 수 있는 단위를 함수라고 함 파이썬은 들여 쓰기에 의존적 언어이며 코드의 논리적 집합인 블록을 표현하는데 사용 됨 주석은 개발 속도 향상 시키고 유지 보수를 용이하게 하는 중요한 설명임 주석은 #과 \"\"\"을 사용함 처리할 데이터와 처리된 결과의 임시적 저장에 변수가 사용되며 할당 연산자의 왼쪽에 정의 함 식별자는 프로그램 내부에 정의된 객체(변수, 함수 등)의 이름임 프로그래밍 언어에서만 사용되는 산술 연산자로 정수 나눗셈 연산자(//)와 모듈로 연산자(%)가 있음 연산자 우선 순위는 표현 식에 사용된 여러 연산자의 연산 순서를 결정함 파이썬 내장 함수는 별도의 모듈이나 패키지 없이 파이썬 인터프리터에서 기본적으로 지원하는 함수임" }, { "title": "[Java 프로그래밍] 4강 - 클래스와 상속", "url": "/posts/knou-java-4/", "categories": "Language, Java", "tags": "knou, java", "date": "2025-03-28 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김희천 교수님의 'Java 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 클래스를 정의하고, 정의된 클래스를 사용하는 것에 관해 살펴봄 static필드와 메소드 및 final필드와 메소드의 의미 학습 객체의 생성과 초기화 및 메소드의 오버로딩 학습 기존 클래스를 이용해 새로운 클래스 정의하기 위한 클래스 상속 개념과 오버라이딩 이해학습 목표 클래스 정의 문법 숙지할 수 있음 static과 final키워드의 의미와 사용법을 설명할 수 있음 메소드 오버로딩과 오버라이딩 구분하고 적용 가능함 상속 개념 활용해 클래스 정의 가능함강의록클래스 정의와 사용static필드 static필드 class Circle { int x, y; int radius; static int count; } 정적 필드 or 클래스 변수 클래스의 모든 객체가 공유하는 데이터 객체의 생성이 없어도 항상 사용 가능 어떤 객체도 값을 변경할 수 있음 사용 방법 클래스이름.정적필드 객체변수.정적필드도 가능 static메소드 static메소드 class Math { public static double sqrt(double a) { } } 정적 메소드 or 클래스 메소드 non-static 메소드와 달리 객체와 무관하게 호출되고 실행 메소드의 몸체에서 this사용 불가 static메소드는 static필드를 다룸 호출 방법 클래스이름.정적메소드() 객체와 무관하므로 클래스 이름으로 호출 가능 객체변수.정적메소드()도 가능 정적 메소드를 호출하는 예시 Math.sqrt(2.0); Integer.parseInt(\"102\"); final필드와 final메소드 final필드 상수 데이터 선언할 때 초기 값 지정 필요 static과 자주 함께 사용 final static double PI = 3.141592; final메소드 자식 클래스로 상속은 가능하나 자식 클래스에서 재정의(오버라이딩) 할 수 없는 메소드 필드의 초기화 객체 생성 시 데이터 필드에 초기 값 지정하는 것 데이터 필드는 자동으로 초기 값(0,false 또는 null)이 주어질 수 있음 클래스 변수(static필드)는 프로그램 시작 시에 초기화 됨 객체 초기화를 위해 초기화 블록을 사용할 수 있음 초기 값 지정을 위한 코드로, 클래스 정의에서 메소드 바깥의 임의 위치에 들어갈 수 있음 static필드는 static초기화 블록을 사용 필드 초기화 방법의 실행 순서 class IniTest { static int nStatic = 0; int nValue = 1; // 초기값 선언하지 않을경우 0으로 자동 초기화 { // 초기화 블록 nValue = 2; // 초기값 변경 } static { nStatic = 1; // 클래스 변수 초기화 블록 } public IniTest() { // 생성자에서 초기화 nValue = 3; // 초기값 변경 } } static필드의 선언문에서 초기화 static초기화 블록 실행 non-static 필드의 선언문에서 초기화 non-static 초기화 블록 실행 생성자 실행 필드 초기화 코드 import java.awt.Point; class Rectangle { public int width = 0; // non-static 변수 초기화 public int height = 0; public Point origin; // Point 클래스 : 좌표상의 어떤 위치를 나타내는데 사용하는 클래스 public Rectangle() { origin = new Point(0,0); } public Rectangle(Point p, int w, int h) { // 생성자를 사용해 데이터 필드 초기화 origin = p; width = w; height = h; } } public class Main { public static void main(String args[]) { Point originOne = new Point(23, 94); // Point 클래스에 x와 y좌표값을 저장하기 위한 멤버 변수 존재 Rectangle rectOne = new Rectangle(originOne, 100, 200); } } 메소드 오버로딩class PrintStream { public void println() { } public void println(String x) { }} 매개 변수의 개수나 매개 변수의 자료형이 다르면 같은 이름의 메소드를 한 클래스에서 여러 개 정의 가능 매개 변수의 개수와 자료형이 일치하면 중복 정의 불가 리턴형과 접근 제어자는 구분의 기준이 되지 못함 메소드 시그니처를 가지고 메소드 구분 메소드의 이름, 매개 변수 리스트 메소드를 호출할 때, 가장 가까운 매개 변수 목록을 가진 메소드 호출 ex) System.out.println(); // 인자 없음 System.out.println(\"문자열\"); // 인자는 String System.out.println(241); // 인자는 int System.out.println(34.5); // 인자는 double mc.add(10, 10.5); // add(int, int)와 add(double, double) → 자동 형변환 후 add(double, double) 호출 클래스와 객체의 사용 예class Cylinder { private Circle c; // 원 (Circle 클래스 변수 정의) private int h; // 높이 public Cylinder(Circle a, int b) { c = a; h = b; } public double getVolume() { return c.getArea() * h; }}class Circle { double radius; public Circle(double a) { radius = a; } public double getArea() { return radius * radius * 3.14; }}public class Main { public static void main(String args[]) { Circle c = new Circle(3); // Circle 객체 생성 Cylinder cy = new Cylinder(c, 10); System.out.println(cy.getVolume()); }}상속클래스의 재사용 합성 class Line { Point begin, end; } 기존 클래스를 새로운 클래스 정의에서 데이터 필드의 자료형으로 사용 has-a 관계 상속 기존 클래스(부모)를 사용해 새로운 클래스(자식)를 정의 코드의 중복 작성을 줄이고 프로그램의 확장성 증가 기존 클래스를 확장 or 특화하는 것 자식 is -a 부모의 관계 클래스의 상속 상속은 부모 클래스와 자식 클래스 간의 관계 자식 클래스가 부모 클래스의 필드와 메소드를 상속 받음 기존 클래스를 상속 받을 때 키워드 extends사용 ex) class Manager extends Employee { // 자식 클래스(새로운 클래스) Manager // 부모 클래스(기존 존재 클래스) Employee } 자식 클래스에서 상속받은 메소드를 오버라이딩(재정의) 할 수 있음 클래스의 상속은 단일 상속만 가능 인터페이스 상속의 경우는 다중 상속 가능 클래스의 상속 class CSuper { private int f1; public int f2; public void setPrivate(int i) { f1 = i; } public void setPublic(int i) { f2 = i; } private void mPrivate() { f1 = 30; } } class CSub extends CSuper { private int f3; public int f4; } public class Main { public static void main(String args[]) { CSub sub = new CSub(); // sub.f1 = 40; // 오류 발생 sub.f2 = 50; // sub.f3 = 60; // 오류 발생 sub.f4 = 70; sub.setPrivate(10); sub.setPublic(20); // sub.mPrivate(); // 오류 발생 } } 메소드 오버라이딩 부모로부터 상속 받은 메소드의 몸체를 자식 클래스에서 재정의하는 것 부모와 자식에서 같은 이름의 메소드가 다른 기능 수행하게 됨 오버라이딩 방법 메소드의 이름, 인자의 개수와 자료형, 반환형이 같은 메소드를 정의 단, 반환형은 서브 타입(상속 관계에서 자식 클래스)도 가능함 접근 제어자의 가시성(접근 범위)은 같거나 커져야 함 protected인 경우 protected또는 public public인 경우 public만 가능 메소드 오버라이딩 class Shape { // 부모 클래스 public double getArea(double h, double w) { return h * w; } } class Triangle extends Shape { // 자식 클래스 public double getArea(double h, double w) { return h * w * 0.5; } } // getArea 메소드 재정의 -&gt; 메소드 오버라이딩 public class Main { public static void main(String args[]) { Shape t = new Triangle(); // Shape 자식 클래스 Triangle 객체 생성 System.out.println(t.getArea(3.0, 4.0)); // 3.0 * 4.0 * 0.5 = 6.0 출력 } } thisclass Circle { static double PI = 3.14; double radius = 2.0; // 반지름 public double getArea() { return this.radius * this.radius * PI; // c1.radius 호출 시 this값은 c1값을 가지게 됨 } public void display() { System.out.println(\"반지름:\" + this.radius + \" 면적:\" + this.getArea()); } public static void main(String args[]) { Circle c1 = new Circle(); Circle c2 = new Circle(); c2.radius = 5.0; // c2의 반지름을 5.0으로 변경 c1.display(); c2.display(); }} 메소드 호출 시, 숨은 인자로 this가 메소드에 전달됨 this는 현재 객체에 대한 참조 값을 가지고 있음 c1.display()과 c2.display()의 결과가 다른 이유임 인스턴스 메소드나 생성자에서 필드를 참고하거나 메소드를 호출할 때 사용 가능(생략 가능) this.필드 이름 this.메소드 이름(인자) superclass CSuper { public double x = 0; public void f() { System.out.println(\"CSuper\"); }}class CSub extends CSuper { public double x = 1; public void f() { System.out.println(\"CSub\"); } public void print() { System.out.println(\"super.x\"); super.f(); }} this와 같으나 자료형이 부모 클래스 유형임 자식 클래스의 인스턴스 메소드나 생성자에서 사용됨 this와 마찬가지로 static메소드에서 사용할 수 없음 부모 클래스에서 오버로딩 당한 메소드를 호출하거나 상속되었으나 감춰진 필드에 접근할 때 필요함 super.필드 이름 super.메소드 이름(인자) this와 super의 사용 class CSuper { // 부모 클래스 public double x; } class CSub extends CSuper { // 자식 클래스 public double x; public CSub(double new_x) { this.x = new_x; // 자식 클래스의 x 필드 값 지정 super.x = new_x * 10; // 부모 클래스의 x 필드 값 지정 } public double getSuper() { return super.x; // 상속받은 x 리턴 } public double getSub() { return this.x; // 재정의한 x 리턴 } } public class Main { public static void main(String args[]) { CSub sub = new CSub(10.0); System.out.println(sub.x); // 10.0 System.out.println(sub.getSuper()); // 100.0 출력 System.out.println(sub.getSub()); // 10.0 출력 } } 상속과 생성자 this() 같은 클래스의 다른 생성자를 호출하는 것 super() 자식 클래스의 생성자에서 부모 클래스의 생성자를 호출하는 것 상속받은 데이터 필드를 초기화하기 위해 사용 자식 클래스의 생성자 몸체에서 부모 클래스 생성자의 명시적 호출이 없다면, 인자가 없는 생성자인 super()가 자동 호출됨 this()와 super()는 생성자 몸체의 맨 앞에 위치해야 함super와 super()의 사용public class Cyliner extends Circle { private double height; static final double PI = 3.14; public Cylinder() { super(); // 부모클래스의 생성자 초기화 height = 1.0; } public Cylinder(double radius, double h) { super(radius); // double값을 가지는 인자로 부모클래스의 생성자 초기화 this.height = h; } public double getHeight() { return height; } public void setHeight(double h) { this.height = h; } /** * 원기둥의 겉넓이 계산 * 2 * 3.14 * 반지름 * 높이 + 2 * 원의 면적 */ public double getArea() { // Cylinder의 getArea() 메소드 return 2 * PI * getRadius() * height + 2 * super.getArea(); // 상속받은 this.getRadius() 호출 } /** * 원기둥의 부피 계산 * 원의 면적 * 높이 */ public double getVolume() { return super.getArea() * height; // Circle의 getArea() 메소드 호출 } public String toString() { return \"Cylinder of radius = \" + getRadius() + \" height = \" + height; }}public class Main { public static void main(String args[]) { System.out.println(new Cylinder(3, 10).getVolume()); }}메소드 체이닝 하나의 명령문에서 동일 객체에 대해 연속적으로 메소드 호출을 하는 프로그래밍 기법 메소드 체이닝에 사용되는 메소드는 현재 객체의 참조 값(this)을 반환해야 함 메소드 체이닝은 프로그램의 가독성을 향상 시키고, 코딩을 단순화 함 ex) p.setName(\"홍길동\").setAge(30).setAddress(\"서울\"); 메소드 체이닝의 사용 class People { String name; int age; String address; public String getName() { return name; } public void setName(String name) { this.name = name; } } public class Main { public static void main(String[] args) { People p = new People(); p.setName(\"홍길동\"); p.setAge(30); p.setAddress(\"서울\"); } } class People { String name; int age; String address; public String getName() { return name; } public People setName(String name) { this.name = name; return this; } } public class Main { public static void main(String[] args) { People p = new People(); p.setName(\"홍길동\").setAge(30).setAddress(\"서울\"); } } 학습 정리 클래스를 정의할 때, 클래스의 모든 객체가 공유하는 데이터는 static데이터 필드로 정의함 클래스 정의에 있는 데이터 필드의 선언문, 초기화 블록, 생성자를 통해서 객체 생성 시 필요한 데이터 필드의 초기값 지정 가능 메소드 오버로딩이란 한 클래스에서 이름이 같은 여러 메소드가 존재하는 상황을 말함 이때 오버로딩된 메소드끼리는 매개 변수 목록이 달라 구별될 수 있음 부모로부터 상속받은 메소드의 몸체를 자식 클래스에서 다시 정의하는 것을 메소드 오버라이딩이라고 함 인스턴스 메소드와 생성자에서 숨은 인자인 this, super사용할 수 있음 this()는 같은 클래스에 있는 다른 생성자를, super()는 자식 클래스 생성자에서 부모 클래스 생성자를 호출하기 위한 것연습 문제 키워드 final에 관한 설명으로 틀린 것은? a. final클래스의 객체를 생성할 수 없다. 키워드 final final클래스의 자식 클래스를 정의할 수 없음 부모 클래스의 final메소드는 자식 클래스로 상속될 때 재정의될 수 없음 final변수는 상수로 사용됨 Circle 클래스에서 원주율 PI를 상수로 선언하기 위해 밑줄 친 ㉠에 들어갈 적당한 내용은 무엇인가? class Circle { \t// ㉠ \tprivate double radius; \tpublic Circle(double radius) { \t\t// ㉡ \t} \tpublic double getArea() { \t\treturn radius * radius * PI; \t} } a. static final double PI = 3.14; Circle 클래스의 생성자에서 밑줄 친 ㉡에 들어갈 적당한 내용을 작성하시오 a. this.radius = radius; " }, { "title": "[데이터베이스 시스템] 3강 - 관계형 모델", "url": "/posts/knou-dbs-3/", "categories": "Database", "tags": "knou, database", "date": "2025-03-27 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '데이터베이스 시스템' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 우리 주변에서 사용되는 상용 DBMS의 대다수가 관계형 모델을 사용할 정도로 관계형 모델은 DBMS를 학습함에 있어 매우 중요한 데이터 모델이라고 할 수 있음 관계형 모델은 일련의 정형화된 릴레이션과 수학적 이름에 기초하고 있어 사람에게 가장 직관적이기 때문에 설계 및 사용이 쉽고, 다른 모델에 비해 가장 우수한 성능을 나타냄 관계형 모델의 기본적인 특징과 용어 및 그 의미에 대하여 학습함 개념적 데이터 모델링의 결과인 ER 다이어그램을 관계형 모델로 변환하는 방법, 릴레이션을 조작하기 위한 다양한 관계 대수 연산자에 대하여 학습함주요 용어 릴레이션 관계형 모델에서 데이터를 저장ㆍ관리하는 2차원 형태의 표 레코드의 유일성, 무순서성, 컬럼의 무순서성, 컬럼 값의 원자성 특징이 있음 키 릴레이션에 포함된 레코드를 유일하게 식별할 수 있는 값 유일성과 최소성을 만족 제약 조건 모든 릴레이션 인스턴스가 만족해야 하는 조건으로 영역 제약 조건, 키 제약 조건, 개체 무결성 제약 조건, 참조 무결성 제약 조건 관계 대수 주어진 릴레이션에서 필요한 릴레이션을 만드는 과정을 연산자 사용한 수식으로 표현하는 방식 강의록관계형 모델의 개념데이터베이스 모델링 과정논리적 데이터 모델링 단계 DBMS의 구현 모델에 맞춰 데이터의 구조를 표현하는 과정 구현 모델 데이터의 저장, 인출 방법을 명시 데이터 정의 언어로 기술된 개념 스키마 생성 관계형 모델(relational model) 1969년 에드가 F.코드에 의해 제안 릴레이션(relation)으로 데이터를 표현하는 모델 데이터 표현이 단순하고 직관적 구조화 모델 현재 대다수 DBMS의 기초 관계형 모델을 사용하는 관계형 DBMS(RDBMS) Oracle, DB2, PostgreSQL, MySQL, MSSQL 등 데이터를 빨리 찾을 수 있도록 체계화 시킨 큰 틀 개념적 데이터 모델링의 결과릴레이션의 구성 릴레이션 방대한 메타 데이터와 값을 집약적으로 표현, 저장할 수 있는 구조 모든 형태의 데이터들은 두 개의 메타 데이터에 의해 결정 하나의 값이 데이터가 되기 위해서는 두 개 이상의 메타 데이터가 있어야 함(레코드, 컬럼) 물리적 데이터 모델링에서는 table이라 부름 하나의 컬럼과 레코드가 관계를 형성해 데이터를 결정 지을 수 있는 구조 스키마 릴레이션을 구성하고 있는 컬럼을 명시하는 전체적인 구조 레코드 스키마에 맞춰서 하나에 해당하는 데이터의 집합 컬럼 같은 특성을 가지고 있는 하나의 속성 값들의 집합 릴레이션의 특징 레코드의 유일성 중복된 레코드의 존재가 불가능 레코드의 무순서성 레코드의 순서는 의미가 없음 컬럼의 무순서성 컬럼은 순서가 없고, 이름과 값의 쌍 컬럼 값의 원자성 모든 값들은 나눌 수 없는, 단 하나의 의미 키(key)의 개념 릴레이션 레코드를 유일하게 식별하는 값 키의 속성 및 종류 키의 속성 유일성(Uniqueness) 최소성(Irreducibility) 최소성 여러 개의 컬럼으로 구성된 키(key)가 있을 때, 없어도 되는 컬럼이 있으면 제외해야 함 키의 종류 수퍼 키(super key) 유일성 만족 최소성 만족 못 시킴 후보 키(candidate key) 유일성, 최소성 만족 기본 키(PK: primary key) 레코드의 구분을 위해 선택된 후보 키 관리자가 후보 키 중에서 지정 외래 키(FK: foreign key) 참조된 한 릴레이션의 기본 키 한 릴레이션 레코드와 다른 릴레이션에 관계된 레코드가 무엇인지 파악 가능 관계형 모델의 예 수퍼 키 학과 이름, {학과 이름, 단과 대학}, 주소, 전화번호, {전화 번호, 졸업 학점} 등 후보 키 학과 이름, 주소, 전화 번호 기본 키 학과 이름 키가 될 수 있는 것들 단과 대학 + 졸업 학점, 학과 이름, 전화 번호 키의 참조 두 릴레이션에 포함된 레코드 간 연관성을 표현 하나의 릴레이션에 포함된 레코드가 다른 릴레이션과 연관되어 있다는 것을 표현하기 위한 방법 외래 키(FK)를 통해 다른 릴레이션의 레코드 식별 가능 값이 중복될 수 있음 관계형 모델의 제약 조건 영역 제약 조건 컬럼에 정의된 영역(domain)에 속한 값으로만 컬럼 값이 결정 키 제약 조건 키는 레코드를 고유하게 구별하는 값으로 구성 개체 무결성 제약 조건 어떠한 기본 키 값도 null이 될 수 없음 기본 키에는 반드시 무언가가 입력되어야 함 null 한번도 입력되지 않은 상태 참조 무결성 제약 조건 반드시 존재하는 레코드의 기본 키만 참조 가능 널(NULL)의 개념 없음 또는 0이 아닌 미지의 값에 대한 표현 입력된 적이 없는 값 적용 불가능한 값 논리적 데이터 모델링의 수행논리적 데이터 모델링의 개념 DBMS의 구현 모델에 맞춰 데이터를 표현하는 과정 데이터 정의 언어로 기술된 개념 스키마 생성 논리적 데이터 모델링의 역할 관계형 DBMS(RDBMS)의 구현 모델이 맞춰 데이터의 구조와 관계를 표현 도출된 ERD를 RDBMS가 수용 가능한 구조로 변환 관계형 모델로 변환 방법 개체 집합 개체 집합은 릴레이션으로 변환 약한 개체 집합 강한 개체 집합의 키 속성을 약한 개체 집합의 릴레이션에 포함 일대일 관계 두 릴레이션 중에서 한 릴레이션의 기본 키를 다른 릴레이션에서 외래 키로 참조 일대다 혹은 다대일 관계 일 쪽의 기본키를 다 쪽 릴레이션에서 외래 키로 참조 다대다 관계 관계 릴레이션을 생성하고, 두 릴레이션의 기본 키를 각각 참조하는 외래 키를 복합 키 형태의 컬럼으로 구성 다중 값 속성 릴레이션의 기본 키를 참조하는 외래 키와 다중 값 속성으로 별도의 릴레이션으로 구성 관계 집합의 속성 외래 키가 위치한 릴레이션의 컬럼으로 삽입 ER 다이어그램의 변환 과목 코드를 교수 릴레이션의 외래 키로 넣으면 컬럼 값의 원자성에 위배됨 일대다의 관계에서는 다쪽의 개체 집합에 의해 만들어진 릴레이션에 외래키 위치 시킴 다대다의 관계에서는 관계 자체가 릴레이션으로 만들어짐 제약 조건을 표현하기 위해서 학생 번호도 PK로 지정 학생이 없어지면 계좌도 없어져야 함 관계형 데이터 연산관계 연산의 개념 관계형 모델을 기반으로 구성된 릴레이션을 사용하여 새로운 릴레이션을 생성하는 연산자 사용자의 관점에서 필요한 데이터를 다수의 릴레이션에서 추출하는 방법이 필요 관계 대수(relational algebra) 관계 연산을 정의하는 방법 주어진 릴레이션에서 필요한 릴레이션을 만드는 연산자(⋃, ⋂, -, σ, π, X, ⋈, ÷, 집계 연산 등)로 구성 관계 대수 연산자는 새로운 임시 릴레이션을 생성 연산자를 중첩하여 연산 처리 절차를 표현 셀렉트 연산 주어진 릴레이션에서 조건을 만족하는 레코드를 갖는 릴레이션을 생성 σ조건(R) 조건 a⊝b 또는 a⊝v a, b 속성 이름 V 상수 값 Θ 비교자 {=, ≠, &lt;, &gt;, ≤, ≥} R 릴레이션 조건의 결합 ∧ and ∨ or 셀렉트 연산의 예 교수번호 교수이름 직위 소속학과 연봉 186432-760829 최우성 조교수 생활과학과 52000000 189414-790829 한용운 조교수 법학과 45000000 191924-730620 이동휘 부교수 행정학과 51000000 194634-810228 김규식 정교수 컴퓨터과학과 70000000 194834-760517 정재화 부교수 컴퓨터과학과 53000000 201216-158465 정용제 조교수 국어국문학과 55000000 조건 σ소속학과 = '컴퓨터과학과'(교수) 결과 교수번호 교수이름 직위 소속학과 연봉 194634-810228 김규식 정교수 컴퓨터과학과 70000000 194834-760517 정재화 부교수 컴퓨터과학과 53000000 교수번호 교수이름 직위 소속학과 연봉 186432-760829 최우성 조교수 생활과학과 52000000 189414-790829 한용운 조교수 법학과 45000000 191924-730620 이동휘 부교수 행정학과 51000000 194634-810228 김규식 정교수 컴퓨터과학과 70000000 194834-760517 정재화 부교수 컴퓨터과학과 53000000 201216-158465 정용제 조교수 국어국문학과 55000000 조건 σ소속학과 = '컴퓨터과학과' ^ 연봉 ≥ 60000000(교수) 결과 교수번호 교수이름 직위 소속학과 연봉 194634-810228 김규식 정교수 컴퓨터과학과 70000000 프로젝트 연산 기술된 컬럼만 갖는 릴레이션으로 재구성 Π&lt;컬럼리스트&gt;(R) A^1, A^2, … A^n와 같이 R에 존재하는 컬럼을 ,(콤마)로 분리하여 기술 컬럼의 순서를 다르게 표현하고자 할 때에는 프로젝트 연산자에서 컬럼의 순서를 다르게 표기하면 됨프로젝트 연산의 예 교수번호 교수이름 직위 소속학과 연봉 186432-760829 최우성 조교수 생활과학과 52000000 189414-790829 한용운 조교수 법학과 45000000 191924-730620 이동휘 부교수 행정학과 51000000 194634-810228 김규식 정교수 컴퓨터과학과 70000000 194834-760517 정재화 부교수 컴퓨터과학과 53000000 연산식 Π교수이름, 소속학과(교수) 결과 교수이름 소속학과 최우성 생활과학과 한용운 법학과 이동휘 행정학과 김규식 컴퓨터과학과 정재화 컴퓨터과학과 관계 대수 연산식의 활용 Q. 직위가 부교수인 교수의 교수 이름을 출력하라 교수번호 교수이름 직위 소속학과 연봉 186432-760829 최우성 조교수 생활과학과 52000000 189414-790829 한용운 조교수 법학과 45000000 191924-730620 이동휘 부교수 행정학과 51000000 194634-810228 김규식 정교수 컴퓨터과학과 70000000 194834-760517 정재화 부교수 컴퓨터과학과 53000000 201216-158465 정용제 조교수 국어국문학과 55000000 201547-634895 현경석 정교수 생활과학과 66000000 210315-549413 황지수 부교수 유아교육과 52000000 연산식 σ직위 = '부교수'(교수) 결과 교수번호 교수이름 직위 소속학과 연봉 191924-730620 이동휘 부교수 행정학과 51000000 194834-760517 정재화 부교수 컴퓨터과학과 53000000 210315-549413 황지수 부교수 유아교육과 52000000 연산식 Π교수이름(σ직위 = '부교수'(교수)) 결과 교수이름 이동휘 정재화 황지수 집합 연산자 릴레이션은 집합, 레코드는 집합에 포함된 원소 집합 이론에서의 이진 연산 합집합 : R ⋃ S 교집합 : R ⋂ S 차집합 : R - S 집합 연산자 사용 조건 릴레이션 R과 S의 차수가 동일 모든 i에 대해 R의 i번째 컬럼의 도메인과 S의 i번째 컬럼의 도메인이 반드시 동일 카티시언 프로덕트 연산R X S 두 릴레이션에 포함된 레코드 간의 모든 조합을 생성하는 이항 연산자 카티시언 프로덕트 연산의 예 교수 X 학과 교수 릴레이션 교수번호 교수이름 소속 소속학과 186432-760829 최우성 … 생활과학과 189414-790829 한용운 … 법학과 191924-730620 이동휘 … 행정학과 194634-810228 김규식 … 컴퓨터과학과 194834-760517 정재화 … 컴퓨터과학과 201216-158465 정용제 … 국어국문학과 201547-634895 현경석 … 생활과학과 210315-549413 황지수 … 유아교육과 학과 릴레이션 학과이름 단과대학 주소 전화번호 졸업학점 국어국문학과 인문과학대학 … … 120 법학과 사회과학대학 … … 130 생활과학과 자연과학대학 … … 125 유아교육과 교육과학대학 … … 125 컴퓨터과학과 자연과학대학 … … 130 행정학과 사회과학대학 … … 120 교수 X 학과 교수번호 교수이름 소속 소속학과 학과이름 단과대학 주소 전화번호 졸업학점 186432-760829 최우성 … 생활과학과 국어국문학과 인문과학대학 … … 120 186432-760829 최우성 … 생활과학과 법학과 사회과학대학 … … 130 186432-760829 최우성 … 생활과학과 생활과학과 자연과학대학 … … 125 186432-760829 최우성 … 생활과학과 유아교육과 교육과학대학 … … 125 186432-760829 최우성 … 생활과학과 컴퓨터과학과 자연과학대학 … … 130 186432-760829 최우성 … 생활과학과 행정학과 사회과학대학 … … 120 조인 연산 두 릴레이션에서 조건을 만족하는 레코드만 결합한 레코드로 구성된 릴레이션을 생성 Q. 컴퓨터 과학과 소속의 교수가 강의하는 과목의 과목명과 과목 코드는? 과목코드 과목명 학점 선수과목 이수구분 교수번호 COM11 컴퓨터의이해 3   교양 194634-810228 COM12 파이썬프로그래밍기초 3   교양 194834-760517 COM24 자료구조 3 COM12 전공필수 194634-810228 COM31 데이터베이스시스템 3 COM24 전공필수 194834-760517 COM34 알고리즘 3 COM24 일반선택 194634-810228 COM44 클라우드컴퓨팅 3   전공필수 194834-760517 ECE24 놀이지도 3   전공필수 210315-549413 … … … … … … 과목 X 교수 과목코드 과목명 … 교수번호 교수번호 교수이름 직위 … COM11 컴퓨터의이해 … 194634-810228 186432-760829 최우성 조교수 … COM11 컴퓨터의이해 … 194634-810228 189414-790829 한용운 조교수 … COM11 컴퓨터의이해 … 194634-810228 191924-730620 이동휘 부교수 … COM11 컴퓨터의이해 … 194634-810228 194634-810228 김규식 정교수 … COM11 컴퓨터의이해 … 194634-810228 194834-760517 정재화 부교수 … COM11 컴퓨터의이해 … 194634-810228 201216-158465 정용제 조교수 … COM11 컴퓨터의이해 … 194634-810228 201547-634895 현경석 정교수 … COM11 컴퓨터의이해 … 194634-810228 210315-549413 황지수 부교수 … … … … … … … … … LAW12 헌법의기초 … 189414-790829 201547-634895 현경석 정교수 … LAW21 세법개론 … 189414-790829 210315-549413 황지수 부교수 … PA05 행정학개론 … 191924-730620 186432-760829 최우성 조교수 … σ과목.교수번호=교수.교수번호(과목X교수) 집계 함수 연산 집계 함수를 값들의 집합 또는 레코드의 집합에 적용하는 연산 A 집계 연산을 적용할 컬럼 x( ) AVG, SUM, MIN, MAX, COUNT 등의 집계 함수 집계 함수의 예그룹화를 이용한 집계 함수 연산 레코드 그룹화를 위해 집계 함수 연산자 앞에 그룹화 속성을 기술 B 그룹의 기준이 되는 컬럼 x() 집계 함수 A 집계 연산을 적용할 컬럼 R 릴레이션 그룹화 속성이 없는 경우, 전체 릴레이션을 한 개의 그룹으로 가정 그룹화를 이용한 집계 함수의 사용 예연습 문제 관계형 모델에서 표와 유사하게 2차원 구조로 데이터를 표현하는 저장하는 것은? a. 릴레이션 관계형 모델은 2차원 구조 표와 유사하게 컬럼과 레코드로 데이터를 표현하는 릴레이션에 데이터를 저장함 다음은 무엇에 대한 설명인가? 두 개의 릴레이션 사이에 명시되는 제약 조건으로, 한 릴레이션에 있는 레코드가 다른 릴레이션에 있는 레코드를 참조하려면 반드시 존재하는 릴레이션만 참조해야 한다는 제약 조건을 명시한다. a. 참조 무결성 제약 조건 영역, 키, 개체 무결성 제약 조건을 한 릴레이션에 대한 제약 조건인 반면, 참조 무결성 제약 조건은 두 릴레이션 사이에서 명시되는 조건 반드시 존재하는 값만을 참조할 수 있다는 조건 데이터 간 관계를 대표 되는 값을 참조하는 형태로 표현하는 관계형 모델에서 관계에 대한 일관성을 유지하는데 사용 다음의 ER 다이어그램을 관계형 모델로 올바르게 변환한 것은? a. 두 개체 집합에 대응하는 릴레이션이 생성되므로 고객 릴레이션과 계좌 릴레이션이 생성되며 각각의 속성을 릴레이션의 컬럼에 대응됨 그리고 키 속성을 기본 키로 변환되어 고객 릴레이션에는 고객 번호가, 계좌 릴레이션에는 계좌 번호가 기본 키가 됨 개설 관계 집합에 연관 된 두 개체 집합에서 고객 개체 집합만 화살 선으로 연결되어 있으므로 1:N 관계 집합임 외래 키는 N쪽인 계좌 집합 쪽에 위치함 정리 하기 관계형 모델은 표와 매우 유사한 구조인 릴레이션에 기초함 레코드는 릴레이션의 각 행을 의미하며, 컬럼은 각 열을 의미 릴레이션 스키마란 어떠한 테이블에서 사용되는 컬럼과, 컬럼이 지니는 데이터 타입을 정의한 것을 의미 릴레이션은 일반 표와는 달리, 레코드의 유일성, 레코드의 무순서성, 컬럼의 무순서성, 컬럼 값의 유일성이라는 특징을 갖음 기본 키는 한 데이터베이스 내에서 레코드를 유일하게 판별할 수 있는 컬럼을 말하며, 카디널리티는 레코드의 개수를 의미 키의 종류로는 기본 키, 후보 키, 수퍼 키 등이 있음 관계형 모델은 영역 제약 조건, 키 제약 조건, 개체 무결성 제약 조건, 참조 무결성 제약 조건이 항상 만족 되도록 모든 데이터의 삽입, 수정, 삭제 시 데이터를 검증하며, 이를 통해 데이터의 무결성과 일관성을 유지 시킴 ER 모델링의 결과를 토대로 실제 상용 DBMS상의 데이터베이스를 만들기 위해서는 각 DBMS에 맞는 구현 데이터 모델로의 변환이 필요함 이러한 변환 과정을 논리적 데이터 모델링이라고 함 ER 모델에서 관계 데이터 모델로의 변환 시 보통 개체는 릴레이션으로, 약한 개체 집합의 경우 강한 개체의 키를 약한 개체의 부분 키와 합쳐서 기본 키로 갖는 릴레이션으로 변환 가능 ER 모델에서 관계 데이터 모델로의 변환 시 사상수에 따라 테이블 간 레코드의 연관성을 외래 키와 기본 키의 참조 관계로 표현 관계 데이터베이스에서는 관계 대수라는 절차적 질의 언어를 사용할 수 있음 관계 대수 연산에서 릴레이션에 대한 집합 연산으로는 셀렉트, 프로젝트, 합집합, 교집합, 차집합, 카티션 프로덕트 연산 등이 있음 관계 대수의 또 다른 연산은 자연 조인, 할당 연산자 및 프로젝트 연산과 SUM, AVG, MAX, MIN, COUNT와 같은 집계 함수가 있음체크 포인트 데이터 베이스에서 릴레이션에 대한 설명으로 틀린 것은? a. 모든 필드는 서로 다른 값을 가지고 있다. 릴레이션에 대한 설명으로 옳은 것 모든 속성 값은 원자 값(atomic value)을 가짐 각 속성은 릴레이션 내에서 유일한 이름을 가짐 하나의 릴레이션에서 투플은 특정한 순서를 가지지 않음 릴레이션에서 기본 키를 구성하는 속성은 널(null) 값이나 중복 값을 가질 수 없다는 것을 의미하는 제약 조건은? a. 개체 무결성 " }, { "title": "[유비쿼터스 컴퓨팅 개론] 4강 - 디바이스 기술 - SoC/MEMS", "url": "/posts/knou-uqc-4/", "categories": "Computer Science, CS Theory", "tags": "knou, ubiquitous computing", "date": "2025-03-26 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정광식 교수님의 '유비쿼터스 컴퓨팅 개론' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 인간과 사물이 지능화되고 고도화되는 과정에서 여러 가지 세부 기술들이 결합되어 새로운 유비쿼터스 세상으로 발전하게 됨 유비쿼터스 컴퓨팅 환경의 디바이스에 가장 큰 영향을 주고 디바이스를 구성하는 주요 기술 요소인 SoC(System on Chip), 미세 전자기계 시스템(Micro Electro Mechanical Systems; MEMS) 기술 등을 공부함학습 목표 소형화 지능화가 요구되는 미래 환경에 대응하기 위한 핵심 기술인 MEMS 기술의 개념과 MEMS 기술의 발달 과정을 이해할 수 있음 반도체 기술과 비교하여 MEMS 기술의 특징을 이해할 수 있음 MEMS 기술의 다양한 응용 분야를 이해할 수 있음 SoC 기술의 장담점과 기술개발 현황을 이해할 수 있음강의록SoC배경 많은 전자기기가 본래의 서비스 제공 영역을 넘어 다기능화 및 소형화되고 있으며, 서로 다른 서비스를 제공하던 전자기기 간에 융합 및 복합화가 일어나고 있는 상황에서, SoC는 이러한 변화의 중추적인 역할을 하고 있음정의 SoC (System-on-Chip) 기술 칩(Chip) 자체가 하나의 시스템으로 기능할 수 있도록, 마이크로프로세서(CPU)와 디지털 신호 처리 장치(DSP), 메모리, 베이스밴드 칩, 임베디드 소프트웨어 등 다양한 기능 블록을 하나의 칩에 집적시킨 것 PC는 메인 보드와 CPU, 메인 메모리, 그래픽 카드 등으로 구성되지만 이러한 모든 부품(또는 핵심 기능)을 하나의 칩 위에 구현하여 집적하는 기술 칩 자체가 하나의 시스템으로 기능할 수 있도록 정보통신 기기의 핵심 기능을 담당하는 메모리, 디지털 회로, 아날로그 회로, CPU, 센서, 안테나, 수동 소자 등을 하나의 반도체 칩에 집적하는 기술 ex) Apple M1 칩 다이어그램 구성 요소: CPU, GPU, DRAM, Neural Engine, 캐시 등 5나노 공정, 160억 개 트랜지스터, 고성능/저전력 등 개요 각종 부품을 하나의 반도체 칩에 집적 시킴으로써, 향후 반도체 뿐만 아니라 개별 부품을 모두 하나의 칩으로 만들기 위한 기술 고성능 및 저전력 특성 때문에 휴대용 정보 단말기나 여러 임베디드 시스템에 적합 현재는 대규모 집적 회로(LSI)를 기반으로 마이크로프로세서와 메모리 등을 통합하는 데 초점을 맞추고 있으나, 향후에는 미세 전자 기계 시스템(MEMS) 기술과도 융합되어 발전할 것으로 전망 됨SoC의 개념 예를 들면, 휴대폰 내에 통신 기능 칩과 컴퓨팅 기능 칩 2개가 필요하지만, SoC 기술을 이용하면 칩 하나가 이 두 기능을 모두 수행할 수 있음 적절한 SoC의 개발은 휴대폰의 소형화와 전력 효율 향상과 직결 됨 대표적인 적용 사례는 스마트폰의 AP (Application Processor)이며, 명령어 처리 및 연산을 위한 CPU, 멀티미디어 데이터 재생 및 처리를 위한 영상 연산 담당 GPU, 기억 장소를 제공하는 메모리 (RAM), 기본적인 음성 통화 기능 및 데이터 송수신 기능 부분 등이 하나의 칩으로 통합된 형태임 기능마다 별개의 칩을 구성하는 것에 비해 SoC는 비용과 부피 및 크기의 소형화에 이점이 있으며, 전력 소모 절감 등의 효과가 있음 스마트폰 뿐만 아니라 태블릿 PC, 비디오 게임 콘솔, 홈 서버, 노트북 등에서 광범위하게 사용되고 있음 SoC를 사용하면 급속한 정보 통신 기술의 변화와 경쟁에 대응하기에 유리함 반도체 산업과 IT 산업 전반에 걸쳐 상당한 파급 효과를 가져 오고 있음 SoC의 발전 요소 초소형, 저전력화가 가능하도록 설계 기술 및 원가에서의 경쟁력 제고와 함께 생산 설비와 기술을 확보하는 것이 매우 중요함 나노 미터급 초미세 회로 공정 기술이 필수적이므로 대규모 투자와 기술 개발 능력의 확보가 필요함SoC 기술 발전의 특수성 하나의 SoC에 동적 램(DRAM)이나 정적 램(SRAM)을 포함할 수 있지만, 물량이 많이 확보된 제품이나 비디오 게임기와 같이 특수한 응용 분야가 아니면 경제성 문제가 발생할 수 있음 플래시 메모리는 제조 공정이 너무 달라서 단일 칩으로 SoC화 하는 것 보다는 별도의 칩으로 분리하는 것이 더 바람직함 아날로그 방식은 디지털 방식에 비해 단일 칩으로 소화하기에는 규모의 효과가 훨씬 떨어지는 약점이 있음MEMSMEMS (Micro Electro Mechanical System) 개요 초소형 3차원 구조물 또는 이를 포함하는 시스템 구현을 의미함 소형화 및 지능화가 요구되는 분야에서 핵심 기술로 인식됨 반도체 제조 공정 기술을 이용한 실리콘 미세 가공 기술 및 집적 회로(IC) 공정 기술을 접목하여 탄생 함 미세 기계 제작 및 전자 회로와의 집적화를 가능하게 하는 기술MEMS 기술의 정의 MEMS M(Micro)는 마이크로 스케일로 매우 작은 크기를 의미 EM(Electro Mechanical)은 전자와 기계적인 동작 영역 S(System)는 특정한 기능을 갖는 시스템을 의미 전자 기계 소자를 육안으로는 보이지 않을 정도로 작은 수 밀리미터에서 수 마이크로미터의 크기로 제작하는 기술 단순히 기존의 기계를 축소한다고 해서 마이크로 기계가 되는 것은 아님 MEMS 기술로 만들어진 기계의 구성 요소 뇌와 신경에 해당하는 논리 회로 탐지 기능을 담당할 각종 센서 팔과 다리 역할을 할 기계 장치 유기적으로 움직이게 할 수 있는 구동 장치 MEMS (Micro Electro Mechanical System)MEMS 기술의 특징 주변 환경을 인식하여 데이터를 수집, 처리하고, 이에 따라 적절한 동작을 취할 수 있는 일련의 통합 시스템이어야 함 MEMS의 제작은 전통적인 기계 가공 방법으로는 곤란하므로 반도체 미세 가공 기술을 이용하여 제작 됨 대량 생산이 가능하고, 가격이 저렴하며, 소형이고 고밀도 집적화가 가능함 반도체 칩 작고 좁은 면적에 수많은 전기 회로를 2차원적으로 집적 MEMS 3차원으로 공간을 마련해 회로를 배열하는 점이 다르며, 반도체 소자와는 차별화된 특수 첨단 제작 공정이 필요함 대규모 집적 회로(LSI) 프로세서에 의한 신호 처리와 메모리에 의한 기억 기능을 수행하며, 인간의 두뇌라 할 수 있음 MEMS 외부 세계와의 인터페이스 역할이 추가된 시스템으로 인간의 눈, 귀, 피부 등에 해당한다고 할 수 있음 부품 자체의 가치보다 시스템 응용에서 더욱 가치를 발휘함 군사, 우주 항공, 자동차, 정보 통신, 바이오, 의료, 가전, 엔터테인먼트, 환경, 산업 프로세스 등 광범위한 응용 분야에 적용할 수 있음 ex) MEMS 디바이스 잉크젯 프린터 헤드, 압력 센서, 가속도 센서, 디스플레이 소자 등 입체 구조를 형성하는 기술로 제조 과정이 다양하고 복잡하여 표준화하기 어려움 설계와 제조가 직결되기 때문에 실리콘 제조 공정과 같은 형태를 채택하는 것이 어려움 주로 반도체 미세 가공 생산 기술을 기반으로 하므로 초소형이며, 고정도, 고품질의 부품으로 구성됨 입출력 대상의 다양성 MEMS는 하나의 기판에 센서와 신호 회로, 구동 장치 등으로 구성된 3차원 구조체이기 때문에, 다루어져야 하는 입출력 대상이 전기 신호, 전력 처리, 기계 변위, 물리적 제어 신호 등과 같이 다양함 효율적인 소형화 MEMS는 경박단소한 상품 개발을 가능하게 하는데, 협소한 공간에서 미세하고 정교한 기능을 발휘해야 함 MEMS를 통해 MEMS는 극히 제한적인 작업 공간 속이나 폐쇄된 초소형 공간에서 가동될 수도 있음 효율적인 고기능성 휴대 기기나 복잡한 장치 내부의 보수 검사 시스템 등에 적합 제한된 공간의 다양한 장소에서 똑같은 센서나 구동 장치 등을 설치하고 총괄적으로 가동함으로써 작업 공간 내에 효율적이고 효과적인 고기능, 고성능의 결과를 만들어냄 제작의 융합화 MEMS는 기계, 전기, 전자, 재료, 물리, 화학 등 거의 모든 분야의 기술을 필요로 함 기술 간의 유기적인 결합 또는 융합에 의해 새로운 기능의 창출이 가능함 제작의 다양성 MEMS는 센서나 구동 장치, 신호 처리 등의 다양한 요소를 사용하기 때문에 기계, 전기, 빛, 재료 등의 제작 기술이 융합되고, 다양한 제작 공정과 설비가 필요하다는 점에서 복잡함 생산 공장의 복잡화 MEMS는 설계, 패키징, 테스트가 부품 별로 다르므로 각 부품에 대한 품종 별 설계 과정, 제작 설비 및 개발 장비를 개발해야 함 광범위한 산업 분야와 연계 MEMS는 자동차, 의료, 가전, 운수, 우주 항공, 군사 등 산업 전반의 광범위한 분야와 연관되어 시스템의 핵심 구성 요소로 자리 잡기 시작했으며, 앞으로는 더욱 더 많은 분야에서 더 큰 비중을 차지할 것으로 예상 됨 센서 기술과의 융합 MEMS 기술은 다양한 센서에서 응용 됨 실리콘을 재료로 한 MEMS 센서의 종류로 물리 센서와 화학/바이오 센서가 있음 MEMS 기술은 센서에 그치지 않고 광 디바이스, 고주파 디바이스, 발전 디바이스, 유체 분석 디바이스 등에도 활용되고 있음 그 외의 특징 핵심 부품으로 사용되는 경우가 많음 부가 가치가 높음 긴 제품 수명 장기간에 걸쳐 투사를 회수하게 됨 MEMS의 응용 분야 응용 분야에 따라 구분 가속도, 자이로, 압력, 온도, 센서 등의 미래 자동차 극소 반사경, 초정밀 렌즈, 극소 레이저, 감광 소자, 광신호 분리기, 광 단속기, 정보 검출기, 초 정밀 조립기 등의 정보 통신 고 해상도 잉크젯 프린터 헤드, 고 해상도 마이크로 디스플레이 등의 컴퓨터/사무 자동화 기기 초 소형 박막 전지, 각종 제조 장비 및 시설용 센서, 가정용 전기 제품의 센서 및 자이로 센서 등의 전자, 가전 설비 일회용 분석기, 초소형 내시경, 혈압 센서 랩온어침(Lab-On-a-Chip)등의 의료 및 환경 분야 자동차 분야 자동차의 각 부분에 가속도, 자이로스코프, 압력 및 온도 센서 등 초소형 고성능의 각종 감지 센서가 부착되어 운전자의 안전 운행을 도움 자동차용 각종 센서 개발은 에어백용 가속도 센서, 차체 제어용 자이로 센서, 타이어 공기압 센서, 자동차 엔진에 부착되는 흡기관 압력 센서와 공기 유랑 센서 등에 집중 되고 있음 예를 들면, 가속도 센서는 사고가 발생하는 순간의 가속도 차이를 감지해서 자동으로 에어백이 터지도록 함 자동차용 초소형 센서들은 기존 센서의 성능 및 신뢰성을 향상 시키면서도 가격 경쟁력을 높임 스마트 자동차의 자율 주행을 위해 필수적인 레이더, 라이다, 비디오 및 초음파 센서도 MEMS 기술을 기반으로 제작되고 있음 자동차용 초소형 센서는 차량 내비게이션에도 포함돼 에어백 및 ESP 시스템을 제어하며 주행 안전, 편안함, 편의성 및 효율성을 향상 시키는 광범위한 보조 기능을 지원함 정보 통신 분야 광 MEMS를 이용한 극소 반사경, 초정밀 렌즈, 극소 레이저, 감광 소자 등의 극소화 광학 요소를 마이크로 구동기와 결합함으로써 광신호 분리기, 광 단속기, 정보 검출기, 초정밀 조립기 등의 다양한 응용 제품에 적용하여 개발하고 있음 컴퓨터/사무 자동화 기기 분야 컴퓨터/사무 자동화 기기 분야에서 MEMS의 응용은 고해상도 잉크젯 프린터 헤드, 고해상도의 마이크로 디스플레이, 하드 디스크 등 정보의 저장, 검출 시스템 개발에 집중 되어 있음 하드 디스크, 광 디스크, 광 자기 디스크 등 정보 저장 시스템은 대용량, 고밀화, 고속화의 추세에 맞추어 MEMS가 주목 받고 있음 전자, 가전 및 설비 분야 전자, 가전 및 설비 분야에서 MEMS는 초소형 박막 전지, 각종 제조 장비 및 시설용 센서와 가정용 전기 제품 등에 적용됨 미국의 텍사스 인스트루먼츠사 및 국내 기업체에서 대화면 디스플레이용 극소 거울 배열을 개발한 바 있으며, 국내에서는 손떨림 방지를 위해 캠코더용 자이로 센서의 선행 개발이 이루어졌음 스마트폰 압력 센서는 스마트폰의 고도를 수센티미터 내의 오차로 정확히 측정해 낼 수 있으며, 스마트폰 사용자가 조난 상태에 빠졌을 때 정확한 위치를 제공할 수 있음 로옴 압력 센서 의료 및 환경 분야 의료 기기 분야에서 최초의 MEMS 적용은 1980년대 초에 등장한 일회용 혈압 센서임 이후 의료용 초소형 진단 분석기 개발에 많은 관심을 두게 됨 의료 기기 중 많은 연구가 이루어지고 잇는 것은 휴대용 및 일회용 분석기인데, 이들 시스템은 압력 센서, 마이크로 펌프, 마이크로 밸브, 화학 센서 등으로 이루어져 있음 마이크로 니들은 인체 내에 약물을 전달하거나 건강 진단을 위한 검체 채취에 사용되는 미세 바늘임 MEMS 기술을 기반으로 나노미터 수준으로 제작되는 마이크로 니들은 적재적소에 접근할 수 있어 효과적으로 약물 전달을 가능하게 하는 장점이 있으면서도, 최소의 고통과 감염 위험이 적은 특징이 있음 마이크로 니들을 활용한 화장품을 만들면 직접 피부에 바르는 것보다 침투가 훨씬 빨라서 효과적임 피부 안으로 유효 약물을 전달하는 마스크 팩이나 패치, 채혈이 필요 없는 혈당 측정기나 효과적인 백신 투약과 같은 응용 분야에서의 연구, 개발이 진행되고 있음 정리 하기 SoC는 여러 부품을 하나의 칩에 집적 시킬 수 있는 기술임 MEMS는 전자 기계 소자를 육안으로는 보이지 않을 정도로 작게 제작하는 기술임연습 문제 SoC의 특징이 아닌 것은 무엇인가? a. 기능마다 별개의 칩으로 구성된다. SoC의 특징 칩 자체가 하나의 시스템으로 기능을 수행할 수 있음 마이크로 프로세서, 디지털 신호 처리 장치, 메모리 등을 직접 시킨 칩 부품의 개수와 부피를 줄일 수 있음 SoC 제작 과정중에서 펌 웨어등의 개발이 관여 되는 과정은 무엇인가 ? a. 시제품 제작 및 테스트 단계 다음 중 MEMS 기술의 특징이 아닌 것은 무엇인가 ?  a. 생산 공정의 단순화 MEMS 기술의 특징 입출력 대상의 다양성 효율적인 소형화 제작의 융합화 생산 공정의 복잡화 정리 하기 SoC 기술 칩 자체가 하나의 시스템으로 기능할 수 있도록 정보 통신 기기의 핵심 기능을 담당하는 메모리, 디지털 회로, 아날로그 회로, CPU, 센서, 안테나, 수동 소자 등을 하나의 반도체 칩에 집적하는 기술 SoC의 장점 급속한 정보 통신 기술의 변화와 경쟁에 대응하기 유리함 비용과 부피 및 크기의 소형화 가능 전력 소모 등의 효과 미세 전자기계 시스템(MEMS) 유비쿼터스 네트워크나 초소형 휴먼 인터페이스 분야의 핵심 요소인 3차원 미소 구조물, 센서 및 구동 장치 등을 소형화 및 고정밀화하고 복합화를 가능 MEMS 기술의 특징 입출력 대상의 다양성 효율적인 소형화 제작의 융합화 생산 공정의 복잡화 광범위한 산업 분야와 연계 센서 기술과의 융합 " }, { "title": "[유비쿼터스 컴퓨팅 개론] 3강 - 가상 현실 및 메타버스", "url": "/posts/knou-uqc-3/", "categories": "Computer Science, CS Theory", "tags": "knou, ubiquitous computing", "date": "2025-03-26 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정광식 교수님의 '유비쿼터스 컴퓨팅 개론' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 가상 현실(VR), 증강 현실(AR), 혼합 현실(MR) 기술의 발달로 현실 세계와 가상의 세계를 생생하게 시각적으로 표현하고, 이미지 화 된 객체와 상호 작용하는 기술인 메타버스를 공부함 가상현실의 개념 및 주요 기술을 살펴보고, 메타버스의 개념 및 플랫 폼 유형에 대해 살펴봄학습 목표 가상성의 연속성을 통한 가상현실의 개념과 주요 기술을 이해할 수 있음 메타버스의 개념 및 플랫폼의 유형을 이해할 수 있음 가상성의 연속성을 이해할 수 있음강의록가상 현실가상 현실(VR: Virtual Reality) 실제로 존재하지 않은 환경이나 상황을 컴퓨터 등으로 구현한 후 인간의 감각을 이용하여 체험하게 하는 기술 실제로 존재하지 않은 완전히 허구적 환경이나 상황을 가능하게 하는 기술 유비쿼터스 컴퓨팅 기술을 활용하여 실제로 얻기 힘들거나 혹은 아예 얻을 수 없는 경험이나 환경 등을 제공해 인체의 오감을 자극함으로써 실제와 같이 체험하게 하는 기술 컴퓨터 그래픽을 이용해서 기본적으로 만들어내는 내용 증강 현실(AR: Augmented Reality) 단말 소프트웨어 등을 활용해 현실에 가상의 정보를 추가한 실재와 허구가 혼합된 환경을 구현하는 기술 객체, 사물은 진짜인데 사물들에 대한 정보나 사용법, 유래와 같은 여러가지 정보들을 같이 제공해 주는 것 현실 세계에 있는 사물들을 기반으로 해 서비스 제공 특정 장소에 도달하면 스마트폰으로 가상의 게임 캐릭터인 포켓몬을 잡을 수 있는 포켓몬GO 게임은 증강 현실의 대표적인 예에 해당함가상 현실과 증강 현실 넓은 의미의 가상 현실은 증강 현실을 포함함 가상 현실은 현실의 물리적 공간과 관련성이 필수적이지 않지만, 증강 현실은 현실에 가상 정보를 추가하는 형태임 기술의 발달은 가상 세계를 단지 보는 것에 그치지 않고 가상 현실 속에 구현된 것들과 상호 작용을 가능하게 만듦 가상 현실 내에서 사용자와 상호작용이 가능하고, 그 과정에서 사용자가 새로운 경험을 할 수 있으므로 의도한 대로만 보여주는 시뮬레이션과는 구분됨 가상 현실에서 사용자는 현실과 단절되어 가상 세계에 몰입하지만 증강 현실은 실제 현실 속에서 현실과 연계되어 사용자를 보조하는 차이가 있음 가상 현실은 집중이 필요한 교육 훈련 등에, 증강 현실 기술은 현실 개체 간 상호 작용이 필요한 유통이나 서비스 산업 등에 주로 활용 됨가상성의 연속성(Virtuality Continuum) 현실과 가상 세계 사이에서 가상성의 정도를 구분하기 위해 제시된 개념임 현실에 얼마나 많은 가상적인 요소가 포함되어 있는지를 의미하는데, 이는 단계적 개념이라기보다는 현실과 가상 세계 간에 연속적인 속성을 보임증강 가상(Augmented Virtuality) 디스플레이에 보여지는 내용이 현실보다 컴퓨터 그래픽으로 만든 가상 요소의 활용이 상대적으로 더 많은 단계를 의미함 컴퓨터 그래픽으로만 제공된 환경을 가상 현실이라 하며, 이에 반해 증강 현실은 현실적인 요소에 비해 컴퓨터 그래픽의 활용이 상대적으로 적은 환경을 의미함 증강 현실은 현실 세계에 가상의 대상물을 구현하게 함으로써 실재를 대체하는 것이 아닌 실재를 보완하는 역할(인공적인 기술을 통한 가성 정보)을 함혼합 현실(MR;Mixed Reality) 현실과 가상 환경 사이에 존재하는 모든 것을 의미함 증강 현실은 혼합 현실의 한 부류임 현실 세계와 가상의 대상물이 함께 존재하는 것을 의미함360도 동영상 360도 전방위를 촬영한 영상을 의미함 가상의 대상물로 구성된 동영상이 아닌 현실을 360도로 재현한 동영상이며, 새로운 영상 정보 전달 방식이지만 가상 현실은 아님가상 현실 주요 기술가상 현실 기술 사용자가 가상 현실을 체험하고 상호 작용하는 입출력 인터페이스 기술과 콘텐츠 제작이나 서비스 제공을 위한 콘텐츠 기술로 구분 됨 가상현실 콘텐츠 관련 기술 가상 현실 콘텐츠를 개발∙실행하기 위한 개발 엔진 가상 현실 콘텐츠를 개발∙제작하기 위한 저작 도구 가상 현실 콘텐츠를 사용자에게 제공하는 서비스 기술 가상 현실 입출력 기술의 특징 기술 분류 기술 설명 입력 인터페이스 사용자 동작을 인식하여 사용자 의도를 전달하는 제스처 인식 하드웨어 기술   음성으로 사용자의 의도를 전달하는 음성 인식 기술   BCI(Brain Computer Interaction) 등 생체 신호를 이용하여 사용자의 의도 및 상태를 인식하는 기술   몰입감 향상을 위해 주변 환경을 자율적 · 지능적으로 인식하는 상황 인식 기술 출력 인터페이스 가상 현실을 표현하고 상호작용하기 위한 컴퓨터 그래픽스(CG) 기술, HMD(Head Mounted Display), 디스플레이 기술   공간 내 이동과 상호 작용에 따른 입체음향 표현 및 음향을 출력하기 위한 하드웨어 기술   몰입감 향상을 위한 촉각, 후각 등 감각 요소별 표현 기술 및 감각 유형별 디바이스 기술   6자유도 지원 모션 축의 자유로운 움직임을 지원하는 모션 플랫폼 및 모션 하드웨어 기술 가상 현실 콘텐츠 기술의 특징 기술 분류 기술 설명 콘텐츠 개발 엔진 콘텐츠 제작에 자주 활용되는 개발 노하우나 기술, 하드웨어 API 사용법 등을 쉽게 활용할 수 있는 소프트웨어 라이브러리나 모듈의 형태로 구현해 놓은 개발 환경   2D 및 3D 콘텐츠를 개발할 수 있는 환경, 즉 저작도구가 포함된 개발 플랫폼으로 제공   유니티(Unity): 2D 및 3D 비디오 게임의 개발 환경을 제공하는 게임 엔진 저작 도구 하드웨어와 소프트웨어를 통합하여 가상현실 환경 구성과 응용 프로그램을 개발하는 도구 기술   유니티 에디터(Unity Editor): 3D 애니메이션과 건축 시각화, 가상현실 등 상호작용하는 콘텐츠 제작 도구 서비스 실제 세계의 자연 규칙이 가상의 사물에도 적용되는 물리 시뮬레이션 기술   원격지 사용자가 가상에서 콘텐츠를 공유하고 인지할 수 있는 네트워크 기반 기술   온라인에서 가상현실 콘텐츠를 유통하고 서비스하는 플랫폼 기술 가상 현실을 위한 입출력 인터페이스 몰입감을 위한 입체감을 표현하기 위해 3D 입체 기술의 활용도 높음 상호 작용을 위한 영상 기반의 제스처 인식과 하드웨어 센서를 활용한 동작 인식 및 상황 인지 기술 등의 복합 활용 다양한 하드웨어와의 호환성을 가진 모션 플랫폼 기술 제공 네트워크 기반 기술을 활용한 지리적 공간의 제약 극복 스마트폰을 이용한 사용자 지원 HMD(Head Mounted Display)와 같은 착용형 디스플레이와 제스처나 생체 신호 인식을 위한 센서 디바이스 등 하드웨어 기술 사용자가 이동하거나 가상 사물과 상호 작용을 지원하려면 부수적 요소 기술의 활용이 필요함 가상 현실을 구현하기 위해 다양한 센서로부터 데이터를 수집하고 분석하여 의미 있는 정보를 제공하는 측면에서 사물 인터넷과 기술적으로 겹치는 부분이 많음출력 기술 기본 감각인 시각을 통해 정보 전달을 위한 영상 출력 인터페이스 기술로 발전함 현장감과 몰입감을 위해 시각 효과에서 어지러움과 모션 블러 현상을 제거하기 위한 방향으로 기술 개발 HMD, 증강 현실 안경, 프로젝션 매핑, 홀로그램 등의 기술 개발 고글 형태의 가상 현실용 HMD 장치들 가상 현실 관련 음향 기술 시각과 함께 콘텐츠를 인지하는 음향 기술은 기본 감각인 청각을 통해 정보를 전달하는 기술로 시점 이동에 따른 입체 표현과 현장감 및 몰입감을 극대화할 수 있는 3D 실감 음향 기술로 발전하고 있음 영상에 나오는 사물의 움직임, 사용자의 움직임 등을 실시간으로 추적하고 예측함으로써 음향에 방향성을 부여하는 음향 기술임 헤드폰 방식 HMD 기기 일체형이거나 연결하는 방식으로 지원됨 음향이 출력 되는 공간 제어가 가능하며 3D 실감 음향 표현이 쉬움 스피커 방식 공간 내 음향 출력을 움직임에 따라 제어하는 기술임 기술적으로 어렵지만 헤드폰 방식에 비해 입체감이 좋음 가상 현실 관련 오감 기술 시각, 청각 외에도 가상 현실 콘텐츠의 실감성과 몰입감 향상을 위해 오감 기술은 촉각, 후각, 미각 기관 등 오감을 자극하여 정보를 전달하는 인터페이스 기술임 기존에는 전용 시뮬레이터 장치로 촉각을 제공하였으나 범용성이 있는 장갑이나 슈트 같은 착용형 기기로 발전하고 있음 촉감 등을 포함하는 햅틱 인터페이스는 스마트폰의 진동 표현이 대표적 사례이며, 진동 강도와 패턴으로 입체감을 표현하는 수준으로 진화하고 있음 물체의 접촉을 통한 촉각 이외에도 압축 공기를 이용한 촉각 기반 인터페이스 개발 등 감각을 확장하는 기술도 등장하고 있음 디즈니 연구팀이 개발한 에어리얼(Aireal)은 인터페이스 장치로부터 사용자의 손이나 얼굴 같은 대상까지의 거리를 계산하여 링 형태의 압축 공기를 분사함으로 촉각을 느끼게 함가상 현실 관련 모션 기술 가상 현실 공간에서 적절하게 움직이거나 동작을 취하면서 사실적인 체험을 할 수 있는 기술 공간과 비용이 최소화된 형태의 모션 플랫폼으로 발전하고 있음 모션 플랫폼 탑승 디바이스를 전후좌우로 움직이는 기계 공학적인 기술로, 움직임에 따라 3 자유도, 6 자유도로 구분할 수 있음 넓은 시야각 확보를 위한 광 시야각 HMD, 바람 체감, 입체 음향과 함께 가상 현실 영상과 동기화 된 모션이 제공되는 가상 현실 융합형 모션 플랫폼이 개발되고 있음 ex) 가상 현실 관련 모션 기술 가상 현실 관련 입력 기술 가상 현실의 상호 작용을 실현하기 위한 인식 기능이며, 직관적인 인터페이스 활용을 위한 내추럴 사용자 인터페이스 방식(NUI)으로 진화하고 있음 상호 작용 인터페이스는 단일 기능을 이용하는 방식에서 음성, 동작 등의 여러 기능을 복합적으로 활용하는 멀티 모달 형태로 진화하고 있음 동작 인식 기술은 움직임과 동작을 추적하여 사용자의 의도를 파악하는 것이 핵심 기술 요소이며, 더욱 정밀한 추적을 위해 3D 센싱 기술 등을 활용함 3D 센싱 카메라를 이용하여 몸, 머리, 손, 눈동자 등 추적 부위의 움직임을 인식하고 배경과 사람을 분리한 후 3D 공간 정보를 제공하는 기술임 착용형 형태 움직임 감지가 가능한 가속도 센서, 자이로 센서 등을 디바이스 또는 사용자 신체에 직접 부착하고 이를 통해 얻은 데이터를 분석해 동작을 인식함 비착용형 형태 손이나 몸에 디바이스를 장착하지 않고 적외선 카메라 등을 이용하여 손가락 움직임에 대한 데이터를 얻음 대표적인 동작 인식 기술 중 손 추적 기술의 유형은 일반적으로 착용형 형태와 비착용형 형태로 분류 할 수 있음 메타 버스메타버스(Metaverse) 개요 메타버스는 기존의 가상 현실보다 진보된 개념으로 지금도 발전하고 잇는 개념이며, 웹과 인터넷 등의 가상 세계가 현실 세계에 흡수된 형태를 의미함 가상 현실의 몰입감을 높이기 위해 시각적 요소 뿐만 아니라 청각, 촉각, 후각 등 인간의 여러 감각 정보로 확장하는 기술까지도 포함 온라인 회의, 공연이나 전시회, 온라인 교육, 학회, 게임이나 엔터테인먼트 등의 분야에서 이전과 다른 접근 방식으로 사용자 층을 넓히고 있으며, 메타버스 관련 서비스는 계속 확산되고 있음 미래 가속화 연구재단(ASF)은 초기에 메타버스를 증강과 시뮬레이션, 외적인 것과 사적인 것 이라는 두 가지 기준에 따라 네가지 시나리오로 구분함 현실과 가상을 결합한 증강 현실(Augmented Reality) 창조된 가상 세계(Virtual Worlds) 현실을 복제한 거울 세계(Mirror Worlds) 사람의 일상 생활을 통해 인생을 기록하는 일상 기록(Lifelogging) 메타버스에 포함된 4개의 시나리오와 결합 관계메타버스 개념 메타버스란 단어는 본래 가상, 추상을 의미하는 메타와 현실 세계를 의미하는 유니버스의 합성어임 메타버스에서는 가상의 인물이 가상의 사물을 이용하여 다양한 활동을 할 수 있음 상호작용을 이용해 다양한 활동 일반 적으로는 현실 세계와 같은 사회적, 경제적 활동이 통용되는 3차원 가상 공간 정도의 의미로 사용되고 있음메타버스 플랫폼HTC -바이버스 HTC의 메타버스 플랫폼인 바이버스(Viverse) 바이버스에서는 사용자가 아바타로 변신해 사무실에서 근무하고, 게임이나 콘서트, 쇼핑 등을 즐길 수 있음 인게이지(ENGAGE), VR챗(VRCHAT) 등 다른 회사의 메타버스 플랫폼과 연동되는 개방형으로 개발되었음SK 텔레콤 - 이프랜드 SK 텔레콤은 메타버스 플랫폼인 이프랜드(ifland)의 글로벌 버전과 헤드셋 기기 버전을 선보였음 이프랜드에 블록체인 기반의 NFT, 마켓 플레이스 등과 같은 경제 활동을 지원하는 시스템을 갖추어 80개국 이상에 서비스를 제공할 계획임LG 유플러스 - 아이돌 라이브 LG 유플러스는 K팜 확장 현실 플랫폼인 아이돌 라이브에 NFT 이용을 활성화하여 동남아시아에 이어 중동 지역과 아프리카까지 수출할 계획임유형 메타버스 플랫폼은 개발 동기, 접속 목적에 따라 세가지 유형으로 분류할 수 있음 소셜 기반 메타버스 게임 기반 메타버스 생활 · 산업 기반의 메타버스 소셜 기반 메타버스 소셜 미디어가 모임, 쇼핑, 게임 등이 가능한 메타버스로 발전한 형태임 대표적으로 제페토, 게더타운, 호라이즌 월드, 위버스 등 게더타운은 줌(Zoom)이나 팀즈(Teams) 같은 온라인 회의 솔루션의 일종이지만, 2D 가상 공간에 아바타를 도입함 예를 들어, 사무실이라는 가상 공간을 만들고, 각 참여자는 각자의 아바타를 생성하고 가상 공간 내에 자리를 부여 받음 아바타는 이동할 수 있으며, 다른 아바타에 접근하여 그 사람과 화상 채팅을 할 수 있음 일대일 화상 채팅은 물론 N대N 화상 채팅도 가능함 게임 기반 메타버스 모바일, 컴퓨터, 콘솔용 게임이 확장하여 탄생한 것임 게임을 수행하는 것이 주목적이지만 소통 공간을 겸함 게임 제작 · 판매, 쇼핑, 공연 등 이용 형태가 계속 발전 중임 로플록스, 마인크래프트, 포트나이트 등이 있음게임 기반 메타버스(로블록스) 오픈 월드 롤플레잉 게임인 로블록스는 무료로 플레이할 수 있음 블록 형태의 세상에서 이용자는 자신의 아바타를 조작하며 여러가지를 창작하고 이를 다른 이용자와 공유할 수 있음 기업은 플랫폼만 제공하고 그 안에서 이용자가 직접 만든 규칙에 따라 많은 이들이 상호 작용하며 점점 해당 미니 게임이 형성됨 마치 동네 놀이터에 모인 아이들이 나름의 규칙을 만들어서 놀이를 시작하고, 점점 그 놀이를 즐기는 아이들이 많아지는 것과 같은 사례가 수시로 펼쳐지는 셈 사용자가 게임을 제안하고 다른 사용자가 그 게임을 즐길 수 있는 온라인 게임 플랫폼 및 게임 제작 시스템으로 게임 뿐만 아니라 아이템 제작도 가능함 사용자는 이런 아이템을 로벅스라는 가상 화폐를 통해 구매할 수 있고, 프리미엄 멤버십 사용자는 아이템을 판매할 수도 있음게임 기반 메타버스(포트나이트 배틀 로얄) 최후의 생존자 1인을 가리는 포트나이트 배틀로얄 슈팅 게임은 게임 내에 평화 지대를 두고, 이용자가 마음껏 소통할 수 있게 구현함 이 공간에서 이용자들은 적을 쏘고 쫓는 액션을 즐기는 것 뿐만 아니라 달리기를 하고 높은 곳에서 뛰어내리는 다이빙을 할 수도 있음생활 · 산업 기반 메타버스 혼합 현실이나 증강 현실 등의 기술이 적용된 디바이스를 이용하여 운동, 교육 및 훈련, 시뮬레이션 등을 수행하기 위한 목적의 메타버스 레벨 향상 및 그에 따른 보상 시스템과 같은 게임적 요소를 접목하여 활동에 몰입할 수 있도록 함 마이크로소프트사의 홀로렌즈2, 닌텐도의 링피트 어드벤처, 탁스의 스마트로라인도어 사이클링 등이 있음 홀로렌즈2는 스마트폰이나 컴퓨터에 연결할 필요가 없는 혼합 현실 착용형 홀로그래픽 컴퓨터임 혼합 현실은 현실 공간과 단절된 가상 현실 기기와 달리 현실 공간에 가상 정보를 보여 주어 주변과 상호 작용할 수 있음 증강 현실처럼 단순히 가상 정보를 현실 공간에 표시하는 것을 넘어, 현실의 공간과 사물 정보를 파악해 거기에 맞는 3D 홀로그램을 입힘정리 하기 가상 현실은 실제로 존재하지 않는 완전히 허구적 환경이나 상황을 가능하게 하는 기술 증강 현실은 현실에 가상 정보를 추가하는 형태 메타버스는 가상, 추상을 의미하는 메타(Meta)와 현실 세계를 의미하는 유니버스(Universe)의 합성어연습 문제 실제로 존재하지 않은 환경이나 상황을 컴퓨터 등으로 구현한 후 인간의 감각을 이용하여 체험하게 하는 기술은 무엇인가 ?  a. 가상 현실 미래 가속화 연구 재단(ASF; Acceleration Studies Foundation)에서 정의한 메타버스 구성의 네 가지 시나리오가 아닌 것은  무엇인가 ?  a. 혼합 현실 미래 가속화 연구 재단에서 정의한 메타버스 구성의 네 가지 시나리오 가상 세계 일상 기록 증강 현실 소셜 미디어가 모임, 쇼핑, 게임 등이 가능한 메타버스로 발전한 형태인 소셜 기반 메타버스가 아닌 것은 무엇인가 ?  a. 로블록스(Roblox) 소셜 기반 메타버스 제페토 게더 타운 호라이즌 월드 정리 하기 가상 현실은 실제로 존재하지 않는 완전히 허구적 환경이나 상황을 가능하게 하는 기술 증강 현실은 현실에 가상 정보를 추가하는 형태 가상성의 연속성(Virtuality Continuum)은 현실과 가상 세계 사이에서 가상성의 정도를 구분하기 위해 제시된 개념 혼합 현실은 현실과 가상 환경 사이에 존재하는 모든 것을 의미하며, 현실 세계와 가상의 대상물이 함께 존재하는 것을 의미 가상 현실 콘텐츠 관련 기술 가상 현실 콘텐츠를 개발∙실행하기 위한 개발 엔진 가상 현실 콘텐츠를 개발∙제작하기 위한 저작 도구 가상 현실 콘텐츠를 사용자에게 제공하는 서비스 기술 메타버스는 가상, 추상을 의미하는 메타(Meta)와 현실 세계를 의미하는 유니버스(Universe)의 합성어" }, { "title": "[데이터 정보 처리 입문] 3강 - 통계 정보의 검색 및 활용", "url": "/posts/knou-dip-3/", "categories": "Data Science, Data Analysis", "tags": "knou, data information processing", "date": "2025-03-25 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김성수, 이기재 교수님의 '데이터 정보 처리 입문' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 인터넷은 전 세계 수많은 컴퓨터가 연결되어 있는 지구촌 네트워크를 일컫는 말임 인터넷은 전자 우편, 인터넷 전화 등을 통해 효율적인 통신 수단의 역할을 하고 있으며, 연결된 데이터베이스의 증가와 검색엔진 등의 활성화로 인해 좋은 정보 습득의 도구로 이용되고 있음 국가 통계 정보의 검색 및 데이터 제공 사이트를 알아봄학습 목표 인터넷을 이용하여 국가 통계 정보를 검색할 수 있음 데이터 제공 사이트를 찾아볼 수 있음강의록국가 통계 정보인터넷을 이용한 통계 정보 인터넷 전 세계 수 많은 컴퓨터가 연결되어 있는 네트워크 각종 정보를 취득하는 중요한 도구 지식 정보화 시대에 유용한 통계 정보의 좋은 검색 도구 및 활용 도구로 이용 통계 정보와 지리 정보 시스템(GIS; Geographic Information System)을 결합하여 그래프와 결합된 유용한 통계 정보도 제공되고 있음 국가 통계 정보 국가 통계 정보 국가 경영 등에 필요한 경제, 경영, 환경, 보건, 농업 등의 통계 정보 정부 3.0 시대 정부 기관 등이 보유하고 있는 공공 정보를 누구나 손 쉽게 활용할 수 있도록 적극 개방, 공유하는 시대 양방향 맞춤형 서비스 빅 데이터 활용 통계청 국가 통계 총괄 관리 통계청 홈페이지 통계청 핵심 서비스 KOSIS 국가 통계 포털, 마이크로 데이터, 통계 데이터 센터, SGIS 통계 지리 정보, 통계 분류 포털 KOSIS 국가 통계 포털 KOSIS(Korea Statistical Information System) 통계청을 비롯하여 여러 통계 작성 기관에서 제공되고 있는 통계 정보를 제공 KOSIS 주요 기능 통계 자료의 목록, 작성 기관, 수록 기관, 소재 정보의 파악 원하는 항목의 통계 자료 검색 여러 항목 간의 통계 자료 비교 검색 원하는 항목의 장기 시계 열 자료 검색 항목의 통계 자료를 크기 순으로 배열 통계 자료를 시각적인 그래프로 표현 자료 받기 기능 등 ex) 장래 인구 추계 자료 검색 검색 순서 http://kosis.kr → 국내 통계 → 주제 별 통계→ 인구 → 장래 인구 추계 → 전국(또는 시도) → 성 및 연령 별 추계 인구(1세 별, 5세 별) 자료 다운 받기 자료 형식을 바꾸기 위한 피봇 이용(행렬 전환) 차트 그리기 ex) KOSIS 통계 시각화 버블 차트로 보는 통계 e-나라지표 : 국가주요지표 e-나라 지표 국정 전문 분야에 대한 통계와 추이, 통계 분석 등을 제공 ex) e-나라지표에서 소비자 물가지수를 알아보자 마이크로 데이터 서비스 마이크로 데이터 서비스 사용자가 직접 자료를 가공하여 처리할 수 있도록 조사 자료들을 제공하는 서비스 교육용 데이터도 제공 통계 지리 정보 통계 지리 정보 서비스 국가 통계 자료를 지도 위에서 쉽게 이용할 수 있도록 제공되고 있는 서비스 통계 내비 게이터, 지도로 보는 행정구역 통계, 통계 지도 시계열 서비스 등 다양한 내용을 제공 한국 은행 경제 통계 시스템 한국 은행 경제 통계 국민 소득, 물가 등과 같은 경제 통계에 관한 각종 자료들을 시계열로 제공 데이터 제공 사이트StRD NIST(National Institute of Standards and Technology)에서 제공하는 StRD(Statistical Reference Datasets) 통계 분석 등과 관련하여 유용한 데이터를 제공 특히 분산 분석, 회귀, 기술 통계 관련 자료들이 다양하게 제공 ex) Strd에서 선형 회귀 자료 추출 DASL DASL 카네기 멜론 통계학과에서 제공하고 있는 다양한 데이터 및 통계적 방법 UCI data UCI data UCI (University of California at Irvine) Machine Learning Repository 에서 제공하는 데이터 한국 사회 과학 데이터 KSDC(Korean Social science Data Center) 정부, 공공 기관, 연구소, 민간 단체 등 여러 기관에서 제공하고 있는 방대한 분량의 통계 및 여론 조사 자료들을 제공 미국의 최대 사회 과학 데이터 보관소인 ICPSR(The InterUniversity Consortium for Political and Social Research) 등을 비롯한 외국의 조사 기관 자료 사이트와도 연계되어 있음 USA 통계 자료 USA 통계 자료 미국 정부 부처에서 생산하는 각종 통계 자료를 제공 지역 별, 주제 별 검색 가능 연습 문제 한국사회과학데이터센터 사이트는? a. http://ww.ksdc.re.kr  다음 중 카네기 멜론 통계학과에서 운영하는 사이트로서 다양한 데이터를 제공하는 사이트는? a. http://lib.stat.cmu.edu/DASL 국가경제에 관한 통계들을 제공하는 한국은행 경제시스템 사이트는? a. http://ecos.bok.or.kr/ NIST(National Institute of Standards and Technology)에서 여러 통계 분석 등과 관련하여 유용한 데이터를 제공하는 사이트는? a. http://www.itl.nist.gov/div898/strd/ 통계청 사이트는? a. http://kostat.go.kr/ a. http://kostat.go.kr/ " }, { "title": "[운영 체제] 3강 - 프로세스 스케줄링", "url": "/posts/knou-os-3/", "categories": "OS, Operating System", "tags": "knou, os", "date": "2025-03-24 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김진욱 교수님의 '운영 체제' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 운영 체제는 실행할 준비가 된 프로세스들이 CPU를 적절히 배정 받아 작업을 효율적으로 처리할 수 있도록 관리해야 하고, 이를 위해 다양한 스케줄링 알고리즘을 활용함 프로세스 스케줄링의 개요와 정책에 대해 살펴보고, 스케줄링 알고리즘의 성능 평가 기준과 함께 여러 가지 스케줄링 기법에 대해 학습함학습 목표 프로세스 스케줄링의 개요와 정책을 설명할 수 있음 스케줄링 성능 평가 기준을 설명할 수 있음 다양한 스케줄링 기법을 설명할 수 있음강의록프로세스 스케줄링프로세스 스케줄링 스케줄링 여러 가지 작업의 처리 순서를 결정하는 것 ex) 프로세스 스케줄링, 디스크 스케줄링 등 프로세스 스케줄링 주어진 프로세스가 여러 개인 경우, 프로세스 처리 순서를 결정하는 것 스케줄링 단계 하위 단계 스케줄링 준비 큐에 있는 프로세스를 선택하여 사용 가능한 CPU를 할당(디스패치)하는 역할 수행 주체 디스패처(dispatcher) 스케줄링의 목표 스케줄링 기본 목표 공정성 모든 프로세스가 적정 수준에서 CPU 작업을 할 수 있게 함 균형 시스템 자원이 충분히 활용될 수 있게 함 운영 체제의 유형에 따른 스케줄링의 목표 일괄 처리 운영 체제 처리 량의 극대화 주어진 시간에 처리한 프로세스 수 반환 시간의 최소화 프로세스 생성 시점부터 종료 시점까지의 소요 시간 CPU 활용의 극대화 시 분할 운영 체제 빠른 응답 시간 요청한 시점부터 반응이 시작되는 시점까지의 소요 시간 과다한 대기 시간 방지 프로세스가 종료될 때까지 준비 큐에서 기다린 시간의 합 실시간 운영 체제 처리 기한 맞춤 스케줄링 정책 스케줄링의 목표에 따라 우선적으로 고려해야 할 기본적인 정책 선점 스케줄링 정책 비선점 스케줄링 정책 선점(preemptive) 스케줄링 정책 실행 중인 프로세스에 인터럽트를 걸고 다른 프로세스에 CPU를 할당할 수 있는 스케줄링 방식 높은 우선 순위의 프로세스를 우선 처리해야 하는 경우에 유용 실시간 시스템, 시분할 시스템 문맥 교환에 따른 오버 헤드 발생 운영 체제는 문맥 교환이 매우 빠르게 실행되도록 만들어져야 함 문맥(context) CPU의 모든 레지스터와 기타 운영 체제에 따라 요구되는 프로세스의 상태 문맥 교환(context switching) CPU가 현재 실행하고 있는 프로세스의 문맥을 PCB에 저장하고 다른 프로세스의 PCB로부터 문맥을 복원하는 작업 비선점(nonpreemptive) 스케줄링 정책 실행 중인 프로세스를 바로 준비 상태로 전이 시킬 수 없는 스케줄링 방식 CPU를 할당 받아 실행이 시작된 프로세스는 대기 상태나 종료 상태로 전이될 때까지 계속 실행 상태에 있게 됨 강제적인 문맥 교환이 없어 오버 헤드 발생하지 않음 긴 프로세스가 실행 중이라면 짧은 프로세스가 오래 기다리게 되는 경우 발생스케줄링의 평가 기준 평균 대기 시간 각 프로세스가 수행이 완료될 때까지 준비 큐에서 기다리는 시간의 합의 평균 값 평균 반환 시간 각 프로세스가 생성된 시점부터 수행이 완료된 시점까지의 소요 시간의 평균 값 스케줄링 알고리즘FCFS 스케줄링 FCFS(First-Come First-Served) 비선점 방식 준비 큐에 도착한 순서에 따라 디스패치 장점 가장 간단한 스케줄링 기법 단점 짧은 프로세스가 긴 프로세스를 기다리거나 중요한 프로세스가 나중에 수행될 수도 있음 시분할 운영 체제나 실시간 운영 체제에는 부적합 프로세스들의 도착 순서에 따라 평균 반환 시간이 크게 변함 SJF 스케줄링 SJF(Shortest Job First) 비선점 방식 준비 큐에서 기다리는 프로세스 중 실행 시간이 가장 짧다고 예상되는 것을 먼저 디스패치 장점 일괄 처리 환경에서 구현하기 쉬움 단점 실제로는 먼저 처리할 프로세스의 CPU 시간을 예상할 수 없음 새로 들어온 짧은 프로세스가 긴 프로세스를 기다리거나 중요한 프로세스가 나중에 수행될 수도 있음 시 분할 운영 체제나 실시간 운영 체제에는 부적합 SRT 스케줄링 SRT(Shortest Remaining Time) SJF 알고리즘의 선점 방식 준비 큐에서 기다리는 프로세스 중 남은 실행 시간이 가장 짧다고 예상되는 것을 먼저 디스패치 장점 SJF보다 평균 대기 시간이나 평균 반환 시간에서 효율적임 단점 실제로는 프로세스의 CPU 시간을 예상할 수 없음 각 프로세스의 실행 시간 추적, 선점을 위한 문맥 교환 등 SJF보다 오버 헤드가 큼 RR 스케줄링 RR(Round Robin) 선점 방식 준비 큐에 도착한 순서대로 디스패치하지만 정해진 시간 할당 량에 의해 실행 제한 시간 할당 량 안에 종료하지 못한 프로세스는 준비 큐의 마지막에 배치됨 장점 CPU를 독점하지 않고 공평하게 이용 시분할 운영 체제에 적합 단점 시간 할당량이 너무 크면 FCFS 스케줄링과 동일 시간 할당량이 너무 작으면 너무 많은 문맥 교환 발생으로 오버헤드가 커짐 HRN 스케줄링 HRN(Highest Response Ratio Next) 비선점 방식 준비 큐에서 기다리는 프로세스 중 응답 비율이 가장 큰 것을 먼저 디스패치 예상 실행 시간이 짧을수록, 대기 시간이 길수록 응답 비율이 커짐 장점 SJF 스케줄링의 단점을 보완 예상 실행 시간이 긴 프로세스도 오래 대기하면 응답 비율이 커져 나중에 들어오는 짧은 프로세스보다 먼저 디스패치 가능 단점 실제로는 프로세스의 CPU 시간을 예상할 수 없음 다단계 피드백 큐 스케줄링 선점 방식 I/O 중심 프로세스와 연산 중심 프로세스의 특성에 따라 서로 다른 시간 할당 량 부여 단계 1부터 단계 n까지 하나 씩의 준비 큐 존재 단계 k는 단계 k+1에 피드백 단계가 커질수록 시간 할당 량도 커짐 스케줄링 방법 디스패치 후 대기 상태로 갔다가 준비 상태가 될 때에는 현재와 동일한 단계의 준비 큐에 배치 시간 할당 량을 다 썼으면 다음 단계의 준비 큐로 이동 배치 단계 k의 준비 큐에 있는 프로세스가 디스패치 되려면 단계 1부터 단계 k-1까지 모든 준비 큐가 비어 있어야만 함 특징 I/O 위주 프로세스는 높은 우선권 유지 연산 위주의 프로세스는 낮은 우선권이지만 긴 시간 할당 량 스케줄링 알고리즘정리 하기 프로세스의 스케줄링을 위해 상위 단계, 하위 단계 및 중간 단계 스케줄링이 사용됨 선점 스케줄링 정책 실행 중인 프로세스에 인터럽트를 걸고 다른 프로세스에 CPU를 할당할 수 있는 스케줄링 방식 비선점 스케줄링 정책 실행 중인 프로세스를 바로 준비 상태로 전이 시킬 수 없는 스케줄링 방식 FCFS 스케줄링 준비 큐에 도착한 순서에 따라 디스 패치하는 비선점 방식의 스케줄링 알고리즘 SJF 스케줄링 준비 큐에서 기다리는 프로세스 중 실행 시간이 가장 짧다고 예상되는 것을 먼저 디스패치하는 비선점 방식의 스케줄링 알고리즘 SRT 스케줄링 준비 큐에서 기다리는 프로세스 중 남은 실행 시간이 가장 짧다고 예상되는 것을 먼저 디스패치하는 선점 방식의 알고리즘 RR 스케줄링 프로세스가 도착한 순서대로 프로세스를 디스패치하지만 정해진 시간 할당 량에 의해 실행을 제한하는 선점 방식의 스케줄링 알고리즘 HRN 스케줄링 준비 큐에서 기다리는 프로세스 중 응답 비율이 가장 큰 것을 먼저 디스패치하여 실행하는 비선점 방식의 스케줄링 알고리즘 HRN 스케줄링의 응답 비율은 예상 실행 시간이 짧을수록, 그리고 대기 시간이 길수록 커짐 다단계 피드백 큐 스케줄링 입출력 위주의 프로세스가 연산 위주의 프로세스보다 우선권을 갖도록 하는 선점 방식의 알고리즘 " }, { "title": "[파이썬 프로그래밍 기초] 3강 - 파이썬의 이해", "url": "/posts/knou-python-3/", "categories": "Language, Python", "tags": "knou, python", "date": "2025-03-21 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '파이썬 프로그래밍 기초' 강의를 개인 공부 목적으로 메모하였습니다. 학습 목표 파이썬의 특징을 설명할 수 있음 파이썬 프로그램의 실행 과정을 나열할 수 있음 파이썬 프로그래밍 환경의 특징을 설명할 수 있음주요 용어 프로그래밍 패러다임 프로그래밍을 생성하는 접근 방식 라이브러리 자주 사용되는 프로그래밍 구성 요소를 미리 작성하여 패키징한 프로그램 모음 주피터 노트북 오픈소스 웹 기반 대화형 개발 및 실행 환경 강의록파이썬의 개요파이썬의 탄생 히도 판 로쉼(Guido van Rossum) 1991년 개발 네덜란드 암스테르담 대학에서 컴퓨터 전공 좋아하는 코미디 ‘Monty Python’s Flying Circus’에서 이름을 따옴 크리스마스 주 연구실이 잠겨 할 일이 없어 만든 프로그래밍 언어 분산 운영 체제(아메바)의 시스템 관리를 위한 쉘 스크립팅 언어로 개발 스크립트 명령어를 순차적으로 나열 운영 체제가 어떤 순서로 동작해야하는지 명령어를 집합으로 만들어놓은 형태 다중 프로그래밍 패러다임 채용 정의 프로그램을 생성하는 접근 방식 명령형 프로그래밍, 절차적 프로그래밍, 객체 지향 프로그래밍, 함수형 프로그래밍 지원 패러다임 현실 세계를 어떠한 방식으로 모델링하는 것에 대한 여러 관점들을 규칙화하여 만든 것 다목적 활용 응용 프로그램과 웹, 백엔드, 사물 인터넷(IoT) 분야 뿐만 아니라 교육적인 목적으로 활용 파이썬의 발전 과정 1991년 ABC의 후속 프로그래밍 언어로 개발 1999년 DARPA에 ‘Computer Programming for Everybody’ 제안 DARPA 미 국방성 연구 기관으로 이곳에서 최초의 인터넷이 탄생 2000년 파이썬 2.0 출시 커뮤니티를 통한 개발 체계 시작 2008년 파이썬 3.0 출시 비 하위 호환을 갖는 메이저 업데이트 정수 부분에 있는 버전 → 메이저 업데이트 소수점 대에 있는 버전 → 마이너 업데이트 파이썬의 인기 대형 개발자 커뮤니티 지원 직관적이고 가독성이 높은 문법 다양한 라이브러리와 프레임워크 제공 데이터 과학, 머신러닝, 웹 개발 등에서 활발히 사용됨Pythonic (파이썬스러움) 독립적 다양한 플랫폼에서 실행 가능 운영 체제를 가리지 않고 모두 실행이 가능해 플랫폼 독립적임 오픈 소스 PEP(파이썬 개선 제안) 기반의 개방형 개발 방식 인간적 의사 코드(Executable pseudocode) 수준의 문법 자연어와 유사한 문법 구조 신속성 빠른 개발 속도 여러 라이브러리와 프레임 워크들이 만들어져있어 빠르게 가져다 프로그래밍 할 수 있음 직관적 읽고 쓰기 쉬운 코드 스타일 생각을 빠르게 코드화 시킬 수 있음 오픈 소스 파이썬 관련 개선을 위한 제안(PEP) 많은 개발자의 의견을 수용하고 토론하며 발전한 언어 새로운 파이썬의 기능, 파이썬 프로세스, 환경에 대해 커뮤니티에 설계 문서나 정보를 제공 파이썬 기능의 간결한 기술적 사양과 기능을 위한 근거들을 제공 커뮤니티의 의견을 수집, 합의 도출, 반대 의견 청취 PEP 8(스타일 가이드) 대표적인간적 &amp; 직관적 실행할 수 있는 의사 코드(Executable pseudocode) 수준의 문법 if 3 in [1, 3, 5, 7]: print(\"3이 들어있습니다\") 리스트 [1, 3, 5, 7]에 3이 포함 되어 있으면 \"3이 들어있습니다\"를 출력하시오 생산성 &amp; 신속성 C int i, n; int sum = 0; printf(\"입력:\"); scanf(\"%d\", &amp;n); for(i = 0; i &lt; n; i++) { sum += i; } printf(\"합은 %d\", sum); Python n = int(input(\"입력:\")) sum = 0 for i in range(1, n+1): sum += i print(\"합은\" + sum) 대형 개발자 커뮤니티라이브러리와 프레임워크 주어진 라이브러리들을 빠르게 임포트하여 쉽고 편하게 사용 가능 Pytorch, TensorFlow 딥 러닝을 위한 라이브러리 astropy, biopython 각종 과학 기술 분야에서 특화되어 사용할 수 있음 matplotlib, Bokeh, pandas 어떤 데이터의 결과를 만들어내고 그래프화 할 수 있게 함 ipython, jupyter 편리하게 개발할 수 있는 환경 제공 flask, django 대형 프로젝트 개발 시 특정 순서대로 개발하기 위한 프레임워크 제공 numpy, Numba, SymPy 수치 해석 관련된 여러가지 기능을 내장하고 있는 라이브러리 파이썬의 단점 C나 Java 등으로 작성된 프로그램보다 느린 속도 완전한 애플리케이션 단독 개발이 불가능 쉘 스크립트 언어 용으로 개발 모바일 앱 등 응용 애플리케이션 개발 불가능 대안으로 Rust 또는 Go 고려 가능파이썬 프로그램의 실행파이썬 실행 환경 플랫폼에 독립적이며 인터프리터 식 객체 지향적 동적 타이핑(dynamically typed) 대화형 언어 윈도우, 리눅스, 유닉스, 맥OS 등 다양한 운영 체제(플랫폼)에서 별도의 컴파일 없이 실행 가능 CPython, PyPy, Cython, Jython 등 다양한 인터프리터 환경 사용 가능 프로그램을 객체로 모델링 변수의 자료형을 지정하지 않음 작성한 코드에 대한 수행 결과를 바로 확인하고 디버깅하면서 코드 작성 가능 CPython C 언어로 개발된 파이썬 인터프리터 C 구현 라이브러리와의 연동을 통한 확장에 최적 컴파일러의 유형 소스 코드를 기계어로 바꾸어주는 컴파일러와 인터프리터 셀프 호스팅 컴파일러 부트 스트래핑 단계를 통해 자신의 언어로 작성한 컴파일러 소스 대 소스 컴파일러 타 언어로 작성한 컴파일러 오픈소스로 커뮤니티의 기여로 지속적 발전 https://github.com/python/cpython 파이썬 프로그램 실행 과정 파이썬 애플리케이션은 소스 코드 형태로 배포 CPython이 컴파일 후 바이트 코드(.pyc) 파일 생성 파이썬 가상 머신은 바이트 코드를 한 라인씩 실행 변경 없이 재 실행 시 바이트 코드로 빠르게 실행 파이썬 애플리케이션 → 소스 코드 작성 (.py) CPython이 바이트코드(.pyc)로 변환 바이트코드를 파이썬 가상 머신(PVM)이 실행 실행 결과 출력 파이썬 프로그래밍 환경IDLE 기본으로 포함된 파이썬 통합 개발 환경 (IDE) 파이썬과 Tkinter GUI 툴킷으로 개발 구문 강조, 코드 자동 완성, 스마트 들여쓰기 등이 포함된 단순한 IDE 지향 stepping, breakpoint, call stack을 확인할 수 있는 통합 디버거 환경 제공 파이썬 공식 홈페이지에서 다운로드 가능 http://www.python.org Jupyter Notebook 오픈 소스 기반의 웹 플랫폼 파이썬을 비롯한 40여 개 이상의 프로그래밍 언어 지원 전통적인 소스코드-컴파일-실행 방식에서 벗어나 웹 기반 대화형 개발 및 실행 환경 문서화하여 다른 사람과 공유하기가 편리 마크 다운(Markdown)을 이용하여 코드 관련 타이틀, 설명 등 작성 가능 Google Colab 2017년 과학 연구와 교육을 목적으로 개발 클라우드 기반 주피터 노트북 개발 환경 주피터 노트북 + 구글 드라이브를 결합한 서비스 데이터 분석 및 딥러닝 연산 등 고성능 컴퓨팅 리소스 활용 가능 연습 문제 다음 중 파이썬의 장점이라고 할 수 없는 것은? a. 빠른 실행 속도 파이썬의 장점 뛰어난 생산성 대형 개발자 커뮤니티 직관적 문법 파이썬 프로그램이 플랫폼 독립적으로 실행될 수 있도록 (가)와 같이 파이썬 인터프리터가 동작하는 과정에서 중간 언어로 만드는 것은?  a. 바이트 코드 파이썬 프로그래밍 환경 중 오픈 소스이며 문서화가 쉽고 전통적인 소스코드-컴파일-실행 방식에서 벗어나 웹 기반 대화형 개발 및 실행 환경을 제공하는 것은? a. 주피터 노트북 학습 정리 파이썬은 히도 판로쉼(Guido van Rossum)에 의해 1991년 분산 운영 체제(아메바)의 시스템 관리를 위한 쉘 스크립팅 언어로 개발됨 파이썬은 명령형 프로그래밍, 절차적 프로그래밍, 객체지향 프로그래밍, 함수형 프로그래밍 패러다임을 지원함 파이썬은 교육적인 목적뿐만 아니라 응용 프로그램과 웹, 백 엔드 개발, 사물 인터넷 등 다양한 분야에 활용됨 파이썬은 파이썬 확장 제안(PEP)를 통해 새로운 파이썬의 기능, 파이썬 프로세스, 환경에 대해 커뮤니티에 설계 문서나 정보를 제공하는 등 많은 개발자의 의견을 수용하고 토론하며 발전한 언어임 파이썬은 플랫폼에 독립적이며 인터프리터식 객체 지향적, 동적 타이핑(dynamically typed) 대화형 언어임 파이썬 소스 코드는 파이썬 인터프리팅 과정에서 CPython에 의해 바이트 코드로 변환되고, 파이썬 가상 머신(PVM)이 한 라인씩 기계어 코드로 변환하여 실행됨 파이썬 개발 환경에는 구문 강조, 자동 완성, 스마트 들여 쓰기 등의 기능을 지원하는 IDLE, 주피터 노트북, 구글 코랩 등이 있음 구글 코랩(Colab)은 주피터 노트북과 구글 드라이브를 결합한 서비스로 데이터 분석 및 딥러닝 연산 등 고성능 컴퓨팅 리소스 활용 가능함" }, { "title": "[데이터베이스 시스템] 2강 - 데이터베이스 모델링", "url": "/posts/knou-dbs-2/", "categories": "Database", "tags": "knou, database", "date": "2025-03-19 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '데이터베이스 시스템' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 데이터베이스를 구축하기 이전에 반드시 선행되어야 하는 작업은 데이터를 조직화하여 저장할 수 있는 명확한 체계를 설계하는 것이다. 서로 복잡하게 연관되어 있는 실 세계의 데이터를 명확한 구조화 없이 곧바로 DBMS 입력하여 사용하는 경우 효율적인 데이터 처리가 불가능해진다. 효과적인 데이터베이스 구조를 도출하기 위해 필요한 전반적인 데이터베이스 모델링 과정에 대하여 살펴보고 초기 단계인 사용자 요구 사항 분석과 개념적 데이터 모델링에서 사용하는 ER 모델의 요소 및 ER 모델링 방법에 대하여 학습한다.주요 용어 사용자 요구 사항 분석 사용자가 원하는 애플리케이션 프로그램의 요구 사항을 만족하는 데이터베이스를 모델링 하기 위해 실제 업무에서 사용되는 데이터의 종류와 특징을 폭넓게 파악하는 과정 개념적 데이터 모델링 실 세계의 데이터를 개념적으로 일반화 시켜 데이터 구조, 데이터 타입, 속성, 관계, 제약 조건 등을 이끌어내는 과정 ER 모델 실 세계의 속성들로 이루어진 개체(entity)와 개체 사이의 관계(relationship)를 정형화 시킨 모델 개체 집합 실 세계에 존재하는 다른 객체와 구별되는 유, 무형의 사물의 집합 관계 집합 개체 집합 간의 연결 관계 강의록데이터베이스 모델링의 이해데이터베이스 모델링의 필요 비즈니스적 관점 어떤 데이터를 저장해야 하는가? ex) 편의점 최종목표 상품들을 고객들에게 효율적으로 판매하기 위한 데이터베이스 시스템 구축 필요한 정보 고객들의 판매 성향, 고객들의 대략 수입(추정치) 등 불필요한 정보 고객의 혈액형, 정치 성향, 종교 등 IT적 관점 어떻게 데이터를 저장해야 하는가? 데이터베이스 모델링의 정의 데이터의 의미를 파악하고 데이터와 관여하는 업무 프로세스를 개념적으로 정의하고 분석하는 작업 데이터베이스 모델링의 단계? 명확한 정의 필요 저장하려는 데이터가 무엇인지? 데이터는 어떤 의미로 활용되는지? 어떻게 연산 되어 결과를 도출하는가? 사용할 데이터를 선별하고 데이터베이스에 체계적으로 구조화하여 저장, 사용할 방법이 필요 개념적 데이터 모델링 → 논리적 데이터 모델링 → 물리적 데이터 모델링 데이터 모델 데이터의 의미, 데이터 타입, 연산 등을 명시하기 위해 사용할 수 있는 개념(표기법)의 집합 데이터 모델링 데이터에 대한 요구 사항을 분석하여 추상화 하는 과정 실 세계의 일부분을 DBMS가 지원하는 데이터 모델의 형태로 나타내는 과정 비즈니스 모델에 필요한 실 세계의 다양한 형태의 데이터를 DBMS가 효율적으로 저장할 수 있는 구조로 전환하는 과정 여러 사람이 공동으로 작업해야 하므로 동일한 표기법 사용해야함 데이터베이스 모델링의 단계 개념적 데이터 모델링 요구 사항을 바탕으로 추상화하고 해석 오류를 방지 실 세계의 데이터를 개념적으로 일반화 시켜 데이터 타입, 속성, 관계, 제약 조건 등을 이끌어내는 과정 논리적 데이터 모델링 DBMS의 구현 모델에 맞춰 데이터의 구조를 표현 데이터 정의 언어로 기술된 스키마(schema) 생성 스키마 어떤 물건들을 적재하기 위한 효율적인 구조 데이터를 저장하기 위한 구조체 물리적 데이터 모델링 데이터베이스 파일의 내부 저장 구조, 파일 구성, 인덱스, 접근 경로 등을 결정하는 과정 사용자 요구 사항 분석사용자 요구 사항 분석의 필요 데이터에 대한 충분한 사전 분석 없이 적절한 설계가 불가능 데이터베이스의 구조가 점차 복잡해지고 수명 주기가 단축되는 최근 경향에 신속, 정확성이 요구 데이터베이스의 활용 범위가 확대됨에 따라 데이터베이스의 효율적인 운용에 초점 사용자의 요구를 명세하지 않고 데이터베이스 설계 및 개발을 진행하는 경우 결과물의 완성도 저하 및 신뢰도 추락 개발 후, 발생하는 에러 수정에 대량의 추가 비용 지출 사용자 요구 사항 분석의 개념 정보 시스템의 대상이 되는 업무를 분석 정보 시스템의 데이터베이스가 신속하고 효과적으로 업무 처리를 지원 필요한 데이터를 저장 및 운용할 수 있는 구조 개발 도출 → 분석 → 기록 단계로 수행 국제 표준화 IEEE-Std-830 ex) IEEE-Std-830 스타일의 Software Requirements Specification 요구 사항 명세 양식 소프트웨어 만들기 앞서 기능적 요구 사항과 비 기능적 요구 사항은 무엇? 좋은 요구 사항 명세란? 도출 → 분석 → 기록 단계를 수행하면서 추상적 → 구체적 모호하지 않게 사용자 요구 사항 분석 과정 요구 사항 도출 개발 프로젝트 배경, 목표 및 범위를 파악 업무 관계자 인터뷰 수행 제안 요청서의 요구 사항을 기능 별 분류 및 상세화 외부 자료 수집 및 분석 요구 사항 분석 도출 된 요구 사항의 명확성, 완전성, 모호성 검증 기술 개요, 기능 및 비기능 요구 사항, 위험 요소, 용어와 데이터 정의, 사용자 인터페이스 명세화 불완전한 부분이 존재할 경우, 요구 사항 도출 단계 재수행 요구 사항 기록 요구 사항 목록 정리 및 관리자의 승인 정리된 요구 사항을 형식에 맞춰 문서화 프로젝트 종료 때까지 반영 여부 지속적 관리 요구 사항 정의서 실질적인 개념적 데이터 모델링 진행 ER 모델ER 모델의 개념 1976년 카네기 멜론 대학의 P.Chen 박사 제안 실 세계의 속성들로 이루어진 개체(entity)와 개체 사이의 관계(relationship)를 정형화 시킨 모델 개념적 데이터 모델링 단계에서 사용되는 모델 데이터 구조와 관계를 ER 다이어그램(ERD)으로 표현 구성 요소 개체 집합, 관계 집합, 속성 제약 조건 특수 속성과 특수 관계 개체 집합 개체(entity) 실 세계에 존재하는 다른 객체와 구별되는 유, 무형의 사물 개체를 설명하는 여러 속성들로 구성 개체 집합(entity set) 같은 속성을 공유하는 개체들의 모임 구체적인 내용 X 추상적, 구조적인 성격 관계 집합 관계 개체와 개체 사이의 연관성 관계 집합 개체 집합 간의 연결 관계 속성 개체를 구체적으로 설명하는 특성으로 개체 집합은 속성의 집합 속성 값의 특성에 따라 여러 종류로 구분 속성의 종류 단순 속성과 복합 속성 단일 값 속성과 다중 값 속성 유도 속성과 저장 속성 각각의 속성은 위 세 그룹 중 하나의 속성에 해당속성의 종류 단순 속성 더 작은 요소로 나눌 수 없는 속성 복합 속성 더 작은 구성 요소로 나눌 수 있는 속성 ex) 1999년 12월 5일 → 연, 월, 일 단일 값 속성 한 개체에 대해 단 하나의 속성 값 만을 갖는 속성 다중 값 속성 한 개체에 대해 여러 개의 속성 값을 갖는 속성 유도 속성 다른 속성의 값으로부터 값이 유추 될 수 있는 속성 저장 속성 실제 값을 저장해야 하는 속성, 유도 속성을 위해 사용 제약 조건 데이터 모델은 데이터, 의미, 구조, 연관성 및 데이터의 조건을 표현하기 위한 도구 ER 모델은 개체와 관계에 대한 표현의 정확성을 위해 데이터가 준수해 하는 제약 조건을 정의할 수 있는 표현 방법 제공 제약 조건(contraints)의 종류 사상수 참가 제약 조건 키 속성 사상수(mapping cardinality) 관계 집합에 참가한 개체 집합에 대해 한 개체 집합의 개체가 다른 개체 집합의 개체와 관계를 맺을 수 있는 수량 일대일(1:1) X 하나가 Y 하나에 연결 Y 하나가 X 하나에 연결 다대일(N:1) Y 하나가 X 여러 개에 연결 다대다(M:N) 사상 수에 따라 최종 생성되는 내부 스키마가 완전히 달라짐일대일 사상수 표현 1에 해당하는 쪽에 화살표 1인이 1계좌를 보유하고 1계좌는 1인에게만 속함 1:1의 관계 일대다 사상수 표현 1 교수는 다 과목을 강의하고 1 과목은 1 교수가 강의함다대다 사상수 표현 서로 여러 개체에 대응 다:다의 관계 참가 제약 조건(participatoin constraints) 전체적 참가 한 개체 집합의 모든 개체가 관계 집합에 참여하는 조건 이중 선으로 나타냄 부분적 참가 한 개체 집합의 일부 개체만 관계 집합에 참여하는 조건 단일 선으로 나타냄 이 과목은 반드시 교수에 의해 꼭 강의 됨(의무) 일부 교수는 과목을 강의가 아닌 다른 역할을 담당할 수도 있음키(key) 속성 각 개체를 구별하는데 사용되는 유일한 값을 가지는 속성의 집합 개체를 고유하게 구분하는 역할 관계 집합의 특정 관계를 찾는 역할 해당 키에 해당하는 자물쇠는 무엇인가를 밝히기 위한 방법을 제공하는 속성 특수 속성과 특수 관계 관계 집합의 속성 두 개체 집합의 관계에서 생성되는 값을 저장하는 속성 재귀적 관계 한 개체 집합이 자기 자신과 관계 집합을 형성하는 관계 선수 과목 과목 개체 집합 후수 과목 과목 개체 집합 특수 개체 집합 약한 개체 집합 개체의 존재 유무가 관계를 맺고 있는 개체의 존재에 종속되는 개체 집합 강한 개체 집합 약한 개체 집합과 연결되는 개체 집합 계좌는 학생이 없어지면 반드시 따라 없어져야함 이중선 표기 개념적 데이터 모델링의 결과연습 문제 사용할 데이터를 선별하고 데이터베이스에 체계적으로 구조화하여 저장 · 사용할 방법을 정의할 수 있도록 데이터의 의미, 데이터 타입, 연산 등을 명시하기 위한 개념들의 집합을 무엇이라고 하는가? a. 데이터 모델 데이터의 의미, 데이터의 타입, 연산 등 현실 세계의 정보들을 데이터베이스에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현할 수 있는 모형을 데이터 모델이라고 함 사용자 요구 사항 분석 과정의 순서로 올바른 것은? a. 요구 사항 도출 → 요구 사항 분석 → 요구 사항 기록 사용자 요구 사항 분석 과정을 통해 제안 요청서에서 요구 사항 정의서를 도출할 수 있으며 이를 위해 사용자 요구 사항 분석 과정은 요구 사항 도출, 요구 사항 분석, 요구 사항 기록 단계를 거침 관계 집합에 참가한 개체 집합에 대해 한 개체가 다른 개체와 관계를 맺을 수 있는 수량을 명시한 것은? a. 사상수(mapping cardinality) 개체와 관계에 대한 표현의 정확성을 위해 명시할 수 있는 제약 조건에는 사상수, 참가 제약 조건, 키 속성이 있으며 이 중 사상수는 관계 집합에 참가한 개체 집합에 대해 한 개체가 다른 개체와 관계를 맺을 수 있는 수량을 명시함 정리 하기 데이터베이스 모델링 과정은 사용자 요구 사항을 분석하여 개념적 데이터 모델링, 논리적 데이터 모델링, 물리적 데이터 모델링의 단계로 진행됨 사용자 요구 사항 분석 단계에서는 요구 사항을 도출하고 분석하고 기록하는 단계로 진행되며, 요구 사항이 모호하거나 정확하지 않을 때는 이전 단계로 회귀하여 요구 사항을 교정함 데이터 모델링이란 데이터에 대한 요구 사항을 정의하고 분석하는 방법으로, 데이터 모델링을 통하여 데이터베이스가 구축되기까지는 개념적 데이터 모델링, 논리적 데이터 모델링, 물리적 데이터 모델링 과정으로 나뉨 ER 모델은 전체적인 데이터베이스의 논리적인 구조를 표현하는 전체 스키마의 명세서를 작성하는데 사용되는 개념적 데이터 모델링 도구로, 실 세계의 조직 업무의 의미와 상호 작용을 개념적으로 나타내는 데 매우 유용함 ER 모델의 기본 요소인 개체는 공통된 속성을 가지며 구별 가능한 실 세계의 개체들로 구성 됨 이러한 개체들은 각 개체 집합의 구성원들이 가지는 기술적 특성인 속성들의 집합으로 표현되며, 속성의 유형은 단순 속성, 복합 속성, 단일 값 속성, 다중 값 속성, 유도 속성, 저장 속성, 널 속성 등으로 구분할 수 있음 ER 모델의 중요한 제약 조건은 사상 수, 참가 제약 조건, 키 속성으로 나뉘며, 이진 관계에서 사상 수 비율은 1：1(일대일), 1：N(일대다), N：1(다대일), M：N(다대다)의 형태가 있음 참가 제약 조건에서는 특정 개체 집합이 관계 집합에 참여할 때 모든 개체가 관계에 참여한다면 전체적 참여, 일부만 참가하면 부분적 참여라고 함 또한 구조적 제약 조건을 통해 개체가 최소 몇 번, 최대 몇 번 관계에 참여할 수 있는지 정의할 수 있음 키 속성의 경우 어떤 개체 집합 안의 각각의 개체들을 구별해 주기 위해 선택되는 것으로, 최소한의 속성의 조합으로 만들어지며, 대표적으로 사용될 수 있는 속성 조합을 키라고 함 동일한 개체 집합이 서로 다른 역할로 참가하여 생성되는 관계 집합을 재귀적 관계 집합이라고 함 이 때 관계에 참가하는 개체가 행하는 기능을 개체의 역할(role)이라고 함 약한 개체 집합은 1：N 관계 집합을 통해 강한 개체 집합에 연결해야 하며, 약한 개체 집합의 구별자(또는 부분 키)는 약한 개체 집합 내의 개체들을 구분하는 속성의 집합임 약한 개체 집합의 키 설정은 반드시 지배 개체 집합의 키와 약한 개체 집합의 부분 키로 구성되어야 함 체크 포인트 데이터베이스 모델링에 대한 단계 중 아래에서 설명하는 단계는? 추상화 수준이 높고 업무 중심적이고 포괄적인 수준의 모델링 진행 전사적 데이터 모델링으로 EA 수립 시 많이 이용됨 a. 개념적 데이터 모델링 ER 모델에서 다중 값 속성의 표기법은? a. 2 ER 표기법 " }, { "title": "[유비쿼터스 컴퓨팅 개론] 2강 - 유비쿼터스 컴퓨팅 개념과 주요 이슈", "url": "/posts/knou-uqc-2/", "categories": "Computer Science, CS Theory", "tags": "knou, ubiquitous computing", "date": "2025-03-18 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정광식 교수님의 '유비쿼터스 컴퓨팅 개론' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 보이지 않는 컴퓨팅, 내재된 컴퓨팅 과 같이 다양한 이름을 가지고 있는 유비쿼터스 컴퓨팅은 ‘Ubiquitous Computing(Ubicomp)’이라 명명되면서 사용되기 시작했으며, 줄여서 ‘Ubiquitous’로 통용되기도 함 유비쿼터스 컴퓨팅과 유비쿼터스 환경의 개념과 정의를 공부함학습 목표 언제, 어디에 있든지 컴퓨터의 지원을 받을 수 있는 유비쿼터스 컴퓨팅의 정의 및 특징을 이해할 수 있음 정보통신 서비스의 통합화와 다양화의 기술 진화 방향이 공존하는 유비쿼터스 컴퓨팅의 개념적 기술 전개 환경을 이해할 수 있음 각국의 유비쿼터스 컴퓨팅의 개념을 비교할 수 있으며, 유비쿼터스 컴퓨팅의 주요 이슈를 이해할 수 있음강의록유비쿼터스 컴퓨팅의 정의유비쿼터스 컴퓨팅 개요 미국 제록스사 PARC(Palo Alto Research Center)에서 컴퓨터와 네트워크에 대한 근본적인 모습의 연구로부터 시작 사람 중심의 서비스 사람 중심의 서비스 환경을 변화 시킬 수 있는 기술 공간과 사회를 변경할 수 있는 기술 PARC는 이와 관련한 연구 사업을 ‘Ubiquitous Computing(Ubicomp)’ 라고 명명함 유비쿼터스 컴퓨팅의 요구 사항(기본 전제) 사용자 인터페이스 통신 네트워크 무선 통신 등 공간 발전의 역사유비쿼터스 컴퓨팅의 정의 사람을 포함한 현실 공간에 존재하는 모든 대상물들을 기능적, 공간적으로 연결하여 사용자에게 필요한 정보나 서비스를 즉시에 제공할 수 있는 기반 기술 사람, 사물에 대해서 유비쿼터스 네트워크 이용해 기능적으로 공간적으로 연결 언제, 어디서나, 어떤 네트워크와 어떤 기기에서도 사용 가능 (anytime, anywhere, any network, any device) 유비쿼터스 컴퓨팅의 단말기 Tabs a wearable device that is approximately a centimeter in size Pads a hand-held device that is approximately a decimeter in size Boards an interactive larger display device that is approximately a meter in size 유비쿼터스 컴퓨팅이 지향하는 모습 유비쿼터스 환경 우리의 일상생활 속으로 스며들어 밖으로 드러나 보이지 않는 조용한 상태(calm)에서, 서로 유기적으로 연결(connectivity)되어 협조함으로써, 언제 어디서나 컴퓨팅(computing) 기능을 활용할 수 있으며, 우리들에게 필요한 정보나 서비스(contents)를 맞춤 방식으로 즉시 제공하여, 사람-사물은 물론 사물-사물 통신(communication)도 가능하여 우리의 삶의 질을 향상 시키는 새로운 컴퓨터 환경 AI/기계 학습/블록 체인 등의 기술도 함께 고려해야 함 유비쿼터스 컴퓨팅의 발전 방향 유비쿼터스 공간의 구축 유비쿼터스 공간에서는 모든 물리 공간에 컴퓨팅 능력을 심는 것이 주된 목표 기존의 전자 공간의 구축 가상 공간 개념이 주축을 이루어 물리 공간을 가상 공간에 옮기는 것이 주된 목표 유비쿼터스 컴퓨팅의 발전 방향 - 마크 와이저의 예측 보이지 않는 인터페이스 사물에 대한 인간화 기술 새로운 문화 : 유비쿼터스 컴퓨팅의 출현 마크 와이저의 유비쿼터스 컴퓨팅 전개 시나리오유비쿼터스 컴퓨팅 특징유비쿼터스 컴퓨팅 목적 모든 사물에 컴퓨팅 능력을 심는 것 이를 위해서 모든 사물에 극 소형의 컴퓨터 칩을 내재시키고(embedding) 이를 지능화 시켜야 함 유비쿼터스 컴퓨팅 결과 사물의 일부가 된 컴퓨터들은 주변 상황을 인식할 수 있고, 지리적으로 떨어진 곳에서도 사용자가 대상 사물과 그 주변 환경의 변화를 지각하거나 추적할 수 있도록 함유비쿼터스 컴퓨팅 환경 제공 방법 모든 곳에 컴퓨터를 내장 시켜 가장 가까운 컴퓨터를 언제나 사용할 수 있는 방식 모든 곳에 항상 편재하는 컴퓨터를 이용 사용자의 컴퓨터가 항상 네트워크에 연결되어 있고, 언제나 정보 서비스를 제공 받는 방식 사용자가 항상 네트워크와의 통신 가능한 소형 컴퓨터를 가지고 다님 휴대 가능한 컴퓨터 혹은 스마트폰이 보급되면서 유비쿼터스 컴퓨팅의 의미가 크게 확장됨 유비쿼터스 컴퓨팅의 실현유비쿼터스 컴퓨팅의 특징 - 마크 와이저 네트워크에 연결되지 않은 컴퓨터는 유비쿼터스 컴퓨팅이 아님 항상 네트워크에 접근 가능해야 한다는 의미 인간화된 인터페이스로서 눈에 보이지 않아야 함 내장형 또는 소형 마이크로컴퓨터 칩으로 사물에 내재되고 인간 중심의 지능형 인터페이스 기능을 가져야 한다는 의미 가상 공간이 아닌 현실 세계의 어디서나 컴퓨터 사용이 가능해야 함 현실 세계의 구체화된 어떠한 장소에서도 컴퓨터 사용이 가능해야 한다는 의미 인간화 된 인터페이스로서 사용자 상황에 따라 서비스가 변화해야 함 사용자에게 적합한 정보를 특정 기준에 맞춰 개인화하여 제공해야 한다는 의미 유비쿼터스 컴퓨팅의 개념적 기술 전개 환경유비쿼터스 컴퓨팅의 개념적 기술 전개 방향 증강 현실 기술은 국제적 표준화와 사용자 중심의 개인화와 양면성을 가지며 발전함 범용성과 특수성의 조화와 통합 측면의 기술 발전 양상을 보임유비쿼터스 컴퓨팅의 개념적 기술 전개 첫째 파장 서버 기술과 유무선 통신 기술 영역이 끊김 없는 네트워크를 기반으로 통합된 정보 서비스를 제공하는 방향으로 진화됨 둘째 파장 클라이언트와 PostPC 기술, 무선 및 유무선 통합망 기술은 초고속, 대용량의 멀티미디어 데이터에 대한 광대역 접속 서비스를 제공하게 됨 셋째 파장 내장된 초소형 컴퓨팅 객체와 미세 전자기계 시스템(MEMS) 기술, 센서 기술 및 근거리 무선 통신 기술, NFC 등의 기술 발전으로 전자 공간과 물리 공간의 융합이 가능해짐 넷째 파장 딥러닝, 클라우드 컴퓨팅, 스마트 자동차 기반 기술 등의 상업적 적용으로 인한 개인 맞춤형 자율 서비스로 진화함 유비쿼터스 컴퓨팅의 개념적 기술 전개 예측 인공 지능 기술의 융합으로 개인화된 유비쿼터스 서비스의 수준 향상 빅데이터 처리 능력/적용 범위/ 수집 등의 확대로 인한 다양한 유비쿼터스 서비스의 발전성장 동인의 이동 시나리오유비쿼터스 컴퓨팅의 주요 이슈유비쿼터스 네트워크 기반의 유비쿼터스 컴퓨팅 기술 이슈 가시성(Visibility) 측면 복잡하고 방대한 결과에 대한 시각적 편리성을 지향하며, 정보 서비스 제공이 구체화되어야 함 복잡도(complexity) 측면 구체화된 컴퓨터의 운영체제, 응용 등에 대한 협력 작업과 분산 작업을 통한 효율적인 협력 시스템과 서로 다른 기능을 갖는 다양한 시스템들의 융합 컴퓨팅 모델이 제시되어야 함 추상화(abstraction) 측면 가상화나 클러스터링 기술을 통해 스마트폰이나 PC를 단말기로 사용하는 슈퍼 컴퓨터 사용 환경을 제공함 연결성(connection) 측면 인터넷 통신 속도의 고속 화, 안정성, 효율성, 광 대역 채널의 확보를 통해 데이터나 컴퓨팅 능력 면에서 보다 큰 스케일의 컴퓨팅 공간을 구축해야 함 비가시성(invisivility) 측면 인간 중심의 사용자 인터페이스를 통해 편리한 인터페이스를 제공하기도 하고, 개인 화 된 인터페이스를 제공할 수 있는 서비스를 창출해야 함 정리 하기 유비쿼터스는 물리 공간과 전자 공간을 통합하여 모든 물리 공간에 보이지 않는 컴퓨터를 내재하여 전자 공간 속으로 참여 시키는 것을 의미함 유비쿼터스 컴퓨팅 환경을 구현하기 위해서는 가시성, 복잡도, 추상화, 연결성, 비가시성 영역에 대한 컴퓨터 기술 연구가 필요함연습 문제 유비쿼터스 컴퓨팅의 특징으로 틀리는 것은 무엇인가? a. 물리 공간을 가상 공간으로 이동 유비쿼터스 컴퓨팅의 특징 모든 사물의 컴퓨터 내재화 모든 사물의 지능화 사물들의 유기적 연결 유비쿼터스 컴퓨팅 환경을 구현하기 위한 관심 분야로서 전자공간 사이의 좀 더 개선된 결합의 모습을 추구하는 개념은 무엇인가? a. 연결성 위 내용에 알맞은 내용을 답하시오 유비쿼터스 컴퓨팅 환경을 구현하기 위한 관심 분야로서 전자공간 사이의 좀 더 개선된 결합의 모습을 추구하는 개념은 무엇인가? a. 유비쿼터스 컴퓨팅 정리 하기 유비쿼터스 컴퓨팅은 사람을 포함한 현실 공간에 존재하는 모든 대상물들을 기능적·공간적으로 연결하여 사용자에게 필요한 정보나 서비스를 즉시에 제공할 수 있는 기반 기술 사물의 일부가 된 컴퓨터들은 주변 상황을 인식할 수 있고, 지리적으로 떨어진 곳에서도 사용자가 대상 사물과 그 주변 환경의 변화를 지각하거나 추적할 수 있도록 함 유비쿼터스 컴퓨팅의 특징 네트워크에 연결되지 않은 컴퓨터는 유비쿼터스 컴퓨팅이 아님 인간 중심의 인터페이스로서 눈에 보이지 않아야 함 현실 세계의 어디서나 컴퓨터의 사용이 가능해야 함 유비쿼터스 컴퓨팅의 개념적 기술 전개 방향 유비쿼터스 네트워크 유비쿼터스 기술의 인간 친화 사용자에 최적화된 서비스 환경 지능화된 사물 유비쿼터스 컴퓨팅 기술 이슈 가시성(Visibility) 측면 복잡하고 방대한 결과에 대한 시각적 편리성을 지향하며, 정보 서비스 제공이 구체화되어야 함 복잡도(complexity) 측면 구체화된 컴퓨터의 운영체제, 응용 등에 대한 협력 작업과 분산 작업을 통한 효율적인 협력 시스템과 서로 다른 기능을 갖는 다양한 시스템들의 융합 컴퓨팅 모델이 제시되어야 함 연결성(connection) 측면 인터넷 통신 속도의 고속 화, 안정성, 효율성, 광 대역 채널의 확보를 통해 데이터나 컴퓨팅 능력 면에서 보다 큰 스케일의 컴퓨팅 공간을 구축해야 함 비가시성(invisivility) 측면 인간 중심의 사용자 인터페이스를 통해 편리한 인터페이스를 제공하기도 하고, 개인 화 된 인터페이스를 제공할 수 있는 서비스를 창출해야 함 " }, { "title": "[운영 체제] 2강 - 프로세스와 쓰레드", "url": "/posts/knou-os-2/", "categories": "OS, Operating System", "tags": "knou, os", "date": "2025-03-17 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김진욱 교수님의 '운영 체제' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 프로그램을 실행시키면 운영 체제로부터 프로그램이 동작하는 데 필요한 자원을 할당 받아 동작을 시작함 이처럼 실행 상태에 들어간 프로그램을 프로세스라고 함 프로세스의 동작은 CPU가 그 프로세스의 명령들을 실행하는 것임 이때 CPU도 기억 장치나 입출력 장치와 마찬가지로 프로세스가 동작하는데 필요한 자원임 그리고 프로세스 내 에서의 다중 처리를 위해 한 프로세스 안에 여러 개의 쓰레드를 두기도 함 운영 체제의 핵심적인 구성 요소 중 하나인 프로세스에 대한 기본적인 이해와 함께 쓰레드의 개념을 학습함학습 목표 프로세스의 개념을 설명할 수 있음 쓰레드의 개념을 설명할 수 있음 프로세스와 쓰레드의 관계를 설명할 수 있음강의록프로세스프로세스의 개요 프로세스(process) 작업 관리자 앱 사용자가 실행 시킨 프로세스 백 그라운드 프로세스 시스템 프로세스 PID 프로세스 아이디 프로세스에 해당하는 번호 운영 체제가 같은 파일 이름을 갖는 여러 개의 다른 프로세스를 별도로 구분해 관리해주기 위해 이용 실행 중인 프로그램 프로그램 동작을 하지 않는 정적·수동적 개체 저장 장치에 있을 때는 프로그램에 관련된 명령어들의 리스트들이 쭉 들어있음 프로세스 동작을 하는 능동적 개체 실제 프로세스가 되면 메모리 공간에는 그 프로그램 자체에다가 부가적인 다양한 데이터들이 더 필요해져 용량이 더 커짐 프로세스 자체는 프로그램 사이즈보다 훨씬 큼 운영 체제로부터 자원을 할당 받아 동작 자원 CPU, 메모리, 입출력 장치, 파일 등 동작 CPU가 프로세스의 명령을 실행 프로세스와 운영 체제 프로세스를 생성 및 종료 프로세스를 실행시키기 위한 스케줄링 작업 프로세스의 상태 관리프로세스의 구성 메모리 구조 프로그램 실행에 직접적으로 필요한 코드와 데이터 코드 영역 프로그램 자체 데이터 영역 프로그램 실행 시 필요한 데이터 상수나 변수의 값 서브 프로그램 호출 상태 등 정적 데이터 영역 프로그램 시작부터 끝까지 관리되어야 하는 변수(상수, 전역변수) 보관 스택 영역 함수 호출 및 지역 변수 저장 힙 영역 동적으로 할당되는 메모리 공간 동적 변수들 중에서 사용자가 수동으로 할당하는 것 저장 프로세스 제어 블록(PCB) 운영 체제가 프로세스를 관리하기 위해 필요한 정보 각 프로세스마다 존재 여러 프로세스가 번갈아 실행되는 경우 PCB에 저장된 정보 활용 프로그램 카운터(PC) 현재 실행 중인 명령어에 바로 다음 명령어의 위치 값을 가지고 있어야 함 제어의 흐름 프로세스 상태 관리프로세스 상태 변화 디스패치 준비 큐에서 준비하다가 cpu 할당 받게 되는 것 특정 프로세스에다가 cpu를 할당해 주는 과정 자체 부모 프로세스와 자식 프로세스 프로세스 생성 방법 사용자가 프로그램을 직접 실행 한 프로세스가 다른 프로세스를 생성 프로세스 생성 시스템 호출 이용 시스템 호출 사용자 모드에서 동작을 하다가 자원 할당 같은 것이 필요할 때 커널 모드로 변화 시킴 부모 프로세스 시스템 호출을 하는 프로세스 자식 프로세스 시스템 호출을 통해 새로 생성된 프로세스 프로세스 생성 시스템 호출 UNIX, Linux fork(); 자식 프로세스는 부모 프로세스의 복제본 pid 값만 달라짐 fork 후 자식 pid 결과 값을 받아오기 때문에 부모 프로세스는 자식 프로세스의 pid 정보를 알 수 있음 자식 프로세스는 포크 후 pid 결과 값 0 값을 받아와 자식 프로세스인지 구분할 수 있게 됨 UNIX, Linux fork(); 자식 프로세스는 부모 프로세스와는 다른 프로그램 실행 Windows CreateProcess() 자식 프로세스는 새로운 프로그램으로 생성 쓰레드전통적인 프로세스 하나의 프로그램을 실행하기 위한 기본적인 단위 코드(Code) 영역 실행할 프로그램 코드가 저장되는 공간 정적 데이터(Data) 영역 전역 변수 및 초기화된 데이터 저장 스택(Stack) 영역 함수 호출, 지역 변수 저장 힙(Heap) 영역 동적 메모리 할당을 위한 공간 PCB (Process Control Block) 프로세스의 상태, PID(프로세스 ID), PC(Program Counter) 등 정보를 저장 자원 소유의 단위 하나의 메모리 구조 디스패칭의 단위 하나의 제어 흐름 프로세스 내에서 다중 처리 불가능쓰레드(thread) 프로세스 내에서의 다중 처리를 위해 제안 된 개념 코드(Code) 영역 모든 쓰레드가 공유 정적 데이터(Data) 영역 모든 쓰레드가 공유 힙(Heap) 영역 모든 쓰레드가 공유 스택(Stack) 영역 각각의 쓰레드가 독립적으로 가짐 PC (Program Counter) 각 쓰레드가 개별적으로 가짐 하나의 프로그램을 실행하기 위한 기본적인 단위 하나의 프로세스 안에서 여러 개의 작업(쓰레드)이 동시에 실행될 수 있도록 함 디스패칭의 단위 자원 소유의 단위 : 프로세스 하나의 프로세스 내에는 하나 이상의 쓰레드 존재 하나의 메모리 구조를 공유하는 여러 제어 흐름 프로세스의 메모리 공간(코드, 데이터, 힙)을 공유하지만, 각 쓰레드는 독립적인 스택과 레지스터를 가짐 프로세스 비교 구분 전통적인 프로세스 쓰레드가 있는 프로세스 실행 흐름 단일 실행 흐름 다중 실행 흐름(쓰레드) 작업 처리 방식 하나씩 순차 실행 여러 개의 작업을 동시에 수행 가능 메모리 공유 독립적인 메모리 사용 같은 프로세스 내에서 메모리 공유 속도 상대적으로 느림 상대적으로 빠름 (병렬 처리 가능) 전통적인 프로세스 하나의 프로세스는 하나의 실행 흐름을 가짐 한 번에 하나의 작업만 수행할 수 있음 프로세스 내부에는 PC(Program Counter, 프로그램 카운터)가 있어서 현재 실행 중인 명령어를 추적함 쓰레드 있는 프로세스 하나의 프로세스 내에 여러 개의 실행 흐름(쓰레드)이 존재할 수 있음 각 쓰레드는 자신만의 PC를 가지고, 동시에 실행될 수 있음 같은 프로세스 안에서 여러 작업을 병렬로 실행할 수 있어서 성능이 향상됨 쓰레드와 프로세스 비교 항목 프로세스 쓰레드 실행 단위 독립적인 실행 단위 프로세스 내에서 실행되는 흐름 자원 소유 자체적으로 메모리 및 자원 소유 프로세스의 자원을 공유 메모리 구조 독립적인 메모리 구조 코드, 데이터, 힙을 공유하고 스택은 개별적 생성 속도 상대적으로 느림 상대적으로 빠름 문맥 전환 속도 상대적으로 느림 상대적으로 빠름 다중 처리 프로세스 간 통신(IPC)이 필요 같은 프로세스 내에서 쉽게 다중 처리 가능 쓰레드는 실행에 필요한 최소한의 정보만 가짐 PC를 포함한 레지스터 값 상태 정보 스택 영역 나머지 정보는 프로세스에 두고 다른 쓰레드와 공유 다중 쓰레드로 구성된 프로세스 멀티 CPU 또는 멀티 코어 컴퓨터 시스템 다중 쓰레드를 병렬로 처리 가능 처리 속도 별로 쓰레드가 나눠진 경우 효율적인 처리 가능 정리 하기 프로세스는 실행 중인 프로그램을 의미하며, CPU, 메모리, 파일, 입출력 장치 등 실행에 필요한 자원이 할당 됨 프로세스 제어 블록은 프로세스를 명시해 주는 다양한 내용을 포함하고 있음 프로세스는 생성, 준비, 실행, 대기, 종료의 다섯 상태 중 하나로 존재하며, CPU의 스케줄링, 입출력 대기 등에 따라 준비, 실행, 대기 등으로 상태가 변화되며 동작함 쓰레드는 프로세스에서 실행의 개념만 분리한 것으로 디스패칭의 단위임 하나의 프로세스 내에는 하나 이상의 쓰레드가 있을 수 있어, 다중 쓰레드를 생성하여 프로세스 내에서의 다중 처리를 할 수 있음" }, { "title": "[Java 프로그래밍] 3강 - JAVA 기본 문법", "url": "/posts/knou-java-3/", "categories": "Language, Java", "tags": "knou, java", "date": "2025-03-14 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김희천 교수님의 'Java 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 같은 유형의 자료 집단을 표현하기 위한 배열의 사용 방법을 살펴봄 문자열을 다룰 때 사용하는 String클래스의 기본 사항을 알아보고 문자열과 관련된 형변환을 학습함 프로그램에서 키보드나 파일로부터 데이터를 입력받는 방법을 학습하고 클래스 정의 문법과 객체 생성 방법을 확인함학습 목표 프로그램에서 배열을 선언하고 사용 가능함 문자열의 덧셈 연산과 형변환을 이해할 수 있음 간단한 입출력 기능을 프로그램에 추가 할 수 있음 클래스를 정의 할 수 있음 클래스와 데이터필드의 접근 제어자에 관해 설명할 수 있음강의록배열배열 같은 자료형의 원소를 정해진 개수만큼 가지고 있는 객체 원소들의 묶음 배열의 크기는 선언할 때가 아닌 배열이 초기화 또는 생성될 때 정해짐 숫자 인덱스(첨자) 사용해 특정 원소를 다룸 배열의 선언 선언할 때 크기 지정 불가 형식 자료형[] 변수이름; 자료형 변수이름[]; ex) 1차형 배열 int[] a; int b[]; ex) 2차형 배열 int[][] c; int d[][]; int[] e[]; ex) 오류 int f[10]; 대표적인 참조형(클래스, 인터페이스, 배열) 배열 원소에 대한 주소 값만 가지고 있음 실제 데이터가 들어갈 공간 할당 받아 사용 배열의 초기화 선언과 동시에 중괄호 이용해 초기 값 지정 자동으로 메모리 공간 확보 초기화 또는 생성 과정 거쳐야 배열의 원소 사용 가능 ex) 선언과 동시에 초기화 int a[] = {2, 3, 5, 7, 11}; int anArray[][] = { {1, 2, 3}, {4, 5, 6} }; ex) 오류 int b[]; b = {4, 5, 6}; 배열의 생성 배열의 원소가 사용할 메모리 공간 생성 new연산자 이용 배열의 크기 정하고 메모리 공간 확보 new연산자는 메모리의 주소 값 리턴 원소가 숫자인 경우 0, 참조형인 경우 null로 자동 초기화 ex) 선언과 생성 int a[] = new int[3]; int b[]; b = new int[10]; int anArray4[][] = new int[3][2]; 배열의 크기 배열은 크기를 가지는 내장 속성 length가지고 있음 public class Main { public static void main(String args[]) { int twoArray[][] = { {0, 1}, {10, 11, 12} }; // 선언과 동시에 초기화 for (int i = 0; i &lt; twoArray.length; i++) for (int j = 0; j &lt; twoArray[i].length; j++) System.out.println(twoArray[i][j]); } } 형식 : 배열이름.length 문자열String클래스 String클래스는 문자열을 표현하고 처리하기 위한 참조형 String형의 변수는 참조형이나 기본형 변수처럼 사용 가능 참조형 변수는 선언 후 new연산자 이용해 실제 데이터 들어갈 공간 할당 받아 써야 함 문자열 리터럴 이중 따옴표를 사용 ex) 기본형 변수처럼 사용 가능 String s1 = \"Java\"; ex) 생성자 사용 String s2 = new String(\"Java\"); 참조형 변수에는 null이라는 특별한 값 지정 가능 if (s1 != null ) { } 문자열의 +연산자 두 문자열을 연결하는 것 (문자열 + 기본형) 또는 (문자열 + 다른 참조형)도 가능 +연산자 사용 시 기본형(또는 다른 참조형) 값은 문자열로 자동 형변환 가능 print()나 println()에서 자주 사용 1개 매개변수를 문자열로 바꿔 출력함 System.out은 화면 출력을 위한 객체 System.out.println(\"result =\" + \" \" + result); System.out.println('A' + 0); // 문자 char + 숫자 int = 65 System.out.println(\"A\" + 0); // 문자열 String + 숫자 int = A0 Scanner클래스와 입출력Scanner클래스 키보드(표준 입력)나 파일로부터 다양한 자료 입력 받을 때 사용 기본적으로 공백 문자로 구분되는 단어(토큰) 단위로 입력 문자열이나 기본형 값의 입력 위해 next()또는 nextInt()와 같은 입력 메소드 제공 ex) 단어 입력 next() ex) 단어 int 값으로 해석 nextInt() 클래스에 관한 API 설명 페이지 키보드에서 입력을 받는 Scanner객체 만들기 System.in이용해 Scanner객체 만들고 사용 Scanner sc = new Scanner(System.in); // 인자로 표준 입력 이용해 객체 생성 String name = sc.next(); // 객체 변수로 단어 입력 받음 Scanner클래스를 사용한 입력 Scanner클래스의 입력용 메소드 Scanner s = new Scanner(System.in); String name = s.next(); import java.util.Scanner; public class ScannerTest { public static void main(String[] args) { Scanner sc = new Scanner(System.in); // scanner 객체 생성 if (sc.hasNextInt()) { // int 값이 있을 경우 true 반환 System.out.println(sc.nextInt()); } else { System.out.println(\"It's not Integer\"); } } } import java.util.Scanner; public class ScannerTest2 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); // scanner 객체 생성 while(sc.hasNextInt()) { // 단어 입력 시 검사 System.out.println(sc.nextInt()); } } } boolean hasNext() next 수행 전 다음 단어가 있으면 true 반환 String next() 다음 단어를 읽어 String으로 반환 boolean hasNextInt() next 수행 전 다음 단어가 int 값이 있을 경우 true 반환 int nextInt() 다음 단어를 읽어 int 값으로 반환 boolean hasNextDouble() next 수행 전 다음 단어가 double 값이 있을 경우 true 반환 double nextDouble() 다음 단어를 읽어 double 값으로 반환 boolean hasNextLine() next 수행 전 다음 라인이 있으면 true 반환 String nextLine(); 다음 라인을 읽어 String으로 반환 클래스 정의클래스 정의 동종 객체를 표현하기 위한 데이터 필드(멤버 변수)와 메소드를 정의함 부모 클래스의 상속, 인터페이스 구현, 추상 클래스, final클래스 등을 정함 클래스 정의 문법 [접근 제어자] class 클래스이름 [extends 부모클래스이름] [implements 인터페이스 이름] { // 클래스 정의 &lt;데이터 필드 선언&gt;; &lt;생성자 선언&gt;; &lt;메소드 선언&gt;; } 클래스 접근 제어자 클래스 사용 시 어디서 접근 가능한지 지정 생략, public, protected, private 클래스 비접근 제어자 abstract, final abstract클래스는 상속 가능 final클래스는 상속 불가능 헤더와 몸체로 구성됨 클래스 정의 내부에 존재함 메소드 정의 문법 [접근 제어자]반환형 메소드 이름([자료형 인자[, 자료형 인자]]) [throws 예외 이름] { &lt;문장&gt; } class Circle { public double getArea() { return this.r * this.r * 3.14; } } 클래스의 정의와 사용 클래스 정의에서 데이터 필드와 메소드 인스턴스 변수(메소드)와 클래스 변수(메소드) 개별 객체가 소유하는 인스턴스 변수와 인스턴스 메소드 클래스에 속한 객체가 공유하는 클래스 변수(static변수, 정적 변수)와 클래스 메소드 객체의 상태는 데이터 필드로, 행위는 메소드로 구현됨 메소드는 저장된 데이터를 이용해 기능 수행 클래스의 사용 클래스형 변수를 선언할 때 클래스는 객체의 자료형 ex) Circle c; 객체를 생성할 때 ex) c = new Circle(); s = new String(); 상속 받아 클래스를 정의할 때 클래스의 접근 제어자 클래스 접근 제어자의 의미 클래스의 사용 범위를 제한하는 것 생략, public, private, protected private과 protected는 내부 클래스에서만 사용함 abstract와 final은 사용 범위를 제한하는 접근 제어자는 아님 접근 제어자가 생략된 경우와 public class 클래스 선언에서 접근 제어자가 생략된 class 같은 패키지에 있는 다른 클래스에서 사용 가능 패키지 접근 수준 public class로 선언된 경우 모든 클래스에서 즉, 어디서나 사용 가능 클래스 정의에서 데이터 필드나 메소드를 정의할 때도 접근 제어자를 사용 데이터 필드를 사용할 수 있는 범위를 제한하는 것(정보 은닉) 메소드의 접근 제어자도 의미가 같음 데이터 필드 접근 제어자의 의미 private필드 같은 클래스에서만 사용 가능 접근 제어자가 생략된 필드 같은 패키지에 있는 다른 클래스에서도 사용 가능 protected필드 같은 패키지와 자식 클래스에서 사용 가능 public필드 모든 클래스에서 사용 가능 아래 4개의 클래스에서 Alpha 클래스의 어떤 멤버를 사용할 수 있는가? (Alpha는 public 클래스라 가정) ex) class Circle { private double r; // 데이터 필드 선언 시에 접근제어자 사용 가능 // r 은 Circle 클래스 안에서만 사용 가능 public Circle(double a) { // 메소드 선언 시에 접근제어자 사용 가능 r = a; } public double getArea() { return r * r * 3.14; } public double getRadius() { return r; } } public class CircleArea { public static void main(String args[]) { Circle c = new Circle(5); // CircleArea2와 Circle 클래스가 같은 패키지 안에 있을 경우 사용 가능 // System.out.println(c.r); // private 데이터 필드기 때문에 오류 발생 System.out.println(c.getRadius()); // r 을 리턴값으로 가지고 있는 getRadius 메소드 호출해 사용 System.out.println(c.getArea()); } } 객체의 사용클래스의 사용 정의되어 있는 기존 클래스를 사용하는 경우 상속을 위해 클래스를 사용할 때 Class Csub extends Csuper { } 클래스형 변수를 선언할 때 Circle c; 객체를 생성할 때 new는 메모리 공간을 할당 받고, 생성자를 호출하며, 메모리 참조 값을 리턴하는 연산자 c = new Circle(5); 객체의 사용 생성된 기존 객체를 사용하는 경우 객체 변수를 사용하는 경우 객체를 메소드의 인자로 전달하는 경우, 부모 유형 변수에 객체를 대입하는 경우 등 객체 변수와 점(.) 연산자를 사용하여 멤버에 접근하는 경우 객체가 소유하는 데이터(인스턴스 변수)를 읽거나 쓰기 객체를 이용하여 메소드(인스턴스 메소드)를 호출하기 ex) 객체 c를 대입 Shape myShape = c; ex) 객체 c를 전달 System.out.println(c); ex) c의 r을 변경 c.r = 5; ex) c에게 getArea()실행을 요청 c.getArea(); 생성자 객체가 생성될 때 자동으로 실행되는 메소드 객체의 필드 값을 초기화하거나 메모리 할당 등의 작업 객체 생성 방법은 new클래스이름(인자) Circle c = new Circle(5); new연산자를 이용하여 객체를 생성(메모리 할당)하고 생성자가 호출(데이터 필드의 초기화)되면서 객체의 참조 값을 변수에 대입(=) 인자가 없는 생성자를 기본 생성자(default constructor)라고 함생성자의 정의 보통의 메소드와 정의 방법이 다름 생성자는 new를 사용하여 객체를 생성할 때 호출됨 생성자 정의 방법 생성자 이름은 클래스 이름과 같음 반환형을 지정할 수 없음 한 클래스에서 여러 생성자를 정의할 수 있음(생성자 오버로딩) 매개 변수의 개수와 매개 변수의 자료형으로 구분 접근 제어자는 보통 public public class Circle2 { double r; public Circle2(double a) { r = a; } public double getArea() { return r * r * 3.14; } public double getRadius() { return r; } } package thethird; public class Circle2Area { public static void main(String args[]) { Circle2 c2 = new Circle2(5.0); System.out.println(c2.r); System.out.println(c2.getArea()); } } 기본 생성자 인자가 없는 생성자, 디폴트 생성자(default constuctor) 클래스 정의에서 단 하나의 생성자 정의도 없다면 컴파일러가 다음과 같은 것을 자동으로 만들어줌 public Circle() { } 생성자 몸체의 첫 줄에 부모 생성자의 명시적 호출이 없다면, 다음 코드가 자동으로 들어감 부모 클래스의 기본 생성자를 호출 super(); 따라서 부모 클래스에서 기본 생성자의 존재를 확인해야 함 학습 정리 배열은 선언 후에 초기화 과정이나 생성 과정을 거쳐야만 사용 가능함 배열이름.length사용해 배열 크기 표현할 수 있음 문자열 변수나 리터럴에 대해 +연산을 적용한 결과는 두 문자열이 연결된 문자열임 Scanner클래스를 이용하면 키보드나 파일로부터 편리하게 문자열(또는 기본형 값)을 입력 받을 수 있음 클래스를 정의할 때, 내부 클래스가 아니라면 클래스의 접근 제어자로서 생략과 public만 지정 가능함 정의 부분에서 접근 제어자가 생략 된 클래스나 데이터 필드는 해당 클래스 외에 같은 패키지의 다른 클래스에서만 사용할 수 있음 생성자를 정의하려면 이름을 클래스 이름과 같게 하고 반환형을 지정하지 않음연습 문제 다음 중 문법적으로 올바른 문장은 무엇인가? a. int[][] c = new int[5][]; int형 변수 i와 j의 값을 각각 출력하기 위해 적당한 출력문은 무엇인가? a. System.out.println( i + \" \" + j ); int형 변수 i와 j의 값을 각각 출력하기 위해 적당한 출력문은 무엇인가? a. Gamma " }, { "title": "[데이터 정보 처리 입문] 2강 - 데이터 입력과 점검", "url": "/posts/knou-dip-2/", "categories": "Data Science, Data Analysis", "tags": "knou, data information processing", "date": "2025-03-14 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김성수, 이기재 교수님의 '데이터 정보 처리 입문' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 엑셀이나 R, 파이썬 등을 이용한 데이터 분석 방법을 공부하기에 앞서 데이터에 대한 개념과 정의, 데이터 입력, 점검 등에 대하여 학습한다. 데이터란 관심 있는 어떤 주제에 대해서 수집 된 구조화된 정보이다. 데이터는 조사나 실험을 통해서 얻어지는데, 데이터를 분석하기 위해서는 데이터의 코딩 설계가 적합해야 하고, 알맞은 형태로 컴퓨터에 입력되어야 한다. 입력된 데이터에 입력 과정이나 조사 과정의 오류가 없는지 점검해야 한다.학습 목표 데이터의 정의와 분석 목적을 설명할 수 있음 측정의 수준과 데이터의 종류에 대해서 설명할 수 있음 데이터의 입력 과정을 설명할 수 있음 입력된 데이터에 대한 점검 과정을 설명할 수 있음주요 용어 데이터(data) 어떤 관심 있는 주제에 대해서 수집 된 구조화된 정보(organized information) 넓은 의미의 데이터는 수치, 문자, 그림 등의 표현 양식과 관계없이 어떤 주제에 대한 구조화된 정보를 뜻함 케이스(case) 특정 조사 단위로부터 얻어진 정보의 집합체를 말함 변수(variable) 각 조사 단위로부터 측정 된 개별적인 속성들 명목 척도(Nominal scale) 측정 대상의 속성을 단순히 분류하거나 확인할 목적으로 수치를 부여하는 경우에 해당함 단순히 범주 구분이 목적으로 수치의 대소 비교, 연산은 의미 없음 순서 척도(Ordinal scale) 어떤 특성을 많고 적음에 따라 몇 개의 수치 범주로 구분하여 수치를 부여하는 경우에 해당함 수치 자체가 어떤 절대적인 수나 양, 크기 등을 나타내지 않고, 서열, 대소 관계의 구분만 의미 있음 구간 척도(Interval scale) 측정 대상을 속성에 따라 서열 화 함은 물론 서열 간의 간격이 같도록 수치를 부여하여 측정하는 경우에 해당함 연속 형 값으로 측정 값의 차이는 의미 있지만, 비(比)는 의미 없음 강의록데이터의 개념데이터(data) 어떤 관심 있는 주제에 대해서 수집 된 구조화 된 정보(organized information) 일반적인 의미의 데이터는 수치, 문자, 그림 등의 표현 양식과 관계 없이 어떤 주제에 대한 구조화된 정보를 뜻함 여러가지 수치 정보가 모여있는 것 모든 분석의 기초가 되는 것 데이터에서 분석 과정을 통해 얻는 것이 정보가 됨데이터의 특징 어떤 관심 있는 주제에 대하여 얻어진 것 분석에 알맞은 일정한 규칙과 형태로 수집 되고 정리됨 분석 과정을 통해서 유용한 정보(information)로 변환 조사나 실험을 통해서 수집 되어 알맞은 형태로 변환통계적 데이터(statistical data) 수치적 계산과 통계적 분석에 알맞은 데이터데이터 분석의 목적 자연 및 사회 현상에 대한 정확한 현상(집단의 특징) 파악 왜 그런 현상이 나타나게 되었는지(인과관계) 규명 경제, 사회 현상 속에 숨어 있는 법칙성 발견 미래 생활 예측으로 합리적인 의사 결정 도움 궁극적으로 보면 합리적인 의사 결정을 목적으로 함측정의 수준과 데이터 종류데이터 수집 방법 통계 조사, 실험, 관찰 등을 통해서 조사 단위나 실험 단위로부터 정해진 측정 방법(측정 도구, 질문지)으로 측정하여 얻음 측정 각각의 조사 단위의 어떤 특성을 일정한 기준에 따라 관측하여 각 조사 단위에 수치를 부여하는 작업 측정 된 전체 자료를 데이터(data)라고 함 ex) 표본으로 뽑힌 사람들의 몸무게, 지능 혹은 취업 상태 등을 관측하여 수치로 나타내는 경우데이터 관련 기본 용어 케이스(case, 레코드) 데이터 세트에서 하나의 조사 단위에 대한 정보의 집합체 변수(variable, 필드) 각 조사 단위로부터 측정 된 개별적인 속성 데이터 조사 및 표현 ex) 어느 단체에서 10명을 표본으로 추출하여 각 사람으로부터 이름, 성별, 나이, 교육 정도, 월 수입(단위 : 만원)을 조사하는 경우 조사 데이터 * 이름 : 홍길동 * 성별 : 남자 * 나이 : 29 * 교육정도 : 고졸 * 월 수입 : 180 * 이름 : 성춘향 * 성별 : 여자 * 나이 : 27 * 교육정도 : 대졸 * 월 수입 : 210 데이터의 행렬 형태 표현 이름 성별 나이 학력 월수입 홍길동 남자 29 고졸 180 성춘향 여자 27 대졸 190 임꺽정 남자 30 . 220 데이터를 행렬 형태로 표시하면 이해하기 쉬움 각 행은 케이스(레코드), 각 열은 변수(필드)가 됨 임꺽정 케이스에서 교육 정도의 “.”는 결측 값을 뜻함측정의 수준 측정 수준에 따라 명목 척도(nominal scale), 순서 척도(ordinal scale), 구간 척도(interval scale), 비율 척도(ratio scale)로 구분함 측정의 척도에 따라서 제공되는 정보의 수준과 데이터 분석에 이용할 수 있는 분석 방법이 달라짐명목 척도(nominal scale : 명명 척도) 측정 대상의 속성을 단순히 분류하거나 확인할 목적으로 수치 부여 단순히 범주 구분이 목적임 수치의 대소 비교, 연산은 의미 없음 ex) 남(1), 여(2) 구분, 운동선수 등 번호, 종교, 지지 정당, 거주지(대도시, 중소 도시, 농어촌) 등순서 척도(ordinal scale : 서열 척도) 어떤 특성을 많고 적음에 따라 수치를 부여함 수치 자체가 어떤 절대적인 수나 양, 크기 등을 나타내지 않고, 서열, 대소 관계의 구분만 의미 있음 ex) 제품이나 서비스의 질을 묻는 질문 아주 좋음(5), 약간 좋음(4), 보통(3), 약간 나쁨(2), 아주 나쁨(1) 구간 척도(interval scale : 등간 척도) 측정 대상을 속성에 따라 서열 화는 물론 서열 간의 간격이 같도록 수치 부여 연속 형 값으로 측정 값의 차이는 의미 있지만, 비(比)는 의미 없음 절대 0을 정의할 수 없고, 임의로 지정된 0만 있음 ex) 섭씨 온도, IQ, 주가지수, 적성 검사 점수 등비율 척도(ratio scale) 구간 척도와 유사하지만 측정 값의 차이 뿐만 아니라 비(比)도 의미 있는 경우 절대 0을 정의할 수 있음 ex) 소득, 체중, 신장, 시간, 방문객 수 등 **데이터의 구분 측정 수준에 따른 구분 질적 변수(qualitative variable) 명목 척도, 서열 척도, 순서 척도로 측정 된 자료 양적 변수(quantitative variable) : 연속 형 변수 구간 척도, 비율 척도로 측정 된 자료 측정 되는 변수의 수에 따른 구분 일변량 데이터 다변량 데이터 데이터의 입력부호화(coding, 코딩) 수집 된 설문지의 응답 결과나 관측 결과 등을 통계적 분석이 가능하도록 일정한 원칙에 따라 각 응답에 숫자를 부여하는 과정 연속 형 변수는 관측된 값이 숫자이기 때문에 그대로 입력 가능 여러 사람이 부호화 작업에 참여할 때는 부호화의 일관성이 유지되도록 부호화 지침서(code book)를 만들어 사용함데이터의 코딩 설계 조사/실험을 통해서 얻은 데이터를 입력할 때 어떻게 입력해야 더 간편하고, 효과적으로 분석할 수 있는 지를 구상하는 것 ex) 지방 자치 제도가 지역 발전에 미친 영향을 살펴보기 위해서 표본 조사를 실시하는 사례 &lt;설문지 예&gt; 1. 지방 자치 제도가 지역 발전에 도움을 준다고 생각하십니까? ( ) ① 많은 도움을 준다. ② 조금 도움을 준다. ③ 별 도움을 주지 못한다. ④ 전혀 도움을 주지 못한다. 2. 지방 자치가 실시된 이후 지역 간의 경제 불균형에 대해 어떻게 생각하십니까? ( ) ① 지역 간 경제 불균형이 해소되고 있다. ② 과거와 별 차이 없다. ③ 지역 간의 불균형이 심화되고 있다. ④ 잘 모르겠다. 3. 당신의 성별은? 남 ( ), 여 ( ) 4. 당신의 나이는 몇 세이십니까? ( ) ① 20세 미만 ② 20-29세 ③ 30-39세 ④ 40-49세 ⑤ 50-59세 ⑥ 60세 이상 5. 당신의 현재 거주지는 어디입니까? ( ) ① 서울시 ② 광역시 ③ 경기/강원 ④ 충북/충남 ⑤ 경북/경남 ⑥ 전북/전남 ⑦ 제주 설문지의 내용 구성 1, 2 문항 - 지방 자치 제도의 역할을 묻는 문항 3, 4, 5 문항- 응답자의 속성을 묻는 문항 질문지에 대한 부호화 지침 설문번호 변수명 영문 변수명 입력열 코드 및 설명   일련번호 ID 1~2   1 지역발전 C1 4 1, 2, 3, 4, 9(무응답) 2 지역경제 C2 6 1, 2, 3, 4, 9(무응답) 3 성별 P1 8 1(남), 2(여), 9(무응답) 4 나이 P2 10 1, 2, 3, 4, 5, 6, 9(무응답) 5 출신지 P3 12 1, 2, 3, 4, 5, 6, 7, 9(무응답) 텍스트 파일 ASCII 코드 형식으로 저장된 파일로 아스키 파일이라고도 함 한글 2018에서 일정한 양식으로 데이터 입력 후, 파일 &gt; 다른 이름으로 저장 &gt; 파일 형식 텍스트 파일로 저장 자유 형식(free format)과 고정 형식(fixed format)으로 구분 자유 형식 변수와 변수 구분은 공란(blank)으로 구분 고정 형식 각 변수가 위치할 열(칼럼)을 정한 후 입력 한글 2018에서 데이터 입력스프레드 시트나 데이터 베이스 파일 엑셀 등에서 간편한 데이터 입력 가능 열은 변수를 나타내고, 행은 케이스를 나타냄SPSS에서 데이터 입력 직접 데이터를 입력하거나 텍스트 파일, 엑셀 파일 등을 읽을 수 있음SAS에서 데이터 입력 SAS 편집기에 데이터를 직접 입력하거나 외부 입력 파일을 읽어옴S-link에서 데이터 입력 직접 S-Link 워크 시트에 데이터를 입력하거나 외부의 텍스트 파일이나 엑셀 파일을 읽을 수 있음데이터의 점검디버깅(debugging) 입력 오류나 또는 조사 상 실수로 인한 오류(bug)를 찾아 수정 할 목적으로 데이터 세트를 검토하고 분석하는 것데이터 입력 오류 점검(데이터가 큰 경우) 각 변수의 입력 범위를 확인하는 방법 변수들 간의 논리적 일관성 여부를 확인하는 방법각 변수의 입력 범위를 확인하는 방법 ex) 응답자의 성별을 나타내는 변수에 대해서 남자(1), 여자(2)로 나타낸 경우 변수 값이 1보다 작거나 2보다 큰 경우가 있다면 입력 과정 상의 오류이거나 응답자의 잘못된 응답 또는 조사원의 실수로 발생하였다고 볼 수 있음 변수들 간의 논리적 일관성 여부를 확인하는 방법 ex) 환자의 성별과 암의 종류 간에 교차 표 작성 구분 위암 간암 폐암 유방암 자궁암 기타 계 남자(1) 8 12 13 0 3 4 40 여자(2) 5 3 4 9 7 2 30 남자는 자궁 암이 발생할 수 없음에도 불구하고 3명의 환자가 자궁 암으로 입원하였음 해당 케이스의 관측 값을 확인하여 환자 성별이나 암 종류에 대한 입력 오류 여부 확인 연습 문제 설문 문항에서 명목 척도에 해당하는 것은? 설문 응답 문항1. 당신의 나이는 몇 세입니까? ( )세 문항2. 당신의 성별은? 1. 남자 2. 여자 문항3. 당신은 현재의 전공에 만족합니까? 1. 매우 만족 2. 약간 만족 3. 약간 불만족 4. 매우 불만족 문항4. 당신의 전공 분야는 무엇입니까? 1. 인문학 2. 사회과학 3. 자연과학 4. 공학 5. 농학 6. 기타 a. 문항 2, 문항4 주어진 설문지를 이용하여 100명의 학생들에게 응답을 얻었다. 데이터의 구성에 대한 올바른 설명은? a. 100개의 케이스와 4개의 변수로 구성된다. 다음의 데이터에 대한 설명 중 올바른 것끼리 짝 지어진 것은? Ⅰ. 데이터는 어떤 관심 주제에 대한 구조화된 정보(information)이다. Ⅱ. 데이터 수집의 대표적인 방법으로는 조사, 실험, 관찰 등을 들 수 있다. Ⅲ. 데이터는 숫자로만 이루어져 있다. a. Ⅰ, Ⅱ 다음 측정 수준에 대한 설명 중 옳지 않은 것은? a. 변수의 측정 수준이 적합한 통계 분석 기법의 선택에 영향을 미치지는 않는다. 측정 수준에 대한 설명으로 옳은 것 명목 척도에서 각 조사 단위에 부여된 숫자는 구분을 목적으로 부여된 기호에 불과하다. 섭씨 온도, 습도, 지능 지수 등은 구간 척도로 측정 된 값이다. 계란을 크기에 따라 대․중․소로 구분하면 순서 척도로 측정 된 것이다. 데이터를 입력한 후, 제대로 입력되었는지 점검하고자 한다. 데이터의 오류를 점검하기 위한 방법이 아닌 것은? a. 설문 항목 중 하나라도 응답하지 않은 경우가 있다면 해당 설문지는 분석에서 제외한다. 데이터 오류를 점검하기 위한 방법 각 변수의 입력 범위를 벗어난 케이스를 확인해 본다. 변수 간의 논리적 연관성을 고려하여 확인한다. 각 케이스를 조사된 설문지와 비교하면서 점검한다. 통계 · 데이터 과학과에 재학 중인 학생들을 대상으로 통계 조사를 실시하였다. 다음에 제시된 변수를 조사하였는데, 이 중 명목 척도로 측정 된 변수는 몇 개인가? a. 2개 " }, { "title": "[파이썬 프로그래밍 기초] 2강 - 컴퓨터의 구성", "url": "/posts/knou-python-2/", "categories": "Language, Python", "tags": "knou, python", "date": "2025-03-13 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '파이썬 프로그래밍 기초' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 사람이 정보를 처리하는 과정과 매우 유사하게 컴퓨터는 데이터를 장치의 내부로 받아들이고 이를 처리하여 장치의 내부로 출력하는 과정을 위해 입력 장치, 연산 장치, 기억 장치, 저장 장치 및 출력 장치라는 다섯 종류의 하드웨어로 구성됨 하드웨어만으로는 정보 처리 역할이 불가능하기 때문에 각 하드웨어가 사용자의 문제해결을 위해 특정 시점에 작동할 수 있도록 지시하고 제어하는 운영 체제 및 응용 소프트웨어와 같은 여러 소프트웨어가 사용됨 각 장치의 개념과 역할에 대해서 구체적으로 살펴보고 소프트웨어의 종류와 역할에 대하여 학습함학습 목표 하드웨어와 소프트웨어의 차이점을 설명할 수 있음 컴퓨터를 구성하는 각 장치에 포함된 기기를 나열할 수 있음 운영 체제의 역할과 기능에 대하여 설명할 수 있음주요 용어 폰 노이만 구조 CPU, 메모리, 프로그램 구조를 갖는 범용 컴퓨터 구조 하드웨어 컴퓨터를 구성하고 있는 물리적으로 존재하는 부품 소프트웨어 다양한 장치들을 동작 시켜 특정 작업을 해결하는 프로그램 강의록하드웨어와 소프트웨어컴퓨터의 구성 요소 하드웨어 컴퓨터를 구성하고 있는 물리적 부품 소프트웨어 다양한 장치들을 동작 시켜 특정 작업을 해결하는 프로그램 알고리즘을 프로그래밍 언어로 구현한 결과물 사람의 문제 해결 과정 어떤 계산을 먼저하고 나중에 해야 하는지 정함 문제 푸는 과정을 먼저 찾고 이후에 문제 풀기 시작하드웨어 기능에 따라 입력 장치, 기억∙저장장치, 제어 장치, 연산장치, 출력 장치로 구분 소프트웨어 각각의 고유한 기능을 수행하는 하드웨어가 언제 어떻게 동작하여 문제를 해결할 수 있는지 지시하는 명령어 집합 응용 소프트웨어 사용자의 업무나 목적에 맞게 문제 해결을 위한 처리 절차를 표현한 명령어 집합 사용자가 특정한 목적을 가지고 컴퓨터를 쓸 때 사용 시스템 소프트웨어 하드웨어를 제어 · 관리하여 응용 소프트웨어를 실행할 수 있는 환경을 제공 실제 애플리케이션 또는 응용 소프트웨어들처럼 사용하는 것은 아니지만 응용 소프트웨어가 실행될 수 있도록 실제 하드웨어 장치를 제어하는 보조적인 기능을 수행 하드웨어의 이해입력 장치 명령과 데이터를 컴퓨터에 전달하는 장치 컴퓨터가 처리할 수 있는 2진수 형태로 변환 입력 장치의 종류 키보드 마우스 스캐너 터치 스크린특수 입력 장치 마이오(myo) 립 모션(leap motion)출력 장치 정보 처리 결과를 인간이 인식 가능한 형태의 데이터로 내보내는 장치 2진수 형태의 데이터를 문자, 숫자, 도형, 음성, 영상 등의 형태로 변환 출력 장치의 종류 모니터 스피커 프린터 초 지향성 스피커 3D 프린터특수 출력 장치 동작 인식 장치 HUD (Head-Up Display) 현실에 대한 정보가 가상에 대한 정보와 같이 들어옴 AR 애플리케이션을 동작하기 위한 장치 HMD (Head-Mounted Display 현실에 대한 정보는 전혀 들어오지 않음 VR 버츄얼 리얼리티 애플리케이션을 활용할 때 사용하는 장치 기억(저장) 장치 명령과 데이터를 기억(저장)하는 하드웨어 역할에 따라 주 기억 장치 보조 기억 장치로 구분 항목 기억장치(주 기억 장치) 저장장치(보조 기억 장치) 접근 속도 빠름 느림 제조 단가 높음 낮음 용량 작음 큼 전원 차단 시 ROM: 기억 내용 보존, RAM: 모든 내용 초기화 기억 내용 보존 기억(저장) 장치의 종류 주 기억 장치 ROM 데이터를 한번 저장하면 바꿀 수 없음 일반적으로 컴퓨터가 부팅하면서 각각의 장치에 명령을 할 때 들어가야 하는 가장 기본적인 데이터만 저장 시킴 바이오스를 저장하기 위한 기억 장치 RAM random access memory 임의로 아무 곳에나 곧바로 접근 가능한 저장 장치 임시적으로 데이터를 저장시켜놓는 기억 장치 컴퓨터 전원이 소실되면 데이터도 같이 소실됨 보조 기억 장치 플로피 디스크 자기 디스크 광학 디스크 플래시 드라이브 플래시 드라이브 제외하고 전기가 차단되어도 정보가 남아있음 전기를 사용하지 않고 다른 방법으로 데이터를 저장 특수 기억(저장) 장치 SSD(Solid State Drvie) RAM을 이용한 저장 장치 빠른 속도, 외부 충격에 강함, 적은 전력 소모가 강점 최근 하드디스크를 대체할 저장 장치로 각광 제어와 연산 장치 현대의 컴퓨터는 제어 장치와 연산 장치가 별도로 구분되어 있지 않음 cpu 내부에 제어와 연산 기능을 모두 수행하는 회로를 가지고 있음 명령어와 데이터를 읽고 데이터를 연산 또는 처리하는 장치 레지스터에서 명령을 읽고 제어 유닛이 ALU에 명령을 내리면 ALU가 레지스터에서 데이터를 가지고 와서 처리 후 다시 레지스터에 저장을 하는 구조 세개의 서브 유닛을 갖추고 있음 레지스터(register) 고속으로 동작하는 메모리 저장 장치 cpu 내부에서 초고속으로 데이터를 저장하거나 읽어냄 cpu 내부에 메모리보다 더 고속으로 동작하면서 두 개의 유닛을 옆에 둠으로써 초고속으로 데이터를 저장하거나 읽을 수 있음 연산 논리 유닛(ALU) 제어 유닛(control unit) 소프트웨어의 이해소프트웨어 고유한 기능을 수행하는 하드웨어가 언제 어떻게 동작하여 문제를 해결할 수 있는지 절차를 지시하는 명령어 집합 응용 소프트웨어 시스템 소프트웨어 시스템 소프트웨어 다양한 장치들을 서로 유기적으로 동작 시켜 특정 작업을 수행할 수 있는 환경을 조성하는 프로그램 운영 체제(커널) 사용자가 컴퓨터를 효율적으로 운영∙관리∙사용할 수 있도록 하드웨어를 제어하는 소프트웨어 컴파일러 소스 코드를 컴퓨터가 이해할 수 있는 기계어로 번역하는 소프트웨어 유틸리티 부가적인 기능을 제공하여 사용자가 컴퓨터를 효율적이고 편리하게 관리할 수 있도록 지원해주는 소프트웨어 ex) 하드 디스크 검사기 운영 체제의 개념 응용 소프트웨어가 효과적으로 작동할 수 있는 환경을 조성 하나의 소프트웨어가 기능하기 위해 함께 작동해야 하는 것들 사용자 작업 A 처리 명령어 시스템 관리 명령어 장치 제어 명령어 공통된 기능 즉 시스템 환경을 관리해주는 역항을 수행하는 소프트웨어 운영 체제 운영 체제 내부 핵심은 커널 운영 체제의 역할 컴퓨터의 자원(하드웨어)을 효율적으로 관리하고 응용 프로그램에 자원을 할당 사용자 인터페이스 프로세스 관리 네트워크 관리 기억 장치 관리 입출력 장치 관리 사용자 인터페이스 컴퓨터와 사용자를 매개하여 상호 작용하는 방법을 제공 CLI(Command Line Interface) GUI(Graphic User Interface) 프로세스 관리 실행되고 있는 상태의 프로그램 여러 프로그램 실행이 요청되면 한정된 자원(기억 장치 등)을 효과적으로 사용하도록 조율 전체적인 프로그램에 효용성을 높여주는 기능 프로세스 보조 기억 장치가 아니라 주 기억 장치로 올라와 곧바로 실행 가능하도록 되어있는 상태의 프로그램 실행되고 있는 상태의 프로그램 프로그램 보조 기억 장치에 저장되어있는 형태 사용자가 프로그램을 시작하려면 입력 장치를 통해 주 기억 장치로 올려야함 → 메모리, 램에 상주해야함 네트워크 인터페이스 컴퓨터는 네트워크를 통해 상호 데이터 교환 응용 프로그램이 통신할 수 있는 환경 제공 및 통신 장치(하드웨어) 관리 Windows - 네트워크 및 인터넷 MacOS - Network 기억∙저장 장치 관리 보조 기억 장치에 저장된 컴퓨터의 프로그램은 실행되기 위해서 주 기억 장치에 적재 주 기억 장치의 크기는 보조 기억 장치의 크기보다 매우 작기 때문에 효율적 관리가 요구 연습 문제 폰 노이만 구조에 기반한 컴퓨터의 구성 요소에 포함되지 않는 것은? a. 판단장치 폰노이만 구조에 기반한 컴퓨터 구성 요소 입력 장치 출력 장치 기억 장치 안경 또는 헬멧과 같은 장치를 머리에 착용하여 현실 세계와는 차단된 가상 현실을 제공하는 장치는? a. HMD 부가적인 기능을 제공하여 사용자가 컴퓨터를 효율적이고 편리하게 관리할 수 있도록 지원해주는 소프트웨어는? a. 유틸리티 학습 정리 컴퓨터는 물리적 장치인 하드웨어와 논리적 장치인 소프트웨어로 구성 일반적으로 하드웨어는 사람이 정보 처리를 하는 역할과 유사하게 입력 장치, 연산 장치, 기억 장치, 출력 장치, 제어 장치로 구분됨 현대의 컴퓨터는 정보와 정보 처리를 위한 프로그램을 내부의 메모리에 저장하고 이를 처리하는 폰 노이만 구조에 기반함 입력 장치는 외부 데이터를 컴퓨터로 전달하는 장치 출력 장치는 입력 장치를 통해 중앙 처리 장치로 들어온 데이터를 처리하고, 그 결과를 표시해 주는 장치 중앙 처리 장치는 연산, 비교, 판단을 수행하는 연산 장치와 명령어를 해석하고 실행하는 제어 장치로 구성됨 주 기억 장치는 컴퓨터에서 처리할 데이터와 프로그램을 기억하고, 처리 결과를 기억하는 장치 보조 기억 장치는 주 기억 장치를 보완하여 컴퓨터 전원이 차단 되었다가 다시 컴퓨터를 켰을 때, 주 기억 장치에 데이터를 불러 올 수 있도록 영구적으로 저장하는 역할을 함 시스템 소프트웨어는 응용 소프트웨어를 실행하기 위한 환경을 제공하고 하드웨어를 제어 · 관리할 수 있도록 설계된 컴퓨터 소프트웨어임 시스템 소프트웨어 종류에는 운영 체제는 사용자가 컴퓨터를 효율적으로 운영 · 관리 · 사용할 수 있도록 하드웨어를 제어하는 운영 체제, 고급 언어로 작성된 프로그램을 컴퓨터가 이해할 수 있는 기계어로 번역해 주는 컴파일러, 그리고 사용자가 컴퓨터를 효율적이고 편리하게 사용할 수 있도록 지원해 유틸리티 등이 있음 운영 체제는 중앙 처리 장치, 주 기억 장치, 보조 기억 장치와 같은 장치로 구성되는 컴퓨터의 하드웨어를 작동 시켜 사용자가 원하는 작업을 처리할 수 있는 환경을 제공하고 컴퓨터와 사용자 사이에 중계 역할을 함" }, { "title": "[Java 프로그래밍] 2강 - JAVA 기본 문법", "url": "/posts/knou-java-2/", "categories": "Language, Java", "tags": "knou, java", "date": "2025-03-12 00:24:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김희천 교수님의 'Java 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 java 언어의 기본 문법과 기본 자료형을 숙지하며 리터럴 사용 방법 익힘 자료형 변환에서 묵시적 변환과 명시적 변환의 차이를 이해 연산자 종류와 각 연산자의 기능 이해 변수의 종류를 용도 별로 구분 선택문과 반복문의 사용 방법 확인학습 목표 java의 기본 자료형 나열 가능 변수의 종류를 나열하고 용도의 차이 설명 가능 연산자의 종류를 나열하고 기능 설명 가능 제어문의 종류와 기능 설명 가능강의록Java 프로그램과 기본 사항Java 프로그램의 작성 성적 처리 프로그램 1 class Grade { int e; //영어 성적을 위한 변수 int m; //수학 성적을 위한 변수 void input_grade(int a, int b) { e = a; //영어 성적 입력 m = b; //수학 성적 입력 } void output_grade() { // 성적의 합을 출력 System.out.println(e+m); } } public class GradeOutput { public static void main(String args[]) { Grade g1, g2; // 성적을 표현하는 객체 g1 = new Grade(); // 객체 생성 g2 = new Grade(); g1.input_grade(90, 85); // 점수 입력 g2.input_grade(80, 80); g1.output_grade(); // 점수 출력 g2.output_grade(); } } 성적 처리 프로그램 2 public class GradeOutput2 { int e; // 영어 성적을 위한 변수 int m; // 수학 성적을 위한 변수 void input_grade(int a, int b) { e = a; // 영어 성적을 입력 m = b; // 수학 성적을 입력 } void output_grade() { // 성적의 합을 출력 System.out.println(e + m); } public static void main(String args[]) { GradeOutput2 g1, g2; // 2명의 성적을 표현 g1 = new GradeOutput2(); // 객체 생성 g2 = new GradeOutput2(); g1.input_grade(90, 85); // 점수 입력 g2.input_grade(80, 80); g1.output_grade(); // 점수 출력 g2.output_grade(); } } 식별자 프로그래머가 작명하는 이름 클래스, 변수, 메소드. 레이블 등의 이름 public class HelloApplication { static String szMsg = \"Hello, Java!\"; public static void main(String args[]) { int nTest = 0; System.out.println(szMsg); } } 식별자 작명 규칙 대소문자 구분 길이에 제한 없음 영 대소문자, 한글, 숫자, _, $ 사용 숫자로 시작할 수 없음 키워드, 예약어(true, false, null) 불가 ex) 2002WorldCup, my#class, class, World Cup, lee@knou 식별자를 만들 때의 관례 클래스 첫 자는 대문자, 단어의 첫 글자는 대문자, 나머지는 소문자 ex) Car, HelloWorld, MyClass, String 메소드, 변수(필드) 위와 같으나 첫 글자가 소문자 ex) speed, myCar, gearArea() 상수 모든 문자를 대문자로 표기하고 단어 사이에 _ 넣어 구분 static final int NUM_GEARS = 6; 변수 자료형을 표시하기 위한 접두어를 붙이기도 함 int nSpeed; String szStr1; 키워드 키워드 abstract assert boolean break byte case catch char class const continue default do double else enum extends final finally float goto if implements import instanceof int interface long native new package private protected public return short static strictfp super switch synchronized this throw throws transient try void volitile while 의미가 미리 정해진 단어 프로그램에서 정해진 의미로만 사용해야 함 자료형변수의 종류와 자료형 변수와 자료형 변수를 선언할 때, 저장되는 값의 자료형 선언 int i; 메소드 선언 시, 파라미터와 반환 값의 자료형 선언 함수에서 반환하는 값이 없을 경우 void사용 자료형에 따라 적용 가능한 연산이 다름 ex) 1 + 3 → 숫자 계산 ex) “a” + “bcd” → 문자열 합치기 변수의 종류 데이터 필드 인스턴스 변수 클래스 정의에서 non-static이 아닌 필드 개별 객체가 소유하는 변수 클래스 변수 클래스 정의에서 static 필드 동종 객체 간 공유 변수(정적 변수) 지역 변수 메소드 내부 또는 블록 내부에서 선언된 변수 파라미터 메소드 호출 시 전달하는 값 저장하기 위한 변수 인자, 매개변수 ex) args 변수의 사용 범위 지역 변수와 파라미터 선언된 곳부터 해당 블록이 종료될 때까지 유효함 메소드가 실행될 때 만들어지고 끝나면 없어짐 지역 변수는 초기 값 지정 후 사용 지역 변수 선언에서 접근 제어자를 사용하지 않음 데이터 필드(인스턴스 변수 or 클래스 변수) 선언된 클래스 내부에서 사용 가능 클래스 외부에서의 사용 가능 여부는 접근 제어자(access modifier)에 따라 다름 class Circle { protected int radius; } Java의 기본 자료형과 키워드 Java의 기본 자료형과 키워드 분류 키워드 길이 (byte) 값의 범위 문자 char 2 \\u0000~ \\uFFFF 논리 boolean 1 true 또는 false 정수 byte 1 -128 ~ 127 정수 short 2 -32768 ~ 32767 정수 int 4 -2^31 ~ 2^31-1 정수 long 8 -2^63 ~ 2^63-1 실수 float 4 (+/-) 약 1.4E-45 ~ 3.4E38 실수 double 8 (+/-) 약 4.9E-324 ~ 1.8E308 리터럴 상수 값이 한번 할당되면, 값을 변경할 수 없는 변수 final int nConst = 3; //선언시 초기 값 지정 리터럴 소스 코드에서 사용되는 실제 데이터 값 정수형 리터럴 byte, short, int 또는 long형의 실제 값 소문자 l이나 대문자L로 끝나면 long형, 나머지는 int byte와 short는 허용 범위 안에서 int와 호환 ex) 26L, 26, 0b11010(2진수), 032(8진수), 0x1a(16진수) 실수형 리터럴 소수점이 있는 숫자 f나 F로 끝나면 float형, 나머지는 double형 ex) 123.4f, 123.4, 1.234e2 문자형 리터럴 1개의 문자를 표현하고 16비트 UNICODE로 인코딩됨 단일 따옴표를 사용하고 Unicode 사용 가능 1개 문자는 (0~65536)의 수와 호환됨 ex) ‘\\u0000’~ ‘\\uFFFF’ ex) (char)65 = ‘A’ = ‘\\u0041’ ex) ‘가’ = ‘\\uAC00’ 참조형 기본형을 제외한 모든 자료형 참조 값(주소 값)을 가지는 자료형 참조형 변수는 객체를 가리키는 변수로 객체의 주소 값(참조 값)을 저장함 실제 객체는 동적 메모리 공간에 저장됨 기본형 변수는 저장 공간에 값 자체를 저장 대표적 참조형은 배열, 클래스, 인터페이스, 열거형 등 int anArray[]; Circle myCircle; String szStr; 자료형의 변환(형변환) 묵시적 자료형의 변환 작은 타입에서 큰 타입으로는 자동 형변환 byte → short → int → long → float → double 개발자 → 직원 → 인간 → 포유류 double d = 5; // 대입문 // 5.0 자동 형변환 되어 대입 System.out.println(\"j=\" + 10); // 수식 // 숫자 10이 문자열 10으로 자동 형변환 double res = Math.sqrt(2); // 메소드 호출 시 인자의 유형 // 2.0으로 자동 형변환 명시적 자료형의 변환 큰 타입에서 작은 타입으로 변환할 때 명시적 형변환 필요 강제적 형변환 문법 : (자료형)피연산자 float f = (float)5.5; // double형 실수 float형 실수로 명시적 형변환 연산자와 제어 문연산자 특정 연산을 수행하기 위한 기호 연산자는 우선 순위가 있으며, 적용 방향이 있음연산자의 종류 연산자의 종류 구분 연산자 예 산술연산자 +-*/%단항연산자 +-++-- 비교연산자 &gt;=~&lt;===!=instanceof 논리연산자 &amp;&amp;\\|\\|단항 !삼항 ?:&amp;\\|^ 비트연산자 비트논리 &amp;\\|^~비트이동 &lt;&lt;&gt;&gt;&gt;&gt;&gt; 대입연산자 +=-=*=/=%=&amp;=^=\\|=&gt;&gt;=&lt;&lt;=&gt;&gt;&gt;= 형변환연산자 (자료형) 기타 [](). 명령 행 매개변수명령 행 매개 변수 프로그램을 실행할 때 전달하는 인자 main()함수에 전달되는 인자 문자열로 전달됨 java CommandInputTest Kim 123 public class CommandInputTest { public static void main(String args[]) { // 매개변수 빈칸으로 구분 System.out.println(args[0]); int n = Integer.parseInt(args[1]); // 문자열을 integer 형식으로 변환 System.out.println(n); } } public class Main { public static void main(String args[]) { System.out.println(args[0] + \", \" + args[1]); } } 문장의 종류 수식 문 수식은 변수, 연산자, 함수 호출 등으로 구성되며, 결과 값을 계산함 대입문, 증가문, 함수 호출문, 객체 생성문 등 a = b; // b의 값을 a에 대입 a++; 변수 선언문 제어 문 선택문, 반복문, 점프문 실행의 흐름 제어 기타 블록문 여러 문장을 중괄호로 묶은 것 {…} 레이블문 레이블:문장 예외처리문 try-catch문 동기화문 synchronized문 제어 문 프로그램의 실행은 기본적으로 위에서 아래로 순차 실행 제어 문은 실행 흐름을 바꿈 제어 문의 종류 선택 문 조건에 따른 문장의 선택 if문, switch문 반복문 조건에 따른 문장의 반복 for문, while문, do-while문 점프 문 분기 문 return문, break문, continue문 선택 문 if문 if (boolean-수식) 문장 if-else문 if (boolean-수식) 문장 else 문장 if와 else의 짝짓기 int a = 2; int b = 2; if (a == 1) \tif (b == 2) \t\tSystem.out.println(\"a was 1 and b was 2.\"); else // if (b == 2)와 짝지어진 else문 \tSystem.out.println(\"a wasn't 1.\"); else는 자기 짝이 없는 가장 가까운 if와 짝을 이룸 public class IfElse { public static void main(String args[]) { int a = 2; int b = 2; if (a == 1) { if (b == 2) { System.out.println(\"a was 1 and b was 2.\"); } } else { // if (b == 2)와 짝지어진 else문 System.out.println(\"a wasn't 1.\"); } } } switch문 switch(n) { case 10 : System.out.println(\"10입니다.\"); break; case 20 : case 30: System.out.println(\"20이거나 30입니다.\"); break; default: System.out.println(\"모르겠습니다.\"); break; } public class SwitchTest { public static void main(String[] args) { int n = 20; switch(n) { case 10 : System.out.println(\"10입니다.\"); break; case 20 : case 30: System.out.println(\"20이거나 30입니다.\"); break; default: System.out.println(\"모르겠습니다.\"); break; } } } 다중 선택 구조 case조건은 정수(long형 제외)와 호환되거나 String값 default는 생략 가능하며, 어떤 case에도 해당되지 않은 경우 매칭됨 만족되는 case를 실행한 후, break문 만날 때까지 계속 실행 반복 문 for-each문 int[] array0fInts = {32, 87, 3, 589, 12, 1076, 2000, 8}; for (int element : array0fInts) { \tSystem.out.print(element + \" \"); } System.out.println(array0fInts); public class ForEachTest { public static void main(String[] args) { int[] array0fInts = {32, 87, 3, 589, 12, 1076, 2000, 8}; for (int element : array0fInts) { System.out.print(element + \" \"); } System.out.println(array0fInts.length); // 32 87 3 589 12 1076 2000 8 } } 개선된 for문 배열이나 컬렉션의 원소들을 차례로 다룰 때 편리 형식 : for( 변수선언 : 배열 ) { 문장 … } 점프 문 break문 break문을 포함하는 가장 가까운 switch문, for문, while문, do-while문의 실행을 끝냄 반복문이나 switch문을 빠져나갈 때 사용 형식 : break; 레이블을 사용하면 특정 블록 또는 특정 반복문을 빠져나갈 수 있음 중첩 for문에서 바깥 for문을 종료하는 경우 형식 : break 레이블; 반복문에 레이블을 지정하려면 레이블: 반복문 continue문 반복문 안에서 사용함 가장 가까이 있는 반복문의 다음 반복을 위한 조건 식으로 즉시 제어를 이동하기 위한 것 형식 : continue; 레이블을 사용하여 특정 반복문의 다음 반복으로 이동할 수 있음 public class Main { public static void main(String args[]) { int nSum = 0; my_loop: for (int i = 1; i &lt;= 10; i++) { if (i % 2 == 0) continue my_loop; nSum += i; } System.out.println(nSum); } } 중첩 for문에서 바깥 for문의 다음 반복으로 갈 때 형식 : continue 레이블;형식 return문 함수 실행 끝날 때 사용 형식 : return; 함수 리턴 값이 존재하지 않을 경우 return 자료형값; 함수 리턴 값이 존재할 경우 학습 정리 java의 기본형을 나타내는 키워드는 byte, short, int, long, float, double, char, boolean 8가지임 변수의 종류로는 인스턴스 변수, 클래스 변수, 지역 변수, 파라미터가 있음 인스턴스 변수는 객체가 소유하는 변수이며, 클래스 변수는 해당 클래스의 객체들이 공유하는 변수 클래스와 배열은 대표적인 참조형으로 ,참조형 변수에는 참조 값(주소 값)이 저장 명령형 매개 변수란 main()함수에 전달되는 인자로서, 프로그램을 실행시킬 때 클래스 이름 뒤에 나열하는 인자를 말함 제어문은 프로그램의 실행 흐름을 제어하는 문장 break문, continue문, return문은 제어문 중 점프 문(분기 문)에 해당연습 문제 다음 중 클래스 이름에 해당하지 않는 것은? a. boolean 클래스 이름 Integer String System 다음 정수 리터럴 중 값이 다른 하나는 무엇인가? a. 0b0000_1010 2진수 10을 의미하는 정수 리터럴, 2진수 10은 10진수 2 모두 10진수 10을 의미하는 정수 리터럴 10 00001010 0x0A 위의 for문을 향상된 for문을 이용해 다시 작성하여라. int[] a = {32, 87, 3, 589, 12 }; for (int i = 0; i &lt; a.length; i++) System.out.print( a[i] + \" \" ); a. 답 int[] a = {32, 87, 3, 589, 12 }; for (int element : a) { System.out.print( element + \" \" ); } " }, { "title": "[운영 체제] 1강 - 운영 체제 소개", "url": "/posts/knou-os-1/", "categories": "OS, Operating System", "tags": "knou, os", "date": "2025-03-12 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김진욱 교수님의 '운영 체제' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 운영 체제는 컴퓨터를 사용하기 위해 반드시 필요한 소프트웨어 중 하나임 컴퓨터가 사용자에게 제공하는 서비스가 다양해지고 편리해지는 만큼 사용자를 위해 컴퓨터 내에서 이루어져야 하는 자원의 관리나 활용이 효율적으로 동작해야 하는데, 운영 체제는 그 근간을 이루는 핵심적인 시스템 소프트웨어임 운영 체제에 대한 전반적인 개요에 대해 알아봄 운영 체제의 정의와 역할을 살펴본 후, 운영 체제를 구성하는 기본적 요소인 프로세스 관리자, 메모리 관리자, 장치 관리자, 파일 관리자의 역할에 대해 개략적으로 학습함 운영 체제의 유형에 대해 살펴봄학습 목표 운영 체제의 개념과 역할을 설명할 수 있음 운영 체제의 구성을 설명할 수 있음 운영 체제의 유형을 설명할 수 있음강의록운영 체제란컴퓨터 하드웨어 CPU, 메모리, 저장 장치, 입출력 장치, 네트워크 장치 등 소프트웨어 웹 브라우저, viewer, ppt 등 문서프로그램, 컴파일러 등 컴퓨터 시스템의 구성 응용 소프트웨어 사용자가 직접 다루는 소프트웨어 시스템 소프트웨어 하드웨어와 응용 소프트웨어 사이의 매개체 역할을 하는 소프트웨어 운영 체제, 컴파일러 등 하드웨어 관리 운영 체제 대표적인 시스템 소프트웨어 컴퓨터 시스템의 자원을 관리하고 컴퓨터 프로그램이 동작하기 위한 서비스를 제공하는 프로그램들의 모음 운영 체제의 역할 컴퓨터 시스템의 자원 관리 자원 하드웨어 자원 소프트웨어 자원 데이터 ex) 저장장치에서 데이터 읽어오기 키보드나 마우스 제어 프로그램 동시 실행 시 CPU와 메모리를 효율적으로 관리 컴퓨터 시스템을 효율적으로 운영하는 목적 사용자 지원 사용자가 내린 명령을 해석하여 실행하게 함 사용자와 하드웨어 사이의 매개체 역할 사용자에게 편의성을 제공하는 목적 컴퓨터 시스템과 운영 체제 운영 체제가 없던 초기의 컴퓨터 시스템 응용 프로그램이 직접 컴퓨터 시스템의 자원 제어 응용 프로그램 개발자는 하드웨어 제어 방법을 잘 알아야 함 여러 사용자가 하드웨어를 공유하는 경우 자원 분할 어려움 운영 체제가 있는 컴퓨터 시스템 하드웨어와 응용 프로그램 사이에 운영 체제 위치 운영 체제가 컴퓨터 시스템의 자원 제어 컴퓨터 시스템이 안정적이고 효율적으로 동작하도록 함 커널 모드와 사용자 모드 커널 모드(슈퍼바이저 모드) 하드웨어를 직접 제어할 수 있는 CPU 명령어를 사용할 수 있는 모드 운영 체제의 커널이 동작함 사용자 모드(보호 모드) 하드웨어를 직접 제어할 수 있는 CPU 명령어를 사용할 수 없는 모드 응용 프로그램이 동작함 시스템 호출 응용프로그램이 하드웨어에 대한 제어가 필요한 경우 이용 운영 체제의 서비스를 요청하는 메커니즘 커널모드와 사용자 모드가 변화되면서 일을 처리 커널 커널(kernel) 커널 모드에서 동작하는 운영 체제의 핵심 요소 응용 프로그램과 하드웨어 수준의 처리 사이의 가교 역할 구성 방식 일체형 커널, 마이크로 커널 일체형 커널(monolithic kernel) 운영 체제의 모든 서비스가 커널 내에 포함됨 커널 = 운영 체제 장점 커널 내부 요소들이 서로 효율적으로 상호작용을 함 단점 한 요소라도 오류가 발생하면 시스템 전체에 장애 발생 가능 ex) UNIX, Linux 마이크로커널(microkernel) 운영 체제 요소의 대부분을 커널 외부로 분리 메모리 관리, 멀티태스킹, 프로세스 간 통신(IPC) 등 최소한의 요소만 커널 내에 남김 장점 새로운 서비스를 추가하여 운영 체제를 확장하기 쉬움 유지 보수가 용이하여 안정성이 우수함 단점 커널 외부 요소들 사이는 IPC가 필요하여 성능 저하 발생 운영 체제의 구성운영 체제의 구성 컴퓨터 시스템의 자원 성격에 따라 구분 프로세스 관리자 프로그램 실행 및 스케줄링 관리 메모리 관리자 RAM과 저장장치의 효율적 사용 관리 파일 관리자 파일 시스템을 관리하고 접근 권한 제어 장치 관리자 키보드, 마우스, 프린터 등 입출력 장치 관리 프로세스 관리자 프로세스의 생성 및 삭제 CPU 할당을 위한 스케줄 결정 프로세스의 상태를 관리하며 상태 전이 처리메모리 관리자 메모리(주기억 장치) 공간에 대한 요구의 유효성 확인 메모리 할당 및 회수 메모리 공간 보호장치 관리자 컴퓨터 시스템의 모든 장치 관리 시스템 장치의 할당, 작동, 반환파일 관리자 컴퓨터 시스템의 모든 파일 관리 저장 장치의 공간 관리 파일의 접근 제한 관리운영 체제의 유형운영 체제의 유형 일괄처리 운영 체제 시 분할 운영 체제 실시간 운영 체제 분산 운영 체제일괄 처리 운영 체제 Batch Processing 작업을 모아서 순차적으로 처리하는 방식 사람(오퍼레이터)이 하던 일을 프로그램이 빠르게 처리하게 되면서 전체적인 작업 처리 속도가 향상됨 나중에 들어온 작업은 앞선 작업들이 모두 끝날 때까지 아무런 상호 작용 없이 기다려야만 함시 분할 운영 체제 (Time-Sharing) 각 사용자의 프로그램을 한 번에 조금씩 수행하는 방식 대화형(interactive) 운영 체제라고도 함 사용자들은 마치 혼자 컴퓨터를 사용하는 듯한 느낌을 받음 응답 시간이 일괄처리 운영 체제보다 크게 단축됨 응답 시간 (Response Time) 요청한 시점부터 반응이 시작되는 시점까지의 소요 시간 실시간 운영 체제 Real-Time 원하는 시간 내에 프로그램의 결과를 얻을 수 있는 방식 처리 결과가 현재의 결정에 영향을 주는 환경에서 사용됨 ex) 미사일 제어 시스템, 증권 거래 시스템 중요한 작업에 대한 처리 기한을 맞추는 것이 중요 우선 순위가 높은 작업을 우선 처리할 수 있는 기법 활용 분산 운영 체제 분산 시스템을 관리하기 위한 운영 체제 분산 시스템 2개 이상의 컴퓨터 시스템이 네트워크로 서로 연결되어 서로의 자원을 이용하는 시스템 다른 컴퓨터 시스템의 자원을 이용하는 것이 마치 자신의 컴퓨터 시스템에 있는 자원을 이용하는 것처럼 가능해야 함정리 하기 운영 체제는 컴퓨터 시스템의 자원을 관리하고 컴퓨터 프로그램이 동작하기 위한 서비스를 제공하는 프로그램들의 모습으로 대표적인 시스템 소프트웨어임 커널 모드는 하드웨어를 직접 제어할 수 있는 CPU의 명령어를 사용할 수 있는 모드 사용자 모드는 하드웨어를 직접 제어할 수 있는 CPU의 명령어를 사용할 수 없는 모드 응용 프로그램은 사용자 모드에서 동작하기에, 하드웨어에 대한 제어가 필요한 경우 시스템 호출을 통해 필요한 서비스를 운영 체제에 요청해야 함 운영 체제의 주요 구성 요소에는 프로세스 관리자, 메모리 관리자, 장치 관리자, 파일 관리자가 있음 운영 체제의 대표적인 유형으로는 일괄처리 운영 체제, 시 분할 운영 체제, 실시간 운영 체제, 분산 운영 체제가 있음" }, { "title": "[데이터베이스 시스템] 1강 - 데이터의 이해", "url": "/posts/knou-dbs-1/", "categories": "Database", "tags": "knou, database", "date": "2025-03-10 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '데이터베이스 시스템' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 실세계의 방대한 데이터를 효과적으로 처리하기 위해서는 데이터베이스 응용이 필수적임 최근 데이터 생성과 관련된 기술의 등장으로 데이터를 관리하고 효과적으로 사용하기 위한 데이터베이스의 역할이 더욱 중요해지고 있음 따라서 데이터베이스의 기본적인 특징 및 구조에 대한 이해가 반드시 선행되어야 함 데이터베이스란 무엇이며, 기존 파일 처리 시스템과는 어떤 차이점이 있는지 알아보고, 데이터 모델, 데이터베이스 3단계 구조 등 데이터베이스의 특징과 장단점을 학습함 데이터베이스 사용자 유형에 따른 역할과 데이터베이스의 구조 등 데이터베이스와 관련한 전반적인 개념을 학습함학습 목표 파일 처리 시스템과 데이터베이스 시스템의 차이점을 설명할 수 있음 데이터베이스의 특징을 이해할 수 있음 데이터베이스 시스템의 구성 요소를 나열할 수 있음주요 용어 파일 처리 시스템 파일을 사용하여 업무에 해당하는 데이터를 관리하는 방식 데이터베이스 관리 시스템(DBMS) 정보를 데이터베이스에 저장·관리하여 사용자에게 요구된 형태의 정보로 제공하는 컴퓨터 기반 시스템 DBMS 3단계 구조 데이터 추상화와 데이터 독립성을 확보하기 위한 개념적-논리적-물리적 3단계 구조 트랜잭션 하나의 논리적인 작업을 수행하는 일련의 데이터베이스 명령의 집합 강의록데이터베이스의 역할사회 트렌드의 변화 쌓인 데이터들과 다양한 서비스를 연결 시킨 데이터베이스 시스템이 있어야 서비스 가능 데이터 생성 시간이 갈 수록 데이터가 빠르게 쌓이고 있음 데이터 단위 bit 컴퓨터가 데이터를 처리하는 가장 작은 단위 0과 1 byte bit가 8개 모인 데이터 단위 사람이 쓰기 위한 데이터 최소한의 단위 ex) 영문자 한단어 KB 1024 byte ex) 신문 기사 하나 분량 MB 1024 KB ex) 신문, 잡지 하나 GB 1024 MB ex) 저화질 영화 한편 TB 1024 GB PB 1024 TB ex) 신문 기사 하나 분량 EB 1024 PB ex) 하나의 it 공용 기업이 전체적으로 처리하는 데이터 단위 ZB 1024 EB 데이터 처리 데이터 수집, 저장, 분석 단계 판단하기 위해 필요한 정보 만들어낼 수 있음 데이터 관리 대량의 데이터를 저장 및 관리하고 필요한 데이터를 신속히 검색할 수 있도록 보조하는 장치에 대한 요구 증가 데이터베이스 발생된 데이터 저장하고 필요한 데이터 빠르게 검색해서 제공해주는 장치 한 조직의 여러 응용 시스템을 다수의 사용자가 공용으로 사용하기 위해 통합, 저장, 관리하는 장치 컴퓨터는 사람과 동일한 방식으로 데이터를 검색, 처리함 각각의 데이터가 조건에 맞는 것인지 일일이 체크 후 사용자에게 제공하기 때문에 많은 시간이 소요됨 데이터 관리의 역사전통적 데이터 관리 방식 파일 처리 시스템(file processing system) 각각의 애플리케이션이 별도의 파일들을 만들어 저장, 관리함 파일 처리 시스템 데이터베이스가 개발되기 전 데이터 관리에 사용 업무별 애플리케이션에서 사용하는 데이터를 개별 데이터 파일에 저장, 관리하는 시스템 발생 가능한 문제 데이터 종속의 문제 데이터 중복의 문제 무결성 훼손의 문제 동시 접근의 문제 데이터 종속의 문제 저장된 데이터가 특정 H/W에서 또는 특정 사용자 및 S/W에서만 사용될 수 있도록 제한되는 문제 물리적 데이터 종속 약간의 물리적 변화에도 동작하지 않을 수 있음 논리적 데이터 종속 데이터 기록 순서, 방법이나 형태, 인코딩 변경 될 경우에도 동작하지 않을 수 있음 데이터 중복의 문제 동일한 사항에 대한 중복된 데이터는 일관성, 보안성, 경제성 측면에서 문제 발생의 원인 일관성 한 사살에 대해 한개의 데이터 값을 유지 보안성 같은 데이터에 같은 수준의 보안 유지 경제성 데이터에 대해 최소한의 저장 공간만을 점유 무결성 훼손의 문제 실 세계의 데이터는 데이터가 가질 수 있는 가능 범위(제약 조건)를 포함 ex) 데이터 : 홍길동의 수강 학점 ex) 가능 범위 : 한 학기 최대 수강 학점 18학점 데이터 무결성의 정의 데이터 정확성을 보장 데이터의 값과 값에 대한 제약 조건을 동시에 만족 파일 처리 시스템은 데이터 무결성을 보장하기 위한 기능을 제공하지 않음 데이터의 신뢰성이 저하됨 동시 접근의 문제 동일 데이터에 다수 사용자의 접근 허용 시 일관성이 훼손 데이터베이스의 특징데이터베이스 사용 의미 애플리케이션이 파일에 직접적으로 접근하지 못하도록 함 애플리케이션의 요청을 받아 관리하며 파일에 각각 접근하여 애플리케이션에 전달 데이터 사용, 관리하는 영역 분리데이터베이스의 특징 데이터베이스 시스템의 자기 기술성 데이터와 데이터의 정의 및 설명(메타 데이터)를 포함 자기가 저장하고 있는 데이터가 무엇인지 명확하게 알고 있음 프로그램 데이터의 격리 및 추상화 사용자에게 데이터에 대한 개념적인 표현을 제공하여 접근성을 향상 다중 뷰 제공 각 사용자가 관심을 갖는 데이터베이스의 일부만을 표현할 수 있는 기능 제공 데이터 공유와 다수 사용자 트랜잭션 처리 다수의 데이터 조작 요청을 동시성 제어 기능을 통해 데이터의 일관성을 보장하면서 동시에 작업 수행 데이터베이스 시스템의 구성 시스템 카탈로그 데이터에 관련된 여러가지 사항들을 저장하고 있는 메타 데이터의 집합 저장한 데이터의 의미 등을 관리해주는 집합 DBMS가 자동적으로 관리해주는 정보 값, 데이터 그리고 메타 데이터 메타 데이터 값에 의미를 부여하는 또 다른 개념이 2개 이상 붙을 경우 그 값을 메타 데이터라 함 값, 그리고 메타 데이터가 함께 관리되어야 데이터의 역할을 수행할 수 있음DBMS의 3단계 구조 어떠한 데이터를 저장할 때 DBMS가 3단계의 구조로 나눠서 저장함 서로 다른 정보의 수준을 다루는 세 개의 정보 집합 외부 스키마 사용자 별 접근 권한에 따라 뷰 제공 개념 스키마 데이터 베이스의 전체 구조와 각각의 관계 내부 스키마 물리적으로 어떻게 저장되어있는가? 개념, 내부 사상 통해 물리적 데이터 종속 피할 수 있음 외부, 개념 사상 통해 논리적 데이터 종속 해결 외부 단계 사용자가 직접적으로 볼 수 있음 개념 단계 데이터의 구조 형식을 볼 수 있음 내부 단계 데이터가 물리적으로 어떻게 저장되어 있는지 다룸 다수 사용자 트랜잭션 처리 트랜잭션의 정의 하나의 논리적 작업을 처리하기 위한 일련의 데이터베이스 명령의 집합 데이터베이스 관련 용어 데이터(data) 어떠한 사실에 대한 정량적, 정성적 특징을 나타낼 수 있는 값과 값에 대한 설명 데이터베이스(datbase) 특정 기관의 애플리케이션 시스템에서 사용되는 데이터의 집합 특정 목적에 맞춰 관리되는, 집합화 된 데이터 주제 지향적인 데이터의 집합 데이터베이스 관리 시스템(DBMS) 데이터베이스에 저장된 데이터의 구성, 저장, 관리 사용을 위한 소프트웨어 패키지 데이터베이스 시스템(database system) 정보를 데이터베이스에 저장, 관리하여 사용자에게 요구된 형태의 정보로 제공하는 컴퓨터 기반 시스템 데이터베이스 시스템 구성 요소데이터베이스 언어 DBMS 는 사용자가 데이터를 쉽게 사용하고 다룰 수 있도록 언어 형태의 인터페이스를 제공 정확한 결과를 위해서는 부탁도 명확히 해야 함 역할에 따라 종류의 언어로 구분 데이터 정의 언어(DDL) 데이터 조작 언어(DML) 현대의 데이터베이스 언어는 자연어와 유사한 형태의 SQL로 표준화데이터 정의 언어 DDL(Data Definition Language) 데이터베이스 객체를 생성, 수정, 삭제하기 위한 언어 DDL의 요구 기능 데이터 모델에 따라 애플리케이션 프로그램이 요구하는 데이터의 논리적 구성이나 특징을 규정 데이터가 저장장치에 저장되도록 데이터의 물리적 구성을 규정 물리적 구성을 논리적 구성으로 변환이 가능하도록 데이터의 물리적 구성과 논리적 구성 간의 사상을 규정 데이터 조작 언어 DML(Data Manipulation Language) 구조화된 데이터에 사용자가 접근 및 조작할 수 있도록 지원하는 언어(검색, 삽입, 삭제, 수정) DML의 요구 조건 데이터 조작이 쉽고 간편 데이터 조작 기능이 정확하고 완전 사용자의 요청을 시스템 내부에서 효율적으로 처리 가능 데이터베이스 시스템 아키텍처 아키텍처 (architecture) 전체적인 구조, 골조 데이터를 관리하는 DBMS 서버와 DBMS 에 접근해 데이터를 사용하는 애플리케이션으로 구성 서버와 애플리케이션 구조, 관계를 정의 중앙 집중 방식 단일 서버가 다수의 터미널을 대신하여 데이터 처리 중앙 서버의 과부하로 전체적인 성능 저하 dbms 서버가 데이터의 전반적인, 모든 관리와 처리 담당 구성 간편해 비용 저렴하게 데이터베이스 시스템 구축 가능 클라이언트-서버(분산 처리) 방식 클라이언트의 성능 향상으로 자체적인 처리 능력 보유 애플리케이션 프로그램의 부하를 분산 소프트웨어의 유지 보수 비용을 절감 및 이식성 증가 2 계층 구조 서버와 클라이언트가 논리적으로 분리되어 있는 상태에서 연결되어 데이터베이스 시스템을 구성하는 방식 3 계층 구조 작업에 변화가 있더라도 단순히 애플리케이션 서버를 변경함으로써 유연하게 변화에 대응 가능 데이터베이스 시스템 설계 복잡하고 중앙 집중 방식보다 구축 비용 증가 연습 문제 다음 중 파일 처리 시스템의 데이터 중복으로 발생할 수 있는 문제가 아닌 것은? a. 통일성 파일 처리 시스템은 데이터 중복을 방지할 수 없으며, 이로 인에 데이터의 보안성, 경제성, 일관성 측면에서 문제가 발생함 데이터베이스 3단계 구조에서 논리적 데이터 독립성이 확보되는 과정은? a. 외부-개념 사상 DBMS는 데이터의 추상화를 위해 외부-개념-내부 3단계로 구조화되며, 외부-개념 사상 과정에서 논리적 데이터 독립성, 개념-내부 사상을 통해 물리적 데이터 독립성이 확보됨 구조화된 데이터에 사용자가 데이터를 삽입 · 수정 · 삭제하고 저장된 데이터를 검색할 수 있도록 지원하는 데이터베이스 언어는? a. 데이터 조작 언어, DML(Data Manipulation Language) DBMS 인터페이스인 데이터베이스 언어는 데이터 조작 언어와 데이터 정의 언어로 구분되며, 이 중 데이터 조작 언어(DML)는 데이터 정의 언어로 구조화된 데이터에서 다양한 유형의 데이터 조작을 지원하는 명령어로 구성됨 정리 하기 기존 전산 시스템, 스마트 기기, 소셜 미디어, IoT 센서 등 사회 트렌드의 변화로 대량의 데이터가 저장 및 활용되고 있어 데이터 관리가 점차 중요해지고 있음 파일 처리 시스템은 프로그램이 직접 데이터에 접근하여 데이터를 저장 및 사용하는 데이터의 중복성, 데이터의 종속성, 데이터의 무결성 훼손, 그리고 동시 접근 이상의 문제점을 내포함 데이터베이스는 파일 처리 시스템과 달리 자기 기술성, 추상화, 다중 뷰, 동시성 제어 등의 기능을 통해 파일 처리 시스템의 문제점을 극복함 데이터베이스 시스템은 3단계 구조, 즉 외부 단계, 개념 단계 그리고 내부 단계로 구성됨 외부 단계는 사용자 뷰를 나타냄 개념 단계는 데이터베이스의 논리적인 전체 구조를 나타냄 내부 단계는 데이터가 기억 장소에 저장되기 위한 물리적 구조를 정의함 각 단계 간의 접속에서 특정 외부 스키마와 개념 스키마 간의 대응 관계를 정의한 외부-개념 사상과, 개념 스키마와 내부 스키마 간의 대응 관계를 정의한 개념-내부 사상에 의해 연관성을 갖음 데이터베이스 언어란 데이베이스 사용을 위한 언어 형태의 인터페이스로 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)로 구성됨 DBMS는 전체 시스템을 구성하는 방식에 따라 중앙집중식과 분산 시스템 방식으로 아키텍처를 구성할 수 있음체크 포인트 시스템 카탈로그에 대한 설명으로 틀린 것은? a. 시스템 카탈로그에 대한 갱신은 데이터베이스의 무결성 유지를 위하여 사용자가 직접 갱신해야 한다. 시스템 카탈로그에 대한 설명 시스템 카탈로그는 DBMS가 생성하고 유지하는 데이터베이스 내의 특별한 테이블의 집합체임 테이블 데이터베이스가 데이터를 저장하기 위한 가장 기본적인 집합체, 구조 시스템 카탈로그 내의 각 테이블은 DBMS에서 지원하는 개체들에 관한 정보를 포함함 일반 사용자도 시스템 카탈로그의 내용을 검색할 수 있음 다음 설명에 해당하는 것은? 물리적 저장 장치의 입장에서 본 데이터 베이스 구조로서 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타낸다. a. 내부 스키마 " }, { "title": "[유비쿼터스 컴퓨팅 개론] 1강 - 유비쿼터스 혁명", "url": "/posts/knou-uqc-1/", "categories": "Computer Science, CS Theory", "tags": "knou, ubiquitous computing", "date": "2025-03-07 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정광식 교수님의 '유비쿼터스 컴퓨팅 개론' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 유비쿼터스 컴퓨팅 기술로 구축될 수 있는 유비쿼터스 공간을 기존의 사이버공간(전자 공간)과 구분하여 이해함 유비쿼터스 환경에서 ICT가 가지는 역할과 발전 방향에 대해서 공부함학습 목표 유비쿼터스 공간을 물리 공간과 전자 공간의 유기적 공간으로 이해할 수 있음 물리적 속성과 전자적 속성간의 상호 작용이 긴밀한 유비쿼터스 공간의 특성을 이해할 수 있음 유비쿼터스 공간의 구현을 위한 전자 공간과 물리 공간의 연계를 이해할 수 있음강의록공간의 발전 역사 도시 혁명 → 산업 혁명 → 인터넷 혁명 → 유비쿼터스 혁명 인터넷 혁명 → 유비쿼터스 혁명 컴퓨팅 측면에서의 기술적 점프 발생 기술에서 서비스가 만들어지며 서비스가 새로운 공간을 만들고 공간들이 사회로 확장되거나 환경으로 확장됨 소비와 생산이 모여있는 한정된 공간에서 함께 이루어짐 → 여러가지 편리함과 효율성 갖춤 유비쿼터스 컴퓨팅이 유비쿼터스 혁명을 만들어내고 새로운 형태의 사회와 환경을 만들어냄 도시 혁명 대규모의 도시 사회를 기반으로 복합적인 사회 서비스를 제공하는 사회 구조 사회적 거리와 시간을 줄이기 위한 측면의 발전산업 혁명 생산의 기계화를 통해 대량 생산과 대량 소비를 기반으로 하는 산업 구조 및 사회 구조 운송 수단의 발달로 인한 물리적 이동 범위의 확대 및 소식과 정보의 유통이 가능해짐인터넷 혁명 정보 기술의 발달로 인한 인터넷과 웹 서비스의 탄생 단순히 전선으로 연결된 통신 네트워크 개념을 초월하여 사람과 사람, 관계와 관계를 통해 사회/경제적 활동을 수행할 수 있는 실제적 공간으로서 전자 공간을 탄생 시킴 인터넷을 기반으로 하는 전자 통신 기술이 발전하면서 생활의 기반을 전자 공간으로 이동 시킴 인터넷을 기반으로 하는 전자 공간은 접근성과 활용성이 뛰어남 반면, 물리 공간(현실 공간)과 전자 공간(사이버 공간)의 분리 현상 발생 물리 공간과 전자 공간의 격차를 좁히면 물리적인 이동, 시간적인 격차를 줄일 수 있고 누구나 서비스를 받을 수 있어 편리해짐 유비쿼터스 환경 언제, 어디서나, 어떠한 통신 단말기를 가지고, 어느 정보통신망을 통해서든, 원하는 정보통신 서비스를 받을 수 있는 환경유비쿼터스 혁명 서로 이질적인 물리 공간(제1공간)과 전자 공간(제2공간)이 제3의 가치 공간인 유비쿼터스 공간으로 통합/진화됨 모든 사물들이 통신을 통해 자기가 데이터를 받거나 생산해서 전송할 수도 있게 되는 상황 사물에 대한 추적 가능, 사물과 통신 가능, 사물 제어 가능해지기 때문에 여러가지 서비스 제공 받을 수 있음 사람-컴퓨터-사물이 하나로 연결되어 기능적이며 유기적으로 최적화된 증강 현실(Augmented Reality) 공간을 지향하는 공간 혁명유비쿼터스 컴퓨팅 기존의 컴퓨팅 시스템이 컴퓨터 중심적인 것을 비판하며, 1991년 마크 와이저가 사람 중심의 사람-사물-컴퓨터 간의 연계를 위한 차세대 컴퓨팅 환경으로 유비쿼터스 컴퓨팅 개념을 주장 물리 공간과 전자 공간과 유비쿼터스 공간물리 공간(Physical Space) 실제 세상과 사물 같은 만질 수 있는 공간 물리 공간에서 기능을 갖는 사물은 용도가 정해진 공간에 놓여짐 ex) 놀이 공간과 놀이 시설 물리 공간에서의 사물은 만지거나 보면서 지각 가능전자 공간(Electronic Space) 전자를 기반으로 하여 만질 수 없는 공간 논리적으로만 존재하는 가상적 공간 인터넷과 웹 서비스 같은 전자적 요소로 구성됨 실제의 공간적 위치와 상관없이 통신 네트워크에서 관리되는 통신 프로토콜을 사용하여 연결되고 위치를 결정함유비쿼터스 공간(Ubiquitous Space) 공간 구성 요소로서 원자와 비트가 연계되어 형성됨 물리와 전자가 연계 만지지 않아도 공간에 존재하거나 공간에 관한 정보를 사용자가 알 수 있는 현실체가 지능적으로 증강된 공간으로 인식됨 무한하게 많은 사람들과 사물들에 주소를 부여할 수 있게 됨으로써 물리 공간이나 전자 공간이 갖는 주소 체계의 한계를 뛰어넘을 수 있게 됨 특정한 기능이 내재된 컴퓨터가 특정한 장소와 사물에 내재됨 (embedded computing)으로써, 사물이 지능화 되거나 네트워크화 되는 공간 사물의 일부로서 사물 속에 심어진 컴퓨터들은 주변 공간의 상황을 인식할 수 있게 됨 공간 속에서 주변 환경과 사물들의 변화를 떨어진 거리에서도 지각, 추적, 감시할 수도 있게 됨 사물 속에 내재된 컴퓨터들은 주변의 사물들 속에 내재된 컴퓨터들과 무선 네트워크(IoT)로 연결되어 있어 사람이 인식하지 못하는 상황에서 의사 소통을 할 수도 있음 사용자가 들고 다니는 다양한 형태의 단말기에 실시간으로 가장 유용한 정보를 제공하거나 필요한 의사 결정을 내려줄 수도 있음 물리 공간과 전자 공간이 최적으로 연계, 통합된 기능을 형성하고 서비스를 제공할 수 있는 지능적인 공간물리 - 전자 - 유비쿼터스 공간의 비교 구분 물리 공간 전자 공간 유비쿼터스 공간 공간 지각 만질 수 있는 공간 만질 수 없는 공간 만지지 않아도 지각 가능한 공간 공간 구성 (소비 방식) 토지 + 사물 (소유) 인터넷 + 웹 (접속) 유비쿼터스 네트워크 + 지능화된 환경 + 사물 기능 형성 물리 공간에 사물이 심어짐 전자 공간에 가상 사물이 심어짐 유비쿼터스 기술이 사물에 내재됨 기반 네트워크 도로망, 철도망 인터넷 및 통신 네트워크 사물과 사물을 연결하는 유비쿼터스 네트워크 공간 개발 기술 토목, 건축 IT(컴퓨터 + 통신 + 방송 융합) IT + NT + BT 융합 산업 경제 유형의 1 · 2 · 3차 산업 (부동산, 제조업 등 물질 재화) 정보의 가공 및 전달을 통한 산업(정보 재화) 환경 및 사물에 대한 식별 · 인식 · 추적에 관한 전방위 공간 산업(공간 재화) 전자 공간과 물리 공간의 연계전자 공간과 물리 공간의 연계에 대한 시각 (I) 증강 된 상호 작용 또는 증강 현실을 전자 공간과 물리 공간의 연계로 보는 시각 유비쿼터스 컴퓨팅 개념을 토대로 하는 접근 방법 (I) 물리 공간의 사물 이미지를 해석하여 사용자의 주변을 분석하고 주위의 특정 사물의 존재를 컴퓨터가 인식할 수 있도록 함 전자 공간과 물리 공간 간의 연계를 위한 비디오 중심의 분석 유전자 공간과 물리 공간의 연계에 대한 시각 (II) 사람(유비쿼터스 컴퓨팅 개념)을 중신으로 하는 시각 유비쿼터스 컴퓨팅 개념을 토대로 하는 접근 방법 (II) 다양한 컴퓨터 (칩, 센서, 태그, 구동체 등)를 사물 속에 심고 이들을 네트워크로 연결하여 물리 공간의 상황을 사물과 사물, 사물과 컴퓨터, 컴퓨터와 사물 간의 지능적인 상호 작용을 통해 유비쿼터스 공간 (전자 공간-물리 공간)으로 인식함 사물-컴퓨터-사람이 네트워크로 연결되어 의사소통하며, 물리 공간에서의 상황을 지각, 추적, 감시, 구동하는 데 있음유비쿼터스 환경 사물-컴퓨터-사람의 네트워크 연결 사물-컴퓨터-사람의 연결은 물리 공간 (사물)에 내재된 센서, 칩, 태그들이전자 공간상의 정보통신 서비스를 제공하는 컴퓨터와 통신 네트워크로 연결되어야 함 사물의 인식 물리 공간의 사물 속에 심어져 있는 센서, 칩, 태그와 구동체들은 전자 공간에서 서비스 제공에 필요한 물리적 속성 (ID, 유일 이름 등)과 물리적 상태 (속도, 기울기 등)를 가지고 통신 및 구동할 수 있어야 함 물리적 속성과 전자적 속성 간의 연계 차원 특정 물리적 객체(사물, 도로, 건물 등)의 상태는 전자적 객체(Web, Java, XML, Physical Markup Language)와 상호 작용할 수 있어야 함 유비쿼터스 환경 물리 공간의 사물(센서/칩/태그), 전자 공간의 컴퓨터, 양쪽에 존재하는 사람 간의 제한 없는 통신 네트워크를 기반으로 하며, 물리 공간에 존재하는 장소, 사물, 사람의 물리적 속성에 대한 인식이 가능하고, 이러한 물리적 속성과 전자 공간 상의 전자적 속성이 양방향으로 상호 작용할 수 있는 기능 중심의 환경 정리 하기 물리 공간 우리가 살고 있는 실제 공간 전자 공간 논리적으로만 존재하는 가상 공간 유비쿼터스 공간 현실체가 지능적으로 증강된 공간 연습 문제 물리 공간과 전자 공간을 유기적으로 융합한 것을 무엇이라고 하는가 ?  a. 유비쿼터스 공간 물리 공간과 전자 공간의 연계를 위한 관점에 포함되지 않는 것은 무엇인가 ?  a. 인공 지능 기반의 전자 기반 관점에 포함 되는 것 사물- 컴퓨터 - 사람의 네트워크 연결 사물의 인식 물리적 속성과 전자적 특성 간의 연계 전자 공간과 물리 공간의 연계는 “물리 공간의 (가), 전자 공간의 (나), 양쪽에 존재하는 (다)간의 제한 없는 통신 네트워크를 기반으로 하며, 물리 공간에 존재하는 장소, 사물, 사람의 물리적 속성에 대한 인식이 가능하고, 이러한 물리적 속성과 전자 공간 상의 전자적 속성이 양방향으로 상호 작용할 수 있는 기능 중심의 환경”이라고 정의할 수 있으며, 이러한 환경을 유비쿼터스 환경이라고 한다. 위 내용의 빈칸에 알맞은 것은? a. 사물(센서/칩/태그), 컴퓨터, 사람 정리 하기 유비쿼터스 환경은 언제, 어디서나, 어떠한 통신 단말기를 가지고, 어느 정보 통신망을 통해서든, 원하는 정보통신 서비스를 받을 수 있는 환경을 의미함 유비쿼터스 혁명은 서로 이질적인 물리 공간(제1공간)과 전자 공간(제2공간)이 제3의 가치 공간인 유비쿼터스 공간으로 통합/진화 되는 사회 전반에 걸친 변화임 유비쿼터스 컴퓨팅 개념을 토대로 하는 접근 방법 물리 공간의 사물 이미지를 해석하여 사용자의 주변을 분석하고 주위의 특정 사물의 존재를 컴퓨터가 인식할 수 있도록 하거나, 다양한 컴퓨터(칩, 센서, 태그, 구동체등)를 사물 속에 심고 이들을 네트워크로 연결하여 물리 공간의 상황을 사물과 사물, 사물과 컴퓨터, 컴퓨터와 사물 간의 상호 작용을 통해 유비쿼터스 공간(전자 공간-물리 공간)으로 인식하는 방법이 있음 유비쿼터스 공간은 만지지 않아도 공간에 존재하거나 공간에 관한 정보를 사용자가 알 수 있는 현실체가 지능적으로 증강된 공간으로 인식됨" }, { "title": "[데이터 정보 처리 입문] 1강 - 데이터 분석과 컴퓨터", "url": "/posts/knou-dip-1/", "categories": "Data Science, Data Analysis", "tags": "knou, data information processing", "date": "2025-03-07 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김성수, 이기재 교수님의 '데이터 정보 처리 입문' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 지식 정보화 사회에서 우리는 수많은 정보를 접하게 되는데, 특히 많은 부분이 데이터를 통한 정보라고 할 수 있음 우리가 살고 있는 현실을 파악하고, 현실을 이해하는 많은 과정이 데이터를 통해서 이루어짐 데이터 분석을 위해서는 데이터 분석에 대한 기본 개념과 방법론이 요구되며, 데이터 분석 소프트웨어의 활용이 필수적으로 요구됨 데이터 분석을 위한 기본 개념을 소개하고, 데이터 분석 소프트웨어들을 소개하고, 엑셀과 R을 이용한 데이터 분석 예를 소개함학습 목표 지식 정보화 사회에서 컴퓨터의 활용에 대하여 이해할 수 있음 데이터 분석 절차를 설명할 수 있음 데이터 분석 소프트웨어들을 설명할 수 있음 엑셀과 R을 이용한 데이터 분석 예를 설명할 수 있음강의록데이터 정보와 컴퓨터지식 정보화 정보화 사회 빅 데이터(Big Data), 딥러닝(Deep Learning), AI(Artificial Intelligence) 시대 정보가 중심이 되어 사회, 경제가 움직이는 사회 정보의 수집과 분석 및 정확한 파단 없이는 살아갈 수 없는 사회 정보가 급격하게 증대, 성장, 보급되는 사회 정보화 사회에서는 효율적인 정보의 수집, 수집된 정보의 가치 판단, 정보 활용 능력 등이 필수적으로 요구됨 이러한 의미에서 지금은 지식 정보화 사회라고함 지식 정보화 사회에서 데이터를 효율적으로 처리하고 분석하기 위해서는 컴퓨터의 활용 및 데이터 분석 능력이 필수적임지식 정보화 사회에서 필수적인 요구 사항 컴퓨터의 활용 방법을 알고 있어야 함 인터넷을 효율적으로 활용할 수 있도록 함 정보를 제대로 이해하고, 문제를 파악하고 판단하기 위한 통계적인 (논리적인) 사고가 요구됨 데이터 분석에 대한 기본 개념과 방법론들을 숙지 데이터로부터 유용한 정보를 추출하고, 합리적인 의사 결정을 하기 위해서는 데이터 분석 소프트웨어를 잘 활용할 수 있도록 함데이터 분석 개요데이터 분석 절차 문제의 정의 → 조사, 실험의 계획 → 데이터의 수집 → 데이터의 정리, 분석 → 분석 결과의 평가 문제의 정의 일반적으로 연구의 시작은 대개 간단하고 모호한 질문으로부터 시작됨 이것을 자세하고 정확한 질문으로부터 구체화 시켜 연구의 목적으로 하는 것이 문제의 정의임 연구 대상이 되는 모집단이 어떠한 것이며, 무엇이 불확실한 상황이고, 어떠한 의사 결정들이 내려질 수 있는 지에 대한 자세한 검토가 이루어져야 함 조사 실험의 계획 연구의 목적이 명확하게 정의가 되면 달성할 수 있는 조사 또는 실험을 계획하여야 함 구체적으로 연구 대상이 되는 모집단을 모두 조사할 것인지 아니면 표본만을 조사할 것인지 결정 표본을 조사하려고 한다면 어떻게 표본을 선택할 것이며, 표본의 크기는 어느 정도로 하며, 각 표본에서는 무슨 자료를 얻을 것 인지를 결정해야 함데이터의 수집 구체적인 조사, 실험이 계획되면 이에 따라 데이터를 수집 어느 경우에는 자료가 이미 수집 되어 있거나, 인터넷 또는 문헌에서 쉽게 구할 수도 있는데, 이때는 이 자료들이 과연 연구 목적에 적절하고 정확한 것인지 검토 직접 자료를 수집하는 일은 대개 시간과 경비가 많이 들고 또 오류도 많이 발생할 수 있는 매우 복잡하고 힘든 일임. 어느 경우에는 계획한 대로 자료를 수집하기가 불가능한 경우도 있고, 수집 된 자료가 연구 목적에 적절하지 않은 경우도 있음 이러한 문제점들을 줄이기 위해 예비 자료를 먼저 수집하여 자료 수집 계획을 수정 또는 보완하기도 함.데이터의 정리 분석 적절한 데이터를 수집한 후에는 도표나 그림을 이용하여 자료를 정리 또한 주어진 문제의 해결에 적합한 분석 방법을 이용하여 자료를 분석 데이터 분석 시스템의 활용 엑셀, R, python, SAS, SPSS, Minitab 등 통계적 방법 기술 통계, 탐색적 자료 분석, 범주형 자료분석, 두 모집단 비교, 회귀 분석, 실험 계획, 다변량 분석 등 분석 결과의 평가 분석된 결과를 이용하여 연구 목적에서 제기 된 질문에 대한 결론을 내림 어느 경우에는 부분적인 답만 결론 내릴 수도 있고, 다른 경우에는 제기 되지 않았던 질문에 대한 결론도 얻을 수 있음 결론에 따른 여러 가지 새로운 연구에 대한 제안도 할 수 있음데이터 분석 소프트웨어 소개SPSS(www.spss.co.kr) GUI(Graphic User Interface) 환경 하에서 통계 분석 및 자료 처리가 이루어짐 분석 절차에 맞게 다양한 대화 상자가 제공되므로 쉽게 분석 처리가 가능 스프레드시트 형태의 데이터 입력으로 일반 사용자에게 친숙 메뉴 방식 및 프로그램 방식을 모두 이용하여 통계 분석 절차를 제공 메뉴 방식을 이용한 통계 그래픽스 기능이 뛰어남SPSS 사용 - 기술 통계량을 구하는 예 데이터 입력 : SPSS를 실행하고 데이터를 입력한 초기 화면 분석 → 기술 통계량 → 기술 통계 선택 대화 상자에서 변수 선택 기술 통계 출력 결과 SAS(www.sas.com) 자료의 처리 기능이 뛰어남 데이터베이스, 데이터 웨어하우징(data warehousing) 등의 기능이 탁월 다양한 통계 분석 절차 데이터 마이닝 기능이 뛰어남 빅 데이터 솔루션 기능 프로그램 방식이 기본SAS 모듈(module) SAS/BASE : SAS 기본 SAS/STAT : 자료의 분석 및 통계 분석 SAS/AF : 응용 프로그램 개발 지원 SAS/ASSIST : 메뉴 형식의 SAS 시스템 지원 SAS/ETS : 시계열 분석 SAS/GRAPH : 그래프 SAS/IML : 행렬 연산 SAS/INSIGHT : 통계 분석 및 그래픽 구현 SAS/OR : Operation Research SAS/QC : 통계적 품질 관리 SAS/E-Miner : 데이터마이닝SAS 사용 - 산점도 및 상관 계수R(www.r-project.org) Free 기능이 매우 뛰어남 프로그램 처리 방식 자료 처리, 분석 및 그래픽스 분야에 탁월한 기능R 다운 받기 www.r-project.org 의 CRAN 클릭 → Mirrors 사이트 선택(Korea) → Download for Windows → base → Download R https://cran.yu.ac.kr/ R 사용math = c(66, 64, 48, 78, 60, 90, 50, 66, 70)physics = c(70, 68, 46, 84, 64, 92, 52, 68, 72)cor(math, physics)plot(math, physics, pch=16, col=\"BLUE\", main=\"(수학, 물리) 산점도\")abline(lm(physics~math))identify(math, physics)Python(www.anaconda.com) Free 객체 지향 언어 프로그램 문법이 쉬움 머신 러닝, 딥 러닝 분야에 탁월한 기능데이터 분석 예엑셀을 이용한 데이터 분석 2000년부터 2018년도까지의 연도 별 총 출생 성비가 다음과 같다. 연도 별 출생 성비(여아 100명당 남아의 수)를 시계 열 도표로 그려보자 출생 성비 자료(KOSIS 국가 통계 포털) http://kosis.kr → 국내 통계 → 주제 별 통계 → 인구 → 인구 동향 조사 → 출생 → 시도/출산 순위 별 출생 성비 선택 데이터 입력 첫번째 행은 변수(필드) 이름 차트 그리기 데이터 영역을 선택한 후, 메뉴 삽입 → 분산형 에서 원하는 차트를 선택 차트 수정 마우스로 왼쪽 축을 선택 → 마우스 오른쪽 단추를 눌러 나온 pop-menu에서 축 서식 선택 → 축의 최소, 최대 값을 변경 R를 이용한 데이터 분석R를 이용한 데이터 분석 - 산점도, 상관 분석 다음은 어느 고등학교의 학생 10명을 임의로 뽑아서 수학과 물리 성적을 기록한 것이다. 두 변수 간의 산점도를 그리고, 두 변수 간의 상관 계수를 알아보도록 하자 R 실행하기 - 산점도 명령어 ex12 &lt;- read.csv(\"c:/data/ex1-2.csv\") # csv 파일을 데이터 파일로 읽어들임 head(ex12) # 읽어들인 csv 파일 확인 plot(ex12$math, ex12$physics, pch=19, col=\"BLUE\") # 산점도 title(\"\\n Scatter Plot of (math, physics)\\n\") # 제목 실행 결과 R 실행하기 - 상관 분석 명령어 cor(ex12$math, ex12$physics) cor.test(ex12$math, ex12$physics) 실행 결과 R Studio의 소개 R Studio 사용자가 친숙하게 R을 쉽게 사용할 수 있도록 개발된 통합 환경 시스템 R Studio 화면 연습 문제 컴퓨터를 통하여 데이터 정보를 효율적으로 처리하기 위해 요구되는 사항이 아닌 것은? a. 정보를 검색하고 수집․분석하기 위해서는 반드시 컴퓨터 프로그램 언어를 알아야 한다. 요구되는 사항 컴퓨터를 쉽게 사용할 수 있어야 한다. 데이터 분석에 대한 기본개념과 방법론들을 숙지하여야 한다. 데이터 분석을 위한 다양한 소프트웨어의 활용법을 숙지하여야 한다. R 통계 패키지를 다운 받고자 한다. R 공식 사이트는? a. www.r-project.org 다음 중 범용 통계 패키지에 대한 설명으로 잘못된 것은? a. 파이썬은 미국에서 개발된 프로그램 언어로 스프레드시트 형태의 데이터 입력을 취하고 있다.    설명으로 알맞은 것 SPSS는 GUI 환경 아래에서 통계 분석 및 자료 처리가 이루어지므로 쉽게 분석 처리를 할 수 있다. SAS는 방대한 양의 자료 처리 기능이 뛰어나며 다양한 통계 분석 절차를 제공하고 있다. R은 객체 지향 프로그래밍 언어로서 대화형 통계 분석과 그래프 기능이 뛰어나다. ( a ) - 조사, 실험의 계획 - 데이터의 수집 - ( b ) - 분석 결과의 평가 일반적인 데이터 분석 절차이다. ( )안에 순서대로 가장 적합한 것은? a. a : 문제의 정의,\tb : 데이터의 정리, 분석 오늘날과 같이 효율적인 정보의 수집, 수집 된 정보의 가치 판단, 정보 활용 능력이 필수적으로 요구되는 사회를 가장 잘 나타낸 말은? a. 지식 정보화 사회 " }, { "title": "[Java 프로그래밍] 1강 - JAVA와 객체 지향 프로그래밍", "url": "/posts/knou-java-1/", "categories": "Language, Java", "tags": "knou, java", "date": "2025-03-05 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김희천 교수님의 'Java 프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. 학습 개요 java 언어의 발전 과정과 java 언어의 특징 살펴봄 바이트 코드, java 플랫폼 등의 새로운 개념 이해 간단한 예제 프로그램 학습 java 프로그래밍을 위한 개발 환경 설치 중요한 객체 지향 개념인 추상화와 클래스에 대해 정리학습 목표 java 언어의 특징 나열 바이트 코드, java 플랫폼에 관해 설명 가능 java 프로그래밍을 위한 개발 환경 준비 객체와 클래스 구별 가능강의록Java 언어 개요Java 언어의 기원 Sun Microsystems의 제임스 고슬링 1990년 그린 프로젝트와 Oak 언어 개발 그린프로젝트 소형 전자 제품의 셋톱 박스에 들어갈 제어용 프로그램 개발 프로젝트 Oak 언어 후에 Java 언어로 개명 1990년 초 World Wide Web의 태동기 1995년 Java와 HotJava 발표 웹에서 동작하는 프로그램 개발에 적당 → 웹 확산과 함께 자바 주목 HotJava 자바 언어 수용한 첫번째 웹브라우저 1996년 1월 JDK1.0 발표 1998년 Java2 SDK, SE 1.2 2014년 Java Platform(JDK) SE 8 소프트웨어 개발 키트 다양한 프로세스에서 수정 없이 사용 가능 2023년 9월 Java SE 21 발표 2009년 Oracle이 Sun 인수Java 언어의 특징 C/C++ 언어와 문법적으로 유사하나 단순함 포인터 개념, 전처리기, 메모리 작업 불필요 운영체제와 무관, 하드웨어 플랫폼에 독립적 자바 플랫폼이 있을 경우 어떤 운영체제에서 사용하든지 간에 수정 없이 실행 가능 실행 환경(자바 플랫폼)이 언어에 함께 포함 완전한 객체 지향 프로그래밍 언어 하이브리드 객체 지향 언어인 C++은 객체 지향적 프로그래밍 및 절차적 언어처럼 작성 가능 객체 지향 스타일로만 프로그램 작성 가능 데스크톱 응용 외에 웹 또는 네트워크 프로그래밍 용이 웹 운영이나 네트워크 활용한 클라이언트 서버 프로그램 작성 시 맞춤 라이브러리 제공 변수 등의 사용에 있어서 엄격한 자료형의 검사 변수 사용 시 자료형에 대한 검사 엄격 예외 처리 기능 제공 프로그램 실행 도중 에러 발생 시 비정상적으로 종료가 되기 때문에 예외 처리 기능으로 오류 발생 처리해 프로그램을 끝까지 실행 멀티 스레딩 지원 스레드 하나의 프로그램 안에서 진행 될 수 있는 세부 작업 흐름 프로세스 안에서 존재하는 독립적인 작은 실행 흐름 운영체제에서 프로세스 생성 → 프로그램 실행 독립적인 실행 흐름을 동시에 실행 가능 Java 플랫폼 프로그램 실행을 위한 하드웨어, 소프트웨어 환경 Java 플랫폼은 Java 프로그램의 개발과 실행을 위한 소프트웨어 환경 컴파일 후 만들어진 바이트 코드가 자바 플랫폼에서 실행 사용 중인 운영 체제(Windows, Linux)에 맞는 Java 플랫폼을 설치해야함 Java 플랫폼의 구성 Java VM Java 프로그램의 실행 환경을 제공하는 가상 기계(소프트웨어 환경) Java 프로그램의 구동 엔진 Java 프로그램 실행에 필요한 사항을 관리 메모리 정리를 자동으로 수행 가비지 컬랙션 메모리 할당 받은 후 메모리를 더 이상 사용하지 않을 때 프로그램 상에서 운영체제로 반환 필요 Java API(Application Programing Interface) 프로그램의 개발에 필요한 클래스 라이브러리 패키지(클래스 묶음)들이 계층 구조로 분류되어 있음 서브 패키지 존재 실행 과정 Java 소스 파일 작성 컴파일러 이용해 소스파일 컴파일 시 클래스 파일 생성 jdk에 컴파일러 존재 .java파일 -컴파일→ .class파일 자바는 완전한 객체 지향 언어기 때문에 자바 프로그램 작성한다는 것은 클래스를 작성하는 일이 됨 클래스가 소스프로그램에 존재 시 각 클래스마다 클래스 파일이 컴파일 과정을 통해 만들어짐 클래스 파일이 자바 VM에서 실행되어 프로그램이 실행됨 어떤 OS를 사용하던지 간에 호환되는 Java 플랫폼이 존재한다면 자바 프로그램 어디서든지 실행 가능 Java 소스 .java Java 소스 프로그램의 확장자 바이트 코드 .class 바이트 코드 파일 확장자 클래스 파일 Java 소스를 컴파일한 결과물 Java 플랫폼의 Java VM에서 실행 가능한 코드 JDK(Java Deveplopment Kit)의 설치 JDK, Java SDK Java 플랫폼과 개발 도구의 묶음 컴파일러, 디버거, 문서도구 등 Java 홈페이지에서 다운로드 후 설치 자신이 사용하는 운영 체제에 맞는 것을 선택 JDK 설치 후 Java 프로그램의 실행 소스 작성을 위해 텍스트 편집기 사용 명령 프롬프트 창에서 컴파일 명령은 javac javac Hello.java 명령 프롬프트 창에서 실행 명령은 java java Hello 환경 변수 PATH 변수 경로 추가 C:\\Program Files\\Java\\jdk-21\\bin 컴파일 명령, 자바 실행 명령 등 개발 툴 존재 JAVA_HOME 변수 경로 추가 JDK 설치 폴더 C:\\Program Files\\Java\\jdk-21 Eclipse 설치 Eclipse 홈페이지에 접속 무료 오픈 소스 프로그램 개발 도구 Eclipse IDE for Java Developers 설치용 파일(.exe) 또는 압축 파일(.zip) 다운로드 설치 과정에서 작업 공간(workspace) 폴더 지정 workspace 프로젝트 폴더, 소스 코드, 클래스 파일 등을 저장하는 장소 Eclipse 사용하여 Java 프로그램 개발하기 Java Project 생성 File → New → Java Project 클래스가 저장될 패키지 생성 프로젝트 → 마우스 오른쪽 버튼 → New → Package 패키지 안에 클래스 생성 Java 프로그램은 클래스 단위로 작성 패키지 이름 → 마우스 오른쪽 버튼 → New → Class 클래스 이름으로 파일 이름(.java) 정해짐 Java 소스 저장 시 컴파일 되며, 클래스마다 .class 파일 생성됨 main()메소드를 가진 클래스 실행Java 소스의 구성주석, 클래스, main()메소드 주석 /*...*/ 실행과 무관 사이의 내용을 무시함 여러 줄 주석 /**...*/ 소스 코드 맨 앞에 전반적 설명을 작성하는 주석 자동으로 소스 코드의 매뉴얼 생성을 가능하게 함 javadoc 명령 여러 줄 주석 // 같은 라인에서 이후에 나오는 내용은 실행과 무관함 이후 내용을 무시 한줄 주석 클래스 정의와 main메소드의 형식 package com; public class Main { public static void main(String[] args) { } } public class의 이름이 A 일 경우, A.java 파일에 저장되어야 함 Hello 애플리케이션 /** * The Hello class implements an application that * simply prints \"Hello, Java Application! \" to standard output. */ public class Hello { // 클래스 정의 블록 public static void main(String args[]) { // 프로그램 실행시 main 함수 필요 System.out.println(\"Hello, Java Application!\"); // 출력문 } } 대소문자 구분 주석, public class, main()메소드, 출력문을 가진 프로그램 System.out 표준 출력 담당하는 객체 System클래스 안에 정의 되어있는 static field인 out사용해 화면 출력 print()또는 println()을 수행 실행 프로그램 작성 Hello.java 파일 저장 실행 실행 버튼 또는 Run 메뉴(Ctrl+ F11) 실행 명령어 사용 컴파일 명령 javac Hello.java 컴파일 명령 실행 시 class 파일 생성 클래스 이름.class 생성 실행 명령 java Hello main함수를 가지고 있는 클래스 이름 입력 시 실행 가능 Hello 클래스에서 main()메소드 실행 프로젝트 배포하기 배포 개발된 Java 프로그램을 묶어서 외부에서 실행 가능하게 내보내는 것 실행에 필요한 클래스 파일을 묶어서 .jar 파일을 만들 수 있음 프로젝트 → 마우스 오른쪽 버튼 → Export 선택 export 유형, jar 파일 경로 및 이름 지정 객체 지향 프로그래밍클래스와 객체 추상화 구체적인 모든 사실이 아니라 전형적이고 필요한 부분만을 추려서 사물을 이해하고 표현하는 것 필요한 일부분만 간단히 표현 클래스 객체를 만들기 위한 모형 또는 틀 공통적인 특징을 가지는 객체들을 추상화하기 위한 수단 객체의 상태는 필드(데이터)로, 행위는 메소드로 구현 동종의 객체들을 표현한 필드 정의 데이터 필드를 가지고 메소드로 표현 객체는 특정 클래스의 인스턴스 추상화를 통해 프로그램 상에서 표현된 것 인스턴스 클래스가 실체화 된 것 객체 지향 Java 프로그램 Java 프로그램과 클래스 클래스가 프로그램 구성의 기본 단위 객체의 데이터(필드)와 객체의 기능(메소드)이 클래스 구조로 캡슐화되어 있음 클래스 정의로부터 객체(인스턴스)들이 만들어지고 객체들 간의 상호작용으로 프로그램이 동작 C 프로그램과 Java 프로그램의 비교 성적 처리를 위한 C 프로그램 #include &lt;stdio.h&gt; int e[2]; //영어 성적을 위한 변수 int m[2]; //수학 성적을 위한 변수 void input_grade() { //영어, 수학 성적을 입력 받는 함수 e[0] = 90; //첫 번째 학생의 영어 성적 e[1] = 80; //두 번째 학생의 영어 성적 m[0] = 85; //첫 번째 학생의 수학 성적 m[1] = 80; //두 번째 학생의 수학 성적 } void output_grade() { //총점 출력하는 함수 printf(\"%d, %d\", e[0]+m[0], e[1]+m[1]); } void main(void) { // main 함수 input_grade(); output_grade(); } 절차적 프로그래밍 프로그래밍의 기본 단위는 함수 성적 처리를 위한 Java 프로그램 // GradeOutput.java class Grade { // 성적 클래스 int e; //영어 성적을 위한 변수 int m; //수학 성적을 위한 변수 void output_grade() { //총점을 구하는 메소드 System.out.println(e+m); } } public class GradeOutput { public static void main(String args[]) { Grade g1, g2; //2명의 성적을 표현하는 변수 선언 g1 = new Grade(); //객체의 생성 g2 = new Grade(); g1.e = 90; g1.m = 85; //점수 입력 g2.e = 80; g2.m = 80; g1.output_grade(); g2.output_grade(); } } 객체 지향적 프로그래밍 객체.함수이름 연습 문제 똑같은 바이트 코드가 Java 플랫폼이 설치된 다양한 하드웨어와 운영체제에서 수정 없이 실행될 수 있다. Java 언어의 특징 중에 다음 내용이 의미하는 것은? a. 플랫폼에 독립적 Java 언어의 특징 중에 다음 내용이 의미하는 것은? public class A { } class B { } a. A.class와 B.class가 생성된다. “Hello, World!”를 화면에 출력하는 자바 프로그램을 작성하라. a. public class Main { public static void main(String[] args){ System.out.println(\"Hello, World!\"); } } 학습 정리 java 프로그램의 기본 구성 단위는 클래스 java에서는 변수 자료형에 대한 검사 엄격 java 프로그램을 위해서 jdk 설치 필요 java 소스는 컴파일 된 후, 바이트 코드가 java 플랫폼에서 실행됨 java 플랫폼은 java VM과 java API로 구성됨 main()메소드 형식은 public static void main(String[] args) 클래스는 동종 객체를 추상화시켜 표현한 틀이며, 데이터와 메소드로 구성됨 객체는 특정 클래스의 인스턴스임" }, { "title": "[파이썬 프로그래밍 기초] 1강 - 컴퓨터의 이해", "url": "/posts/knou-python-1/", "categories": "Language, Python", "tags": "knou, python", "date": "2025-03-04 00:00:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 정재화 교수님의 '파이썬 프로그래밍 기초' 강의를 개인 공부 목적으로 메모하였습니다. 학습 목표 데이터와 정보의 차이점 설명 데이터의 표현 방식에 대해 설명 프로그램과 알고리즘의 차이점에 대해 설명주요 용어 데이터 어떤 현상이나 사실에 대한 설명 또는 설명의 집합 정보 문제 또는 질문을 해결하기 위해 사용할 수 있는 데이터와 데이터의 집합 프로그램 컴퓨터가 어떠한 작업을 자동으로 처리할 수 있도록 처리 방법 및 순서를 컴퓨터가 이해할 수 있는 언어 형태로 기술한 것 알고리즘 문제를 풀기 위한 단계별 절차를 체계적 명령의 형태로 기술한 것 강의록데이터와 정보데이터의 개념 어떤 현상이나 사실에 대한 설명 또는 설명의 집합 ex) 불 붉다, 밝다, 뜨겁다 → 질적 데이터 3500도 → 양적 데이터 데이터(data)의 정의 관찰이나 실험, 조사로 얻은 사실 이론을 세우는 데 기초가 되는 사실 또는 바탕이 되는 자료 관찰이나 측정을 통해 얻은 수치, 문자 형태의 질적(quality) 또는 양적(quantity) 값정보의 개념 문제 또는 질문을 해결하기 위해 사용할 수 있는 데이터와 데이터의 집합정보(information)의 정의 어떤 데이터나 소식을 통해 얻은 지식이나 상태의 총량 관찰이나 측정을 통하여 수집한 자료를 문제 해결에 도움이 될 수 있도록 정리한 지식 관찰과 측정을 통해 얻은 데이터를 처리(정렬, 합산, 군집화 등)하여 실제 문제 해결에 도움이 되는 데이터 또는 결과물정보 처리 과정 현상 — 관찰, 측정 → 데이터 — 처리, 가공 → 정보 데이터는 현상에 대한 관찰과 측정으로 생성 데이터는 기록된 사실이지만, 직접적으로 문제를 해결하는데 도움이 되지 않음 처리과 가공을 통해 정보로 변환관찰과 측정 관찰 사물 또는 현상을 파악하는 행위 측정 절대적인 기준에 맞춰 현상을 수치로 나타내는 과정 데이터의 종류 연속적 데이터 온도, 길이 등 끊임없이 변하는 데이터 ex) 불 - 3500도 범주형 데이터 성별, 혈액형처럼 분류할 수 있는 데이터 ex) 불 - A급 화염 처리와 가공 수집된 데이터의 집합을 정렬, 군집화, 계산, 표현 방법 변경 등의 데이터를 변환하여 정보를 생산하는 과정컴퓨터의 개념컴퓨터의 정의 정의된 방법에 따라 입력된 데이터를 자동으로 처리하여 정보를 생산하는 기계데이터의 기본 단위 비트(bit) binary digit 2개의 상태 값을 표현하는(0과 1) 가장 작은 기본 단위 여러 개 중첩 시켜 데이터를 표현 또는 처리함 바이트(byte) 8비트로 구성된 단위 컴퓨터와 2진법 컴퓨터는 트랜지스터를 통해 2진법 숫자로 데이터를 표현하여 저장 및 처리 트랜지스터는 0과 1을 이용하여 정보를 표현 아날로그와 디지털 아날로그(Analog) 사물이나 개념을 연속적인 물리량 값으로 표현 중간 과정을 고스란히 보여줌 질적 데이터 또는 양적 데이터로 표현 디지털(Digital) 사물이나 개념을 이산적인 값으로 표현 양적 데이터로 표현 숫자 데이터의 표현 2진수 0과 1로만 표현 10진수 일반적인 숫자 표현 방식 16진수 0 ~9, A ~ F까지 사용하여 표현 문자 데이터의 표현 ASCII 코드 2진법 십진법 문자 2진법 십진법 문자 2진법 십진법 문자 010 0000 32 SP 100 0000 64 @ 110 0000 96 ` 010 0001 33 ! 100 0001 65 A 110 0001 97 a 010 0010 34 ” 100 0010 66 B 110 0010 98 b 010 0011 35 # 100 0011 67 C 110 0011 99 c 010 0100 36 $ 100 0100 68 D 110 0100 100 d 010 0101 37 % 100 0101 69 E 110 0101 101 e 010 0110 38 &amp; 100 0110 70 F 110 0110 102 f 010 0111 39 ’ 100 0111 71 G 110 0111 103 g 010 1000 40 ( 100 1000 72 H 110 1000 104 h 010 1001 41 ) 100 1001 73 I 110 1001 105 i 010 1010 42 * 100 1010 74 J 110 1010 106 j 010 1011 43 + 100 1011 75 K 110 1011 107 k 010 1100 44 , 100 1100 76 L 110 1100 108 l 010 1101 45 - 100 1101 77 M 110 1101 109 m 010 1110 46 . 100 1110 78 N 110 1110 110 n 알파벳, 숫자, 특수 문자를 2진수로 변환 유니코드 다양한 언어를 지원하는 확장된 문자 표현 방식 컴퓨터와 프로그램프로그램의 이해 컴퓨터는 정보를 처리하기 위한 방법과 과정을 자의적으로 결정 불가능 처리 방법과 과정이 정의된 프로그램을 사용 프로그램이란 컴퓨터가 어떠한 작업을 자동으로 처리할 수 있도록 처리 방법 및 순서를 컴퓨터가 이해할 수 있는 언어 형태로 기술한 것 유사한 유형의 여러 문제를 추상화 시킨 알고리즘(algorithm)을 구현한 결과물 알고리즘의 정의 문제 해결을 위한 단계별 절차를 체계적 명령의 형태로 기술한 것 주어진 명령어를 처리하는 컴퓨터에게 문제를 해결하도록 만드는 정형화된 절차 ex) 모든 카드를 오름차순으로 정렬하는 문제 → 선택 정렬 알고리즘 선택 정렬 가장 작은 값을 선택하여 정렬하는 방식 버블 정렬 인접한 두 값을 비교하여 정렬하는 방식 프로그래밍 언어 사람과 컴퓨터 간 의사소통 도구 프로그래머는 컴퓨터가 이해할 수 있는 언어를 사용하여 프로그램을 작성프로그래밍 언어의 분류 저급 언어 기계에 가까운 언어 1세대 기계어 (0과 1로 구성된 코드) 2세대 어셈블리어 (기계어를 간단한 영어 명령어로 대체) 고급 언어 사람에 가까운 언어 3세대 자연어와 유사한 프로그래밍 언어 (C, Java, Python 등) 4세대 자동화 (Visual Basic) 프로그래밍의 실행 고급 언어로 작성된 프로그램은 기계어 밖에 인식할 수 없는 컴퓨터에 의해 실행 불가능 고급 언어로 작성된 코드는 기계어로 변환해야 실행 가능 컴파일러 또는 인터프리터 사용 컴파일러 방식 전체 코드를 한 번에 번역 후 실행 (C, Java 등) 인터프리터 방식 한 줄씩 번역하며 실행 (Python, JavaScript 등) 연습 문제 다음과 같이 어떤 문제(라면끓이기)를 해결하기 위한 절차를 무엇이라고 하는가? a. 알고리즘 ‘방송대 컴퓨터과학과의 파이썬 프로그래밍 기초는 전공 과목이다’ 라고 할 때, ‘전공’이라는 설명은 어떤 유형의 데이터에 속하는가? a. 범주적 데이터 표현의 모호성을 제거하고 자연어와 유사한 형태의 문법을 갖는 프로그래밍 언어는? a. 3세대 프로그래밍 언어 학습 정리 데이터 관찰이나 측정을 통해 얻은 수치, 문자 같은 변할 수 있는 질적 또는 양적 값 정보 데이터를 처리해 실제 문제 해결에 도움 될 수 있도록 정리한 결과물 데이터 처리에는 정렬, 합산, 군집화 등의 작업이 동반 됨 데이터와 정보 데이터는 현상에서 관찰 · 측정을 통해 얻어지며, 정보는 데이터를 처리 · 가공해 추출 컴퓨터 입력된 데이터를 자동으로 처리하는 기계로, 데이터 처리 과정을 순서화해 전체 과정을 자동화할 수 있는 장치 컴퓨터의 기능 입력 기능(외부 데이터 수신) 제어 기능(내부 장치 조정) 저장 · 기억 기능(입력 데이터 저장) 연산 기능(계산 수행) 출력 기능(내부 데이터를 사용자에게 전달) 디지털 컴퓨터 0과 1의 신호로 동작하므로 데이터 및 명령문도 0과 1로 표현되어야 함 수나 문자, 명령어도 0과 1로 표현됨 프로그램 컴퓨터가 작업을 자동으로 처리할 수 있도록 처리 방법 및 순서를 컴퓨터가 이해할 수 있는 언어로 기술한 것 프로그램을 만드는 사람을 프로그래머라 하며, 제작 과정은 프로그래밍이라 함 알고리즘 문제 해결을 위한 단계별 절차를 수학적으로 기술한 것 입력과 출력이 있어야 하며, 명확성 · 유한성 · 효율성이 보장되어야 함 프로그램 프로그래밍 언어를 이용하여 알고리즘을 구현한 결과 프로그래밍 언어로 작성된 소스 코드를 컴파일러나 인터프리터를 통해 컴퓨터에서 실행 가능한 프로그램으로 생성됨 " }, { "title": "[UNIX 시스템] 1강 - 리눅스 소개", "url": "/posts/knou-unix-1/", "categories": "OS, UNIX", "tags": "knou, os, unix", "date": "2023-09-07 23:28:00 +0900", "snippet": "💡해당 게시글은 방송통신대학교 김희천 교수님의 'UNIX 시스템' 강의를 개인 공부 목적으로 메모하였습니다. 학습 목표 유닉스와 리눅스의 발전사와 특징 확인 오픈소스 소프트웨어 라이센스의 종류 나열 가능 주요 리눅스 배포판의 특징 설명 가능유닉스와 리눅스UNIX의 특징 다중 사용자, 다중 작업을 지원하는 신뢰성 높은 운영체제 뛰어난 이식성, 강력한 네트워킹 기능, 셸 스크립트, 파이프라인, 명령형 기반 인터페이스, 단순하고 모듈화된 설계 등UNIX와 리눅스 리눅스는 UNIX의 무료 공개 버전 초기에 리눅스는 PC용 운영체제로 개발되었음UNIX 발전사 최초의 UNIX Multics 1969년 assembly 언어로 작성된 최초의 시분할 운영체제 Unics → Unix 작고 심플한 운영체제로 다시 작성됨 1973 대부분이 C언어로 다시 작성됨 대표적인 UNIX 시스템 BSD 계열 Free BSD, SunOS, GNU/Linux System V HP-UX(HP), AIX(IBM), Solaris(Oracle) 리눅스 리눅스의 등장 1983년 GNU 프로젝트 리처드 스톨만이 UNIX와 유사한 공개 운영체제를 개발하기 위해 GNU 프로젝트를 시작 소프트웨어 상업화에 반대하고 소스코드의 공유, 자유로운 사용과 배포를 주장 1985년 GNU 선언문(Manifesto) 발표 1989년 GPL을 발표 현재 Free Software Foundation(FSF)이라는 이름으로 활동 1991년 리눅스 커널(Kernel) 리누스 토르발스는 리눅스 커널을 작성하여 발표 커널 하드웨어를 제어하고 응용 프로그램과의 상호작용을 제공하는 운영체제의 핵심 개발자인 Linus와 Unix의 이름을 따서 Linux라고 명명 1992년 최초 리눅스 배포판인 MCC Interim 리눅스가 발표됨 보통 리눅스라 함은 리눅스 커널을 사용한 운영체제(리눅스 배포판)를 의미 1998년 IBM과 Oracle이 리눅스 지원을 발표 리눅스 개요리눅스의 발전상 전 세계 리눅스 사용자는 9,160만명 정도로 추산됨 유수의 100만 도메인 중 95% 이상이 리눅스를 사용 스마트폰의 70% 이상이 리눅스 기반의 안드로이드에서 동작 슈퍼 컴퓨터의 95%가 리눅스에서 운영됨 주요 증권 거래소, Google, Twitter, Facebook, Amazon 등에서 리눅스 서버를 사용 대다수 전자 장비(폰, TV 등)에서 리눅스를 사용리눅스의 특징 다중 사용자와 다중 작업을 지원 뛰어난 이식성을 제공 모듈화되어 있어 업그레이드 또는 업데이트가 용이 CUI와 GUI를 지원 Character UI : 셸(shell)을 통해 커맨드를 입력 Graphical UI : X Window 기반의 GNOME이나 KDE 등의 데스크톱 환경 소스 코드가 공개됨 공개 소스로서 문제점이 빠르게 발견되고 보완됨 여러 종류의 파일 시스템을 지원 Minix, ext 계열, FAT, FAT32, NTFS, NFS, ISO-9660 등 효율적 하드웨어의 활용 다양한 응용 프로그램과 소프트웨어 개발 환경을 제공오픈소스와 라이센스오픈소스 소프트웨어(OSS) 개발자(저작권자)가 소스 코드를 공개하여 누구나 사용, 수정, 공유할 수 있도록 허가한 소프트웨어 반대 개념은 proprietary(closed) 소프트웨어소프트웨어 라이센스 컴퓨터 프로그램은 지식 재산권으로 보호 받는 저작물 원칙적으로 저작자가 공표, 복제, 배포, 개작할 권한 가짐 타인에게 일정한 대가나 조건을 전제로 권한을 부여할 수 있음(라이센스) OSS도 보호받는 저작물이며 OSS 라이센스가 있음 https://opensource.org/licenses/ 오픈 소스의 장점 누구나 잘못된 점을 발견하고, 알리거나 고칠 수 있음 배울 수 있고, 프로그램 개발에 효율적으로 적용 가능 오픈 소스는 여러 사람에 의해 테스트 되어 안전 커뮤니티를 통한 협력, 공유, 개방이 발전을 위해 효율적이라는 것이 오픈 소스 운동의 철학GNU 프로젝트와 자유 소프트웨어 운동 목적에 상관 없이 프로그램을 실행할 수 있는 자유 프로그램을 복제하고 공유할 수 있는 자유 소스 코드를 개작할 수 있는 자유 개작된 프로그램을 배포할 수 있는 자유 소프트웨어의 소스코드는 공개 리눅스의 라이센스 리눅스는 독점되거나 배타되지 않는 자유 소프트 웨어 공개 라이센스에 따라 자유롭게 수정하고 배포 가능 주로 GPL(GNU General Public License)를 따름 일부는 LGPL(GNU Lesser General Public License) X Window는 MIT 라이센스GNU GPL 자유롭게 사용, 복제, 배포 필요에 따라 자유롭게 수정하고 배포 수정하여 배포하는 경우 소스코드를 공개해야함 수정된 소프트웨어에 저작권자를 표시하고 똑같이 GPL 조건으로 배포해야함다양한 오픈소스 소프트웨어 라이센스 GPL, LGPL, MPL 소스 코드를 공개해야 하는 CopyLeft 라이센스 기본적으로 코드를 공개하도록 함 LGPL은 주로 오픈소스 라이브러리에 적용됨 MPL 코드와 결합하여 프로그램을 만들 때, MPL 코드를 포함하지 않은 파일은 공개 의무가 없음 소스 코드의 공개 범위는 다르게 정의됨 전체/파일/모듈 단위 등 BSD, Apache, MIT 라이센스 배포 시 소스 코드의 비공개가 허용됨 Permissive 라이센스라고 함 코드의 재사용을 높이려는 목적 리눅스 배포판리눅스 배포판의 역사 리눅스 배포판은 리눅스 커널 외에 시스템 유틸리티, 응용프로그램, 설치 프로그램을 포함한 완전한 운영체제 리눅스 커널은 1991년 처음 개발됨 1994년에 커널 1.0이 발표되었고 최신 안정 버전은 6.4 1992년 최초의 배포판 MCC Interim과 SLS(Softlanding Linux System) 배포판이 발표됨 1993년부터 주요 배포판이 나오기 시작주요 리눅스 배포판의 종류 배포판 관련 URL 설명 CentOS centos.org RHEL의 무료 버전 Debian debian.org GNU의 공식 후원 Fedora fedoraproject.org RHEL의 신기술 시험용 Red Hat Ent. redhat.com 상용 버전 Rocky Linux rockylinux.org CentOS의 대안 Slackware slackware.com 현존 가장 오래된 배포판 SUSE suse.com 유럽에서 주로 사용 Ubuntu ubuntu.com Debian의 개인용 버전 Debian 계열 Debian, Ubuntu 등 Slackware 계열 Slackware, SUSE 등 Red Hat 계열 Redhat, Fedora, CentOS, Rocky Linux 등 Debian 리눅스 Debian 프로젝트 자유 운영체제를 만들어가는 사람들의 독자적인 모임 lan Murdock에 의해 1994년에 비영리 조직으로 설립 GNU 정신에 가장 충실한 배포판 GNU의 공식적인 후원을 받는 유일한 배포판 세 가지 릴리스를 유지 stable, testing, unstable 숫자 버전 외에 코드명을 가지며 unstable 버전은 항상 코드명이 sid Red Hat 리눅스 배포판 가운데 가장 널리 알려진 리눅스 배포판 Red Hat Linux 2003년 지원 중단(마지막 버전 9) Red Hat Enterprise Linux(RHEL) Red Hat 사에 의해 지원(최신 버전 9) Fedora와 CentOS라는 오픈소스 프로젝트를 지원 RPM(Red Hat Package Manager) 바이너리, 설정 파일, 라이브러리, 문서 등의 일괄 관리 기능 RPM 데이터 베이스를 검색하여 패키지나 특정 파일의 검색 기능 패키지에 필요한 파일, 의존성 유무 등을 조사하는 기능 CentOS 리눅스 Red Hat 리눅스로부터 파생 Red Hat Enterprise Linux(RHEL) 기반의 무료 버전 RHEL의 소스 코드를 기반으로 만들어지는 무료 배포판 RHEL 자체는 유료로 기술지원을 제공하는 엔터프라이즈 버전 서버용으로 많이 사용됨 최근에는 RHEL의 업스트림 버전(개발 버전)인 CentOS Stream만 지원Rocky 리눅스 기존 CentOS 리눅스의 대체 제품 CentOS의 릴리스 정책이 변경됨 CentOS Stream은 RHEL의 안정적 버전이 아닌 개발 버전 → 기존 CentOS의 대안이 필요해짐 그레고리 커처가 Rocky Linux 프로젝트 시작 RHEL 소스 코드 기반의 다운스트림 버전 RHEL과 실행 코드가 호환됨 엔터프라이즈 환경에서 안정적이고 신뢰성 있는 운영 환경 제공하는 것이 목표SuSE 리눅스 Slackware 리눅스로부터 파생 독일에서 만든 배포판, 유럽에서 많이 사용 Software Und System Entwicklung의 약자 풍부한 기능, 안정성, 보안 기능 포함 Novell 사에 의해 지원 두가지 종류 SUSE Linux Enterprise(유료) openSUSE(무료) Slackware 리눅스 SLS 리눅스로부터 파생 가장 먼저 대중화된 현존하는 가장 오래된 배포판 1992년 Patrick Volkerding에 의해 시작 간결함을 설계 철학으로 함(the KISS principle) 현재 GNOME desktop이 제외되어 있음 유닉스 자체 학습에 적합Ubuntu 리눅스 Debian 리눅스로부터 파생 영국 기업 Canonical의 지원 데스크톱 환경 Unity를 제공했으나 최근 GNOME을 다시 사용 Debian 리눅스에 비하여 사용 편의성에 중점 개인 사용자에게 인기 있는 리눅스 배포판 중 하나정리하기 리눅스는 UNIX의 표준을 준수하여 만들어진 무료 공개 운영체제 오픈소스 소프트웨어란 소스 코드가 공개된 소프트웨어로 누구나 자유롭게 사용, 수정, 배포할 수 있는 소프트웨어 리눅스 배포판이란 리눅스 커널을 기반으로 시스템 유틸리티, 응용 프로그램, 설치 프로그램 등을 포함하여 완전한 운영체제로 패키지화한 것 GPL은 진정한 CopyLeft 라이센스로 가장 널리 적용되는 오픈소스 소프트웨어 라이센스" }, { "title": "Default/Static/Dynamic Routing", "url": "/posts/routing/", "categories": "Network", "tags": "network, routing", "date": "2022-11-11 01:29:00 +0900", "snippet": "Routing과 경로Routing (Default/Static/Dynamic) 서로 다른 네트워크에 존재하는 장비가 통신하기 위해서 2가지에 근거하여 최적 경로 연산하는 방식 상대방 주소 학습 나의 주소 광고 라우터로 패킷을 전송하는 것최단 경로 Algrithm bellman Algrithm과 dijkstra Algrithm bellman ford algrithm 거리 우선 최단 경로 dijkstra algrithm 안전 우선 최단 경로 Routing 경로 결정 방법 메트릭 값이 가장 낮은 것 AD (Administrator Distance) 값이 가장 낮은 것 가장 오래 된 매칭 값Routing Table 라우터가 해야하는 일이나 경로에 대한 정보가 담긴 table 수신할 곳의 네트워크와 그에 대한 전송 방법 포함 패킷 전송 제어Router ID 미지정 시에는 설정된 IP 주소에서 가장 높은 것을 결정 (loopback &gt; interface) 가장 낮은 ID가 우선 순위를 가짐Process ID 라우터 내부적으로 사용하는 ID이며, 다른 라우터와 동일할 필요 없음 운용 상의 편리성을 위해 서로 동일하게 사용하는 것이 좋음 한 Router는 여러 개의 OSPF 프로세스를 운용할 수 있음 = 여러개의 OSPF DB를 사용Toplogy 네트워크 망 전체Default Gateway 기본적으로 설정된 라우팅 경로 자신이 소속된 네트워크 이외에 보내려는 패킷의 목적지에 대한 정보를 갖고 있지 않을 때 전송처Classful/Classless RoutingClassful Routing Class가 주가 되는 라우팅 Class는 알지만 Netmask는 알지 못함 (Subnetting 하기 zz전)Classless Routing Subnet이 주가 되는 라우팅 Netmask를 전달 받음 프로토콜은 Subnet을 배워야함자동/수동 축약(Summary)Auto-summary (자동 축약) default 값 Classful 방식 Routing Table을 다른 네트워크로 보낼 때 기본 클래스 단위로 요약해서 광고 네트워크 정보 routing시 network 자체를 합침Manual-summary (no auto-summary) 관리자가 수동으로 필요한 만큼 분리된 네트워크를 합침 축약 (여러 개의 네트워크를 하나의 네트워크로 사용) 방지 RIP, IGRP, EIGRP에서는 꼭 사용Default/Static/Dynamic RoutingDefault Routing (기본 라우팅) 라우터가 모든 라우터를 다음 홉으로 보내도록 구성하는 방법 통신하려는 장비의 IP를 다음 홉의 Routing Table을 참조 PC1과 PC2가 통신하도록 Default Routing 설정 R1 Router # global modeip route 0.0.0.0 0.0.0.0 1.1.12.2 # 모든 네트워크 대역을 인접한 라우터로부터 학습 R2 Router # global modeip route 0.0.0.0 0.0.0.0 1.1.13.1 # 모든 네트워크 대역을 인접한 라우터로부터 학습ip route 0.0.0.0 0.0.0.0 1.1.12.1 # 모든 네트워크 대역을 인접한 라우터로부터 학습 R3 Router # global modeip route 0.0.0.0 0.0.0.0 1.1.13.2 # 모든 네트워크 대역을 인접한 라우터로부터 학습 Static Routing (정적 라우팅) 수동 학습 라우팅 통신하려는 장비의 IP를 administrator가 하나씩 직접 알려줌 (관리자 직접 설정) 네트워크 접속이 변경 될 때마다 Routing Table에 경로 수동 추가 필요 네트워크 전체의 규모가 아주 작거나 구성 변경할 일이 별로 없는 경우 사용 PC1과 PC2가 통신하도록 Static Routing 설정 R1 Router # global modeip route 22.1.1.0 255.255.255.0 1.1.12.2 # 목적지 대역을 인접한 라우터로부터 학습ip route 1.1.13.0 255.255.255.0 1.1.12.2 # R3 대역을 인접한 라우터로부터 학습# privilege modeshow ip route # 학습한 routing table 확인 R2 Router # global modeip route 22.1.1.0 255.255.255.0 1.1.13.1 # 목적지 대역을 인접한 라우터로부터 학습ip route 11.1.1.0 255.255.255.0 1.1.12.1 # 목적지 대역을 인접한 라우터로부터 학습# privilege modeshow ip route # 학습한 routing table확인 R3 Router # global modeip route 11.1.1.0 255.255.255.0 1.1.13.2 # 목적지 대역을 인접한 라우터로부터 학습ip route 1.1.12.0 255.255.255.0 1.1.13.2 # R1 대역을 인접한 라우터로부터 학습# privilege modeshow ip route # 학습한 routing table확인 장점 연산 부하 없음 보안성 높음 불필요한 traffic 없음 단점 동기화(= 변화 인지, 수렴, convergence) 문제 Dynamic Routing (동적 라우팅) 자동 학습 라우팅 통신하려는 장비의 ip를 Routing Table에서 경로의 현재 상태에 따라 경로를 자동으로 조정함 하나의 경로가 다운되면 네트워크 대상에 도달하도록 자동 조정 Router는 경로를 교환하기 위해 동일한 동적 프로토콜을 실행해야함 Router가 토플로지에서 변경 사항을 감지하면 다른 모든 라우터에게 알림 네트워크 전체의 규모가 크거나 구성을 자주 변경해야 하는 경우 사용 PC1과 PC2가 통신하도록 Dynamic Routing 설정 장점 동기화(= 변화 인지, 수렴, convergence)가 빠름 단점 연산 부하 있음 (많은 대역폭 소비) 보안성 낮음 Routing ProtocolAS (Autonomous System) 인터넷 자율 시스템 고유 번호 (라우터들의 집합) 하나의 관리자가 관리 가능한 네트워크 영역 자율적으로 모아둔 라우터 집합 라우터가 가진 정보를 효율적으로 관리하고 인터넷 서비스를 편리하기 위해 묶음 어떤 하나의 그룹, 기관, 회사와 같이 여러 라우팅으로 이루어진 단위Area area가 2개 이상일 때는 무조건 0번을 거쳐가야 함 area 0 (Backbone Area)를 경유해서 다른 area가 연결 됨 area를 기준으로 경로 축약 area 0과 붙어 있는 다른 area는 routing 가능 area 0과 떨어진 다른 area는 routing 불가 AD (Administrative Distance : 관리자와의 거리) 관리자가 바라보는 라우팅 최소 거리 우선 순위 AD Routing 0 connect interface 1 static 90 eigrp 110 ospf 120 rip Routing Protocol 라우터 간 통신 방식을 규정하는 통신 규약Routing Protocol Metric 단위/유형 Routing Protocol Metric 단위/유형 RIP Hop(1~15) IGRP Bandwidth, Deplay, Reliability, Load, MTU EIGRP Bandwidth, Deplay, Reliability, Load, MTU OSPF Cost IS-IS Cost Dynamic Routing Protocol(EGP/IGP) 인접 라우터들과 주기적으로 라우팅 테이블을 교환해 자신의 정보 변화 여부 확인, 관리 EGP(Exterior Gateway Protocol) 외부 gateway 프로토콜 (AS간의 통신) AS의 외부 목적지로 가기 위해 gateway 찾는것 외부 AS간 연결해주는 protocol BGP IGP(Interior Gateway Protocol) 내부 gateway 프로토콜 (AS 간의 통신) AS의 내부 목적지로 가기 위해 gateway 찾는 것 같은 AS 내부의 경로 제어에 이용되는 protocol 우선 순위는 AD 번호 기준 distance vector(RIP/EIGRP)와 link state(OSPF/IS-IS)로 나뉘어짐 Distance Vector Routing Protocol 목적지까지 거리 + 어떤 인접 라우터를 거쳐가야 하는지에 대한 방향만 저장(거리 방향에 대한 수식화) 라우터를 지날 때마다 TTL (Time to Live)값 소모 혼선을 없애기 위해 일정 시간이 지나면 패킷을 죽임 패킷에 대한 유예 기간 지급 (TTL) Bellman ford algorithm RIP(v1/v2) RIP v1 RIP v2 Classful Routing Protocol Classless Routing Protocol IP 학습 Subent 학습 VLSM지원 X VLSM지원 O No authenticatin support(인증 알고리즘 미지원) plain text/md5 라우팅 업데이트 보안 처리(인증 추가) Broadcast를 사용하여 광고 Multicast를 사용하여 광고 자동 축약 O 자동 축약 O 수동 축약 X 수동 축약 O Distance Vector Routing 거리 방향 라우팅 홉의 수를 세어서 거리 측정 최대 15홉까지 허용 소규모 네트워크에 사용 라우팅 업데이트 주기 30초 PC1, PC2, PC3, PC4가 통신하도록 RIP Routing 설정 RIP v1 # R1 global moderouter rip # rip설정# R1 router configuration modenetwork 1.0.0.0 # 자기 주소 광고network 10.10.10.0 # 자기 주소 광고network 192.168.1.0 # 자기 주소 광고no auto-summary # 수동 축약 사용하기 위한 옵션, 상세 서브넷 정보 전달​# R2 global moderouter rip # rip설정# R2 router configuration modenetwork 1.0.0.0 # 자기 주소 광고network 20.20.0.0 # 자기 주소 광고network 192.168.2.0 # 자기 주소 광고no auto-summary # 수동 축약 사용하기 위한 옵션, 상세 서브넷 정보 전달 RIP v2 # R1 global moderouter rip # rip설정# R1 router configuration modenetwork 1.0.0.0 # 자기 주소 광고network 10.10.10.0 # 자기 주소 광고network 192.168.1.0 # 자기 주소 광고version2 # version2 입력 시 RIPv2 사용 no auto-summary # 수동 축약 사용하기 위한 옵션, 상세 서브넷 정보 전달# R1 privilege modeshow ip route # 라우팅 테이블 확인​# R2 global moderouter rip # rip설정# R2 router configuration modenetwork 1.0.0.0 # 자기 주소 광고network 20.20.0.0 # 자기 주소 광고network 192.168.2.0 # 자기 주소 광고version2 # version2 입력 시 RIPv2 사용 no auto-summary # 수동 축약 사용하기 위한 옵션, 상세 서브넷 정보 전달# R2 privilege modeshow ip route # 라우팅 테이블 확인 EIGRP(Enhanced Interior Gateway Routing Protocol) EIGRP Packet Role hello 이웃 관계를 성립 (multicast 224.0.0.10), hello 주기 3배동안 응답 없을 시 hold time 진행 update 라우터 정보 전송 query(질의) 이웃 라우터에서의 정보 요청 패킷 reply query에 대한 응답 (unicast) ack update, query, reply 패킷의 수신 응답 강화 내부 경로 제어 통신 규약 RIP의 확장형 변화에 가장 빠름(convergence time 빠름) CISCO에서 만든 전용 routing protocol 여러 라우팅 기술 사용 가능 VLAN 가능(classlsess routing protocol : VLSM &amp; CIDR 사용 가능) distance vector와 link state의 장점 결합 unequal cost load balancing 지원(메트릭이 달라도 부하 분산 가능) 기본 split horizon (한쪽만 보내기) 혼합 메트릭 홉 100까지 가능 metric : 라우터가 목적지에 이르는 여러 경로 중 최적의 경로를 결정하는데 cost를 숫자로 표현해 서열 정할 수 있도록 하는 변수 PC1, PC2가 통신하도록 EIGRP Routing 설정 # R1 global moderouter eigrp 90 # eigrp 설정 {ROUTER_ID}# R1 router configuration modenetwork 10.0.0.0 255.0.0.0 # 자기 주소 광고 network {NW대역} {NETMASK}network 1.0.0.0 255.0.0.0 # 자기 주소 광고 network {NW대역} {NETMASK}no auto-summary # 수동 축약 사용하기 위한 옵션, 상세 서브넷 정보 전달# R1 privilege modeshow ip eigrp neighbors # 이웃 정보 확인show ip eigrp topology # 네트워크 망 확인show ip route # 라우팅 테이블 확인debug eigrp packet # 패킷 송수신 모니터​# R2 global moderouter eigrp 90 # eigrp 설정 {ROUTER_ID}# R2 router configuration modenetwork 1.1.1.2 0.0.0.0 # 자기 주소 광고 {NW대역} {NETMASK}network 20.20.20.2 0.0.0.0 # 자기 주소 광고 {NW대역} {NETMASK}no auto-summary # 수동 축약 사용하기 위한 옵션, 상세 서브넷 정보 전달# R2 privilege modeshow ip eigrp neighbors # 이웃정보확인show ip eigrp topology # 네트워크 망 확인show ip route # 라우팅 테이블 확인debug eigrp packet # 패킷 송수신 모니터 장점 Routing Table 줄일 수 있어 메모리 절약, 간단한 라우팅 구성 단점 시간마다 Routing Table 업데이트 발생 해 트래픽 낭비 변화 발생 시 모든 라우터 경로 알 때까지 convergence time(수렴 시간) 발생 Link-state Routing Protocol 짧은 경로 최적 경로 학습 LSA (Link State Advertisement)를 사용하는 Shortest Path First Free 구축 광고를 던져주고 그 광고를 가장 빨리 받는 네트워크, 최단 루트를 찾아서 연결 dijkstra algrithm OSPF(Open Shortest Path First) IETF (Internet Engineering Task Force) 표준 (국제 인터넷 표준화 기구) LSA(Link State Advertisement 광고 패킷)을 통해서 Link State Database 구축 규모가 크고 성장하는 Network를 위해 고안 변화 시에만 Multicast(224.0.0.5)로 업데이트하기 때문에 대역폭 사용 적음 누적 cost를 기반으로 최단 경로 계산(cost = 10^8 / bandwidth) area 안에서만 Routing이 가능함 (area 0이 우선) dijkstra 알고리즘 이용해 최적 경로 계산 area 단위로 대규모 네트워크 안정되게 운영 PC1, PC2, PC3, PC4가 통신하도록 OSPF Routing 설정 # R1 global moderouter ospf 110 # ospf 설정 {ROUTER_ID}# R1 router configuration modenetwork 10.10.10.0 0.0.0.255 area 0 # 자기 주소 광고 {NW대역} {WILDCARD} {AREA}network 1.1.1.1 0.0.0.0 area 0 # 자기 주소 광고 {IP} {WILDCARD} {AREA}# R1 privilege modeshow ip ospf neighbor # interface별 neighbor 정보 표시show ip route # routing table 확인show ip ospf interface # area-ID와 neighbor 인접성 표시 (cost 값 확인)show ip ospf database # ospf 정보보기debug ip ospf adj # 광고 내용 보기​# R2 global moderouter ospf 110 # ospf 설정 {ROUTER_ID}# R2 router configuration modenetwork 1.1.1.2 0.0.0.0 area 0 # 자기 주소 광고 {IP} {WILDCARD} {AREA}network 2.2.2.1 0.0.0.0 area 100 # 자기 주소 광고 {IP} {WILDCARD} {AREA}network 20.20.20.254 0.0.0.0 area 100 # 자기 주소 광고 {IP} {WILDCARD} {AREA}network 40.40.40.254 0.0.0.0 area 100 # 자기 주소 광고 {IP} {WILDCARD} {AREA}# R2 privilege modeshow ip ospf neighbor # interface별 neighbor 정보 표시show ip route # routing table 확인show ip ospf interface # area-ID와 neighbor 인접성 표시 (cost 값 확인)show ip ospf database # ospf 정보보기debug ip ospf adj # 광고 내용 보기​# R3 global moderouter ospf 110 # ospf 설정 {ROUTER_ID}# R3 router configuration modenetwork 2.2.2.2 0.0.0.0 area 100 # 자기 주소 광고 {IP} {WILDCARD} {AREA}network 3.3.3.1 0.0.0.0 area 150 # 자기 주소 광고 {IP} {WILDCARD} {AREA}network 30.30.30.254 0.0.0.0 area 150 # 자기 주소 광고 {IP} {WILDCARD} {AREA}# R3 privilege modeshow ip ospf neighbor # interface별 neighbor 정보 표시show ip route # routing table 확인show ip ospf interface # area-ID와 neighbor 인접성 표시 (cost 값 확인)show ip ospf database # ospf 정보보기debug ip ospf adj # 광고 내용 보기​# R4 global moderouter ospf 110 # ospf 설정 {ROUTER_ID}# R4 router configuration modenetwork 3.3.3.2 0.0.0.0 area 150 # 자기 주소 광고 {IP} {WILDCARD} {AREA}# R4 privilege modeshow ip ospf neighbor # interface별 neighbor 정보 표시show ip route # routing table 확인show ip ospf interface # area-ID와 neighbor 인접성 표시 (cost 값 확인)show ip ospf database # ospf 정보보기debug ip ospf adj # 광고 내용 보기 OSPF Packet Packet Type OSPF Packet Role 1 Hello neighbor 구성 유지 및 관리 (hello 10, dead 40) 2 Databse Description 라우터 정보 전송 3 Link State Request 데이터베이스 상세 내용 요청 4 Link State Update 데이터베이스 업데이트 5 Link State ACK ACK(응답) 전송 (정상 수신) Hello OSPF의 neighbor 유지 및 관리 일정시간 간격에 따라 Hello packet을 보내서 neighbor 관계를 확인 Hello packet에 대한 응답이 없으면 neighbor 관계를 해지 Router-ID : OSPF Router를 구분 Area-ID : OSPF Area를 구분 Password : OSPF간 인증 수행 시 사용 Subnet mask Hello Time : Hello packet을 송신하는 주기 10 sec : broadcast, point-to-point 30 sec : multicast Stub Area Flag : 다른 Area의 routing information을 차단 Router Priority : DR/BDR 선출에 사용 Dead Time : Hello Packet을 수신 X시 router간 연결 해제로 보는 주기 default : Hello Time X 4회 DR Priority = 1 OSPF의 routing table 전달을 관장 BDR Priority = 1 &lt; BDR DR의 보조 역할 Neighbor List : neighbor에 있다고 보는 Router-ID Database Description LSA, DDP(Database Description Packet) 정보를 저장 → Link State Database DDP LSA의 요약 정보 neighbor 간 교환 시 DDP 선발송 update 내용 있는 경우에 LSA 발송 Link State Request (LSR) neighbor update를 요청하는 router가 DDP 정보를 발신 수신 router는 DDP 정보를 확인 update할 것이 있으면 송신 측에 LSA를 요청 (LSR 발송) Link State Update (LSU) 상대에게 LSR을 수신하거나 Link State의 변화가 있을 때, routing information을 전송 LSA를 실어나르는 packet Link State Ack (LS ACK) OSPF packet을 정상적으로 수신했다고 알려주는 packet DDP, LSR, LSU packet의 수신 시 필수 OSPF Router Type Backbone Router : area 0 IR (Internal Router) : area 0가 아닌 것, area 내 포함 라우터 ABR (Area Border Router) : area 0와 area 0가 아닌 것이 공존하는 router, area 경계 router ASBR (Autonomous System BR) : area 0와 다른 router type 간의 재분배 router, 다른 AS 경계에 있는 router ASBR/ABR : area 경계와 AS 경계 모두 있는 경우 IS-IS 장점 link 변화가 발생해도 확인하는 시간이 짧음 table 교환이 자주 발생하지 않음 변화 있는 table만 교환해 트래픽 감소 단점 메모리 소모가 큼 CPU가 많은 일을 해야함 비싸다 → 고용량 라우터에 적합 OSPF DR/BDR/DROTHERLSA 정보 통신 방법 LSA(Link State Advertisement)정보를 교환할 때 토플로지가 복잡해질수록 네트워크 운영이 어려워짐 이를 보완하여 OSPF를 BR과 BDR로 나누어 설계 DRother는 멀티캐스트를 통해 DR과 BDR에게 전송 LSA 정보는 DR를 통해서만 전송OSPF DR/BDR/DROTHER DR (Design Router) 지정 라우터 Router - ID 가장 높은 것, 반장 priority = 1 LSA의 중개 BDR (Backup Designed Router) 백업 지정 라우터, 부반장 priority &gt; 1 DR에 장애 발생 시 DR 역할 수행 DROTHER DR, BDR이 아닌 나머지 라우터 정보 교환 없음 DROTHER 간 2way priority = 0 OSPF DR/BDR/DROTHER 우선 순위 선정 방식 OSPF 우선도 우선 순위가 가장 높은 라우터가 DR, 다음 순위의 라우터가 BDR OSPF Router ID 높은 순 OSPF 우선 순위가 모두 동일하면, Router ID가 높은 것이 DR, 다음이 BDR Router-ID = 지정한 Router-ID → Loopback 높은 IP → Interface 높은 IP (물리 주소) OSPF DR/BDR/DROTHER 선출 방식 중복된 LSA와 ACK를 방지 Multi-Point Access Mode에서만 선출 point-to-point는 환경에서 선출 X 선출 후 더 높은 priority router 추가해도 재선출 X router 재부팅이나 clear ip ospf process 사용해야함 DR이 다운되면 BDR이 DR이 되고, BDR을 새로 선출 OSPF DR/BDR/DROTHER 재선출 # privilege modeint {INTERFACE}ip ospf priority {NUM} # priority 별도 설정 X → default : 1clear ip ospf process # 재선출 (장비 재부팅, DR 또는 BDR의 priority가 0으로 변경 시) OSPF Adjacent Neighbor OSPF routing information을 서로 주고 받는 것 ex) EIGRP : 모든 Neighbor DRother끼리만 아니면 해당 DR과 다른 Router BDR과 다른 Router Point-to-Point 방식 Point-to-Multi Point 방식 Virtual Link (GRE) OSPF Neighbor Status Down OSPF 설정 후 송신 단에서 Hello Packet을 보냈으나 수신 단에서 응답이 없는 상태 연결이 안된 상태 Attempt Non-Broadcast일 때만 적용 지정한 neighbor에게서 Hello Packet을 수신하지 못한 상태 Init neighbor에서 Hello Packet은 수신 했으나 송신 측에서 보낸 Hello Packet은 수신 측에서 받지 못한 상태 Two-Way neighbor 간 상호 통신이 가능한 상태 Router-ID가 상호 등록된 상태 DR/BDR 선출 과정 Exstart Master/Slave Router 선출 Exchange LSA 헤더를 전송하는 상태 Loading DDP 교환할 내용이 있으면 LSA의 전체 내용을 보내서 교환 중인 상태 Full 교환을 마치고 실질적으로 통신이 진행 가능한 상태 OSPF Network Route OSPF의 AD 값은 110이지만 같은 AD 값이 존재할 때는 Priority (우선 순위)를 기준으로 경로를 산정 Intra-Area Router 동일 Area 내에 속한 Network Code : O Priority : 1 2. Inter-Area Router 다른 Area 내에 속한 Network Code : O IA Priority : 2 3. Domain Extra Network 변동 Cost를 가진 외부 Network 다른 Routing Protocol에서 OSPF로 재분배 했을 때 (metric을 지정했을 때) Code : O E1 Priority : 3 변동 Cost를 가진 NSSA 외부 Network Code : O N1 Priority : 4 고정 Cost를 가진 외부 Network 다른 Routing Protocol에서 OSPF로 재분배 했을 때 (Default) Code : O E2 Priority : 5 고정 Cost를 가진 NSSA 외부 Network Code : O N2 Priority : 6 OSPF Security Neighbor 인증 평문 # global mode int {INTERFACE_NAME} # config-interface ip ospf authentication ip ospf authentication-key {인증 키 내용} MD5 # global mode int {INTERFACE_NAME} ip ospf authentication message-digest ip ospf message-digest-key {KEY} [md5] {인증 키 내용} Area 인증 *평문 # global mode router ospf {PROCESS_ID} area {AREA} authentication int {INTERFACE_NAME} ip ospf authentication-key {인증 키 내용} MD5 # global mode router ospf {PROCESS_ID} area {AREA} authentication message-digest int {INTERFACE_NAME} ip ospf authentication-key {인증 키 내용} Routing 재분배Routing 재분배 (redistribute) routing protocol이 다른 router에서 routing table의 정보를 공유하는 것 각 routing protocol마다 사용하는 metric을 지정해주어야함 양쪽 라우팅 프로토콜을 둘다 아는 ASBR를 이용하여 재분배를 함 # R1 global mode router rip # rip 설정 # R1 router configuration mode network 30.0.0.1 # {IP} network 192.168.10.30 # {IP} network 192.168.10.14 # {IP} no auto-summary # 수동 축약 # R1 privilege mode show ip route # routing table 확인 # R2 global mode router rip # rip 설정 # R2 router configuration mode network 30.0.0.2 # {IP} no auto-summary # 수동 축약 # R2 global mode router ospf 110 # ospf 설정 {ROUTER_ID} # R2 router configuration mode network 20.0.0.2 0.0.0.0 area 1 # {IP} {WILDCARD_MASK} {AREA_NUM} network 10.0.0.2 0.0.0.0 area 0 # {IP} {WILDCARD_MASK} {AREA_NUM} # R2 global mode router eigrp 90 # eigrp 설정 {ROUTER_ID} # R2 router configuration mode network 40.0.0.2 0.0.0.0 # {IP} {WILDCARD_MASK} no auto-summary # 수동 축약 # R2 privilege mode show ip route # routing table 확인 # R3 global mode router ospf 110 # ospf 설정 {ROUTER_ID} # R3 router configuration mode network 10.0.0.1 0.0.0.0 area 0 # {IP} {WILDCARD_MASK} {AREA_NUM} network 192.168.0.65 0.0.0.0 area 0 # {IP} {WILDCARD_MASK} {AREA_NUM} # R3 privilege mode show ip route # routing table 확인 # R4 global mode router ospf 110 # ospf 설정 {ROUTER_ID} # R4 router configuration mode network 20.0.0.1 0.0.0.0 area 1 # {IP} {WILDCARD_MASK} {AREA_NUM} network 172.16.47.254 0.0.0.0 area 1 # {IP} {WILDCARD_MASK} {AREA_NUM} # R4 privilege mode show ip route # routing table 확인 # R5 global mode router eigrp 90 # eigrp 설정 {ROUTER_ID} # R5 router configuration mode network 40.0.0.1 0.0.0.0 # {IP} {WILDCARD_MASK} network 10.0.0.254 0.0.0.0 # {IP} {WILDCARD_MASK} network 192.168.15.254 0.0.0.0 # {IP} {WILDCARD_MASK} no auto-summary # 수동 축약 # R5 privilege mode show ip route # routing table 확인 # PC끼리 ping 확인 → 같은 routing 프로토콜끼리만 통신 # ASBR router에만 설정 router rip # RIP 재분배 설정 redistribute eigrp 90 metric 1 # eigrp와 재분배 설정 redistribute ospf 110 metric 1 # ospf와 재분배 설정 router eigrp 90 # EIGRP 재분배 설정 redistribute rip metric 1 1 1 1 1 # rip과 재분배 설정 metric {BW} {Dlay} {load} {reliability} {MTU} redistribute ospf 110 metric 1 1 1 1 1 # ospf와 재분배 설정 metric {BW} {Dlay} {load} {reliability} {MTU} router ospf 110 # OSPF 재분배 설정 redistribute rip subnets # rip과 재분배 설정 redistribute eigrp subnets # eigrp와 재분배 설정 ​RIP의 재분배# global moderouter rip# router configuration moderedistribute eigrp {AS_NUM} metric 1redistribute ospf {PROCESS_ID} metric 1EIGRP의 재분배# global moderouter rip# router configuration moderedistribute rip metric 1544 20000 1 255 1500 # {BW} {delay} {load} {reliability} {MTU}redistribute ospf {PROCESS_ID} metric 1544 20000 1 255 1500 # {BW} {delay} {load} {reliability} {MTU}show interface serial/fastethernet # metric값 내용 보기 {BW} {delay} {load} {reliability} {MTU}OSPF의 재분배# global moderouter ospf {PROCESS_ID}# router configuration moderedistribute rip subnetsredistribute eigrp {AS_NUM} subnets" }, { "title": "Cisco Packet Tracer 설정 및 CLI 명령어", "url": "/posts/packet-tracer/", "categories": "Network", "tags": "network, packet tracer", "date": "2022-11-10 23:40:00 +0900", "snippet": "Cisco Packet Tracer 구성Cisco Packet Tracer Cisco에서 제공하는 네트워크 실습 프로그램 Cisco Packet Tracer DownloadCable 구성 Packet Tracer Cable 실선 다른 계층 장비 연결 시 direct cable 연결 점선 같은 계층 장비 연결시 cross cable 연결 Router 내부 구조 및 부팅 순서Router 내부 구조 ROM(Read Only Memory) 읽기 전용, 비휘발성 POST(Power On Self Test) CPU, 메모리, 인터페이스 운영 상태 점검 0x2102 : 로드 하는 값 0x2142 : 로드 하지 않는 값 BootStrap 시스코 장비 부트로더, ROM을 활성화함 RAM(Random-Access Memory) 읽기 쓰기 가능, 현재 운영 중인 설정, 휘발성 running-config 라우터 부팅 후 작업 설정 내용 NVRAM(Non-volatile Random-Access Memory) 비휘발성 RAM, 저장 된 설정 startup config 실제 라우터 부팅 시 설정 내용 config-register Router Mode 결정 0x2102 : 기본 값 0x2142 : 복구 모드 Flash Memory(IOS) 읽고 쓰기가 가능한 비휘발성 memory IOS(Internetwork Operating System) 운영 체제, 프로그램 Router 부팅 순서 POST(Power On Self Test) Bootstrap Load(Boot Loader) config-register IOS locate(Flash 저장된 IOS 찾기) IOS loading router 제어권을 IOS가 획득 startup-config에 내용 적용 CLI 창을 진행하는 내용이 runnig-config에 임시 저장됨 Router Prompt ModeRouter mode 설정 prompt mode description &gt; user mode 사용자 모드 # privilege mode 관리자 모드 (장비 사용, 권한 부여) config)# global mode 전역 설정 모드 (실제 장비 설정) config-if)# config-interface 인터페이스 설정 모드 config-line)# line configuration mode 관리 포트 설정 모드 config-router)# router configuration mode 라우팅 프로토콜 설정 모드 모드 변경 # user mode → privilege modeenable # privilege mode → user modeexit # privilege mode → global modeconfig terminal # global mode → privilege modeexit # global mode → config-interfaceinterface fast ethernet 0/0 # config-interface → global mode exit interface mode 확인 명령어 인터페이스 장치 상태 확인 # config-interface modedo show ip int bri RAM 정보 확인 # config-interface modedo show running-config NVRAM 정보 확인 # config-interface modedo show startup-config routing table 정보 확인 # config-interface modedo show ip route router의 전체적인 정보 확인 # config-interface modedo show run do 일시적으로 관리자 모드 사용 가능 privilege mode 확인 명령어 인터페이스 장치 상태 확인 # privilege modehow ip int bri RAM 정보 확인 # privilege modehow running-config NVRAM 정보 확인 # privilege modehow startup-config routing table 정보 확인 # privilege modehow ip route router의 전체적인 정보 확인 # privilege modehow run Router 복구Router 복구 모드 (모든 설정 초기화) 라우터 재부팅 하면서 ctrl + c 버튼으로 Rommon 모드 진입 confreg 0x2142 # reg 값 복구 모드로 변경 reset # 장비 재부팅 enable conf t config-register 0x210 end copy run star Router 고급 복구 모드(설정 유지 = 비번만 없애기) 라우터 재부팅 하면서 ctrl + c 버튼으로 Rommon 모드 진입 confreg 0x2142 # reg 값 복구 모드로 변경 reset # 장비 재부팅 enable conf t config-register 0x2102 end copy start run conf t no enable password/secret lint console 0 no login local # 비번 없애기 적용 no enable password # 비번 없애기 end copy run start # 불러온 내용 수정 후 다시 저장 # 재부팅 Router hostname 및 password 설정Router hostname 설정# global modehostname {HOST_NAME}Router 관리자 비밀번호 설정# global modeenable password {PASSWORD}enable secret {PASSWORD}service password-encryption # 모두 암호화Router 관리자 비밀번호 해제# global modeno enable password-encryption저장 명령어# privilege modecopy running-config startup-config # 휘발성 메모리를 비휘발성 메모리에 복사reload # 재부팅해서 확인Router IP 설정ip 설정# user mode\tenable# privilege modeconf t# global modeint fa0/0 # ip 설정 할 인터페이스에 진입# config-interfaceip add {IP} {NETMASK} # ip와 netmask 입력no shut # 인터페이스 활성화ip 자동 할당# user mode\tenable# privilege modeconf t# global modeint fa0/0 # ip 설정 할 인터페이스에 진입ip add dhcp # ip 자동 할당ip 설정 삭제# user mode\tenable# privilege modeconf t# global modeint fa0/0 # ip 삭제 할 인터페이스에 진입# config-interfaceno ip add # ip 삭제no shut # 인터페이스 활성화 # user mode\tenable# privilege modeconf t# global modeint fa0/0 # ip 삭제할 인터페이스에 진입# config-interfaceshut # 비활성화 Router Console 설정CDP(Cisco Discovery Protocol) 명령어 CDP 시스코 장비들이 동일 링크 상에 있는 다른 장비 등을 찾는 시스코 독점 프로토콜 (표준 프로토콜 : LLDP) # privilege modeshow cdp neighbors # 인접해있는 장비 확인 가능show cdp entry * # cisco 장비의 인접해있는 장비를 자세히 보여줌 Console(장비) 설정 console mode 진입 # global mode line console 0 비밀번호 설정 여부 확인 # line configuration mode login Password 인증 # line configuration mode password {PASSWORD} # console 접속시 비밀번호 설정 login # 비밀번호 설정 적용 Local 인증 # global mode username {USER_NAME} password {PASSWORD} # ID와 PW 설정 # line configuration mode login local # config 모드에서 설정한 ID/PW 설정 적용 미인증 # line configuration mode no password no login 오랜시간 자리를 비워도 세션이 끊기지 않도록 설정(분 초) ```shell # line configuration mode exec-timeout 0 0 명령어 입력 도중에 시스템 메시지 표시하지 않도록 설정 # line configuration mode logging synchronous Telnet 설정 telnet 같은 서비스가 접속할 수 있는 가상포트 0~4(5개) 설정 # global mode line vty 0 4 비밀번호 설정 여부 확인 # line configuration mode login Password 인증 # line configuration mode password {PASSWORD} # 가상 포트 접속시 비밀번호 설정 login # config 모드에서 설정한 비밀번호 설정 적용 Local 인증 # global mode username {USER_NAME} password {PASSWORD} # ID와 PW설정 # line configuration mode login local # ID/PW 설정 적용 미인증 # line configuration mode no password # line configuration mode no login 오랜시간 자리를 비워도 세션이 끊기지 않도록 설정(분 초) exec-timeout 0 0 명령어 입력 도중에 시스템 메시지 표시하지 않도록 설정 logging synchronous ​ IOS 백업 및 복구IOS 백업(TFTP에 설정 파일 저장) 버전 확인 # privilege mode show version Flash 메모리를 TFTP 서버로 백업 # privilege mode copy flash: tftp: show flash로 Flash 메모리명 확인해 입력 # privilege mode source filename []? # c2600-i-mz.122-28.bin 복사할 서버 ip 입력 # privilege mode address or name of remote host[] # xxx.xxx.xxx.xxx 파일 이름 정해서 입력 # privilege mode Destination filename[c2600-i-mz.122-28.bin]? # R1_IOS TFTP에 설정 파일 복사 # privilege mode copy start tftp: IOS 복구 (TFTP 사용) Rommon Mode로 접속 router의 IP 주소 입력 IP_ADDRESS=192.168.1.254 router의 서브넷 마스크 IP_SUBNET_MASK=255.255.255.0 tftp 서버의 IP/router의 IP DEFAULT_GATEWAY=192.168.1.254 tftp 서버의 IP TFTP_SERVER=192.168.1.100 IOS 파일 이름 TFTP_FILE=R1_IOS 복구 모드 tftpdnld tftpdnld router의 IOS 이미지가 깨져서 Rommon Mode로 부팅했을 경우 사용하는 복구 모드 재부팅원격 접속SSH 암호화 원격 접속 global mode로 진입 # user mode\t enable # privilege mode conf t ssh 접속 시 사용 될 user ID/PW 설정 # global mode username {USER_NAME} password {PASSWORD} RSA 공개 키 만들기 위해 도메인명 지정 (보통 라우터 이름 사용) # global mode ip domian-name {DOMAIN_NAME} 암호화 키(RSA) 생성 (1024byte 이상에서만 가능) # global mode crypto key generate rsa ssh2 버전 사용 (보안성 높음) # global mode ip ssh version telnet 설정 # global mode line vty 0 4 config 모드에서 설정한 ID/PW 적용 # line configuration mode login local 가상 터미널 (원격) 접속 프로토콜을 ssh만 허용, 암호화 key 적용 # line configuration mode transport input ssh 키 값 생성 확인 # privilege mode show crypto key mypubkey rsa show ssh telent 접속 확인 # privilege mode telnet {ROUTER_IP} # ssh만 허용했기 때문에 telnet 접속 제한 상태 ssh telnet 이용해 접속 # privilege mode ssh -l [] {ROUTER_IP} -l 로그인 시 사용될 유저 ID 설정 저장 # privilege mode exit copy running-config startup-config " }, { "title": "LAN과 WAN", "url": "/posts/lan-wan/", "categories": "Network", "tags": "network", "date": "2022-11-04 01:30:00 +0900", "snippet": "통신망과 장치LAN(Local Area Network) 근거리 통신망 ex) 강의실, 사무실 Switch(2계층 장비)와 Router (3계층 장비) 사용 비용 적고 속도 빠름 사설 업체 사용, 관리 ethernet(10M), fast ethernet(100M), Giga Ethernet baseband : 기저대역,협대역 LAN cable 사용 : UTP(인터넷)/STP(현장)WAN(Wide Area Network) 원거리 통신망 ex) 지역 - 지역, 국가 - 국가 Router (3계층 장비)로 clock rate (DCE → DTE) 시간 맞춰서 통신 비용 크고 속도 일정 여러개의 LAN을 Serial로 연결 (DTE/DCE) ISP 업체 사용,관리 broadband : 광대역(다양한 신호, 장거리) DTE(Data Terminal Equipment) 데이터가 지나가는 신호 변환 장치 컴퓨터나 단말 장치의 데이터를 통신 회선에 적합한 신호로 변경하거나, 통신 회선의 신호를 컴퓨터나 단말 장치에 적합한 데이터로 변경하는 신호 변환 기능 수행 DCE(Data Circuit Equipment) 상대방과 통신을 위한 장비나 모델 등 단말 장치 데이터 통신 시스템과 외부 사용자의 접속점에 위치하여 최종적으로 데이터를 입출력 입출력, 전송 제어, 기억 기능 Bandwidth와 속도통신 회선 단말장치에서 단말장치에 입력된 데이터 또는 컴퓨터에서 처리된 결과가 실질적으로 전송되는 전송 선로 유선ex) 꼬임선, 동축 케이블, 광섬유 케이블 등 무선 ex) 라디오파, 지상 마이크로파, 위성 마이크로파Bandwidth 전송 폭 일정한 시간 동안 보낼 수 있는 데이터 최대 용량 실제 전송 속도에 영향 X 1544/128/64값 보통 지정 데이터가 넘어갈 수 있는 단위 지정 최대 전송 대역폭 단위에 대한 세기​- EIGRP Bandwidth 구하는 공식 10^10 / (Bandwidth 값 X 1000)ex) 10^7 / 1544 = 6476 MTU(Max Transfer Unit) 최대 전송 단위 네트워크에서 전송 가능한 최대 크기 (일반적으로 1500) 속도 관련Clock Rate 전송 속도 128,000/64,000값 보통 지정 serial 링크의 초당 비트 전송 속도를 지정 주기적으로 보내는 라우터의 신호를 일정하게 함 serial port에서 사용Encapsulation(HDLC/PPP) Serial 통신 프로토콜의 한종류 HDLC 신호 동기화 방식으로써 시스코 장비끼리 연결 시 사용 (시스코 전용) PPP (Point to Point) 시스코 장비와 이외의 장비들과 연결 시 사용 (공용) 보통 WAN에서는 ppp사용 보안 및 여러 계층 제어 가능 " }, { "title": "Raid Level과 구축", "url": "/posts/raid/", "categories": "OS, Linux", "tags": "os, linux, raid", "date": "2022-11-04 01:00:00 +0900", "snippet": "Raid와 Raid LevelRaid(Redundant Array of Independent Disk) 2개 이상의 디스크를 병렬로 처리하여 성능 및 안정성을 향상시키는 방식 디스크 오류나 데이터 손실 등 장애에 대비하기 위해 복수의 디스크를 구성하는 방식 동일한 데이터를 여러 개의 디스크에 중복 저장하면서, 운영 체제에서는 하나의 단일 디스크로 인식Raid Level 레벨 방식 최대 하드 수 구성 설명 0 하드 연결 (stripe) 2개 이상 100M + 100M = 200M 단순 하드 연결, 하드 이중화 1 동기화 (mirroring) 2개 이상 100M + 100M = 100M 동기화 된 하드 대체 연결 (spair) 2 백업 + DATA를 각각 사용 2개 이상 100M + 100M = 100M 백업된 내용으로 복구 (사용 안함) 3 패리티 영역 추가 (byte) 3개 이상 100M + 100M + 100M = 200M 오류 기록 하드 영역 1개 추가, 한개의 하드 에러 시 복구, 패리티 영역 손상 시 복구 불가 4 패리티 영역 추가 (block) 3개 이상 100M + 100M + 100M = 200M 오류 기록 하드 영역 1개 추가, 한개의 하드 에러 시 복구, 패리티 영역 손상 시 복구 불가 5 각 하드에 분산 패리티 영역 할당 3개 이상 100M +100M + 100M(p) = 200M 패리티 영역을 각 하드디스크에 분산시킴, 랜덤한 하드 1개의 손상에 대한 복구 가능 6 각 하드에 분산 패리티 영역 할당 4개 이상 100M + 100M + 100M(p) + 100M(p) = 200M 패리티 영역을 각 하드 디스크에 분산시킴, 랜덤한 하드 2개의 손상에 대한 복구 가능 RAID 0 (Striping) 두개 이상의 디스크에 데이터를 순차적으로 저장하는 방식 (데이터 분산 처리) 복수 개의 디스크에 데이터를 분산해 처리 패리티 (오류 검출기능) 없이 striping 형태 장점 처리속도 향상 단점 하나의 디스크에 문제가 발생하면 raid 0으로 구성된 모든 데이터 유실 RAID 1 (Mirroring) 데이터 처리 시, 동일한 디스크에 똑같이 저장하는 방식 (데이터 복제) 데이터 중복 기록하여 저장 mirroring 장점 디스크 장애 및 오류 발생시 다른 디스크를 통해 데이터 쉽게 복구 가능 (가용성, 안정성 ↑) 단점 중복 저장하기 때문에 실질적으로 사용할 수 있는 용량 줄어듬 RAID 2 데이터 분산 처리 방식 + 에러체크와 수정할 수 있도록 해밍코드 사용 하드 디스크에서 ECC(Error Correction Code)를 지원하지 않기 때문에 ECC를 별도의 드라이브에 저장함 기록용 드라이브와 데이터 복구용 드라이브 별도로 둠 에러 체크와 수정할 수 있는 Hamming Code 사용 최소 디스크 3개 필요 단점 4개의 하드 디스크에 기록하기 위해 3개의 부가 데이터를 기록해야해 효율성 떨어짐 RAID 3 (Parity) RAID 0 + 패리티 전용 디스크 데이터 분산 처리 방식 사용 + 에러 체크 및 수정을 위한 패리티 정보를 별도의 디스크에 따로 저장 Byte 단위로 데이터 저장 전체 디스크 n개 = 실제 사용 디스크 n - 1개 장점 오류 발생 시 패리티 정보를 통해 복구 가능 단점 패리티 정보가 저장된 디스크 손실 시 복구 어려움 RAID 4 (Parity) RAID 0 + 패리티 전용 디스크 데이터 분산 처리 방식 사용 + 에러 체크 및 수정을 위한 패리티 정보를 별도의 디스크에 따로 저장 Block 단위로 데이터를 저장 전체 디스크 n개 = 실제 사용 디스크 n - 1개 장점 RAID 0 대비 높아진 안정성 RAID 1 대비 뛰어난 성능오류 발생 시 패리티 정보를 통해 복구 가능 단점 패리티 정보가 저장된 디스크 손실 시 복구 어려움 RAID 5 (Distribute Parity) RAID 3, 4의 취약점 (병목 현상) 보완하기 위해 나온 방식 Parity bit를 분산하여 구성하여 병목 현상 줄일 수 O 패리티 정보를 보관하는 디스크 구성 없이 일정한 로직에 의해 데이터 분산 처리 + 에러 체크 서버/워크스테이션에서 가장 많이 사용 기본적으로 HDD 3개 이상 필요 1개의 랜덤한 하드 손상에 대한 복구 지원 Disk 3이 고장났을 경우 Disk 3의 D3, D8, D11를 나머지 Disk의 parity가 알고 있기 때문에 데이터 손실 X 전체 디스크 n개 = 실제 사용 디스크 n - 1개 장점 RAID 4 대비 병목 현상 줄임, 성능, 안정성 모두 고려해 자주 사용 단점 1개의 디스크가 손상 된 후 바로 다른 디스크가 손상이 된다면 전체 디스크 데이터 사용 불가 데이터를 읽을 때 흩어져 있는 패리티 정보를 갱신하며 읽기 때문에 성능 저하 생김 RAID 6 Parity bit를 두개의 디스크에 두어 안정성 강화 전체 디스크 n개 = 실제 사용 디스크 n - 2개 장점 RAID 4,5 대비 안정성 증가 단점 RAID 4,5 대비 비용 증가, 래피티 정보를 이중으로 저장하기 때문에 쓰기 작업 구현이 복잡 RAID 0 + 1 최소 4개의 디스크 필요 RAID 0(striping)과 1(mirroring) 결합 방식 RAID 0으로 구성된 디스크들을 다시 RAID 1로 구성 4 * n개 디스크 구성시 RAID 1 + 0과 성능 차이 없음 6개 디스크 구성시 1 개의 디스크만 고장도 나머지 디스크까지 데이터 전체 복구해야함 장점 분산 저장을 통한 성능 향상, 데이터 안정성 보장 단점 전체 용량 50%만 사용, 비용 높음 RAID 1 + 0 최소 4개의 디스크 필요 RAID 0(striping)과 1(mirroring) 결합 방식 RAID 1로 구성된 디스크들을 다시 RAID 0으로 구성 4 * n개 디스크 구성시 RAID 0 + 1과 성능차이 없음 6개 디스크 구성시 1개의 디스크가 고장나면 mirroring으로 묶힌 디스크를 통해 데이터 복구 장점 분산 저장을 통한 성능 향상, 데이터 안정성 보장 단점 전체 용량 50%만 사용, 비용 높음 Raid 관련 명령어Raid 생성 mdadm(Multi DeviceADMin) mdadm --create(-C) [raid 장치명] raid 생성할 장치 mdadm --level(-l)=[raid level] raid 레벨 지정 mdadm --raid-devices(-n)=[사용할 device 갯수] [HDD명] [HDD명] HDD 개수, 디바이스 명 mdadm [device명] --add [파티션] raid 장치에 파티션 추가 mdadm --detail(-D) [device명] raid 장치의 상세내역 출력 mdadm --detail --scan mdadm으로 만든 raid 장치 확인 mdadm [raid 장치명] -f [디스크명] 디바이스 비활성 mdadm [raid 장치명] -r [디스크명] 디바이스 삭제 mdadm [raid 장치명] -a [디스크명] 디바이스 추가,교체 mdadm --zero-superblock [HDD] raid 하드 삭제 mdadm --stop(-S) [raid 장치명] raid 장치 비활, 중지 mdadm --run [raid 장치명] raid 장치 작동 Raid 확인 cat /proc/mdstat raid 구동 확인 mdadm --detail -scan [raid 장치명] raid 구동, 동작 확인 fdisk -l [raid 장치명] raid 구축 확인 ls -l [raid 장치명] raid 확인 Raid 장치 해제 umount [raid 장치명] mount 해제 후 삭제 mdadm --stop [raid 장치명] 일정 시간 경과 후 다시 활성화 → 장치 빼거나 0으로 채움 Raid 고정값 설정 mdadm --detail --scan [device] &gt; /etc/mdadm.conf 재부팅 시 raid 숫자 고정 mdadm -D -s [device] &gt; /etc/mdadm.conf 재부팅 시 raid 숫자 고정 vi /etc/mdadm.conf → 장치 추가 재부팅시 raid 숫자 고정 Raid 구축 실습 조건 1GB 하드 디스크 5개 추가 raid 1 설정하고 /raid1 디렉토리에 mount raid 5 설정하고 /raid1 디렉토리에 mount auto mount 설정 하드 디스크 추가 edit virtual machine setting → add→ hard disk → scsi→ HDD 1G 5개 추가→ power on 디스크 확인 fdisk -l mdadm 패키지 설치 yum install -y mdadm* raid level 설정 HDD sd[b-c] 2개 사용해 level 1인 /dev/md1이란 raid 구축 mdadm --create /dev/md1 --level 1 -n 2 /dev/sd[b-c] /dev/md1를 참조하는 모든 작업이 /dev/sd[b-c]로 보내짐 HDD sd[d-f] 3개 사용해 level 5인 /dev/md5이란 raid 구축 mdadm -C /dev/md5 -l 5 -n 3 /dev/sd[d-f] /dev/md5를 참조하는 모든 작업이 /dev/sd[d-f]로 보내짐 raid 장치 확인 mdadm --detail /dev/md1 # raid 장치 md1의 상세 내역 출력, 동작 확인 mdadm -D /dev/md5 # raid 장치 md5의 상세 내역 출력, 동작 확인 Raid Level : raid1, Raid Level : raid5 장치 raid 레벨 확인 Raid Devices : 2, Raid Devices : 3 raid device 개수 확인 0 8 16 0 active sync /dev/sdb, 1 8 32 1 active sync /dev/sdc raid device 확인 0 8 48 0 active sync /dev/sdd, 1 8 64 1 active sync /dev/sde, 3 8 80 2 active sync /dev/sdf raid device 확인 raid 구축 확인 fdisk -l /dev/md1 /dev/md5 raid 프로세스 확인 cat /proc/mdstat md5 : active raid5 sdf[3] sde[1] sdd[0], [3/3] [UUU] md1 : active raid1 sdc[1] sdb[0], [2/2] [UU] raid 장치 추가 및 확인 mdadm -D -s /dev/md1 &gt; /etc/mdadm.conf # raid 1 device 추가 mdadm -D -s /dev/md5 &gt;&gt; /etc/mdadm.conf # raid 5 device 추가 cat /etc/mdadm.conf # 시스템 시작시 raid array 읽는 파일 ARRAY /dev/md1 ARRAY /dev/md5 자동 mount mkdir -p /raid1 /raid5 # mount point로 지정할 directory 생성 mkfs.ext4 /dev/md1 # /dev/md1 파티션을 포맷 mkfs.ext4 /dev/md5 # /dev/md5 파티션을 포맷 blkid | grep md1 # 파일 시스템 타입 구성 확인 # /dev/md1: UUID=\"0747a647-6974-46b7-90c9-4c52b91b9d4f\" TYPE=\"ext4\" blkid | grep md5 # 파일 시스템 타입 구성 확인 # /dev/md5: UUID=\"f13c3b26-b812-44e9-b8dd-df02e9e1f7fd\" TYPE=\"ext4\" vi /etc/fstab # mount 설정을 영구적으로 할 수 있도록 존재하는 설정 파일 UUID=0747a647-6974-46b7-90c9-4c52b91b9d4f /raid1 ext4 defaults 1 2 UUID=f13c3b26-b812-44e9-b8dd-df02e9e1f7fd /raid5 ext4 defaults 1 2 :.!blkid |grep md1 &amp;&amp; blkid |grep md5 # md1, md5 포함 문자열 추출 mount -a # /etc/fstab에 있는 모든 내용 mount df -h # mount 정보 출력 init 6 # 재부팅 후 확인 raid 프로세스 확인 cat /proc/mdstat # raid 프로세스 확인mdadm -D /dev/md1 /dev/md5 # raid 장치 상세 내역 출력, 동작 확인 " }, { "title": "RHCSA RedHat Linux 7 유형별 연습", "url": "/posts/rhcsa/", "categories": "OS, Linux", "tags": "os, linux, rhsca, redhat", "date": "2022-11-01 05:45:00 +0900", "snippet": "root 패스워드 변경 풀이 # e # linux16 줄 끝에 rd.break # ctrl+xmount | grep -w /sysroot # ro확인mount -o remount,rw /sysroot # 읽기쓰기 버전으로 리마운트chroot /sysroot # root를 /sysroot로 변경passwd # 변경할 패스워드 입력touch /.autorelabel # 레이블재지정exitexit hostname 변경 풀이 hostnamectl set-hostname redhat1 # hostname redhat1로 변경hostname # 변경 확인vi /etc/hostname # 재부팅 후에도 적용되는지 확인 NetWork 설정 문제 IP = 192.168.0.11 NETMASK = 255.255.255.0 GW = 192.168.0.1 DNS = 8.8.8.8 풀이 vi /etc/sysconfig/network-script/ifcfg-eth0 # 네트워크 설정 파일 수정 # /etc/sysconfig/network-script/ifcfg-eth0 DEVICE=ens33ONBOOT=yesBOOTPROTO=staticIPADDR=192.168.0.11GATEWAY=192.168.0.1NETMASK=255.255.255.0DNS1=8.8.8.8 systemctl restart network-service # network 데몬 재시작ping 8.8.8.8 # DNS로 ping 확인 GUI 환경 변경 풀이 systemctl get-default # 환경 확인systemctl set-default graphical.target # runlevel 5 GUI 모드로 변경systemctl get-default # 변경 확인 SELINUX 활성화(재부팅 필수) 풀이 vi /etc/selinux/config # /etc/selinux/configSELINUX = enforcing # 원래설정 각주 처리 후, enforcing으로 변경 getenforce # 변경 확인, 재부팅 전이라 적용 안됨setenforce 1 # 재부팅 없이 enforcing 설정getenforce # 변경 확인init 6 # 재부팅 물리 파티션 생성 문제 100MB 물리 파티션 생성, /meet에 mount 하시오 풀이 find /sys -name scan # 가장 마지막 host 내용 드래그echo \"- - -\" &gt; /sys/device/~~ # 마지막 host 내용 붙이기fdisk -l # 추가한 HDD list 확인fdisk /dev/sdb # 추가한 /dev/sdb를 fdisk 명령어를 이용하여 실행 p # 파티션 테이블 출력(현재의 파티션 정보 확인) n # 새로운 파티션 추가 e # extend 파티션 생성 # Enter # Enter # Enter n # 새로운 파티션 추가 l # logical 파티션 생성 # Enter +100M # 100M 파티션 생성 p # 파티션 테이블 출력(현재의 파티션 정보 확인) w # 저장partprobe # 파티션 변경 저장mkfs.ext4 /dev/sdb5 # 포맷mkdir /meet # mount point 생성blkid |grep ext4 &gt;&gt; /etc/fstab # 포맷한 장치 UUID 내용 /etc/fstab 파일에 추가vi /etc/fstab # /etc/fstab UUID /meet ext4 defaults 0 0 # 파일 내용 수정 mount -a # /etc/fstab에 있는 장치 전부 mountfdisk -l # 확인 swap 파티션 문제 150MB swap 파티션 생성 풀이 free -m # swap 파티션 확인fdisk /dev/sdb # 추가한 /dev/sdb를 fdisk 명령어를 이용하여 실행 n # 새로운 파티션 추가 l # logical 파티션 생성 # Enter +100M # 150M 파티션 생성 t # 파티션 type 변경 # Enter 82 # swap 파티션 선택 p # 파티션 테이블 출력(현재의 파티션 정보 확인) w # 저장 partprobe # 파티션 변경 저장mkswap /dev/sdb6 # 포맷swapon /debv/sdb6 # swap 활성화blkid | grep swap &gt;&gt; /etc/fstab # 포맷한 장치 UUID 내용 /etc/fstab 파일에 추가vi /etc/fstab # /etc/fstab UUID swap swap defaults 0 0 # 파일 내용 수정 mount -a # /etc/fstab에 있는 장치 전부 mountswapon -s # swap 적용 확인free -m # swap 파티션 확인 repo 추가 문제 repo http://content.example.com/rhel7.0/x86_64/dvd server.repo 풀이 yum-config-manager --add-repo=http://content.example.com/rhel7.0/x86_64/dvd # repo파일 내용 자동 생성mv http://content.ex~.repo server.repo # repo명 변경vi /etc/yum.repos.d/server.repo # repo 내용 편집 # /etc/yum.repos.d/server.repo[server]name=serverbasurl=http://content~~enabled=1gpgcheck=0 yum clean all # 캐시 삭제yum -y repolist # repolist 설치yum list kernel 업데이트(재부팅 필수) 문제 1 kernel update http://content.example.com/rhel.7.0/x86_6/errata 재부팅 시에도 기본 커널은 업데이트 된 커널 원래 커널은 시스템에서 사용 &amp; 부팅가능 풀이 yum-config-manager --add-repo=http://content.example.com/rhel.7.0/x86_6/errata # repo파일 내용 자동 생성mv http://content.ex~.repo kernel.repo# repo명 변경vi /etc/yum.repos.d/kernel.repo # /etc/yum.repos.d/kernel.repo[kernel]name=kernelbasurl=http://content~~enabled=1gpgcheck=0 yum update kernel # 커널 업데이트grub2-editenv list # 현재 설정 된 부팅 1순위 확인grub2-set-default 0 # 업데이트 된 커널로 부팅할 수 있도록 설정init 6 # 재부팅해야 적용yum list kernel # 커널 2개 존재 확인 문제 2 kernel update만 http://content.example.com/rhel.7.0/x86_6/errata 풀이 uname -a # 커널 정보 확인(업데이트 ver확인)yum list | grep kernel-* # yum list에 커널 정보 확인yum update kernel # 커널 업데이트grub2-editenv list # 현재 설정 된 부팅 1순위 확인grub2-set-default 0 # 업데이트 된 커널로 부팅할 수 있도록 설정init 6 # 재부팅해야 적용 group,user 설정 문제 보조 그룹이 manager인 harry 계정, sara 계정 manager 권한이 없는 sarah 계정 생성, sarah는 로그인 불가능 모든 계정의 패스워드는 test 풀이 ​groupadd manager # 그룹 생성useradd harry # harry 계정 생성 useradd sara # sara 계정 생성 usermod -aG manager harry # manager 그룹에 harry 계정 추가usermod -aG manager sara # manager 그룹에 sara 계정 추가useradd -s /sbin/nologin sarah # 로그인 불가능한 sarah 계정 생성echo test | passwd --stdin harry # harry 계정 비밀번호 test로 설정echo test | passwd --stdin sara # harry 계정 비밀번호 test로 설정echo test | passwd --stdin sarah # harry 계정 비밀번호 test로 설정id harry # 비번 확인id sarah # 비번 확인su - sarah # sarah 계정으로 로그인 불가능 확인 디렉토리 그룹 소유권 문제 /redhat/manager 디렉토리 생성, 그룹 소유권은 manager (자동 설정) manager의 멤버들은 읽고 쓰고 접근 가능, 다른 유저는 불가능 풀이 mkdir -p /redhat/manager # 디렉토리 생성 chgrp manager /redhat/manager # 그룹소유권 manager로 설정 chmod 2770 /redhat/manager # 권한 설정ls -ltr /redhat # 권한 확인 cd /redhat/managertouch abc.txtls -ltr abc.txt # 권한 확인 IP forwarding 활성 풀이 vi /etc/sysctl.conf # /etc/sysctl.confnet.ipv4.ip_forward = 1 # &lt;name&gt;아래에 내용 추가 sysctl -p # 확인 LDAP 인증 문제 LDAP 검색 베이스 dc=example,dc=com LDAP 인증서 파일 http://classroom.example.com/pub/EXAMPLE-CA-CERT ldapuserX는 시스템에 로그인 (X는 도메인 번호) 풀이 ​yum install -y auth* # LDAP 인증 설치 yum install -y authconfig-gtk sssd krv5-workstationyum install -y sssd*autoconfig-gtk dc=example,dc=com ldap=://classroom.example.com TLS http://classroom.example.com/pub/EXAMPLE-CA-CERT LDAP password 선택 풀이 systemctl enable sssd.service # LDAP 인증 데몬 : sssdsystemctl restart sssd.servicegetent passwd ldapuserX # 확인 LDAP 자동 mount 문제 LDAP 사용자의 홈디렉토리를 자동 mount하도록 autofs 구성 classroom.example.com ext4를 /home/guests를 시스템으로 내보냄 LDAP user X의 홈디렉토리 classroom.example.com/home/guests/ldapuserX 홈디렉토리 사용자가 사용 가능 LDAPuser1 ~ 20까지 사용자로 로그인 가능, 시스템 엑세스는 ldapuserX 유일 풀이 yum install -y autofs*mkdir -p /home/guests # mount point 생성vi /etc/auto.master.d/home.autofs # 확장자 무**문제** .autofs # /etc/auto.master.d/home.autofs/home/guests /etc/auto.home vi /etc/auto.home # mount 옵션 설정 # /etc/auto.homeldapuser X -rw,sync, classroom.example.com:/home/guests/ldapuserX systemctl enable autofs.service # autofs 데몬systemctl restart autofs.service # autofs데몬su - ldapuserX # 로그인 확인 passwordcd # 로그인 확인 NTP 문제 classroom.example.com 풀이 yum install -y chrony # NTP 설치vi /etc/chrony.conf # NTP 설정 파일 # 기존 서버 전부 주석처리server classroom.example.com ibrust # 추가 systemctl enable chronyd.service # NTP 데몬systemctl restart chronyd.service # NTP 데몬chronyc sources -V # NTP 도메인 확인 ACL 문제 /etc/fstab 파일을 /var/tmp에 복사하여 /var/tmp/fstab 파일이 루트 사용자가 소유하도록 권한 구성 harry 사용자는 /var/tmp/fstab 읽기, 쓰기 가능 sara 사용자는 /var/tmp/fstab 읽기, 쓰기 불가 다른 모든 사용자는 /var/tmp/fstab 읽기 가능 풀이 cp /etc/fstab /var/tmp/fstab # etc/fstab 파일을 /var/tmp에 복사cd /var/tmplssetfacl -m u:harry: rw- /var/tmp/fstab # /var/tmp/fstab 읽기, 쓰기 가능한 harry 계정setfacl -m u:sara: --- /var/tmp/fstab# /var/tmp/fstab 읽기, 쓰기 불가한 sara 계정setfacl -m o:: r-- /var/tmp/fstab # /var/tmp/fstab 읽기 가능한 다른 모든 계정getfacl /var/tmp/fstab # 확인 LVM 문제 물리 볼륨 생성, 볼륨 그룹 이름 datacontainer 생성, vg 범위는 16MB 50개의 extend 크기로 datacopy 이름을 가진 새 논리 볼륨 작성 파일 시스템 ext4, /datasource에 mount​* 풀이 fdisk -lfdisk /dev/sdb # 추가한 /dev/sdb를 fdisk 명령어를 이용하여 실행p # 파티션 테이블 출력(현재의 파티션 정보 확인)n # 새로운 파티션 추가l # logical 파티션 생성# Enter+1G # 1G 파티션 생성t # 파티션 type 변경# Enter8e # 볼륨 선택(볼륨으로 변경해야 pv 생성 가능)p # 파티션 테이블 출력(현재의 파티션 정보 확인)w # 저장 partprobe # 파티션 변경 저장pvcreate /dev/sdb7 # 물리 볼륨 생성vgcreate -s 16M datacontainer /dev/sdb7 # 16M 볼륨 그룹 datacontainer 생성vgdisplay # 볼륨 그룹 확인lvcreate -l 50 -n datacopy datacontainer # datacontainer에 속한 크기 50 datacopy 논리 볼륨 생성 lvdisplay # 논리 볼륨 확인mkfs.ext4 /dev/datacontainer/datacopy # 포맷 mkdir /datasource # mount point 생성blkid | grep ext4 &gt;&gt; /etc/fstab # 포맷한 장치 UUID /etc/fstab에 추가 vi /etc/fstab # /etc/fstabUUID /datasource ext4 defaults 0 0 mount -a # /etc/fstab에 속한 장치 전부 mountfdisk -l # 확인df -h # mount확인 논리 볼륨 크기 조정 문제 논리 볼륨 데이터 복사 및 파일 시스템 크기를 400MB 조정 파일 시스템 내용 손상 X 풀이 df -Th # ext4 경로 확인umount /datasource/~~~~ # mount 해제e2fsck -f /dev/datacontainer/datacopy # 파일 시스템 이상 유무 검사,조치lvreduce -r -L 400M /dev/datacontainer/datacopy # 파일 시스템 크기까지 같이 조정 mount -a # mountlvs # 확인 user가 소유한 파일 찾기 문제 talsan 유저 id 2985 추가 julice가 소유한 파일 찾아서 /root/findresults 폴더로 복사 풀이 useradd -u 2985 talsan # talsan user id 2985 설정 useradd julice # julice user 추가 mkdir -p /root/findresults find / -user julice -exec cp {} /root/findresults \\; # julice가 소유한 파일 찾아서 /root/findresults에 복사 ls /root/findresults # 확인 아카이브 생성, 압축 문제 1 /usr/local에 대한 아카이브 파일 /root/local.tgz 생성 gzip으로 압축 풀이 tar -zcvf /root/local.tgz /usr/local 문제 2 /root/backup.tar.bz 디렉토리를 bzip2로 압축된 아카이브 파일을 생성하여 /usr/local로 저장 풀이 tar -jcvf /root/backup.tar.bz /usr/localls 문자열 검색 문제 /etc/passwd 파일에서 sarah 문자열 검색하고 /root/lines에 출력 저장 풀이 grep \"sarah\" /etc/passwd &gt; /root/linescat /root/lines cron 작업 문제 harry 사용자는 매일 14:23에 /bin/echo “hiya”를 실행한는 cron 작업 구성 풀이 yum install -y cronie # cron 설치systemctl enable crond # cron 데몬systemctl restart crond # cron 데몬crontab -eu harry # cron 설정 23 14 * * * /bin/echo \"hiya\" crontab -lu harry # 확인 " }, { "title": "Linux Volume", "url": "/posts/lvm/", "categories": "OS, Linux", "tags": "os, linux, disk, partition", "date": "2022-11-01 03:55:00 +0900", "snippet": "Linux Volume 구조LVM LVM(Logical Volume Manager) 논리적인 공간을 생성, 관리해주는 프로그램 저장 장치를 파티션(하나의 하드디스크에서 나누어진 구역)이 아닌 논리 볼륨으로 할당 관리 쉽고 확장성이 뛰어남 파티션을 원하는 대로 추가하거나 제거하고 크기 조절할 수 있도록 하는 방법LVM의 사용 여러개의 디스크 공간을 합쳐서 하나의 디스크로 사용하기 위해 사용 사용하기 애매한 공간의 디스크 파티션들을 활용하기 위해 사용 기존에 사용 중인 디스크 공간을 확장할 수 있게 사용PV(Physical Volume) 각각의 파티션을 LVM에서 사용하기 위해 나눈 물리적 공간 디스크 공간이 PE라는 단위로 이루어져있음 실제로 나눈 파티션PE(Physical Extent) 물리적 저장공간인 PV의 최소 단위 기본 단위는 4MB 실제 데이터가 저장되는 공간VG(Volume Group) PV들을 하나의 그룹으로 합친 것 PV로 되어 있는 파티션을 그룹으로 설정LV(Logical Volume) mount point로 사용할 실질적인 파티션 크기 확장 및 축소 가능 LVM에서 사용하기 위한 논리적인 공간LE(Logical Extent) 논리적 공간인 LV의 최소 단위LVM 설정LVM 명령어 명령어 기본 베이스 create 생성remove 삭제scan 검색display 확인extend 확장reduce 축소change 속성 변경 물리 볼륨 관련 명령어 pvcreate {DEVICE_NAME} # fdisk로 만든 파티션을 물리 볼륨(PV)로 생성pvscan # 물리 볼륨에 해당하는 시스템에 있는 모든 lvm 블록 장치 스캔pvdisplay # 각각의 물리 볼륨에 대해 상세 출력 가능 (크기, extend, volume group) 볼륨 그룹 관련 명령어 vgcreate {VOLUME_NAME} {DEVICE_NAME} # 볼륨 그룹 설정vgscan # 디스크에 있는 볼륨 그룹 (VG)을 검색하여 출력vgdisplay {-v} {DEVICE_NAME} # 볼륨 그룹의 속성과 정보를 보여주는 명령어vgreduce {VOLUME_NAME} {DELETE_DEVICE_NAME} # 볼륨 그룹에서 물리 볼륨 (장치) 삭제vgextend {VOLUME_NAME} {ADD_DEVICE_NAME} # 볼륨 그룹에 추가로 물리 볼륨 추가vgchange { -a, -l} {VOLUME_GROUP} # 볼륨 그룹 속성 변경 (볼륨 그룹 사용 여부, 최대 LV갯수) vgremove {VOLUME_GROUP} # 볼륨 그룹을 제거 vgdisplay -v logical volume과 physical volume도 같이 자세히 보여주는 옵션 vgchange -a {Y/N} 볼륨 그룹의 사용 여부 지정 vgchange -l​ {COUNT} 해당 볼륨 그룹에 생성할 수 있는 최대 논리 볼륨 수 지정 논리 볼륨 관련 명령어 lvcreate {-L,-l,-n} {VOLUME_GROUP} # 볼륨 그룹 안에 논리 볼륨(LV) 생성lvscan {-v} # 디스크에 있는 논리 볼륨 스캔lvdisplay {-v} {LV_PATH} # 논리볼륨의 정보 출력lvreduce {-L,-l} {LV_PATH} # 논리 볼륨 용량 줄이기lvextend {-L,-l} {LV_PATH} # 논리 볼륨 용량 확장lvresize {-L,-l} {LV_PATH} # 논리 볼륨 용량 조정lvremove {LV_PATH} # 논리 볼륨 제거 lvcreate -L {size} LV의 사이즈 지정 (kb, mb, gb, tb) lvcreate -l {PE COUNT} LV의 사이즈 지정 pe 개수로 용량 지정 (1MB = 4MB) { % }FREE 볼륨 그룹에 있는 나머지 여유 공간 퍼센트 지정 lvcreate -n {VOLUME_NAME} LV의 이름 지정 lvscan -v 정보 자세히 출력 lvdisplay -v 정보 자세히 출력 lvreduce -L {-SIZE} 지정한 사이즈만큼 용량 줄이기 (default : MB) lvreduce -l {-SIZE} 지정한 pe수 만큼 용량 줄이기 lvextend -L {+SIZE} 지정한 사이즈만큼 용량 확장 (default : MB) lvextend -l {+SIZE} 지정한 pe수 만큼 용량 확장 lvresize -L {+/-SIZE} 지정한 사이즈만큼 용량 확장/줄이기 (default : MB) lvresize -l {+/-SIZE} 지정한 pe수 만큼 용량 확장/줄이기 LVM 설정 Virtual Machine Settings → Hardware → HDD 추가 추가한 하드 디스크 재부팅 없이 인식 find /sys -name scan # 가장 마지막 host 내용 드래그 echo \"- - -\" &gt;/sys/devices/~~ # 마지막 host 내용 붙이기 파티션 생성 및 속성 변환 fdisk -l # 추가한 하드 디스크 list 확인 ex) /dev/sdc fdisk /dev/sdc # 추가한 /dev/sdc를 fdisk 명령어를 이용하여 실행 n # 새로운 파티션 추가 p # primary 파티션 생성 # 파티션 넘버 default # Enter # Enter t # 파티션 속성(시스템 ID) 변경 L # 시스템 ID list 확인 8e # LVM 속성으로 변경 w # 파티션 정보 저장 fdisk -l # 속성 변경한 하드 디스크 list 확인 물리적 볼륨 생성 pvcreate /dev/sdc1 # 물리적 볼륨 생성 볼륨 그룹 설정 vgcreate lvmtest /dev/sdc1 # 생성된 PV를 특정 볼륨 그룹에 추가 vgdisplay -v lvmtest # lvmtest 볼륨 그룹의 속성, 정보 자세히 출력 논리 볼륨 생성 lvcreate -L 1000M -n lovolume lvmtest # lvmtest 볼륨 그룹 안에 1000M 크기의 lovolume 논리 볼륨 생성 lvscan # 디스크에 있는 논리 볼륨 스캔 및 경로 확인 lvdisplay -v /dev/lvmtest/lovolume # 논리 볼륨의 정보 자세히 출력 정보 확인 vgdisplay -v lvmtest # lvmtest 볼륨 그룹의 속성,정보 자세히 출력 # vg 속성 정보 확인 # lv 속성 정보 (경로, lv 속한 vg) 확인 # # pv 속성 정보 확인 포맷 후 마운트 mkfs -t ext4 /dev/lvmtest/lovolume # /dev/sdc1 파티션을 포맷 mount -t ext4 /dev/lvmtest/lovolume /mount # ext4 파일시스템 형식으로 /dev/lvmtest/lovolume을 /mount 디렉토리에 mount df -h # mount 정보 출력 blkid # 영구 mount하기 위해 디바이스 UUID 검색 vi /etc/fstab # 영구 mount하기 위한 file 수정 # /etc/fstab UUID=fa29083a-72e5-4e3d-a9c0-1b3c616e56c1 /mount ext4 defaults 0 0 # UUID=파일시스템 DEVICE_NAME mout point filesystem type mount option 로그기록여부 오류체크 " }, { "title": "Disk와 Partition", "url": "/posts/disk-partition/", "categories": "OS, Linux", "tags": "os, linux, mount", "date": "2022-10-31 22:55:00 +0900", "snippet": "Disk 구조와 타입디스크 구조 하드 디스크 구조 sector 하드 디스크의 가장 작은 흐름 단위 boot sector 가장 최초의 섹터(파티션마다 부트섹터가 있음) MBR (Master Boot Sector) 가장 최초의 부트 섹터 cylinder 하드 디스크 용량 결정 (용량 단위) Disk Type IDE 가장 오래된 규격 40개의 핀으로 구성된 직사각형 포트 데이터를 병렬로 전송(병렬 하드) 컴퓨터와 디스크 구동 장치 간의 표준 인터페이스 CPU에서 직접 하드 관리 부팅 중 장착 불가 장치명 : /dec/hda, /dec/hdb, /dec/hdc 등 SATA(Serial Advanced Technologly Attachment) 최근에 나온 interface로 하드 디스크 드라이브의 속도와 연결 방식을 개선하기 위해 개발 직렬 방식 interface(직렬 하드) IDE 확장 버전 장치명 : /dec/sda, /dec/sdb, /dec/sdc 등 SCSI(Small Computer System Interface) 서버나 워크스테이션 등에 쓰이는 고속 인터페이스 안정성이 높지만 가격이 비쌈 별도의 확장 카드를 사용해야 함 컴퓨터와 주변 장치들을 연결하는 인터페이스 규격 하드 디스크 컨트롤러 액세스 속도는 높으나 데이터 저장공간이 많지않음 (디스크 플래터 1장) 초기 병렬 방식 → 직렬 방식 interface (직렬 하드) 내부 SCISI chip에서 직접 하드 관리 부팅 중 장착 가능 장치명 : /dec/sda, /dec/sdb, /dec/sdc 등 SAS(Serial Attached SCSI) SCSI 규격을 한단계 발전 시킨 disk 서버 등 대형 컴퓨터에 주로 사용 (서버 계의 SSD) SATA 하드 디스크를 SAS 장치에 연결 가능, SAS 하드 디스크를 SATA interface에 연결 불가 직렬 방식 interface (직렬 하드) 장치명 : /dec/sda, /dec/sdb, /dec/sdc 등 SSD(Solid State Drive) 하드 디스크 드라이브와 비슷하게 동작하면서도 반도체를 이용하여 정보를 저장 고속으로 데이터 입출력 가능 기계적 지연이나 실패율 적음 장치명 : /dec/sda, /dec/sdb, /dec/sdc,등 Windows와 Linux의 하드 디스크 구조 분류 Windows Linux 하드 이름 disk /dev/sda,b,c,d,e 등 파티션명 C:, D:, drive /dev/sdx1,2,3,4,5 등, 1 ~ 4 physical 영역, 5 ~ logical 영역 파티션 도구 disk part, partition magic, fdisk (98이후 X) fdisk, parted(2TB이상 하드) 포맷 windows 탐색기 mkfs(MaKe File System) FileSystem FAT시리즈, NTFS, REFS UFS, EXT 시리즈 Partition 구조파티션 (partition) 하드 디스크를 논리적으로 나눈 구역 하나의 디스크를 여러개의 파티션으로 나누면 각 파티션마다 하나의 드라이브로 인식 하나의 하드 디스크에는 최대 3개의 primary와 1개의 extended 파티션 생성 가능 primary 파티션 1, extended 파티션 0 (logical 파티션 0) primary 파티션 2, extended 파티션 0 (logical 파티션 0) primary 파티션 3, extended 파티션 0 (logical 파티션 0) primary 파티션 3, extended 파티션 1 (logical 파티션 2) primary 파티션 3, extended 파티션 1 (logical 파티션 5)primary 파티션 기본 파티션 주파티션 부팅 파티션 사용 최대 3개extended 파티션 확장 파티션 여러 개의 논리(logical) 드라이브로 나뉨 논리 영역 공간 부팅 하드 X 최대 1개Linux Disk와 FileSystemFile System 파일 다루거나 조작 할 때 관리하기 편하게 파일이 운용되는 방식(틀) ufs 유닉스 파일 시스템 ext2 속도 UP ext3 속도 UP 저널링 기능 안정성 UP ext4 속도 UP 저널링 기능 대폭 향상 안정성 UP 가장 효율적 xfs 2TB 이하에서는 비효율 (대용량 파일 시스템) Linux Disk 관련 명령어 fdisk (fixed disk) 하드 디스크 분할, 파일 시스템 지정, 새 하드 디스크 포맷이 가능한 상태로 만드는 프로그램 linux의 disk 파티션을 생성, 수정, 삭제 할 수 있는 유틸리티 주로 파티션 나눌 때 사용하는 명령어 /dev/하드 장치명 하드 파티션 구성하기 -a 부트 가능한 flag로 변경 -b bsd 디스크 레이블을 편집 -c DOS 호환 flag로 변경 -d 파티션 삭제 -l 하드 디스크 전체 list 보기 -m 메뉴얼 --help와 동일 -n 파티션 생성 -p 파티션 상태 보기 파티션 테이블 출력 -q 파티션 변경 저장하지 않고 종료 -w 파티션 저장 후 종료 디스크에 테이블을 기록하고 나가기 -t 파티션의 시스템 ID를 변경 파티션 속성 변경 mkfs (MaKe FileSystem) mkfs -t {FILE_SYSTEM_TYPE} {DEVICE_NAME} mkfs.{FILE_SYSTEM_TYPE} {DEVICE_NAME} 파티션 작업을 한 하드 디스크 포맷할 때 사용 extended 파티션은 포맷 불가능 -t 파일 시스템의 형식을 지정(ext2, ext3, ext4 등) mount mount -t {FILE_SYSTEM_TYPE} -o {옵션} {DEVICE_NAME} {MOUNT_POINT} Directory에 파티션을 나누고 포맷 통해 드라이브 연결하는 개념 Linux는 디스크를 파티션으로 나누고 포맷 한 후에 mount 해야 함 포맷이 완료된 파티션 및 장치를 사용자가 읽고 쓸 수 있도록 디렉토리에 연결하는 것 (장치 연결) mount point로 할 directory 생성해야 함 mount point 외의 장소에서 mount 해야 함 -t 파일 시스템의 형식을 지정(ext2, ext3, ext4 등) -o 옵션 (rw, suid, exec, auto, nouser, async 등) umount umount {DEVICE_NAME}umount {MOUNT_POINT} 마운트 해제 명령어 mount point 외의 장소에서 umount 해야함 fuser fuser {MOUNT_POINT} directory 내 process 확인 특정 파일이나 directory를 사용하는 process 정보나 사용자 정보 확인 가능 -u process와 사용자 정보 출력 -v process와 사용자의 상세 정보 출력 -k process를 모두 종료 -mk 디렉토리 내 프로세스 모두 종료 (긴급) df 하드 디스크 여유 공간 확인 명령어 -h mount 확인 -Th file system 정보와 mount 확인 du 하드 디스크 사용 공간 확인 명령어 blkid 포맷한 파일 시스템 확인 명령어 ​fsck 에러 코드 Error Code Error Type Description 0 clean 에러 X 1 fix 파일 시스템 에러 고쳐짐 2 reboot 리부팅 필요 4 save 파일 시스템 에러 고치지 않고 그대로 둠 8 exe error 실행 에러 16 use error 사용법 또는 문법 에러 128 lib error 공유 라이브러리 에러 Linux MountLinux Disk 수동 Mount 하드 디스크 추가 → 파티션 생성 → 포맷 → mount 하드 디스크 재부팅 없이 인식 find /sys -name scan # 가장 마지막 host 내용 드래그 echo \"- - -\" &gt; /sys/device/~~ # 마지막 host 내용 붙이기 새 디스크 장착 VMware Virtual Machine Settings → Hardware → HDD 추가 디스크에 파티션 나누기 fdisk -l # 추가한 HDD list 확인 fdisk /dev/sdb # 추가한 /dev/sdb를 fdisk 명령어를 이용하여 실행 p # 파티션 테이블 출력(현재 파티션 정보 확인) n # 새로운 파티션 추가 p # primary 파티션 생성 1 # 파티션 넘버 1 선택 # Enter # Enter p # 파티션 생성 확인 w # 파티션 정보 저장 파티션에 파일 시스템 생성 (포맷) blkid # 파일 시스템 타입 구성 확인 (sdb1 fs 확인) mkfs.ext4 /dev/sdb1 # /dev/sdb1 파티션을 포맷 done # 저널공간 생성 확인 디스크 마운트 및 마운트 해제 df -h # mount 정보 출력, sdb1은 mount 되지않은 상태 확인 mkdir /mount # mount point로 지정할 directory 생성 cd /mount # mp directory로 이동 pwd # 현재 위치 확인 ls -l mount -t ext4 /dev/sdb1 /mount # ext 4 파일 시스템 형식으로 /dev/sdb1을 /mount 디렉토리에 mount (mount할때는 mp밖에서) df -h # mount 정보 출력 (/dev/sdb1이 /mount에 마운트된 것 확인) touch 1.txt # 1.txt 파일 생성 ls -l # mount 후에 1.txt 존재하는 것 확인 umount /mount # 마운트 해제 (umount할 때는 mp밖에서) df -Th # mount 정보 출력 (-T : filesystem type 출력) ls -l # umount 후에는 1.txt 존재하지 않는 것 확인 lost+found 디렉토리 mount 되는 파일 시스템에 존재하는 fsck 등에 의해서 발견된 결함이 있는 파일에 대한 정보가 보관되는 디렉토리 Linux Disk 자동 Mount 컴퓨터 재부팅 시 mount 했던 설정들은 초기화 됨 파일 시스템 타입 구성 확인 blkid # 파일 시스템 타입 구성 확인 영구 mount할 디바이스 UUID 드래그 ex) /dev/sdb1: UUID=\"eba229d1-9333-4b9a-9058-1c4b63f869c6\" TYPE=\"ext4\" /etc/fstab 파일 수정 vi /etc/fstab # 리눅스 부팅시 mount(자동 mount) 정보 들어있는 파일 # UUID=파일 시스템 장치명 mout point filesystem type mount option 로그 기록 여부 오류체크 /etc/fstab mount 설정을 영구적으로 할 수 있도록 존재하는 설정 파일 리눅스 부팅 시 mount (자동 mount) 정보 들어있는 파일 UUID=파일 시스템 장치명 mount point filesystem type mount option 로그 기록 여부 오류체크 ex) UUID=eba229d1-9333-4b9a-9058-1c4b63f869c6 /mount ext4 defaults 0 0 파일 시스템 장치명(File System Device Name) 파티션들의 위치 fdisk -l 쳤을때 나오는 주소 mount point 등록할 파티션을 어디에 위치한 디렉토리에 연결할 것인지 설정하는 필드 마운트할 디렉토리 경로 filesystem type 파일 다루거나 조작 할 때 관리하기 편하게 파일이 운용되는 방식(틀) ext 초기 리눅스에서 사용했던 종류, 현재 사용 X ext2 긴 파일 시스템 이름을 지원 ext3 저널링 파일 시스템 ext4 더 큰 용량을 지원, 파일 복구, 파일 시스템 점검속도가 빨라짐 ufs Unix File System에서 표준 파일 시스템으로 사용 nfs Network File System, 원격 서버에서 파일 시스템 마운트할 때 사용하는 시스템 swap 스왚 파일 시스템, 스왚 공간으로 사용되는 파일 시스템 vfat window 95/98등등 ntfs를 지원하기 위한 파일 시스템 ramdisk RAM을 지원하기 위한 파일 시스템에 사용 mount option 파일 시스템에 맞게 사용되는 옵션을 설정하는 필드 default rw, nouser, auto, exec, suid 속성을 모두 설정 auto 부팅시 자동 mount noauto 부팅시 자동 mount 하지 않음 exec 실행파일이 실행되는 것을 허용 noexec 실행 파일이 실행되는 것을 허용하지 않음 suid SetUID, SetGID 사용을 허용 nosuid SetUID, SetGID 사용을 허용하지 않음 ro 읽기 전용의 파일 시스템으로 설정 rw 읽기/쓰기 전용의 파일 시스템으로 설정 user 일반 사용자 mount 가능 nouser 일반 사용자 mount 불가능, 관리자만 가능 quota Quota 설정이 가능 noquota Quota 설정이 불가능 로그 기록 여부 로그 (Dump) 기록 여부를 설정하는 필드 0 : 기록 X 1 : 기록 O 오류 체크 (FSCK) File Sequence Check Option에 의한 무결성 검사 우선 순위를 정하는 옵션 0 : 무결성 검사 체크 X 1 : 우선순위 1위부터 체크 2 : 차순 체크 " }, { "title": "[리버싱 핵심 원리] 기초 리버싱", "url": "/posts/reverse-core-1/", "categories": "Security, Reversing", "tags": "reversing", "date": "2022-10-26 23:55:00 +0900", "snippet": "💡해당 게시글은 이승원 님의 '리버싱 핵심 원리'를 개인 공부 목적으로 메모하였습니다. 기초 리버싱리버스 엔지니어링 Reverse Engineering(RE, 역공학) 시스템의 구조, 기능, 동작 분석하여 원리 이해하며 단점 보완하고 새로운 아이디어를 추가하는 작업 리버스 코드 엔지니어링 Reverse Code Engineering(RCE) 소프트웨어 분야의 리버스 엔지니어링 분석 상세분석 소프트웨어를 리버싱 관점에서 상세하게 분석 리버싱(분석) 방법 실행 파일의 분석 방법 정적 분석 파일 실행 없이 파일 겉모습 관찰하여 분석 정보 수집해 해당 프로그램 구조와 동작 원리에 대해 예측 가능 이후 수행될 동적 분석 방법에 대한 아이디어 제공 파일 종류(exe, dll, doc, zip 등), 크기, 헤더(PE) 정보, Import/Export API, 내부 문자열, 실행 압축 여부, 등록 정보, 디버깅 정보, 디지털 인증서 등 다양한 내용 확인 디스어셈블러(Disassembler) 이용해 내부코드와 구조 확인 디스어셈블러 기계어(컴퓨터 언어)를 어셈블리어(인간 언어)로 변환하는 컴퓨터 프로그램 기계어 컴퓨터가 읽을 수 있는 2진 숫자로 이루어진 언어 (0과 1) 어셈블리어 기계어를 사람이 보기 쉽게 문자를 기호화해서 나타낸 것 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급언어 컴퓨터와 가까운 언어이기 때문에 컴파일 시 실행 속도가 빠름 동적 분석 파일을 직접 실행시켜 행위 분석, 디버깅 통해 코드 흐름과 메모리 상태 등을 자세하게 살펴보는 방법 파일, 레지스트리(Registry), 네트워크 등 관찰하며 프로그램 행위 분석 디버거(Debugger) 이용해 프로그램 내부 구조와 동작 원리 분석 가능 디버깅은 리버싱의 하위 개념 Source Code, Hex Code, Assembly Code 리버싱에서 취급하는 대상 → 보통 실행 파일 소스 코드 없이 실행 파일의 바이너리 자체를 분석 ⇒ 소스 코드와 바이너리 코드 사이 관계 살펴보기 중요 Source Code #include \"windows.h\" #include \"tchar.h\" int _tmain(int argc, TCHAR* argv[]) { \tMessageBox(NULL, L\"Hello World!\", L\"www.reversecore.com\", MB_OK); \treturn 0; } 개발도구로 소스 코드 빌드 시 실행 파일 생성 Hex Code 생성된 실행 파일 ⇒ 컴퓨터가 이해할 수 있는 2진수(Binary) 형식 해석하기 위해 2진수 → 16진수 형식 변환 필요 Hex Editor binary 형식 파일을 hex 형식으로 보여주는 유틸리티 _tmain() 소스코드 =빌드과정⇒ Hex Code 변환 int _tmain(int argc, TCHAR* argv[]) { \tMessageBox(NULL, L\"Hello World!\", L\"www.reversecore.com\", MB_OK); \treturn 0; } Assembly Code Hex Code도 사람에게 직관적인 형태가 아니기 때문에 사람이 이해하기 쉬운 어셈블리(Assembly) 코드 형태로 변환 필요 디버거를 이용해 helloworld.exe 실행 파일 open OllyDbg 디스어셈블리와 디버그 두가지 모두 가능한 툴 Hex Code를 디스어셈블 과정을 거쳐 어셈블리 코드로 변환 동적 분석 툴 실행 코드 분석 패치와 크랙 패치(patch) 프로그램 파일 혹은 실행 중인 프로세스 메모리 내용을 변경하는 작업 프로그램의 취약점 수정과 기능 개선이 목적 ex) MS의 windows 업데이트 크랙(crack) 패치와 같은 개념이지만 의도가 비합법적이고 비도덕적인 경우 저작권을 침해하는 행위(불법 복제/사용)에 사용 Reference 리버싱 핵심 원리" }, { "title": "Docker 명령어", "url": "/posts/docker-command/", "categories": "Infrastructure, Docker", "tags": "docker", "date": "2022-10-25 05:55:00 +0900", "snippet": "Docker 명령어Docker 실행 프로세스 docker file 빌드 docker build -t 이미지명:버전 ./ docker 빌드 시 필요한 필수 파일 Dockerfile entrypoint.sh 생성된 docker image 실행하여 docker container 생성 docker run -d -p 들어가는포트:내부포트 -v 로컬위치:내부위치 이미지명:버전 생성된 docker container 상태 확인 docker ps -a Docker 로그 및 프로세스 확인 docker container 로그 확인 docker logs 컨테이너ID docker 프로세스 중지 docker stop 컨테이너ID -f docker 프로세스 재시작 docker restart 컨테이너ID docker container 삭제 docker rm 컨테이너ID docker container 여러 개 한번에 삭제 docker rm $(docker ps -qa) -f docker image 삭제 docker rmi 이미지명:버전 -f Reference Docker docs" }, { "title": "Docker, Docker-Compose 설치", "url": "/posts/docker-install/", "categories": "Infrastructure, Docker", "tags": "docker, docker-compose", "date": "2022-10-25 05:50:00 +0900", "snippet": "Docker와 Docker ComposeDocker 애플리케이션 개발 및 실행을 위한 오픈 소스 플랫폼 os 수준에서 다른 환경을 세팅 할 수 있게 해주는 가상화 기술 application을 신속하게 구축, 테스트 및 배포를 할 수 있는 소프트웨어 플랫폼 host 하나만 존재, 그 위에 Docker 엔진이 컨테이너로 격리해서 실행 관리 vm에 비해서 훨씬 가벼움 컨테이너 단위로 실행 vm과 달리 host OS와 완전히 다른 OS를 설치하는 것 불가 도커 이미지로 도커 컨테이너를 실행 시 새로운 서버 쉽게 배포 가능 dockerfile 빌드 시 dockerimage 생성 dockerimage 실행 시 컨테이너 생성 docker container 실행 Docker Container 독립적으로 격리된 Docker Image 실행 공간을 의미Docker Hub Docker Hub 여러 application들의 image나 dockerfile을 제공하는 사이트 원하는 버전의 docker file 다운받아 docker 실행 가능 실행 환경에서도 검색 가능 가장 위에 있는 official 이미지 다운받아 컨테이너로 실행 가능 검색된 이미지 사용 시 애플리케이션을 설치하고 다시 이미지로 만드는 과정 불필요 Docker Image 환경 세팅 정보를 모아놓은 틀 이미지 실행 시 container 단위로 실행 이미지 하나로 여러 컨테이너 실행 가능Docker File docker 이미지를 구성하는 것을 도와주는 파일 docker file 빌드 시 docker 이미지 생성 docker build -f /home/mxxikr/Dockerfile . docker build . Docker Compose 다중 컨테이너 도커 애플리케이션을 정의하고 관리 및 실행하기 위한 도구 YAML 파일 사용해 애플리케이션의 서비스 설정하고 하나의 명령어로 여러 개의 도커 컨테이너들 사용 가능 프로덕션, 스테이징, 개발, 테스트 등 모든 환경에서 작업 구성 여러 종류의 이미지를 동시에 다른 docker container로 실행하려 할 때 필요 docker compose 파일에서도 이미지마다 docker file 설정 및 volume, port 설정 가능 ex) Docker Compose 샘플 파일 services: frontend: image: awesome/webapp ports: - \"443:8043\" networks: - front-tier - back-tier configs: - httpd-config secrets: - server-certificate backend: image: awesome/database volumes: - db-data:/etc/data networks: - back-tier volumes: db-data: driver: flocker driver_opts: size: \"10GiB\" configs: httpd-config: external: true secrets: server-certificate: external: true networks: # The presence of these objects is sufficient to define them front-tier: {} back-tier: {} Docker 및 Docker Compose 설치Docker 설치 및 repository 설정 기존 버전 도커 삭제 sudo apt-get remove docker docker-engine docker.io containerd runc apt 패키지 업데이트 및 설치 sudo apt-get update sudo apt-get -y install \\ \t\tapt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-release sudo apt-get update apt package index 업데이트 sudo apt-get -y install ca-certificates curl gnupg lsb-release HTTPS 통해 repository 이용하기 위해 pakcage 설치 도커 공식 GPG key 추가 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg stable repository 등록 echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null echo \\ \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null 도커 최신 버전 엔진 설치 sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io 특정 버전 도커 엔진 설치 apt-cache madison docker-ce sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io hello-world 이미지 실행해 도커 엔진 설치 확인 sudo docker run hello-world 도커 버전 확인 docker --version Docker Compose 설치 및 확인 docker compose 설치 sudo curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 실행 할 수 있는 권한 부여 sudo chmod +x /usr/local/bin/docker-compose 설치 확인 docker-compose --version Reference Docker docs" }, { "title": "Windows Event Viewer", "url": "/posts/event-viewer/", "categories": "OS, Windows", "tags": "os, windows, event viewer", "date": "2022-10-25 04:00:00 +0900", "snippet": "이벤트 로그 확인 및 추출이벤트 뷰어 Windows는 계속해서 시스템을 감시하다가 비정상적이거나 따로 기록해야 할 만한 이벤트가 발생하면 로그로 기록함 현재 겪고 있는 오류 원인을 모를 때 참고 사고 발생 시 추적 가능 이벤트 필터링 win+R에 아래 명령어 입력해 이벤트 뷰어 접속 eventvwr.msc 확인할 로그 선택 → 우클릭 → 현재 로그 필터링 필터링 구성 입력 → 확인 로그 기간 이벤트 수준 이벤트 뷰어 로그 확인 일반 이벤트의 공급자, 이벤트 이름 및 ID에 대한 설명 Provider Name 이벤트 소스 EventSourceName 해당 공급자가 지정한 이벤트 TimeCreated SystemTime 이벤트가 발생한 시간 Provider GUID 이벤트 공급자의 ID EventID 이벤트의 ID ProcessID 이벤트가 발생한 프로세스 ThreadID 이벤트가 발생한 스레드의 ID 이벤트 로그 추출 확인할 로그 선택 → 필터링 된 로그파일을 다른이름으로 저장 파일 이름 입력후 이벤트 파일 저장블루 스크린 로그블루 스크린 로그 확인 win+R에 아래 명령어 입력해 이벤트 뷰어 접속 eventvwr.msc 사용자 지정 보기 → 관리 이벤트 → 이벤트 ID 1001 확인 컴퓨터가 오류 검사 후 다시 부팅 되었습니다. 오류 검사 : 0x00000050 덤프 저장 위치 : C:\\Windows\\MEMORY.DMP C:\\Windows\\MEMORY.DMP 블루 스크린 발생 상황 덤프 저장 위치 오류 검사 50 블루 스크린 이벤트 ID 1001 블루 스크린 원본 BugCheck 블루 스크린 Reference Microsoft Learn" }, { "title": "IntelliJ MaxCompute Plugin 설치 및 사용", "url": "/posts/maxcompute-intellij/", "categories": "Cloud, Alicloud", "tags": "alicloud, maxcompute, intellij, plugin", "date": "2022-10-20 04:30:00 +0900", "snippet": "MaxCompute Plugin 설치 및 프로젝트 연동IntelliJ 및 MaxCompute Plugin 설치 IntelliJ 설치 File → Settings → Plugins → MaxCompute Studio 검색 후 Install → IntelliJ restart File → New → Project MaxCompute Studio → Next → 프로젝트명 입력(임의 지정 가능) → Finish View → Tool Windows → Project Explorer ➕ 아이콘 클릭 → Add project from MaxCompute Add MaxCompute Project 대화상자 Connectoin 탭에서 매개변수 입력 → OK Access id : Ali Cloud Access ID Access Key : Ali Cloud Access Key Project Name : MaxCompute 프로젝트 명 MaxCompute 프로젝트 데이터 관리 Project Explorer → 프로젝트명 → Tables &amp; Views → 테이블명 및 프로젝트 정보 확인 테이블명 더블 클릭 시 칼럼 확인 및 테이블 세부 정보 확인 하단 Table Details → Partitions:조회할 날짜 선택 → Preview rows 설정 → Data Preview → 테이블 데이터 미리보기쿼리 작성 Project Explorer → 해당하는 프로젝트 우클릭 → New sql editor 쿼리 작성 → Ctrl + Shift + S / ▶ → 실행 where절 사용한 ds 파티셔닝 조회 필수 ex) where ds &gt;= '2022-10-01' 쿼리문 결과 확인 Reference Ali Cloud MaxCompute" }, { "title": "유클리드 호제법을 이용해 최대 공약수, 최소 공배수 구하기", "url": "/posts/gcd-lcm/", "categories": "Computer Science, Algorithm", "tags": "algorithm", "date": "2022-10-19 22:20:00 +0900", "snippet": "최대 공약수 구하기최대 공약수(GCD) GCD (Greatest Common Divisor) 수들의 공통 약수(공약수) 중 가장 큰 수최대 공약수 구하는 방법 각각의 수에 대한 공통 약수 찾기 (소인수 분해) def gcd(a, b): for i in range(min(a, b), 0, -1): # 가장 큰 약수를 구해야하기 때문에 내림차순 사용 if a % i == 0 and if b % i == 0: # a, b를 나눌 수 있는 가장 큰 약수 return i ex) 12, 8의 최대 공약수 12 = 1 * 2 * 2 * 3 8 = 1 * 2 * 2 * 2 ∴ 최대 공약수 = 1 * 2 * 2 = 4 ex) 25, 20의 최대 공약수 25 = 1 * 5 * 5 20 = 1 * 5 * 2 * 2 ∴ 최대 공약수 = 1 * 5 = 5 ex) 5, 12의 최대 공약수 5 = 1 * 5 12 = 1 * 2 * 2 * 3 ∴ 최대 공약수 = 1 (서로소 : 두 수의 최대 공약수가 1일 때 두 수를 서로소라 함) 유클리드 호제법 큰 수에서 작은 수를 빼서 최종적으로 0이 나오는 수 구하기 def gcd(a, b): while(a != b): # a와 b값이 같을 경우 나머지가 0 # 나머지가 0이 될 때까지 큰 수 에서 작은 수 빼기 if(a &gt; b): # 큰 수 결정 a -= b # 큰 수 - 작은수 반복 else: b -= a return a # 나머지가 0일 경우 해당 수가 최대 공약수 두 수 a, b 중 나머지 r과 b의 최대 공약수는 a와 b의 최대 공약수가 같다는 성질 이용 def gcd(a, b): a, b = max(a, b), min(a, b) # 큰 수, 작은 수 결정 while (b != 0): # 큰 수 에서 작은 수로 나눈 나머지가 0이 될 때까지 실행 a, b = b, a % b # 나머지 값으로 b를 나눠 주기 위해 변경 return a # 나머지(b)가 0일 경우 a가 최대 공약수 a와 b의 최대 공약수 == b와 r의 최대 공약수 (a % b == r) 최소 공배수 구하기최소 공배수(LCM) LCM (Least Common Multiple) 수들의 공통 배수(공배수) 중 가장 작은 수최소 공배수 구하는 방법 각각의 수에 대한 공약수와 서로소 찾기 (소인수 분해) def lcm(a, b): for i in range(max(a, b), a * b + 1): # 가장 작은 배수를 구해야하기 때문에 오름차순 사용 if i % a == 0 and if i % b == 0: # a, b의 공통된 배수 중 가장 작은 수 return i ex) 12, 6의 최소 공배수 12 = 1 * 2 * 2 * 3 8 = 2 * 3 최소 공배수 = 2 * 2 * 3 = 12 ex) 12, 20의 최소 공배수 12 = 1 * 2 * 2 * 3 20 = 1 * 5 * 2 * 2 최소 공배수 = 1 * 2 * 2 * 3 * 5 = 60 ex) 9, 24의 최소 공배수 9 = 3 * 3 24 = 2 * 2 * 2 * 3 최소 공배수 = 2 * 2 * 2 * 3 * 3 = 72 유클리드 호제법 두 수의 곱을 최대 공약수로 나누기 def lcm(a, b): return int((a * b) / gcd(a, b)) # lcm = a * b / gcd Reference khanacademy math" }, { "title": "GCP Compute Engine 생성 및 설정", "url": "/posts/vm-instance/", "categories": "Cloud, GCP", "tags": "compute engine, gcp", "date": "2022-10-19 14:30:00 +0900", "snippet": "VM 인스턴스 생성 및 설정VM 인스턴스 생성 프로젝트 선택 탐색 → Compute Engine → VM 인스턴스 → 인스턴스 만들기 인스턴스 구성 설정 인스턴스명 설정 리전 머신 유형 부팅 디스크 서비스 계정 만들기 → 인스턴스 생성 확인 우측 SSH 클릭해 인스턴스 웹콘솔 접속 root 비밀번호 생성 sudo passwd root 계정으로 접속 su - OS 버전 확인 cat /etc/*-release VM 인스턴스 SSH 키 등록 SSH 키 생성 ssh-keygen -t rsa -f {INSTANCE_NAME} -C {SERVICE_ACCOUNT} -b 2048 -t 타입명 key 생성 type 선택 -b 숫자 type 의 bytes 설정 rsa 암호화 방식은 기본 2048인데 보다 안전한 4096으로 설정 -f 파일명 생성할 key의 이름 -C 내용 주석 입력 gcp의 메일 계정 입력 프로젝트 선택 탐색 → Compute Engine → VM 인스턴스 선택 → 메타데이터 수정 → 항목 추가 → Public Key 메타데이터 복사 후 입력 → 저장 Private 키 사용해 접속방화벽(FireWall) 규칙 설정 및 연결VPC 방화벽 규칙 생성 탐색 메뉴 → 네트워킹 → VPC 네트워크 → 방화벽 방화벽 규칙 만들기 방화벽 규칙 설정 방화벽 이름 설정 네트워크 선택 수신/송신 대상 태그 선택 GCE 연결할 때 설정한 태그 입력 ex) mxxikr-test 소스 IP 범위 설정 ex) 0.0.0.0/0 포트 설정 ex) 8080 방화벽 규칙 생성 확인VPC 인스턴스에 방화벽 연결 탐색 메뉴 → Compute Engine → VM 인스턴스 방화벽 설정할 인스턴스 선택 → VM 인스턴스 세부정보 → 수정 방화벽 연결하기 위해 생성한 네트워크 태그 입력 → 저장 Reference Google Cloud Compute Engine" }, { "title": "GCP BigQuery 프로세스 관리", "url": "/posts/bigquery-process/", "categories": "Cloud, GCP", "tags": "bigquery, gcp", "date": "2022-10-19 12:40:00 +0900", "snippet": "프로세스 확인 및 중지프로젝트 프로세스 확인 완료되지 않은 모든 프로세스 job 확인 SELECT * FROM `{PROJECT_ID}`.`{REGION_NAME}`.`INFORMATION_SCHEMA`.`JOBS_BY_PROJECT` WHERE STATE != \"DONE\" 완료되지 않은 모든 프로세스 job id 확인 SELECT job_id FROM `{PROJECT_ID}`.`{REGION_NAME}`.`INFORMATION_SCHEMA`.`JOBS_BY_PROJECT` WHERE STATE != \"DONE\" USER별 완료되지 않은 프로세스 job 수 확인 SELECT user_email, count(*) FROM `{PROJECT_ID}`.`{REGION_NAME}`.`INFORMATION_SCHEMA`.`JOBS_BY_PROJECT` WHERE STATE != \"DONE\" GROUP BY user_email 프로세스 중지 프로세스 중지 CALL BQ.JOBS.CANCEL('{PROJECT_ID}.{JOB_ID}'); Reference Google Cloud BigQuery Docs" }, { "title": "Alicloud MaxCompute Query", "url": "/posts/maxcompute-query/", "categories": "Database, Data Warehouse", "tags": "alicloud, maxcompute, sql, ddl, dml", "date": "2022-10-19 12:25:00 +0900", "snippet": "테이블 생성 및 변경테이블 생성 파티셔닝 설정한 테이블 생성 CREATE TABLE {TABLE_ID} ( `{COLUMN_NAME}` {DATA_TYPE}, `{COLUMN_NAME}` {DATA_TYPE}, `{COLUMN_NAME}` {DATA_TYPE}, `datetime` datetime ) partitioned by (ds STRING); 기존 테이블 구조 복사해 새로운 테이블 생성 CREATE TABLE `{TGT_PROJECT_ID}.{TGT_TABLE_ID}` like `{SRC_PROJECT_ID}.{SRC_TABLE_ID}`; 원본 테이블 구조와 동일한 테이블 생성 테이블 수정 테이블명 변경 ALTER TABLE {SRC_TABLE_ID} RENAME TO {TGT_TABLE_ID}; lifecycle 변경 ALTER TABLE {TABLE_ID} SET LIFECYCLE {INT}; 테이블 삭제 테이블 삭제 DROP TABLE IF EXISTS `{PROJECT_ID}.{TABLE_ID}`; 칼럼 추가 칼럼 추가 ALTER TABLE {TABLE_ID} add {COLUMN_NAME} (`type` {DATA_TYPE}); 데이터 복사 및 삭제데이터 복사 특정 날짜 데이터 복사 INSERT INTO `{TGT_PROJECT_ID}.{TGT_TABLE_ID}` partition (ds) SELECT * FROM `{SRC_PROJECT_ID}.{SRC_TABLE_ID}` WHERE ds &gt;= '2022-10-01'; 중복 제거 후 특정 날짜 데이터 복사 INSERT INTO `{TGT_PROJECT_ID}.{TGT_TABLE_ID}` partition (ds) SELECT DISTINCT * FROM `{SRC_PROJECT_ID}.{SRC_TABLE_ID}` WHERE ds &gt;= '2022-10-01'; INSERT INTO `{TGT_TABLE_ID}` partition (ds) SELECT DISTINCT * FROM `{SRC_TABLE_ID}` WHERE ds &gt;= '2022-10-01'; 데이터 삭제 특정 날짜 데이터 삭제 DELETE TABLE `{TABLE_ID}` WHERE ds &gt;= '2022-10-01'; 데이터 조회데이터량 조회 날짜별 내림차순으로 데이터 수 조회 SELECT ds, count(*) AS count_ FROM {TABLE_ID} WHERE ds &gt;= '2022-10-01' GROUP BY ds ORDER BY ASC; 날짜별 오름차순으로 데이터 수 조회 SELECT ds, count(*) AS count_ FROM {TABLE_ID} WHERE ds &gt;= '2022-10-01' GROUP BY ds ORDER BY DESC; Reference Alibaba Cloud Docs" }, { "title": "Alicloud AnalyticDB MySQL Query", "url": "/posts/adb-mysql-query/", "categories": "Database, MySQL", "tags": "alicloud, mysql", "date": "2022-10-04 23:55:00 +0900", "snippet": "테이블 생성 및 정책 설정테이블 생성 기본 테이블 생성 CREATE TABLE `{TABLE_ID}`( `{INDEX_COLUMN_NAME}` BIGINT NOT NULL AUTO_INCREMENT, `{COLUMN_NAME}` {DATA_TYPE}, `{COLUMN_NAME}` {DATA_TYPE}, PRIMARY KEY (`{INDEX_COLUMN_NAME}`) ) DISTRIBUTE BY HASH(`{INDEX_COLUMN_NAME}`); 파티셔닝 설정한 테이블 생성 CREATE TABLE `{TABLE_ID}` ( `{INDEX_COLUMN_NAME}` BIGINT NOT NULL AUTO_INCREMENT, `{COLUMN_NAME}` {DATA_TYPE}, `{COLUMN_NAME}` {DATA_TYPE}, `{COLUMN_NAME}` {DATA_TYPE}, `datetime` DATETIME, -- YYYY-MM-DD hh:mm:ss `{PARTITION_COLUMN_NAME}` VARCHAR(255), -- 파티셔닝 설정할 날짜 칼럼 PRIMARY KEY (`{INDEX_COLUMN_NAME}`, {PARTITION_COLUMN_NAME}) -- 파티셔닝 칼럼 primary key 지정 ) DISTRIBUTE BY HASH(`{INDEX_COLUMN_NAME}`) PARTITION BY VALUE(DATE_FORMAT({PARTITION_COLUMN_NAME}, '%Y%m%d')) LIFECYCLE {LIFECYCLE}; PARTITION BY VALUE(DATE_FORMAT({PARTITION_COLUMN_NAME}, '%Y%m%d')) 문자열 형식의 날짜 데이터를 %Y%m%d 형식으로 변환해 파티셔닝 설정 lifecycle 적용 테이블 생성 CREATE TABLE `{TABLE_ID}`( `{INDEX_COLUMN_NAME}` BIGINT NOT NULL AUTO_INCREMENT, `{COLUMN_NAME}` {DATA_TYPE}, `{COLUMN_NAME}` {DATA_TYPE}, PRIMARY KEY (`{INDEX_COLUMN_NAME}`) ) DISTRIBUTE BY HASH(`{INDEX_COLUMN_NAME}`) LIFECYCLE {LIFECYCLE} STORAGE_POLICY = 'MIXED' HOT_PARTITION_COUNT = 30; storage policy 설정한 테이블 생성 CREATE TABLE `{TABLE_ID}`( `{INDEX_COLUMN_NAME}` BIGINT NOT NULL AUTO_INCREMENT, `{COLUMN_NAME}` {DATA_TYPE}, `{COLUMN_NAME}` {DATA_TYPE}, `datetime` DATETIME, -- YYYY-MM-DD hh:mm:ss `{PARTITION_COLUMN_NAME}` VARCHAR, -- 파티셔닝 설정할 날짜 칼럼 PRIMARY KEY (`{INDEX_COLUMN_NAME}`, {PARTITION_COLUMN_NAME}) ) DISTRIBUTE BY HASH(`{INDEX_COLUMN_NAME}`) PARTITION BY VALUE(DATE_FORMAT({PARTITION_COLUMN_NAME}, '%Y%m%d')) LIFECYCLE {LIFECYCLE} STORAGE_POLICY = 'MIXED' HOT_PARTITION_COUNT = 30; STORAGE_POLICY 테이블의 데이터 스토리지 정책 설정 HOT COLD MIXED HOT_PARTITION_COUNT 테이블 데이터 스토리지 정책이 MIXED 일 경우 HOT 스토리지 수 지정 odps 연결 테이블 생성 CREATE TABLE `{TABLE_ID}`( `idx` BIGINT NOT NULL AUTO_INCREMENT, `{COLUMN_NAME}` {DATA_TYPE}, `{COLUMN_NAME}` {DATA_TYPE}, `datetime` DATETIME, `{PARTITION_COLUMN_NAME}` varchar(255), PRIMARY KEY (`idx`, {PARTITION_COLUMN_NAME}) ) DISTRIBUTE BY HASH(`idx`) PARTITION BY VALUE(DATE_FORMAT({PARTITION_COLUMN_NAME}, '%Y%m%d')) LIFECYCLE {LIFECYCLE} ENGINE='ODPS' TABLE_PROPERTIES='{ \"endpoint\":\"http://service.cn-hangzhou.maxcompute.aliyun-inc.com/api\", \"accessid\":\"{ACCESS_ID}\", \"accesskey\":\"{ACCESS_KEY}\", \"project_name\":\"{PROJECT_ID}\", \"table_name\":\"{MAXCOMPUTE_TABLE_ID}\", \"partition_column\":\"{PARTITION_COLUMN_NAME}\" }'; endpoint 연결할 maxcompute가 존재하는 리전의 endpoint 주소 테이블 생성 확인 SHOW CREATE TABLE {TABLE_ID}; 파티셔닝, 정책 확인 및 변경파티셔닝(lifecycle) 설정 확인 및 변경 파티셔닝 설정 확인 SELECT * FROM INFORMATION_SCHEMA.PARTITIONS p ORDER BY TABLE_NAME, PARTITION_NAME ASC 테이블 별 파티셔닝 수 확인 SELECT TABLE_NAME, count(*) AS count_ FROM INFORMATION_SCHEMA.PARTITIONS p GROUP BY TABLE_NAME 테이블 지정하여 파티셔닝 설정 확인 SELECT * FROM INFORMATION_SCHEMA.PARTITIONS p WHERE TABLE_NAME = '{TABLE_ID}' 파티셔닝(lifecycle) 설정 변경 (설정 변경 후 table 빌드 필수) ALTER TABLE `{TABLE_ID}` partitions {LIFECYCLE}; BUILD TABLE {DB_NAME}.{TABLE_ID}; -- 테이블 빌드 후 설정 반영됨 storage policy 확인 및 변경 데이터 스토리지 배포 확인 SELECT * FROM information_schema.table_usage; DB별 스토리지 배포 확인 SELECT * FROM information_schema.table_usage WHERE table_schema = '{DB_NAME}' AND storage_policy = 'HOT'; 테이블 별 스토리지 배포 정책 확인 SELECT * FROM information_schema.table_usage WHERE table_schema='{DB_NAME}' AND table_name ='{TABLE_ID}' storage policy 정책 변경 (설정 변경 후 table 빌드 필수) ALTER TABLE `{TABLE_ID}` storage_policy = 'MIXED' hot_partition_count = 30; BUILD TABLE {DB_NAME}.{TABLE_ID}; 스토리지 변경 진행 상황 확인 SELECT * FROM information_schema.storage_policy_modify_progress; 테이블 및 데이터 복사테이블 구조 복사 테이블 구조 복사 CREATE TABLE {DB_NAME}.{TGT_TABLE_ID} LIKE {DB_NAME}.{SRC_TABLE_ID}; 데이터 복사 특정 날짜 data 복사 INSERT INTO {TGT_TABLE_ID} SELECT * FROM {SRC_TABLE_ID} WHERE {PARTITION_COLUMN_NAME} = '2022-10-04'; 비동기식 import 작업 (실행 후 job id 반환) /*+async_job_priority=1*/ submit job INSERT INTO {TGT_TABLE_ID} SELECT * FROM {SRC_TABLE_ID}; 날짜 지정한 비동기식 import 작업 /*+async_job_priority=1*/ submit job INSERT INTO {TGT_TABLE_ID} SELECT * FROM {SRC_TABLE_ID} WHERE DATE_FORMAT({PARTITION_COLUMN_NAME}, \"%Y-%m-%d\") BETWEEN '2022-10-01' AND '2022-10-04'; /*+async_job_priority=1*/ submit job INSERT INTO {TGT_TABLE_ID} SELECT * FROM {SRC_TABLE_ID} WHERE {PARTITION_COLUMN_NAME} BETWEEN '2022-10-01' AND '2022-10-04'; 시간 지정한 비동기식 import 작업 /*+async_job_priority=1*/ submit job INSERT INTO {TGT_TABLE_ID} SELECT * FROM {SRC_TABLE_ID} WHERE {PARTITION_COLUMN_NAME} = '2022-10-04' AND datetime &lt; '2021-10-04 05:00:00'; 복사 작업 상태 확인 비동기식 작업 상태 확인 SHOW job STATUS 특정 비동기식 job 상태 확인 SHOW job STATUS WHERE job='{JOB_ID}'; 데이터 조회조회 날짜 지정해 데이터 조회 SELECT * FROM {TABLE_ID} WHERE {PARTITION_COLUMN_NAME} = '2022-10-04'; 날짜별 데이터량 오름차순 조회 SELECT {PARTITION_COLUMN_NAME}, count(*) AS count_ FROM {TABLE_ID} WHERE {PARTITION_COLUMN_NAME} &gt;= '2022-10-01' GROUP BY {PARTITION_COLUMN_NAME} ORDER BY {PARTITION_COLUMN_NAME} DESC; SELECT {PARTITION_COLUMN_NAME}, count(*) AS count_ FROM {TABLE_ID} WHERE DATE_FORMAT({PARTITION_COLUMN_NAME}, '%Y%m%d') &gt;= '2022-10-01' GROUP BY {PARTITION_COLUMN_NAME} ORDER BY {PARTITION_COLUMN_NAME} DESC; 특정 날짜 이후 데이터 오름차순 조회 SELECT * FROM {DB_NAME}.{TABLE_ID} WHERE datetime &gt;= '2022-10-01' ORDER BY datetime DESC LIMIT 100; 특정 시간 이후 데이터 오름차순 조회 SELECT * FROM {DB_NAME}.{TABLE_ID} WHERE datetime &gt;= CONCAT(CURRENT_DATE(), ' 07:55') ORDER BY datetime DESC DB별 테이블 조회 SELECT table_name FROM information_schema.tables WHERE table_schema = '{DB_NAME}' 테이블 및 칼럼 수정/삭제테이블 및 데이터 삭제 테이블 삭제 DROP TABLE `{TABLE_ID}`; 테이블 데이터 삭제 DELETE FROM `{TABLE_ID}`; 특정 날짜 지정해 테이블 데이터 삭제 DELETE FROM `{TABLE_ID}` WHERE datetime &gt;= '2021-10-13'; 테이블명 변경 및 이동 테이블명 변경 RENAME TABLE {SRC_TABLE_ID} TO {TGT_TABLE_ID}; ALTER TABLE {SRC_TABLE_ID} RENAME {TGT_TABLE_ID}; RENAME TABLE {SRC_TABLE_ID} TO {TGT_TABLE_ID}, {SRC_TABLE_ID} TO {TGT_TABLE_ID}; 다른 DB로 테이블 이동 RENAME TABLE {SRC_DB_NAME}.{SRC_TABLE_ID} TO {TGT_DB_NAME}.{TGT_TABLE_ID}; 칼럼 추가, 변경, 삭제 칼럼 추가 ALTER TABLE {DB_NAME}.{TABLE_ID} ADD {COLUMN_NAME} {DATA_TYPE} NULL; 칼럼명 변경 ALTER TABLE {DB_NAME}.{TABLE_ID} CHANGE {SRC_COLUMN_NAME} {TGT_COLUMN_NAME} {DATA_TYPE} NULL; 칼럼 타입 변경 ALTER TABLE {DB_NAME}.{TABLE_ID} MODIFY {COLUMN_NAME} {DATA_TYPE}; 칼럼 삭제 ALTER TABLE {DB_NAME}.{TABLE_ID} DROP {COLUMN_NAME}; 계정 설정계정 생성 및 삭제 계정 생성 CREATE USER IF NOT EXISTS '{USER_ID}' IDENTIFIED BY '{USER_PASSWORD}'; 계정 삭제 DROP USER '{USER_ID}'; 권한 설정권한 조회 부여된 권한 확인 SHOW GRANTS; 계정 권한 확인 SHOW GRANTS FOR '{USER_ID}'; 계정 권한 설정 및 삭제 계정에 모든 권한 추가 GRANT ALL ON *.* TO '{USER_ID}'; GRANT ALL ON {DB_NAME}.* TO '{USER_ID}'; 패스워드 변경과 동시에 권한 설정 GRANT SELECT ON *.* TO '{USER_ID}' identified BY '{USER_PASSWORD}'; 계정 모든 권한 삭제 REVOKE ALL ON *.* FROM '{USER_ID}'; 특정 테이블에 SELECT 권한 할당 GRANT SELECT ON {DB_NAME}.{TABLE_ID} TO '{USER_ID}'; 프로세스 및 용량 확인프로세스 확인 실행 중인 프로세스 리스트 확인 SHOW FULL processlist; 용량 확인 테이블 별 용량 확인 SELECT table_name AS 'TableName', ROUND(SUM(data_length+index_length)/(1024*1024), 2) AS 'All(MB)', ROUND(data_length/(1024*1024), 2) AS 'Data(MB)', ROUND(index_length/(1024*1024), 2) AS 'Index(MB)' FROM information_schema.tables GROUP BY table_name ORDER BY data_length DESC; DB별 용량 확인 SELECT table_schema \"Database\", ROUND(SUM(data_length+index_length)/1024/1024,1) \"MB\" FROM information_schema.TABLES GROUP BY 1 WHERE ds; TIME OUT 설정 쿼리 time out 시간 설정 SET query_timeout = 1800000 SET insert_SELECT_timeout = 3600000 Reference Alibaba Cloud Docs" }, { "title": "PostgreSQL Query", "url": "/posts/postgre-query/", "categories": "Database, PostgreSQL", "tags": "postgre, sql", "date": "2022-09-01 23:30:00 +0900", "snippet": "스키마, Table 생성 및 파티셔닝 설정스키마 생성 현재 연결된 데이터베이스에 스키마 생성 CREATE SCHEMA {SCHEMA_NAME} pg_로 시작하는 스키마명 사용 불가 CREATE 권한이거나 슈퍼 유저일 경우 스키마 생성 가능 table 생성 timestamp 기준으로 partition 설정한 table 생성 CREATE TABLE {TABLE_ID} (idx serial, {COLUMN_NAME} {DATA_TYPE}, timestamp TIMESTAMP) partition by range(timestamp); 파티셔닝 설정 partition 설정 위한 pg_partman 확장 사용 적용 CREATE EXTENSION pg_partman SCHEMA public; table 생성 확인 original_table orders old_nonpartitioned_table part_config part_config_sub spatial_ref_sys template_public_original_table partition 적용 - partition 사용할 메인 table 생성 CREATE TABLE {TABLE_ID} ( idx serial, {COLUMN_NAME} {DATA_TYPE}, {COLUMN_NAME} {DATA_TYPE}, timestamp TIMESTAMP ) partition by range(timestamp); partition 적용 - Index 생성 CREATE INDEX ON {SCHEMA_NAME}.{TABLE_ID} (idx, timestamp); 추후 생성되는 partition에 자동 적용 partition 적용 - table에 partition 적용 SELECT {SCHEMA_NAME}.create_parent('{SCHEMA_NAME}.{TABLE_ID}', 'timestamp', 'native', 'daily', p_template_table:= '{SCHEMA_NAME}.{TABLE_ID}', p_premake := 15, p_start_partition := (CURRENT_TIMESTAMP)::text); UPDATE {SCHEMA_NAME}.part_config SET retention_keep_table = false, retention = '6 month' WHERE parent_table = '{SCHEMA_NAME}.{TABLE_ID}'; {SCHEMA_NAME}.{TABLE_ID} partition 기준 table timestamp partition 기준 column partition 타입 native 선언적 partition (파티셔닝 관리 용이. 속도 상승 및 partition pruning 자동) partman 상속 partition (구버전, table 따로 관리, index, vaacuum 등 개별 table로 구분) daily partition 기준 시간 retention table 유지 시간 retention_keep_table true 삭제된 table 유지, false 삭제된 table 완전 삭제 p_premake partition 생성 table 개수 p_start_partition partition 시작지점 partition 적용 - partition table 생성 CREATE TABLE {SCHEMA_NAME}.{TABLE_ID}_p2022_09_01 PARTITION OF {SCHEMA_NAME}.{TABLE_ID} FOR VALUES FROM ('2022-09-01 00:00:00') TO ('2022-09-02 00:00:00'); 하루 단위로 partition 테이블 생성 partition 자동 관리 설정 partition 자동 관리, 특정 Table 지정 가능 SELECT run_maintenance();SELECT run_maintenance('{SCHEMA_NAME}.{TABLE_ID}'); 특정 table 지정 가능 (PostgreSQL 직접 실행, GCP CloudSQL 적용 안됨) time 기준 table 자동 생성 SELECT partition_data_time('{SCHEMA_NAME}.{TABLE_ID}'); 데이터 없으면 table 생성 불가, GCP CloudSQL 적용 가능) time 기준 table 자동 삭제 SELECT drop_partition_time('{SCHEMA_NAME}.{TABLE_ID}') retention 옵션 값으로 table 삭제, GCP CloudSQL 적용 가능) 인덱싱 설정btree 인덱싱 single coulmn 인덱싱 설정 CREATE INDEX {INDEX_NAME} ON only {SCHEMA_NAME}.{TABLE_ID} USING btree({COLUMN_NAME}); 인덱싱 삭제 DROP INDEX {INDEX_NAME}; Table 및 Coulmn 수정/삭제table 및 coulmn 변경 coulmn 명 변경 ALTER TABLE {TABLE_ID} RENAME COLUMN {SRC_COLUMN} TO {TGT_COLUMN}; table 명 변경 ALTER TABLE {SCHEMA_NAME}.{SRC_TABLE_ID} RENAME TO {TGT_TABLE_ID}; coulmn 데이터 타입 변경 ALTER TABLE {SCHEMA_NAME}.{TABLE_ID} ALTER COLUMN {COLUMN_NAME} TYPE {DATA_TYPE}; coulmn 추가 ALTER TABLE {SCHEMA_NAME}.{TABLE_ID} ADD {COLUMN_NAME} {DATA_TYPE} NULL; ALTER TABLE {SCHEMA_NAME}.{TABLE_ID} ADD {COLUMN_NAME} {DATA_TYPE} NULL, ADD {COLUMN_NAME} {DATA_TYPE} NULL; table 및 coulmn 삭제 coulmn 삭제 ALTER TABLE {SCHEMA_NAME}.{TABLE_ID} DROP COLUMN {COLUMN_NAME}; ALTER TABLE {SCHEMA_NAME}.{TABLE_ID} DROP COLUMN {COLUMN_NAME}, DROP COLUMN {COLUMN_NAME}; table 데이터 삭제 TRUNCATE TABLE {SCHEMA_NAME}.{TABLE_ID}; 데이터 조회조회 테이블 전체 데이터 조회 SELECT * FROM {TABLE_ID} LIMIT 100; -- 해당 테이블 데이터 100개 조회SELECT * FROM {TABLE_ID} ORDER BY {COLUMN_NAME} DESC -- 정렬 기준 칼럼에 대해 내림차순 조회SELECT * FROM {TABLE_ID} ORDER BY {COLUMN_NAME} ASC -- 정렬 기준 칼럼에 대해 오름차순 조회 테이블 인덱스 정보 조회 SELECT * FROM pg_catalog.pg_indexes WHERE tablename = '{TABLE_ID}'; 계정 설정계정 생성 현재 사용자 정보 확인 SELECT * FROM PG_USER; 계정 생성 CREATE USER {USER_ID} PASSWORD '{USER_PASSWORD}'; 유저 생성 확인 SELECT * FROM pg_user WHERE usename IN ('{USER_ID}'); 계정 및 비밀번호 수정 계정명 수정 ALTER USER {USER_ID} WITH PASSWORD '{USER_PASSWORD}'; 비밀번호 수정 ALTER USER {USER_ID} WITH PASSWORD '{USER_PASSWORD}'; 권한 설정DB 권한 Grantor 권한을 부여한 role Grantee 권한을 부여받은 role Table_schema schema명 Table_name table명 Privilege_type 권한의 유형 Is_grantable 권한을 줄 수 있을 경우 YES, 아닐 경우 NO 권한 확인 SELECT * FROM information_schema.role_table_grants WHERE grantee ='{USER_ID}' DB 접근 권한 할당 GRANT CONNECT ON DATABASE {DB_NAME} TO {USER_ID}; schema 권한 설정 schema 모든 권한 할당 GRANT ALL ON SCHEMA {SCHEMA_NAME} TO {USER_ID}; schema 엑세스 권한 할당 GRANT USAGE ON SCHEMA {SCHEMA_NAME} TO {USER_ID}; schema SELECT 권한 할당 GRANT SELECT ON ALL TABLES IN SCHEMA {SCHEMA_NAME} TO {USER_ID}; -- Single Schema GRANT SELECT ON ALL TABLES IN SCHEMA {SCHEMA_NAME_1}, {SCHEMA_NAME_2} TO {USER_ID}; -- Multi Schema table 권한 설정 앞으로 생길 table에 all 권한 ALTER DEFAULT PRIVILEGES IN SCHEMA {SCHEMA_NAME} GRANT ALL PRIVILEGES ON TABLES TO {USER_ID}; -- Single Schema ALTER DEFAULT PRIVILEGES IN SCHEMA {SCHEMA_NAME_1}, {SCHEMA_NAME_2} GRANT ALL PRIVILEGES ON TABLES TO {USER_ID}; -- Multi Schema table SELECT 권한 할당 GRANT SELECT ON TABLE {SCHEMA_NAME}.{TABLE_ID} TO {USER_ID}; 앞으로 생길 table에 SELECT 권한 ALTER DEFAULT PRIVILEGES IN SCHEMA {SCHEMA_NAME} GRANT SELECT ON TABLES TO {USER_ID}; -- Single Schema ALTER DEFAULT PRIVILEGES IN SCHEMA {SCHEMA_NAME_1}, {SCHEMA_NAME_2} GRANT SELECT ON TABLES TO {USER_ID}; -- Multi Schema 특정 table 권한 GRANT ALL ON TABLE {SCHEMA_NAME}.{TABLE_NAME} TO {USER_ID}; 전체 권한 설정 all 권한 GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA {SCHEMA_NAME} TO {USER_ID}; GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA {SCHEMA_NAME} TO {USER_ID}; ALTER DEFAULT PRIVILEGES GRANT USAGE ON SEQUENCES TO {USER_ID}; 프로세스 확인프로세스 kill 특정 프로세스 kill SELECT * FROM pg_stat_activity WHERE state = 'active'; SELECT pg_cancel_backend({PROCESS_ID}); Reference pg_partman/pg_partman.md at master · pgpartman/pg_partman pg_partman/pg_partman_howto_native.md at master · pgpartman/pg_partman" }, { "title": "vi 문서 편집", "url": "/posts/vi-vim/", "categories": "OS, Linux", "tags": "os, linux, vi", "date": "2022-09-01 21:55:00 +0900", "snippet": "문서 편집기리눅스 문서 편집기 vi vim pico nano emacswindows 문서 편집기 notepad wordpad office 등vivi (visual editor) Unix 환경에서 가장 많이 쓰이는 문서 편집기 각종 문서 편집 가능한 텍스트 기반의 편집기 한 화면을 편집하는 편집기 버퍼에서 작업을 하므로 저장을 시켜야 파일의 내용이 저장vi 편집 modevi [존재하는 파일명] # 기존 문서 열람vi [미존재 파일명] # 파일 문서 새로 생성vi # 새 문서 생성 # 문서 생성 후 esc → :w /mxxikr/test 입력 시 이름 지정 저장 가능 입력 모드 입력을 원하는 글자 입력 가능 화면에서 입력한 상태를 볼 수 있는 mode 명령 모드 한 글자 또는 두 글자 명령 사용하여 커서 이동, 글자 삭제 및 교체, 문자열 검색하는 mode 라인 모드 콜론(:) prompt에서 명령 입력하여 저장, 편집, 검색 기능 등 다양한 기능 제공하는 mode 명령어줄 번호 표시 :set nu 문서 왼쪽에 번호 표시 명령어 치환 명령 :[검색 범위]s/[원본 문자열]/[수정 문자열]/[치환 범위 옵션]ex) :s/th/1234 # 해당 커서 행 th 1개를 1234로 치환ex) :s/th/1234/g # 해당 커서 행 th를 1234로 모두 치환ex) :10s/i/!@#$/g # 10행 i를 !@#$로 모두 치환ex) :10,12s/i/!@#$ # 10행, 12행 i를 !@#$로 1개씩 치환ex) :%s/th/!@#$/g # 문서 전체 th를 !@#$로 모두 치환 % 문서 전체 검색 범위 옵션 g 전체 치환 범위 옵션 command 명령 실행 ! 강제 명령 :! vi 잠시 중단 후 shell 명령어 수행 :.! 명령 수행 내용 문서 내 삽입 (커서 위치 기준) :[숫자]! 명령 수행 내용 지정 행 삽입 (원본 내용 삭제되므로 행 추가 후 사용) 이동 명령 :cd [directory] 문서 내에서 영구 directory 이동 문서 열기/저장/나가기 명령 :e 문서 열기 :e! 저장없이 강제 실행 문서 열기 :enew 새 문서 열기 :enew! 강제 실행으로 새 문서 열기 :q 나가기 :q! 강제로 저장 없이 나가기 :w 바로 저장 :wq 저장 후 종료 문서 내용 다른 파일에 추가vi /mxxikr/test1## 라인 모드 입력:w &gt;&gt; /mxxikr/test2 # 해당 문서 내용 /mxxikr/test2 파일에 입력:e /mxxikr/test2 문서 내 파일 내용 삽입vi /vi/login.defs## 라인 모드 입력:9r /mxxikr/test1 # 10번째 줄에 파일 내용 삽입:0r /mxxikr/test2 # 1번째 줄에 파일 내용 삽입:10r /mxxikr/test1 # 11번째 줄에 파일 내용 삽입:[삽입 행 범위]r [파일명] 지정 행 아래 줄 추가 후 해당 파일 내용 삽입문서 내 명령 내용 삽입vi /vi/login.defs## 라인 모드 입력:3r! pwd # 4번째 줄에 명령내용 삽입:[삽입 행 범위]r! [명령어] 지정 행 아래 줄 추가 후 명령내용 삽입문서 내부 단축 키방향 키 이동 단축 키 h 좌측 이동 (←) j 상측 이동 (↑) k 하측 이동 (↓) l 우측 이동 (→) 단어 이동 단축 키 w 단어 기준으로 오른쪽 이동 e 단어의 마지막 위치로 커서 이동 b 단어 기준으로 왼쪽으로 이동 행 이동 단축 키 $ 행 끝으로 이동 0 행 최초로 이동 문서 내 이동 단축 키 gg 문서 최초로 이동 shift + g 문서 끝으로 이동 화면 내 이동 단축 키 shift + h 상단 shift + m 중단 shift + l 하단 페이지 내 이동 단축 키 ctrl + f 다음 페이지 (forward) ctrl + b 이전 페이지 (back) 편집 변환 단축 키 a 한 칸 앞 i 그 자리 o 행 추가 후 아래 s 글자 치환 (삭제 후 입력) 삭제(커서 기준) 단축 키 x 한 글자씩 삭제 dd 행 삭제 숫자 + dd 숫자 행만큼 삭제 dw 단어 삭제 de 단어 삭제 db 단어 삭제 d$ 행 끝까지 삭제 d0 행 최초까지 삭제 dgg 문서 최초까지 삭제 d + shifth + g 문서 끝까지 삭제 복사(커서 기준) 단축 키 yy 행 복사 숫자 + yy 숫자 행만큼 복사 p 붙여넣기 yw 단어 복사 ye 단어 복사 yb 단어 복사 y$ 행 끝까지 복사 y0 행 최초까지 복사 ygg 문서 최초까지 복사 y + shift + g 문서 끝까지 복사 복구 단축 키 u 되돌리기 ctrl + r 역되돌리기 검색 단축 키 / [검색 문자열] 문서 하단 방향 검색 (↓) n 다음 문자열 정방향 검색 (↓) N 다음 문자열 역방향 검색 (↑) ? [검색 문자열] 문서 상단 방향 검색 (↑) n 다음 문자열 정방향 검색 (↑) N 다음 문자열 역방향 검색 (↓) " }, { "title": "Linux 명령어", "url": "/posts/linux-command/", "categories": "OS, Linux", "tags": "os, linux", "date": "2022-08-31 19:27:00 +0900", "snippet": "Linux 명령어명령어 법칙 명령어 뒤에는 반드시 띄어 쓰기를 한다. 명령어 --option traget 순서를 지킨다. - : 간소화, 단축 옵션 ex) -h -- : 풀옵션 ex) --help 명령어 옵션은 조합이 가능하다 옵션 순서가 적용될 시 마지막 옵션 적용 ex) 청기들어 청기내려 청기들어 청기내려 → 마지막 청기내려 적용 정반대되는 옵션 : 옵션에 대한 순서 영향 보고 판단 경로가 중간에 누락되면 안된다. 하나의 경로는 절대 띄어쓰지 않는다 경로 띄어쓸 경우 2개로 인식 pwd # 현재 위치 /home/test mkdir /home/test/a/b # a 디렉토리가 없어 에러 발생 mkdir /home/test/a # a 디렉토리가 생성 mkdir /home/test/a/b # 정상적으로 생성 가능 ls -lR # 하위 디렉토리 목록까지 확인하는 명령어 기본 명령어 pwd prompt work directory 약자 경로 확인 명령어 prompt(명령어 입력받을 수 있는 상태)가 대기하고 있는 directory 확인 prompt 창 상태 ID@네트워크 명 현재 위치 dir 권한 형태 [root@localhost 바탕 화면]# root : ID, localhost에 가입되어 있는 root 계정 @localhost : 가입 되어 있는 네트워크 명 바탕 화면 : 현재 위치 dir, pwd # : 관리자 권한 [mxxikr@localhost 바탕 화면]$ mxxikr : ID, localhost에 가입되어있는 mxxikr 계정 @localhost : 가입되어 있는 네트워크 이름 바탕 화면 : 현재 위치 dir(pwd) = /home/mxxikr/바탕화면 $ : 사용자 권한 ls list 약자 디렉토리 목록 확인 명령어 -q -l(--long) 자세한 내용 출력 권한, 포함된 파일 수, 소유자, 그룹, 파일 크기, 파일 이름, 수정 일자 -a(--all) 숨김 파일(.) 포함에서 모든 내용 출력 -dl 디렉토리 정보만 표시 -S(--size) 파일 크기 순으로 정렬하여 출력 -r(--reverse) 거꾸로 출력 (기본값은 알파벳 순서 출력) -R(--recursive) 하위 디렉토리까지 출력 -h(--human) K, M, G단위 사용하여 사람이 보기 좋게 파일 크기 표시 mkdir make directory 약자 directory 생성 -p parents 약자 누락된 상위 디렉토리까지 한번에 생성 touch 파일 생성 rm rm -rf remove 약자 파일 삭제 명령어 -r (recursive) 디렉토리를 하위 내용부터 삭제 -f (force) 확인 메세지 없이 강제 삭제 -i (interactive) 삭제 할 때 매번 삭제 여부 사용자에게 물어봄 -v (verbose) 삭제하는 동안 삭제되는 내용 보여줌 rmdir remove directory 약자 디렉토리 삭제 명령어 -p 필요한 경우 경로 상의 상위 디렉토리도 삭제 mv mv /movetest/a /movetest/b /mvtest # /movetest/a를 /movetest/b로 이름 변경하여 /mvtest에 이동 move 약자 파일/디렉토리 이동 명령어 파일/디렉토리 이름 변경 명령어 경로에 따른 mv 명령 결과 원본과 target이 이름이 같을 경우 하위 dir로 위치 (이름 생략 가능) 원본과 target의 이름이 다를 경우 복사 이동과 동시에 이름 변경 여러 경로 존재 시 가장 마지막 경로가 target cp copy 약자 파일 복사 -r 파일 포함한 dir 복사 -p 보존 복사 (속성 값, 시간 그대로 복사) -f 복사 대상 파일이 이미 그 위치에 존재 한다면 파일 삭제 후 강제 복사 -i 복사 대상 파일이 이미 그 위치에 존재 한다면 덮어쓸 것인가를 사용자에게 확인(y/n) 경로에 따른 cp 명령 결과 원본과 target이 이름이 같을 경우 하위 dir로 위치 (이름 생략 가능) 원본과 target의 이름이 다를 경우 복사 이동과 동시에 이름 변경 여러 경로 존재 시 가장 마지막 경로가 target . pwd # /root/ cd . pwd # /root/ # 계속 현재위치에 머물러 있음 현재위치 .. pwd # /root/ cd .. pwd # / # 상위 디렉토리로 경로 이동 상위 디렉토리 ~ # mxxikr@localhost 바탕화면 pwd # /home/mxxikr/바탕화면 cd ~ pwd # /home/mxxikr 로그인 계정의 home dir cd pwd # /root/ cd /home/mxxikr pwd # /home/mxxikr # /root/에서 /home/mxxikr로 디렉토리 이동 change directory 디렉토리 변경, 이동 ex) /home/mxxikr/c/d 위치에서 디렉토리 이동 cd ./ # /home/mxxikr/c/d cd .. # /home/mxxikr/c cd ../../.. # / cd home # /home cd ./home # /home cd test/a/b # /home/test/a/b cd ../../../mxxikr/c/d # /home/mxxikr/c/d stat 파일 속성 내용, 접근 내용 확인 명령어 mac(modify/access/change) time 확인 access(파일에 대한 접근), modify, change(변조) 확인 가능 vmstat 시스템 메모리 확인 명령어 시스템 리소스 모니터링 cat cat /etc/passwd 파일 내용 출력 명령어 문서 전체 보기 head cat test.txt | head -n 3 # test.txt 문서 상단부터 3줄만 출력 head -3 /etc/passwd | cat -n # 줄 앞에 번호를 붙이고 /etc/passwd 문서 상단부터 3줄만 출력 파일 내용 앞부분만 출력하는 명령어 문서 상단부터 기본 10줄 출력 -n 출력하는 줄 수 입력 (defalt 10줄) tail cat test.txt | tail -n 5 # test.txt 문서 하단부터 5줄만 출력 tail -15 /etc/passwd | cat -n # 줄 앞에 번호를 붙이고 /etc/passwd 문서 하단부터 15줄만 출력 파일 내용 하단부터 출력 명령어 문서 하단부터 기본 10줄 출력 -F 파일 변경 감시해 내용 추가 될 때마다 변경 점 실시간 출력 -n 출력하는 줄 수 입력 (defalt 10줄) more more -3 /etc/passwd # /etc/passwd 3줄씩 끊어 보기 파일 내용을 잘라서 출력 문서 끊어 보기 (= less 명령) [Enter] : 한줄씩 출력 [Spacebar] : 단위 출력 grep cat test.txt | grep \"test\" # test.txt에서 test 문자열 포함한 줄 출력 문자열 검색 명령어 문자가 포함된 열 추출 -r 디렉토리 내의 모든 디렉토리, 파일까지 검색하도록 지정 -i 대문자, 소문자 차이 무시 -v 검색할 문자열이 포함되지 않은 줄만 출력 -n 라인 수 출력 find find [PATH] -name [FILE_NAME] -type [FILE/DIRECTORY] -perm [PERMISSION] find / -name [FILE_NAME] -exec rm { } \\; # 일치하는 파일 찾아 삭제 # { } : find 명령 진행 # \\ : 실행 # ; : 마침표 find /home -name mxxikr # /home에 있는 파일 중 파일명이 mxxikr인 파일 검색 find /home -name mxxikr -o -name mxxikr2 # /home에 있는 파일 중 파일명이 mxxikr, mxxikr2인 파일 검색 find / -perm +4000 # setuid (관리자 권한 확인) find /find -name 'te*' -exec rm {} \\; # /find에서 파일명이 te로 시작하는 모든 파일 찾아서 삭제 하위 폴더에 존재하는 파일 찾아주는 명령어 -name 대소문자 구분하여 파일명 검색 -iname 대소문자 구분하지않고 파일명 검색 -o 여러 개 검색할 때 삽입 -type 파일 타입 검색 -perm 권한 검색 -exec 함수, 실행 결과 -atime +n 파일에 접근한지 +n일 이상인 경우 검색 -atime -n 파일에 접근한지 -n일 이내인 경우 검색 -ctime +n 파일 생성한지 +n일 이상인 경우 검색 -ctime -n 파일 생성한지 -n일 이내인 경우 검색 -mtime +n 파일 변경한지 +n일 이상인 경우 검색 -mtime -n 파일 변경한지 -n일 이내인 경우 검색 -amin +n 파일에 접근한지 +n분 이상인 경우 검색 -amin -n 파일에 접근한지 -n분 이내인 경우 검색 -cmin +n 파일 생성한지 +n분 이상인 경우 검색 -cmin -n 파일 생성한지 -n분 이내인 경우 검색 -mmin +n 파일 변경한지 +n분 이상인 경우 검색 -mmin -n 파일 변경한지 -n분 이내인 경우 검색 -newer target 타겟 파일 생성 후에 수정된 모든 디렉토리 및 파일 (문서 수정) 검색 ifconfig, ip addr ip 확인 free -m 메모리 상태 확인 시간 관련 명령어 hwclock 하드웨어 시간 확인/재설정 hwclock -s CMOS의 시간을 가져와 현재 운영 체제 시간 재설정 hwclock -r 하드웨어 시간 확인 date 리눅스 시스템에서 인식하고 있는 현재 시간 확인/재설정 rdate 시간 동기화 지정한 원격 타임 서버의 시간과 현재 시스템의 운영 체제의 시간 동기화 rdate -p [NTP 주소] NTP(Network Time Protocol) 서버 시간 확인 rdate -s [NTP 주소] NTP(Network Time Protocol) 서버와 시간 동기화 시간 변경 옵션touch -d 07:22 1 # 07:22인 1파일 생성touch -t 200012121212.10 2 # 2000년 12월 12일 12시 12분 10초인 2파일 생성 -d [시]:[분] 당일 시간 변경 -t [yyyy][mm][dd][hh][mm][.ss] 년도 날짜 시간 변경 정규 표현식 * rm -rf * # 전체 파일 삭제 rm -rf 1* # 1로 시작하는 파일 전체 삭제 rm -rf *1 # 1로 끝나는 파일 전체 삭제 모두, 문자전체 ? rm -rf ? # 한자리 숫자 파일 전체 삭제 자리 수, 대체 문자 필터링 할 때 사용 | ls -l /etc | grep sys # sys 문자열을 포함한 /etc 리스트 출력 pipe 오른 쪽 명령을 받아 왼쪽 명령 실행 프로세스 혹은 실행된 프로그램의 결과를 다른 프로그램으로 넘겨줄 때 사용 (input) | (output) &lt; cat &lt; c # cat c와 동일 read 읽기 &gt; ls -l /home /ac &gt; test3 # /home과 /ac의 list를 test3 파일로 생성 write 쓰기, 파일 생성, 덮어쓰기 &gt;&gt; cat b a &gt;&gt; c # c원본 아래 b,a 파일 병합 내용 추가 add 추가, 파일 생성, 원본 아래 내용 추가 Redirection 출력을 입력으로 변환 프로그램의 결과 혹은 출력을 파일이나 다른 스트림으로 전달하거나 남길 때 사용 &lt; # 입력 redirection&gt; # 출력 redirection&gt;&gt; # 추가 출력 redirection0 # 입력, 입력부분, input1 # success (정상출력), output(기본값)2&gt; # error redirection (오류출력), output&amp;&gt; # 표준 출력과 표준 에러를 동시에 redirectioncat a b d &gt; c # 정상 내용만 입력cat a b d 1&gt; c # 정상 내용만 입력cat a b d 2&gt; c # 오류 내용만 입력cat a b d &gt; c 1&gt;&amp;2 # 정상 내용 오류 처리cat a b d &gt; c 2&gt;&amp;1 # 오류 내용 정상 처리 논리 연산자 + 덧셈 - 뺄셈 * 곱셈 / 나눗셈 &amp;&amp; and a &amp;&amp; b # a 그리고 b # 프로그램 반복문 사용(a 성공 시 b 실행, a 실패시 b 미실행) || or a || b # a 또는 b # 백업 관련 사용(a 성공 시 b 미실행, a 실패시 b실행) aliasalias c = 'clear' # alias 설정alias # alias 확인unalias c # alias 삭제 별칭 모음 로그 아웃하면 내용 삭제 영구적 사용은 shell에 부여해야함 ' ' 함수 싱글 쿼터 \" \" 변수 싱글 쿼터 " }, { "title": "OS와 Linux", "url": "/posts/linux/", "categories": "OS, Linux", "tags": "os, linux", "date": "2022-08-31 03:27:00 +0900", "snippet": "OS (Operate System)OS 운영 체제 ex) DOS, window 98, NT, XP, Vista, 7, Unix, Linux 사용자들이 보다 쉽고 간편하게 시스템 이용 가능하도록 제어하는 시스템 소프트웨어의 일종 사용자와 컴퓨터 간의 인터페이스 제공 시스템의 효율적인 운영 및 관리 가능 운영 체제의 성능을 평가하는 기준 처리 능력 (Throughout) : 일정 시간 내에 시스템이 처리하는 일의 양 반환 시간 (Turn Around Time) : 시스템에 작업을 제시하고 나서부터 결과를 받을 때까지의 경과 시간 사용 가능도 (Availability) : 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도 신뢰도 (Reliability) : 시스템이 주어진 문제를 정확하게 해결하는 정도 BIOS (Basic Interface Operate System) 하나의 OS 메인보드에 대한 정보 가지고 있음Kernel 메모리 관리하는 OS의 가장 핵심적인 부분 컴퓨터가 부팅될 때 주기억 장치에 적재된 후 상주하면서 실행 실행 중인 프로그램 관리와 시스템에 대한 전반적인 자원을 관리하는 역할 수행 하드웨어 보호 및 프로그램과 하드웨어 간의 인터페이스 역할 HW/SW의 정보를 메모리 형태로 저장하고, OS에 전달해주는 중계 프로그램LinuxGNU (Gnu’s Not Unix) 자유 소프트웨어 재단 리눅스 등록 관리 무분별한 배포 관리 리차드 스톨만 창시Linux 자유도가 높은 OS (Operate System) 커스터마이징 가능(사용자 설정) Redhat 계열, Debian 계열 등 여러계열의 리눅스 존재 서버, 네트워크 기능 강화 보안 강화 자유도가 높기 때문에 보안에 대한 부분 계속해서 Update Unix(대용량 Data를 관리하기 위해 사용하는 OS)를 소형화한 OSRun level 부팅 레벨 (0~6) 리눅스 시스템 관리의 용이함을 위하여 서비스의 실행을 단계별 구분해 적용한 것 Run Level Mode Description 명령어 0 halt 시스템 종료 init 0 1 singel user mode 시스템 복구 모드, 관리자 권한 default ex) windows 안전 모드 init 1 2 multi user mode NFS 미지원 다중 사용자 모드, TUI 환경 init 2 3 full multi user mode CLI 다중 사용자 모드, graphic user mode 미지원, TUI 환경 init 3 4 unused 임의로 정의해 사용 가능한 레벨, 기본적으로 미사용 init 4 5 graphic user mode 다중 사용자 모드, GUI 환경 init 5 6 reboot 시스템 재부팅 init 6 UI (user interface) GUI (Graphical user interface) 그래픽 환경 그래픽으로 사용자와 상호 작용 정보 저장소 = 폴더(folder) TUI (Text user interface) 텍스트 환경 텍스트로 사용자와 상호 작용 정보 저장소 = 디렉토리(directory) UI 확인 및 변경 명령어 systemctl get-default # interface 확인 sudo systemctl set-default graphical.target # 재부팅 시 GUI mode 변경 sudo systemctl isolate graphical.target # 현재 세션에서 GUI mode 변경 sudo systemctl set-default multi-user.target # 재부팅 시 TUI mode 변경 sudo systemctl isolate multi-user.target # 현재 세션에서 TUI mode 변경 Shell 언어 변환기(명령어 전달 도구) 사용자가 쓰는 명령어, 언어를 Kernel에 전달해주는 언어 변환기 sh 커널 기본 shell bash Linux shell csh C program 전용 shell ksh korn shell Unix shell Linux Directory 구조 트리 구조 /root 최상위 관리자 홈 디렉토리 ex) C:드라이브 /sbin 필수적인 system 명령어 저장소 system binary ascii(문자, 문서파일) ex) C:\\Windows\\wow64 /bin 필수적인 기본 명령어 저장소 대부분의 명령어 저장 binary ascii(문자, 문서파일) ex) C:\\Windows\\system32 /boot 부팅 파일 저장소 부팅 관련 grub(부트로더), lilo(linux loader) 존재 환경 파일 제외한 부팅 과정에서 필요한 모든 구성 요소들 존재 ex) boot.ini (부팅 파일) /home 사용자 계정이 들어가는 저장소 사용자 홈 디렉토리 저장소 계정 접속 위치 계정 전용 공간 (사용자 홈 디렉토리) ex) C\\users\\사용자명 /usr 유저가 사용하는 소스 사용자가 실행할 program files 저장 응용 프로그램 대용량 저장소 /sbin /sbin에 있는 명령을 제외한 system 관리 명령어 저장소 /bin /bin에 있는 명령을 제외한 응용 프로그램 명령어 저장소 /var 자주 변경되는 비휘발성(non-volatility) 데이터 자주 변경되는 누적 파일 저장소 내용 저장소 로그 파일 저장소 계속 남아있음 ex) log, 메일, 상태 메세지, 시스템 에러 메세지 /run 마지막 부트 때부터 작동하는 시스템에 대한 정보 현재 로그인 정보와 작동하고 있는 데몬 /log 컴퓨터 기록 저장 로그 파일 ex) 일기장 /etc 설정 파일, 스크립트(ascii) 기타 등등, 나머지 파일 서버 관리 및 시스템 설정 파일 저장소 /proc 자주 변경되는 program 동작 정보 저장소 kernel, 가상화, 프로그램 등 running 중인 모든 프로그램 휘발성 (volatility) 데이터 실행 중인 process 동작 정보 저장소 재부팅 시 정보 사라짐 /proc/cpuinfo 프로세서 정보 /proc/devices 현재 커널에 설정되어 있는 장치 목록 /lib library 언어 번역기, 언어 관련 해석(변환)기 프로그램 해석(실행)가능 언어 관련 파일 저장소(컴파일러, 모듈) 어떠한 프로그램을 실행하기 위해 있어야 하는 하나의 변환기 → 없으면 해당 언어 번역 불가능 C언어나 Java같은 언어를 해석해주는 하나의 언어 File 정적/동적 라이브러리 정적 라이브러리 Linux : a Window : lib 동적 라이브러리 Linux : so Window : dll (Dynamic Link Library) /tmp temp 임시저장소 (기본 1,000개) 시스템 reboot 후 보존되지 않음 /misc 아키텍처 독립 자료 디렉토리 /dev device 장치 파일 저장소 TUI (Text User Interface) 환경 : 수동 장치 연결 (mount) GUI (Graphic User Interface) 환경 : 자동 장치 연결 (PnP:Plug&amp;Play) /media 자동 장치 연결 시 기본 장치가 연결되는 장소 local device : 키보드, 마우스, HDD, CD-ROM /mnt 자동 장치 연결 시 원격 장치가 연결되는 장소 remote device : 리모콘, 블루투스, 무선 마우스, Wi-Fi Directory 경로 /의 자리에 따라 의미가 달라짐 ex) /var/log : 최상위 directory 안의 var directory 안의 log directory ex) /home/mxxikr : 최상위 directory안의 home directory 안의 mxxikr directory ex) /usr/bin : 최상위 directory 안의 usr directory 안의 bin directory 문자열 가장 앞 / 최상위 디렉토리 의미 문자열 중간 / dir 구분자 문자열 마지막 / 보통 생략 사용 directory 의미 (정보 저장소) 절대 경로 최상위(/) 기준으로 판단 최상위부터 시작 /가 기준이 되는 경로 pwd # /home/mxxikr/a cd /home/test # 절대 경로 지정 이동 pwd # /home/test 상대 경로 현재 경로 (pwd) 기준으로 판단 지금 내 위치에서 이동 pwd 입력 시 출력되는 위치부터 시작 pwd # /home/mxxikr/a cd b # 상대 경로 지정 이동 pwd # /home/mxxikr/a/b 파일/디렉토리 구분법 ls -al 명령어 통해 속성 확인 가능 ls -al # d rwxrwxrwx # - rwxrwxrwx # l rwxrwxrwx d rwxrwxrwx : directory - rwxrwxrwx : file l rwxrwxrwx : link (바로 가기) .파일명 : hidden file (숨김 파일) " }, { "title": "Google Cloud SDK 설치 및 gcloud, gsutil 명령어", "url": "/posts/gsutil/", "categories": "Cloud, GCP", "tags": "gcp, cloud-sdk, gcloud, gsutil", "date": "2022-08-26 17:13:00 +0900", "snippet": "Google Cloud SDKCloud SDK 설치 및 설정 Google Cloud SDK 설치 (New-Object Net.WebClient).DownloadFile(\"https://dl.google.com/dl/cloudsdk/channels/rapid/GoogleCloudSDKInstaller.exe\", \"$env:Temp\\GoogleCloudSDKInstaller.exe\") &amp; $env:Temp\\GoogleCloudSDKInstaller.exe gsutil 컴포넌트 설치 gcloud components install gsutil gcloud CLI 초기화 gcloud init Google 사용자 계정을 사용하여 GCP 로그인 하는 옵션 수락 (Y) To continue, you must log in. Would you like to log in (Y/n)? Y 브라우저 창이 열리면 Google 계정에 로그인 후 허용 버튼 클릭 GCP 리소스 액세스 권한 부여 과정 prompt 창에 표시된 사용 가능한 GCP 프로젝트 선택 Pick cloud project to use: [1] [my-project-1] [2] [my-project-2] ... Please enter your numeric choice: 2 기본 Compute Engine 영역 선택 Which compute zone would you like to use as project default? [1] [asia-east1-a] [2] [asia-east1-b] ... [14] Do not use default zone Please enter your numeric choice: SDK 설치 시 설치되는 구성요소 gcloud 기본 gcloud CLI 명령어 Google Cloud와 상호작용하기 위한 도구 bq BigQuery 명령줄 도구 Google BigQuery의 데이터 처리하기 위한 도구 gsutil Cloud Storage 명령줄 도구 Google Cloud Storage와 관련된 작업 수행하기 위한 도구 core Cloud SDK 핵심 라이브러리 SDK 도구 내부적으로 사용하는 라이브러리 명령어gcloud 기본 설정 gcloud projects create [PROJECT_ID] # GCP 프로젝트 생성 gcloud config set project [PROJECT_ID] # 프로젝트 재설정 gcloud config set compute/zone [COMPUTE-ZONE] # Region 설정 권한 설정 gcloud auth activate-service-account [SERVICE ACCOUNT] --key-file=[KEY_FILE] # 서비스 키로 권한 설정 정보 확인 gcloud auth list # 사용자 인증 정보 확인 gcloud config list # 활성 SDK 구성 속성 나열 gcloud info # gloud SDK 설치 및 활성 SDK 구성 정보 확인 gcloud help # gcloud 명령어 및 기타 주제 정보 확인 gcloud components list # 현재 설치된 사용 가능한 구성요소 목록 확인 명령어 gcloud components install [components-id] # Cloud SDK 설치 버전에서 구성 요소 설치하는 명령어 gcloud components update # 설치된 모든 구성요소를 최신 Cloud SDK 버전으로 업데이트 gcloud components update --version [VERSION] # 지정된 버전으로 버전 gcloud components remove [COMPONENT-ID] # 구성 요소 삭제 Cloud Task Que gcloud tasks queues create [queue_id] # Que 만들기 gcloud tasks queues describe [queue_id] # 대기열 생성 확인 Pub/Sub gcloud pubsub topics create [TOPIC-ID] # 주제 생성 Cloud SQL gcloud sql databases create [DATABASE_NAME] --instance=[INSTANCE_NAME] # Cloud SQL 인스턴스에서 데이터베이스 생성 gcloud sql instances describe [DATABASE_NAME] | findstr \"connectionName\" # 연결 이름 확인 Cloud Function gcloud functions deploy [FUNCTION_NAME] --runtime python37 --trigger-http --allow-unauthenticated --region [REGION] --timeout 540 --project=[PROJECT-ID] # HTTP 함수 배포 gcloud functions deploy [FUNCTION_NAME] --runtime [runtime] --trigger-resource [TRIGGER_BUCKET_NAME] --trigger-event google.storage.object.finalize --region [REGION] --timeout 540 --project=[PROJECT-ID] # 이벤트 기반 함수 배포 deploy 배포 중에 실행할 소스 코드의 함수 이름 지정 --runtime 함수의 runtime --trigger-http 함수의 트리거 유형(HTTP 요청) -trigger-resource 함수의 트리거 리소스 트리거 이벤트가 관찰되는 리소스 지정 함수를 트리거하는 Cloud Storage 버킷 이름 지정 -trigger-event 함수의 트리거 이벤트 함수를 트리거할 작업 지정 -allow-unauthenticated 함수 호출에 인증이 필요한지 지정 gsutil 정보 확인 gsutil version -l # gsutil 버전 확인gsutil list # 나의 버킷 리스트 보기gsutil ls -r gs://[BUKET_NAME] # 버킷 내 객체 확인gsutil du -s gs://[BUKET_NAME] # 버킷 용량 확인gsutil ls -l gs://[FILE_PATH] # 객체 세부 정보 보기 버킷 및 객체 관리 gsutil mb gs://[BUKET_NAME] # 버킷 생성gsutil rb gs://[BUKET_NAME] # 버킷 삭제gsutil cp [LOCAL_FILE_PATH] gs://[BUKET_NAME] # 로컬 파일 → 버킷 복사 (업로드)gsutil cp gs://[BUKET_NAME] [LOCAL_FILE_PATH] # 버킷 객체 → 로컬 복사 (다운로드)gsutil cp -r gs://[BUKET_NAME] gs://[BUKET_NAME] # 버킷 → 버킷 복사gsutil mv [LOCAL_FILE_PATH] gs://[BUKET_NAME] # 로컬 → 버킷 이동gsutil mv gs://[BUKET_NAME] [LOCAL_FILE_PATH] # 버킷 → 로컬 이동gsutil rm gs://[FILE_PATH] # 객체 삭제gsutil rm -r gs://[BUKET_NAME] # 버킷과 객체 삭제 권한 설정 gsutil iam ch allUsers:objectViewer gs://[BUKET_NAME] # 모든 사용자가 버킷 객체 읽을 수 있는 권한 부여gsutil iam ch -d allUsers:objectViewer gs://[BUKET_NAME] # 권한 삭제gsutil iam ch user:[USER_ACCOUNT]:objectCreator,objectViewer gs://[BUKET_NAME] # 특정 사용자에게 버킷 액세스 권한 부여gsutil iam ch -d user:[USER_ACCOUNT]:objectCreator,objectViewer gs://[BUKET_NAME] # 권한 삭제 옵션 gsutil -m acl ch # Access Control List 변경gsutil -m acl set private gs://[BUKET_NAME] # 버킷 및 객체 Access Control List 설정gsutil -m cp -r # 복사gsutil -m mv -r # 이동gsutil -m rm -r # 삭제gsutil -m rsync -r [LOCAL_FILE_PATH] gs://[BUKET_NAME] # 원본과 버킷 사이에 동기화gsutil -m setmeta # meta data 설정 -m 멀티프로세싱 작업 가능 -r 아래 모든 객체 포함해 작업 Reference GCP gsutil docs" }, { "title": "IP 주소 체계와 Subnet, Supernet", "url": "/posts/ip-subnet-supernet/", "categories": "Network", "tags": "ip, network", "date": "2022-08-26 00:24:00 +0900", "snippet": "IPIP(Internet Protocol) PC 간 연결하기 위한 통신 규약 (인터넷 규약) 인터넷 상에 있는 컴퓨터 고유의 주소 인터넷 상의 한 컴퓨터에서 다른 컴퓨터로 데이터 주고 받기 가능 IPv4와 IPv6로 나뉨IPv4 32 bit 10진수와 2진수 사용 0.0.0.0 ~ 255.255.255.255 = 2^8 * 4 = 2^32 = 약 43억개의 IP 생성 가능IPv6 128 bit 16진수 사용(0~f) 0.0.0.0.0.0.0.0 ~ ffff.ffff.ffff.ffff.ffff.ffff.ffff.ffff = 2^123 = 43억 * 43억 * 43억 * 43억 IP 생성 가능 IPv4의 고갈로 인해 생성IP 주소 체계와 클래스Class IP의 사용에 따라 분류된 구분 값 Classful Network ID 고정 따로 알려주지않아도 어디까지가 Net ID인지를 인식 ex) 홍길동 02-123-4567​​ ex) 192.168.1.0​ → 255.255.255​​.0​​ Classless Network ID 유동적 → 관리 효율 따로 알려주지 않으면 어디까지가 Net ID인지 인식 불가능 Net Mask / Wildcard Mask / Prefix로 구분 가능 ex) 연개소문 → 연개​ 소문​/연​ 개소문​​ ex) 192.168.1.0 대역 255.255.255.128 → 192.168.1.0 ~ 127, 192.168.128 ~ 192.168.255​ Class별 IP 주소 Class Net ID Bit 사용 규모 사용 용도 IP Net mask 사설 고정 IP A Class 0 ~ 127​​.0.0.0 128bit 대규모 network 국가 0.0.0.0 ~ 127.0.0.0 255.0.0.0 10.0.0.0 B Class 128 ~ 191.X.0.0 64bit 중소규모 network 공공기관 128.X.0.0 ​~ 191.X.0.0 255.255.0.0 172.16.0.0, 172.31.0.0​ ​C Class​ 192 ~ 223.X.X.0​ 32bit​ 일반 network​ 통신사​ 192.X.X.0 ~ 223.X.X.0​ 255.255.255.0​ 192.168.X.0​ ​D Class​ 224 ~ 239.X.X.0​ 16bit​ Multicast​ network 장비​ ​ ​   ​E Class​ 240 ~ 254.X.X.0​ 16bit​ 연구, 특수 목적으로 예약된 주소​ ​ ​ ​​   네트워크(Net ID)가 일치해야 통신 가능 X(0~255) = Net ID : 상위 네트워크에서 지정된 값 (사용자 변경 불가) 0(0~255) = Host ID : 하위 네트워크에서 지정된 값 (사용자 변경 가능)공인 IP Internet 상에서 사용하는 IP 유일한 IP사설 IP ISP(Internet Service Provider) 업체를 통해서 제공 받음 인터넷이 가능한 IP 같은 IP 여러개 존재 NAT(통신망의 주소 변환기)를 통해 사설 IP를 공인 IP 주소로 변환해 인터넷에 접속 단독 인터넷 사용 불가능 공유기나 내부 네트워크를 사용해 인터넷에 접속할 경우 사설 IP라고 하는 특정 주소 범위(192.168.0.1~192.168.255.254)가 내부적으로 사용되고 공인 IP를 알아 낼 수 없다. port forwarding이나 VPN 사용 시 사설 IP끼리 통신 가능 IP 표기법Net Mask Net ID와 Host ID를 구분해주는 구분자 (기준값) 변하지 않는 부분(Net ID)를 2진수 1로 표기 ex) 10.0.0.0 (10.0.0.0 ~ 10.255.255.255) 대역 → 1111 1111.X.X.X → 255.0.0.0​​ A Class : 255.0.0.0 B Class : 255.255.0.0 C Class : 255.255.255.0Wildcard Mask NetMask를 거꾸로 주는 형태 (1111 1100 → 0000 0011) 연속되지 않은 네트워크를 표현하기 위하여 오류검사를 통해 표현하는 표기법 0 : 검사 시행 (바뀌지 않음) 1 : 검사 미시행 (바꿀 수 있음) 변하는 부분(Host ID)을 2진수 1로 표기 ex) 10.0.0.0 (10.0.0.0 ~ 10.255.255.255) 대역 → X.1111 1111.1111 1111.1111 1111 → 0.255.255.255​ A Class : 0.255.255.255 B Class : 0.0.255.255 C Class : 0.0.0.255Prefix 앞을 고정 Network-ID 부분의 1의 개수를 숫자로 표기 ex) 10.0.0.0 → 1111 1111.0.0.0 → /8CIDR 표기법 (Classless Inter Domain Routing) 네트워크 대역 표기법 2진수로 표기 ex) 1111 1111.1111 1111.1111 1111.0000 0000 → 1의 개수 : 24개 Prefix : 192.168.1.0/24 IP : 192.168.1.1 ~ 192.168.1.254 Net Mask : 255.255.255.0 SubnetSubnet IP 손실 줄이고 IP 보호하기 위해 Network를 나누는 개념 서로 같은 Network 영역일 때는 Switching 했지만 다른 Network 영역이 되어 Routing 하게 됨 균등 Subnetting과 비균등 Subnetting으로 나눠짐 ex) 홍 길동 → 홍ㄱ ㅣㄹ동 ex) 남양 홍씨 홍 길동 → 남양군파 남양 홍씨 홍 길동 → 길자 돌림 남양군파 남양 홍씨 홍 길동균등 Subnettnig 새로 생성된 Subnet에 속하는 Host 수가 일정 ex) 회사 사용 network 200.1.1.0/24 → Network 1개 ex) 8개의 부서별로 Network를 분리(Subnet 8개 필요)해야함 Subnet 8개 = 2^3 = subnet-bit : 3 8bit - 3bit = 5bit : host-bit = Host 32개 = 2^5 부서 IP 범위 CIDR 표기법 사용 가능 host A 부서 200.1.1.0 ~ 200.1.1.31 255.255.255.224 1~30 (0은 대표 주소, 31는 direct broadcast 주소) B 부서 200.1.1.32 ~ 200.1.1.63 255.255.255.224 33~62 (32는 대표 주소, 63는direct broadcast 주소) C 부서 200.1.1.64 ~ 200.1.1.95 255.255.255.224 65~94 (64는 대표 주소, 95는 direct broadcast 주소) D 부서 200.1.1.96 ~ 200.1.1.127 255.255.255.224 97~126 (96은 대표 주소, 127은direct broadcast 주소) E 부서 200.1.1.128 ~ 200.1.1.159 255.255.255.224 129~158 (128은 대표 주소, 159는 direct broadcast 주소) F 부서 200.1.1.160 ~ 200.1.1.191 255.255.255.224 161~190 (160은 대표 주소, 191은 direct broadcast 주소) G 부서 200.1.1.192 ~ 200.1.1.223 255.255.255.224 193~222 (192는 대표 주소, 223은 direct broadcast 주소) H 부서 200.1.1.224 ~ 200.1.1.255 255.255.255.224 225~254(224은 대표 주소, 255은 direct broadcast 주소) 비균등 Subnetting(=VLSM) 새로 생성된 Subnet에 속하는 Host수가 다름 다양한 길이의 Subnet 가변 길이 Subnet Mask 하나의 네트워크 영역을 서로 다른 크기로 Subnetting하는 기법 VLSM (Variable Length Subnet Mask)라고 부름 ex) 회사 사용 network 201.10.1.0/24 Main Network 1개) 4개의 부서별로 Network를 분리 (Subnet 4개 필요)해야 함 영업부는 120개, 인사부는 60개, 관리부와 홍보부는 20개씩 Host 사용) 부서 사용 가능 host IP 범위 CIDR 표기법 영업부 host 120개 &lt; 2^7(128) → host-bit : 7 201.10.1.0 ~ 201.10.1.127 255.255.255.128 인사부 host 60개 &lt; 2^6(64) → host-bit : 6 201.10.1.128 ~ 201.10.1.191 255.255.255.64 관리부 host 20개 &lt; 2^5(32) → host-bit : 5 201.10.1.192 ~ 201.10.1.223 255.255.255.32 홍보부 host 20개 &lt; 2^5(32) → host-bit : 5 201.10.1.224 ~ 201.10.1.255 255.255.255.32 SupernetSupernet 축약 (Summary) 공통되는 호스트를 구해 Subnet 지정 연산부하 줄이거나 상세정보를 감추려고 Network를 합치는 개념 서로 다른 Network 영역일 때는 Routing 하지만 같은 Network 영역이 되기 때문에 Switching 하게 됨 ex) 홍 길동 → 호 ㅇ길동 ex) 11.1.0.0/24 → 0000 1011.0000 0001.0000 0000.0000 0000 ex) 11.1.1.0/24 → 0000 1011.0000 0001.0000 0001​​.0000 0000 ex) 11.1.2.0/24 → 0000 1011.0000 0001.0000 0010​.0000 0000 ex) 11.1.3.0/24 → 0000 1011.0000 0001.0000 0011​​.0000 0000 ex) 11.1.4.0/24 → 0000 1011.0000 0001.0000 0100​​.0000 0000 ex) 11.1.5.0/24 → 0000 1011.0000 0001.0000 0101​​.0000 0000 ex) 11.1.6.0/24 → 0000 1011.0000 0001.0000 0110​.0000 0000 ex) 11.1.7.0/24 → 0000 1011.0000 0001.0000 0111​​.0000 0000 Net-ID Host-ID → 0으로 표기 변하지 않는 Network-ID → 1로 표기 변하는 Network-ID → 0으로 표기 ex) supernetting → 1111 1111.1111 1111.1111 1000.0000 0000 Net Mask → 255.255.248.0 wildcard Mask → 0.0.7.255 prefix → 21 ex) 192.168.1.0 ⇒ 1111 1111.1111 1111.0000 0001.0000 0000 ex) 192.168.2.0 ⇒ 1111 1111.1111 1111.0000 0010.0000 0000 ex) 192.168.3.0 ⇒ 1111 1111.1111 1111.0000 0011.0000 0000 ex) 192.168.4.0 ⇒ 1111 1111.1111 1111.0000 0100.0000 0000 ex) 192.168.5.0 ⇒ 1111 1111.1111 1111.0000 0101.0000 0000 ex) 1111 1111.1111 1111.0000 0111.0000 0000 ⇒ 255.255.248(256-2^3).0통신 발송 방식BroadCast NetWork 상 불특정 다수에게 통신 발송 IPv4에서만 사용 ex) 라디오, TVMulticast NetWork 상 특정 다수에게 통신 발송 특정 그룹 통신 ex) 부산방송, 서울방송, 학교에서 1반만 수업UniCast 1 : 1 통신 발송 방식 ex) 통화AnyCast 가장 가까운 곳에 있는 불특정 다수 랜덤으로 통신 발송 근거리 통신 IPv6에서만 사용 ex) 무전기" }, { "title": "Network와 OSI 7 Layer", "url": "/posts/osi-7-layer/", "categories": "Network", "tags": "network", "date": "2022-08-25 01:40:00 +0900", "snippet": "NetWorkNetwork 여러 PC가 통신하기 위한 망ARPA(the Advanced Research Project Agency) 최초의 네트워크 컴퓨터들을 찾고 도와주는 시스템IMPS(Interface Message Processors) 장치에 대한 메세지를 뿌려주는 프로그램 ICMP 인터넷 protocol로 발전IEEE 미국 전기 전자 엔지니어링 협회(표준) IEE 802.11 무선 IEE 802.3 물리적 매체 RFC 인터넷 표준 문서전자 통신의 통신 방식 Full-Duplex (전이중) 통신 동시에 양방향 전송이 가능한 방식 전송량 많음 전송 매체의 용량 큼 ex) 전화 Half-Duplex (반이중) 통신 양방향 전송이 가능하지만 동시에 양쪽 방향에서 전송할 수 없는 방식 ex) 무전기 Simplex (단방향) 통신 한쪽 방향으로만 전송이 가능한 방식 일방적인 송신 또는 수신만 가능 ex) 라디오, TV ProtocolProtocol 통신 규약 통신하기 위한 방법TCP(Transmission Control Protocol) 질의응답 YES 확인 응답 YES 속도 ↓ 신뢰성 protocol 상호 통신 (양방향 통신) 연결 지향 연결 설정 → 연결 유지 → 연결 종료 3 Way Handshaking 통신 서버와 클라이언트 구조의 명령 전달 서비스 및 프로그램 확인해서 정확하게 데이터를 주고 받아야하는 경우 사용 장거리, 많은 양의 데이터 전송 시 사용 채팅, 원격 접속, 서비스 공유 등 순서번호 → 조각화 (Fragmentation) → 재조립 (Reassembly) → 유실 → 재전송/오류 → 순서대로 조립/재전송 TCP/IP header : 6TCP Flags SYN(Synchronization) 시퀀스 번호 전송, 연결 요청 ACK(Acknowledgement) 응답 RST(Reset) 재시작 PSH(Push) 지연된 내용 우선 처리 URG(Urgent) 긴급 패킷 FIN(Finish) 종료 3 Way Handshake TCP 연결 과정 서로 질의 응답 확인 4 Way Handshake TCP 연결 해제 과정 서로 질의 응답 확인 UDP(User Datagram Protocol) 질의 응답 NO 확인 응답 NO 속도 ↑ 비신뢰성 protocol 일방 통신 (단방향 통신) 끊기면 안되는 스트림 통신이거나 속도가 중요한 경우 사용 실질적인 동기화가 필요한 동영상 스트리밍, 프로세스, 토렌토 등 TCP/IP header : 17TCP/IP 4 Layer &amp; OSI 7 Layer Encapsulation TCP/IP Layer OSI 7 Layer PDU( Protocol Data Unit) Decapsulation ⬇   7 application(응용)계층 data ⬆ ⬇ 4 Appplication 계층(TCP/IP) - 데이터 생성 6 presentation(표현)계층 data ⬆ ⬇   5 session(연결)계층 data ⬆ ⬇ 3 transport 계층(TCP/IP) - 데이터 전송(실제 통신 구간) 4 transport(전송)계층 segment ⬆ ⬇ 2 internet 계층(TCP/IP) 3 network(통신)계층 packet ⬆ ⬇ 1 network interface 계층(TCP/IP) 2 data-link(물리주소)계층 frame ⬆ ⬇   1 physical(물리)계층 bit ⬆ OSI 7 Layer (Open System Interconnect)7 application (응용) 계층 응용 프로그램 사용자에게 편리한 인터페이스를 제공하는 기능 TUI → GUI PDU (Protocol Data Unit) : data6 presentation (표현) 계층 프로그램 표현 (확장자) 결정 jpg, mp4, zip SSL (암호화) 이루어짐 포맷, 압축, 암호화, 인코딩 PDU (Protocol Data Unit) : data5 session (연결) 계층 protocol 제어 서비스 시작, 종료, 정지 서비스 연결 흐름 제어 상대방 PC와 연결시켜주는 service PDU (Protocol Data Unit) : data4 transport (전송) 계층 전송에 대한 결정 통신 방법 결정 TCP : 63555개 / UDP : 63555개 PDU (Protocol Data Unit) : segment3 network (통신) 계층 컴퓨터가 통신할 수 있도록 주소 설정 서로 다른 네트워크를 연결 논리적 주소 체계/통신 논리적 연결 → 주소 광고/학습 → 최적의 경로 연산 Check Sum 오류 체크 TCP 필수 사용 오류 발생 → 재전송 = establish UDP 옵션 사용 오류 발생 → 다음 동작 x 3계층 장비 : Router Gateway를 통해서 서로 다른 네트워크를 연결해주는 네트워크 장비 각 네트워크 당 1개의 IP설정 가능 여러 개의 네트워크 대역 IP 소지 가능 Gateway 존재 다른 네트워크와 통신하기 위한 통로 주소 네트워크 내부 주소를 Router IP에 설정 Gateway가 없으면 다른 네트워크 통신 불가 Gateway의 구조 x.x.x.0 Net IP (start) Gateway 미사용 x.x.x.1 DHCP (Dynamic Host Control Protocol) 공유기 설정 KT/SKT 등 통신사 선점 Gateway 미사용 x.x.x.2 NAT(VMware, 가상화) x.x.x.3~253 Host 할당 (사용자 임의) x.x.x.254 공유기 Gateway로 자주 사용 x.x.x.255 BroadCast (END) Gateway 미사용 대표적인 Protocol ICMP (Internet Control Message Protocol) 인터넷 제어 메세지 인터넷에 대한 흐름을 메세지 형태로 출력 대표 명령어 ping IP (Internet Protocol) PC 간 연결을 하기 위한 통신 규약 (인터넷 규약) 인터넷 상에 있는 컴퓨터 고유의 주소 인터넷 상의 한 컴퓨터에서 다른 컴퓨터로 데이터 주고 받기 가능 논리적 주소 Network-ID 부분은 변경 불가 Host-ID 부분은 변경 가능 ARP (Address Resolution Protocol) 주소 결정 protocol 네트워크 상에서 ip주소를 물리적 네트워크 주소로 대응 시키기 위해 사용 ARP 논리적 주소 → 물리적 주소 변환 RARP 물리적 주소 → 논리적 주소 변환 TCP / IP header : 1 PDU (Protocol Data Unit) : packet2 data-link (물리주소) 계층 SW와 HW를 연결 물리적 주소 체계 / 통신 HW주소 (MAC 주소)관리 및 저장 MAC 주소를 통한 통신 인터페이스 연결 MAC 주소 (Media Access Control) 장치 접근하기 위한 접근 제어 주소 물리적 주소 네트워크 인터페이스의 고유 식별 주소 처음부터 부여된 주소로 변경 불가 동일 network 안에서 host 식별자 통신에 대한 충돌방지 장치 우선 순위 지정하는 기준 값 00-00-00-00-00-00 형식 제조 고유 번호 (OUI조직 식별자) - 실제 주소 (제품 ID) 16진수로 표현 MAC 주소 확인 명령어 show mac_address table Collision Domain을 처리 Duplex 조정 가능 다차선 통신 가능(half / full) CRC 알고리즘을 이용한 FCS (오류검사) CRC(Cyclic Redundancy Check) 오류 검사 신뢰성 검사 2계층 장비 : Switch 2계층 MAC 주소 관리 장치 같은 네트워크를 연결해주는 장비 여러대의 PC를 연결할 때 Switch 사용하면 충돌 방지, 교통 정리 효과 L2 Switch 특징 Hub 확장 version 전송 중 패킷 충돌 방지 하기 위해 패킷의 목적지로 지정할 port를 직접 전송 1 : 1 연결 기본 Switch L3 Switch L2 Switch 확장 라우팅 기능 추가 IP 학습 가능 L4 Switch L3 Switch 확장 TCP/UDP 제어 스위치 TCP/IP protocol 기반 동작 가상 LAN, 그룹화, 부하 분산 기능 제공 Switch의 기능 Flooding(넘치다) 연결된 Port 전부 다 질의(Broadcast), 들어온 port를 제외하고 모든 port에 전송 Learning(배우다) Switch Port에서 받은 수신지와 도착지의 Mac주소를 table에 저장 Filtering(거르다) 배운 Mac주소 상의 경로일 때 경로 외 다른 경로 차단 Fowarding(보내다) 배운 Mac주소대로 패킷을 전송, Mac주소에 일치하는 목적지일 경우 전송 Aging(일정시간 후 삭제) 배운 Mac-Table 일정시간 후 자동 삭제, 일정시간 동안 통신 안될 시 자동 삭제 Switch 기법 store and forward 처음부터 끝까지 검사 후 전송 cut-trough 출발지 = 목적지만 확인 후 바로 전송 fragment free store and forward 64bit까지 검사 후 전송 (cut-trough) PDU (Protocol Data Unit) : frame1 physical (물리) 계층 Cable (1계층 장비) 을 통해 인터페이스 통신 및 데이터 전송 HUB,Repeater를 통해 PC들의 통신 확장 1 계층 장비 : Cable, HUB, Repeater Cable (UTP / STP) 1계층 장비 PC와 장비 간의 연결 LAN 연결 시 사용 UTP (Unshielded Twisted Pair) Direct Cable (T568B-T568B) 다른 계층 장비끼리 연결할 때 사용 Router ↔️ Switch Cross Cable (T568A-T568B) 같은 계층 장비끼리 연결할 때 사용 Hub ↔️ Hub T568B 규격 주띠(RD+) 주(RD-) 초띠(TD+) 파 파띠 초(TD-) 갈띠 갈 T568A 규격 초띠(TD+) 초(TD-) 주띠(RD+) 파 파띠 &lt;/span&gt; 주(RD-) 갈띠 갈 RD (Receive Data) TD (Transmit Data) HUB, Repeater 통신 확장 기능을 가진 1계층 장비 여러 대의 PC를 연결해서 하나의 IP로 나오게 함 Simplex (단방향) 통신 송신지와 수신지가 한번에 전송하면 충돌 발생 PDU (Protocol Data Unit) : bitEncapsulation &amp; DecapsulationEncapsulation (캡슐화) 상위 계층에서 하위 계층으로 이동하면서 각 계층의 기능들을 데이터에 담아서 합치는 방식 패킷 압축 = 전송Decapsulation (캡슐화 해제) 수신한 데이터를 하위 계층에서 상위계층으로 올라갈 때 각 계층의 헤더를 풀면서 올라가는 방식 패킷 압축 해제 = 수신PortPort 서비스마다 구분시켜주는 값 직접 데이터를 전달 서비스를 정의한 전용 통신 회선 2^16 = 65535개 (UDP/TCP 각각) Port 0~255 공공의 목적으로 사용하는 port http = 80, ftp = 20/21 Well Known Port (IANA관리) 정해진 port, 절대적, 자주 쓰는 서비스로 예약된 주소 Port 256~1023 상용 목적 port ssl = 443 넷스케이프가 만든 웹보안 → TLS, https Well Known Port (IANA관리) : 정해진 port, 절대적, 자주 쓰는 서비스로 예약된 주소 Port 1024~4915 충돌 방지 위해 등록된 port 응용 프로그램의 네트워크 통신을 위해 할당된 주소 Registered Port Port 4916~65535 임의 port 동적 port (Dynamic port) 개발자 임의대로 사용 가능한 주소 중요 Port Port Number Protocol Description TCP/UDP 20 FTP 실제 Data 전송 TCP 21 FTP 인증, 명령어 인식, 프로그램 제어 작업 TCP 22 SSH 원격 통신, 암호화 TCP 23 Telnet 평문 통신, 원격 통신, 보안성 ⬇ TCP 25 SMTP 메일 전송(송신)용 TCP 53 DNS IP 주소를 도메인으로 변환 TCP/UDP 67 DHCP IP 주소를 동적으로 할당 UDP 68 DHCP IP 주소를 동적으로 할당 UDP 69 TFTP Router 전용 FTP, 단순한 파일 전송 UDP 80 HTTP 웹서비스 제공 TCP/UDP 110 POP3 메일 수신, 클라이언트에 메세지 저장 TCP 138 NetBios 윈도우에 대한 네트워크, 윈도우에서 파일 공유 TCP 143 IMAP 메일 수신, 서버에 메세지 저장, 보안성 ⬇ TCP 161 SNMP 실제 장치 검색, 네트워크 정보 관리 / 모니터링 UDP 443 HTTPS HTTP over SSL, 암호화 전송 TCP " } ]
