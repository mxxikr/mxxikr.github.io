---
title:  "[C++ 프로그래밍] 2강 - C++언어의 기초"
author:
  name: mxxikr
  link: https://github.com/mxxikr"
date: 2023-08-22 01:28:00 +0900
category:
  - [Knou, C++ 프로그래밍]
tags:
  - [knou, cpp]
math: true
mermaid: true
---

**<center>💡해당 게시글은 방송통신대학교 이병래 교수님의 'C++프로그래밍' 강의를 개인 공부 목적으로 메모하였습니다. </center>**

<br/><br/>

# 학습 목표
---
1. **C++의 문법에 맞게 식별자**를 만들 수 있다.
2. **기본 자료형의 값을 표현하고, 변수를 만들어 저장하는 표현을 활용**할 수 있다.
3. **C++ 언어의 연산자를 사용하여 수식**을 작성할 수 있다.
4. **자료형 사이의 형변환**을 할 수 있다.
<br/><br/>

# 주요 용어
---
- **키워드(keyword)**
    - C++ 언어에서 미리 용도를 정해 놓은 단어
- **변수**
    - 프로그램이 실행되는 동안 기억하고 있어야 하는 값들을 저장하기 위해 자료형과 이름이 지정된 메모리 영역
- **사용 영역(scope)**
    - 이름이 유효성을 갖는 영역
- **지역 변수**
    - 프로그램의 소속 블록 안에서만 사용될 수 있는 변수
- **형 변환**
    - 값의 자료형을 다른 자료형으로 변환하는 것으로, 자료형의 변환은 묵시적 또는 명시적으로 지정 가능

<br/><br/>

# 키워드와 식별자
---
### **키워드(keyword)**
- C++ 언어에서 미리 용도를 정해 놓은 단어
- 반드시 정해진 용도로만 사용해야함
    
    ```cpp
    #include <iostream>
    using namespace std;
    int main()
    {
    	cout << "나의 첫 번째 C++ 프로그램" << endl;
    	return 0;
    }
    ```
    
    - `using namespace`
    - `int`
    - `return`

### **식별자(identifier)**
- 여러 가지 대상을 구분하기 위해 만든 이름
    - 변수나 함수, 클래스 등의 이름
- **식별자를 만드는 규칙**
    - 첫 자는 비 숫자 문자를 사용함(C++11부터 다국어 문자 포함)
        - 비 숫자 문자 : 영문 대,소문자와 `_` (MS C++에서는 $ 포함)
    - 이후의 문자는 비 숫자 문자와 숫자를 사용함(특수 문자 사용 불가)
    - 길이 제한 없음
    - 키워드는 식별자로 사용 불가
- 사용 가능한 적절한 식별자  
    - `myname`
    - `my_name`
    - `myName`
    - `MyName`
    - `a3`
    - `VALUE`
    - `Int`
    - `initial_value`
    - `합계`(C++11 이후)
    - `$price`(MS C++)
- 사용할 수 없는 식별자의 예
    - `4days`
    - `my name`
    - `my#name`
    - `int`
    - `initial-value`
    - `min:value`
<br/><br/>

# 기본 자료형 및 상수와 변수
---
### **C++의 자료형**

- **기본 자료형** - C++ 에서 기본적으로 제공하는 하나의 값을 지정하는 자료형
    - 정수 자료형
    - 실수 자료형
- **복합 자료형** - 여러 개의 데이터를 모아서 사용할 수 있는 자료형
    - 배열, 구조체(struct), 클래스(class), 열거형(enum), 공용체(union)
    - 포인터, 참조

### **C++의 기본 자료형**

- **정수형 자료형(integral types)**
    - 고정 소수점(fixed-point) 방식의 숫자 표현
        - 오버플로(overflow)가 발생하지 않도록 주의해야 함
    - 문자를 표현하는 자료형 - signed/unsigned
        - `char`
    - 정수를 표현하는 자료형 - signed/unsigned
        - `short` ≤ `int` ≤ `long` ≤ `long long`
            - `signed`
                - 부호 있음
                - 양수, 음수 둘 다 표현 가능
            - `unsigned`
                - 부호 없음
                - 양수만 표현 가능
        - `int`, `short`, `long`, `long long`
            - `int` 32bit
            - `short` 16bit
            - `long` 32bit
    - 참/거짓을 표현하는 자료형
        - `bool`
            - `true`(참) / `false`(거짓) 저장
    - 다국어 표현을 위한 자료형
        - `wchar_t`, `char16_t`, `char32_t`
- 실수 자료형
    - 부동소수점(floating-point) 방식의 숫자 표현
        - 부동 소수점
            - 소수점의 위치가 움직일 수 있음
        - 부동 소수점 방식의 숫자 표현
            - 123 = 12.3 * 10^1 = 1.23 * 10^2
    - float (4byte)
        - 부호 1비트, 지수부 8비트, 가수부 23 비트로 구성
        - 1.17549 * 10^-38 ~ 3.40282 * 10^38 범위의 값을 표현
        - (numeric_limits<float>::min(), numeric_limits<float>::max())
            - <climits> 헤더 파일 include 시 float에 대해 가장 작은 값, 큰 값 확인 가능

### **상수의 표현 - 리터럴(iteral)**

- **정수형 리터럴의 표현**
    - 숫자를 표현하는 문자와 부호만으로  표현됨
    - 숫자를 표현하는 문자
        - '0'~'9' 까지의 숫자
        - 10~15에 해당되는 16진수를 표현하기 위한 문자 'a'~'f'와 'A'~'F
    - 접두사를 이용한 진법의 표현  

        | 표현 |  의미 |
        | --- | --- |
        | 159 | 10진수 int형 상수 |
        | 0b10011111 | 2진수 int형 상수 |
        | 0237 | 8진수 int형 상수 |
        | 0x9f | 16진수 int형 상수 |
    
    - 접미사를 이용한 정수 리터럴의 자료형 지정  

        | 표현 |  의미 |
        | --- | --- |
        | 123 | int형 |
        | 123u | unsigned int형 |
        | 123L | long 형 |
        | 123ul | unsigned long 형 |
        | 123ll | long long 형 |  

- 문자 리터럴의 표현  

    | 표현 |  의미 |
| --- | --- |
| 'A' | 문자 'A' (ASCII 코드에 해당되는 정수 65와 동일) |
| '\101' | 'A'와 동일함(65의 8진수 표현) |
| '\x41' | 'A'와 동일함(65의 16진수 표현) |
    
    - 작은 따옴표(' ') 안에 문자를 표기하는 방법
    - 8진수나 16진수 문자 코드로 표기하는 방법
- 실수형 리터럴의 표현    

    | 표현 |  의미 |
    | --- | --- |
    | 1200. 1200.0 12e2 1.2e+3 | double형 값 1200 |
    | 1200.0f 12e2f | float형 값 1200 |
    
    - 소수점이 있거나 10의 거듭제곱을 표현하기 위한 지수 기호인 `e` 가 있으면 실수형 리터럴임

### **변수**

- 프로그램이 실행되는 동안 기억하고 있어야 하는 값들을 저장하는 메모리 영역
- 변수에는 자료형과 이름이 지정되어야 함
- 모든 변수는 사용하기 전에 미리 선언해야 함
    
    ```cpp
    int korScore, mathScore;
    cin >> korScore >> mathScore;
    float avrScore = (korScore + mathScore) / 2.0f;
    ```
    
    - `int`
        - 자료형
    - `korScore, mathScore;`
        - 변수의 이름
    - `float avrScore`
        - 사용하기 전에 선언

### **변수의 초기화**

1. `int total = 0;`
2. `int total(0);`
    ```cpp
    int x(131070.5); // x ← 131070 : 오차 발생
    short y(x); // x ← -2 : 오버플로 발생
    ```
    ![image](/assets/img/knou/cpp/2-1.jpg)
        
3. `int total{0};`
    
    ```cpp
    short a{total}; // 오류: 축소 변환
    float b{total}; // 오류: 축소 변환
    ```
    

### **자료형 추론**

- 변수를 초기화할 때 초기화하는 값의 자료형으로 변수의 자료형을 추론
    
    ```cpp
    auto i(10); // int i(10); 과 동일함
    ```
    

### **변수의 사용 영역(scope)**

- 변수가 유효성을 갖는 영역
    
    ```cpp
    // s1.cpp
    
    int a; // 비 지역변수(non-local variable)
    static int b{10}; // 비 지역변수(non-local variable)
    int f() {
    	int c{20}, d{30}; // 비 지역변수(non-local variable)
    	{
    		int d{40}; // 지역 변수(local variable)
    		int e{50}; // 지역 변수(local variable)
    	
        }
    	
    }
    ```
    
    ```cpp
    // s1.cpp
    extern int a; // 다른 소스 파일에서 존재하는 변수 사용 = s1.cpp 의 a 변수
    static int b{50}; // 해당 소스 파일에서만 사용 가능 =! s1.cpp b 변수
    int g() {

    }
    ```
    
    - 비 지역변수(non-local variable)
        - 선언된 이후 프로그램의 전체 영역에서 사용 가능
        - 선언된 이후 소속 파일의 전체 영역에서 사용 가능
    - 지역 변수(local variable)
        - 선언된 이후 소속 블록의 전체 영역에서 사용 가능

### **const와 constexpr**

- `const` 한정어
    
    ```cpp
    const double PI {3.14159}; // 원주율 정의
    ```
    
    - 변수의 값을 수정할 수 없게 함
    - 초기화를 통해서만 값을 정할 수 있음
        
        ```cpp
        #define PI 3.14159
        // 매크로 상수 정의 - 단순 치환
        ```
        
- `constexpr` 한정어
    
    ```cpp
    int a;
    std::cin >> a;
    const int b = 20;
    const int C1 = a; // cin을 통해 입력된 a의 값으로 초기화
    constexpr int C2 = a + 10; // 오류: 컴파일 시에 a의 값을 알 수 없음
    constexpr int C3 = b + 100; // b + 100을 컴파일 시에 계산할 수 있음
    constexpr int C4 = C1 * 2; // 오류: 컴파일 시에 C1의 값을 알 수 없음
    ```
    
    - 그 값을 컴파일할 때 평가한다는 의미
    - 실행 중 값을 평가하는 것에 비해 효율적으로 동작할 수 있게 함
- `constexpr` 함수
    
    ```cpp
    constexpr int fac(int n) {
    	return n > 1 ? n * fac(n-1) : 1;
    }
    
    void f(int x) {
    	constexpr int a = fac(4); // 컴파일할 때 계산
    	int b = fac(x); // 실행 중 계산
    
    }
    ```
    
    - 모든 인수가 `constexpr` 인 경우 컴파일할 때 값을 구할 수 있게 함

### **변수의 유효 기간(lifetime)**

- 변수가 언제 만들어져서 언제 없어지는가를 나타냄
    
    ```cpp
    int x; // 전역변수 - 정적 유효 기간
    
    int f() {
    	int y{10}; // 지역변수 - 자동 유효 기간
    	static int z{0}; // 정적 지역변수 - 정적 유효 기간
    
    }
    ```
    
- **자동 변수**
    - 생성 시점 : 함수(블록)가 시작될 때
    - 소멸 시점 : 함수(블록)가 종료될 때
- **정적 변수**
    - 생성 시점 : 프로그램이 시작될 때
    - 소멸 시점 : 프로그램이 종료될 때

### **변수와 상수 사용**

- CircleArea.cpp
    
    ```cpp
    #include <iostream>
    using namespace std;
    
    int main( )
    {
    	const double PI { 3.14159 };
    	double radius;
    
    	cout << "원의 반경을 입력하시오 : ";
    	cin >> radius;
    	double area = radius * radius * PI;
    	cout << "원의 면적 = " << area << endl;
    	return 0;
    }
    ```
<br></br>

# 연산자

---

### **산술 연산자**

- **2항 연산자**
    - 사칙 연산자 : `+`, `-`, `*`, `/`
        
        | 수식 | 수식의 값 |
        | --- | --- |
        | 5 + 3 | 8 |
        | 3 / 2 | 1 |
        | 3.0 / 2.0 | 1.5 |

    - 나머지 연산자 : %
        
        
        | 수식 | 수식의 값 |
        | --- | --- |
        | 5 % 3 | 2 |
        | -5 % 3 | -2 |
        | 5 % -3 | 2 |
        | -5 % -3 | -2 |

- **단항 연산자**
    - 증, 감 연산자 : `++`,  `--`
        
        
        | 수식(a = 10일 때) | a의 값 | b의 값 |
        | --- | --- | --- |
        | b = ++a; | 11 | 11 |
        | b = a++; | 11 | 10 |
        | b = --a; | 9 | 9 |
        | b = a--; | 9 | 10 |

    - 부호 연산자 : `+`, `-`

### **대입 연산자**

- **대입 연산자**(=)
    
    
    | 수식(a는 double형, b는 int형) | 실행 결과 |
    | --- | --- |
    | a = 0; | a ← 0 |
    | a = b = 0; | b ← 0, a ← 0 |
    | a = b = 1.5; | b ← 1, a ← 1 |

    - 수식의 값 : 저장된 결과
    - 연산자의 결합 방향 : 우 → 좌
- **복합 대입 연산자**
    
    
    | 수식 | 실행 결과 |
    | --- | --- |
    | a += b; | a = a + b; 와 동일 |

    - 이항 연산자와 대입 연산자를 결합
    - `+=`, `-=`, `*=`, `/=`, `%=`, `<<=`, `>>=` 등

### **관계 연산자**

- 관계 연산자
    
    | 수식(a = 10, b = -5) | 수식의 값 |
    | --- | --- |
    | a > b | true |
    | a == 5 | false |

    - `>`, `<`, `>=`, `<=`, `==`, `≠`

### **논리 연산자**

- 논리 합 `||`, 논리곱 `&&`, 부정 `!`
    
    
    | 수식(a = 10, b = -5) | 수식의 값 |
    | --- | --- |
    | a > 0 && b > 0 | false |
    | a > 0 || b > 0 | true |
    | a < 0 && --b < 0 | false, b는 -5 |
    | !(a > 0) | false |

### **비트 단위 연산자**

- **비트 단위 논리 연산자**
    
    
    | 수식(x = 0x35(0011 0101), y = 0xf0(1111 0000)) | 수식의 값 |
    | --- | --- |
    | x \| y | 0xf5 (1111 0101) |
    | x & y | 0x30 (0011 0000) |
    | x ^ y | 0xc5 (1100 0101) |
    | ~x | 0xca (1100 1010) |  

    - 논리 합 `|`, 논리곱 `&`, 배타적 논리 합 `^`, 부정 `~`

- **비트 이동 연산자**
    - 좌측 이동 (`<<`)
        
        ```cpp
        unsigned char x = 0b00011101; // 29
        unsigned char y = x << 2;
        ```
        
        - 우측 피연산자에 지정된 비트 수만큼 좌측 피연산자를 좌측으로 이동

            ![image](/assets/img/knou/cpp/2-2.jpg)  
            
        - 우측의 비는 비트에는 0이 채워짐
    - 우측 이동 (`>>`)
        - 우측 피연산자에 지정된 비트 수만큼 좌측 피연산자를 우측으로 이동
        - signed 형에 대해서는 부호를 유지할 수 있도록 부호 비트가 좌측의 비는 비트에 채움(구현에 따라 다름)

### **조건 연산자**

- 유일한 3항 연산자
    
    | 수식 ( a = 10, b = 20, c = 30)  | 수식의 값 |
    | --- | --- |
    | a > 0 ? b : c | 20 |  
    
    - `조건 ? 값1 : 값2`
        - 조건이 true이면 수식의 값은 값1, false이면 값2

# 자료형의 변환

---

### **묵시적 형 변환**

- 묵시적 형 변환 개요
    
    ![image](/assets/img/knou/cpp/2-3.jpg)  
    
    - 두 값 사이의 연산에서는 우선순위가 낮은 자료형의 값이 순위가 높은 자료형의 값과 같은 형으로 변환됨
    - 여러 개의 연산으로 구성된 수식에서 묵시적 형 변환은 연산자 단위로 이루어짐
    - 대입 연산자(=)는 값을 저장할 변수의 자료형으로 묵시적 형 변환을 함
        - 오차나 오버플로가 발생할 수 있으므로 주의해야 함

### **명시적 형 변환**

- 형 변환 연산자
    
    ![image](/assets/img/knou/cpp/2-4.jpg)  
    
    - `static_cast`
        - 연관된 자료형 간의 형 변환을 처리하며, 변환 처리는 컴파일 단계에서 정해짐
    - `dynamic_cast`
        - 기초 클래스와 파생 클래스 간의 포인터 또는 참조 형 변환이 프로그램 실행 중에 일어나도록 지시함
    - `reinterpret_cast`
        - 관련이 없는 자료형 사이의 변환을 처리하는 연산자로, 포인터를 다른 자료형의 포인터나 정수 자료형으로, 또는 그 역으로 변환
    - `const_cast`
        - const 지정을 일시 해제함

# 연습문제

---

- **Q1.** 다음 중 부동소수점 표현방식의 수는?
    
    ```
    1. 123
    2. 0x24
    3. 0123
    4. 123e4
    ```
    
    ```
    4. 123e4
    
    1.은 10진수, 2.는 16진수, 3.은 8진수 정수(고정소수점)를 표현한 것이다. 
    4.의 e는 부동소수점 수의 지수부 값을 나타내기 위한 기호로 사용되므로 123.0×10^4을 나타내는 부동소수점 수이다.
    ```
    
- **Q2.** 위 지문에서 문장의 결과 a에 저장되는 값은?
    
    ```
    int x=5, y=2;
    double a, z=10.0;
    a = z + x / y;
    
    1. 7.5
    2. 12.0
    3. 12.5
    4. 7.0
    ```
    
    ```
    2. 12.0
    
    x와 y는 int형이므로 x/y는 정수 연산이 이루어지며, 그 결과는 2이다. 
    이 값을 z의 10.0과 더하므로 결과는 12.0이다.
    ```
    
- **Q3.** 위 지문의 프로그램에서 (가)와 (나)의 의미에 대한 설명으로 옳은 것은?
    
    ```
    constexpr int f(int x) { return x * x; }
    void g(int a) {
        constexpr int b = f(10);	         // (가)
        const int c = f(a);		         // (나)
         ……				// (다)
    }
    
    1. (가)는 f(10)의 값을 컴파일할 때 계산한다.
    2. (가)는 프로그램 실행 중 f(10)을 호출하여 값을 계산한다.
    3. (나)는 f(a)의 값을 컴파일할 때 계산한다.
    4. (다)에서 c의 값을 변경할 수 있다.
    ```
    
    ```
    1. (가)는 f(10)의 값을 컴파일할 때 계산한다.
    
    constexpr 함수는 모든 인수가 constexpr인 경우 컴파일할 때 값을 구할 수 있게 한다.
    ```
    
- **Q4.** 위 지문에서 변수 x, y가 모두 unsigned char 형이다. x의 하위 4비트는 변하지 않고 상위 4비트만 모두 0으로 만들려고 한다. y에는 어떠한 값을 가지고 있어야 하는가?
    
    ```
    x &= y;
    
    1. 0x04
    2. 0xff
    3. 0xf0
    4. 0x0f
    ```
    
    ```
    4. 0x0f
    
    위 수식은    x = x & y; 와 같다. 
    &는 비트단위 논리 곱 연산자이다. 
    어느 비트의 값이 a일 때 a & 0은 a의 값에 관계없이 0이다. 
    반면 a & 1은 a가 0이면 0, 1이면 1이다. 
    즉, a & 1은 a와 같다. 
    그러므로 x의 값에서 0으로 지우고 싶은 비트는 0, 그대로 두고 싶은 비트는 1이 y에 들어 있다면 x의 원하는 비트를 0으로 지울 수 있다. 
    하위 4비트는 변하지 않고 상위 4비트만 0으로 만들려고 하므로 y는 2진수 00001111, 즉 16진수 0x0f를 저장하고 있으면 된다.
    ```
    
- **Q5.** 다음의 변수 선언문 중 오류가 있는 것은?
    
    ```
    1. int a = 100;
    2. float b(20.0);
    3. int c = { 200 };
    4. int d{ 1.5 };
    ```
    
    ```
    4. int d{ 1.5 };
    
    1.과 2.의 형식은 C++11 이전부터 사용되던 형식으로 필요하다면 묵시적 형 변환을 통해 변수가 초기화된다. 
    C++11에서 권장하는 3.이나 4.의 형식은 초깃값으로 사용된 수식에 대해 축소 형 변환이 일어나면 안 된다. 
    3.은 200이 int형이므로 올바르지만 4.는 1.5가 double이므로 int형 변수를 초기화하려면 축소 형 변환이 필요하여 오류이다.
    ```
    
- **Q6.** 위 지문 중 소스 파일에서 변수의 값을 수정하지 않았을 경우 (가) 영역에서 사용할 수 있는 변수와 그 값을 모두 올바르게 나열한 것은?
    
    ```
    int a;
    static int b{10};
    
    int f() {
        int c{20}, d{30};
        {
            int d{40};
            int e{50};
            ······
        }
         ······    // (가)
    }
    
    1. a:0, b:10, c:20, d:30
    2. c:20, d:30, e:50
    3. a:0, b:10, c:20, d:40, e:50
    4. a:0, c:20, d:30, e:50
    ```
    
    ```
    1. a:0, b:10, c:20, d:30
    
    (가)를 포함하는 블록에 선언된 c와 d, 함수 f()의 앞에 선언된 a와 정적 변수 b를 모두 사용할 수 있으며, 함수 f()에 내포된 블록에 선언된 d와 e는 그 블록 안에서만 존재하며, (가)에서는 사용할 수 없다.
    ```
<br></br>

# 학습 정리

---

1. **C++에서 사용하는 단어는 반드시 정해진 용도로 사용하도록 지정된 키워드와 프로그램 내에서 여러 가지 대상을 구분하기 위해 만드는 식별자**가 있다.
2. **문자, 정수, 참/거짓, 실수를 표현하는 기본 자료형과 복합 자료형을 사용**할 수 있음
3. **값을 저장하기 위해 사용하는 변수**는 사용하기 전에 자료형과 이름을 미리 선언해야 함
4. **블록 안에 선언된 변수**는 소속된 블록에서만 사용할 수 있는 지역변수임
5. **const 한정어는 변수의 값을 변경할 수 없게 하며, constexpr 한정어는 변수나 함수의 값을 컴파일할 때 평가**할 수 있게 할 수 있게함
6. **지역 변수**는 자동 유효기간, 전역 변수 및 정적 지역변수는 정적 유효 기간을 갖는다.
7. **연산자는 산술, 논리, 관계, 비트 단위 논리, 대입 등의 처리를 하는 데 사용**됨
8. **서로 다른 자료형이 연산에 사용될 경우 우선순위가 높은 자료형**으로, 대입 연산의 경우 값을 저장할 변수의 자료형으로 묵시적 형 변환이 일어남
9. **형 변환 연산자를 이용**하여 명시적으로 자료형을 변환할 수 있다.