---
title: OS와 Linux
author: {name: mxxikr, link: 'https://github.com/mxxikr'}
date: 2022-08-29 03:27:00 +0900
category: [OS, Linux]
tags: [os, linux]
math: true
mermaid: true
---
## 운영체제(OS)

### 운영체제의 역할

- **운영체제는 하드웨어와 사용자 애플리케이션 사이의 중개자**임
- 컴퓨터가 켜지면 먼저 OS가 메모리에 로드되고, 이후 모든 프로그램과 하드웨어 간의 통신을 중재함

- **핵심 책임**
  - **하드웨어 추상화**
    - CPU, 메모리, 디스크, 네트워크 등을 관리하고 애플리케이션에 일관된 인터페이스 제
  - **멀티태스킹 가능**
    - 여러 프로그램이 동시에 실행되는 것처럼 보이게 함
  - **보안과 격리**
    - 각 프로세스가 서로 방해하지 않도록 메모리 보호 및 권한 관리
  - **리소스 할당**
    - CPU 시간, 메모리, 디스크 I/O를 효율적으로 분배

### 커널(Kernel)이란

- **커널은 OS의 핵심**으로, 하드웨어와 직접 상호작용하는 유일한 소프트웨어 계층임

  ```
  ┌─────────────────────────────────────────┐
  │      Applications (사용자 프로그램)      │  ← User Space
  ├─────────────────────────────────────────┤
  │        System Call Interface            │
  ├─────────────────────────────────────────┤
  │          Kernel (커널)                   │  ← Kernel Space (Ring 0 - 최고 권한)
  ├─────────────────────────────────────────┤
  │        Hardware (CPU, RAM, Disk)        │
  └─────────────────────────────────────────┘
  ```

- **커널의 주요 기능**
  - **프로세스 관리**
    - 어떤 프로세스를 언제 실행할지 결정(스케줄링)
  - **메모리 관리**
    - 각 프로세스에 메모리 할당 및 보호
  - **파일 시스템 관리**
    - 파일과 디렉토리 접근 관리
  - **디바이스 관리**
    - 프린터, 네트워크 카드 등 하드웨어 제어
  - **보안 및 접근 제어**
    - 사용자 권한 관리

### User Mode와 Kernel Mode

- OS는 **Protection Ring**이라는 권한 수준으로 보안을 유지함

  | 항목          | User Mode (Ring 3)        | Kernel Mode (Ring 0)       |
  | ------------- | ------------------------- | -------------------------- |
  | **권한**      | 제한적                    | 완전한 하드웨어 접근       |
  | **실행 주체** | 애플리케이션              | 커널, 드라이버             |
  | **직접 접근** | 할당받은 메모리만         | 모든 메모리, 모든 하드웨어 |
  | **전환 방법** | System Call로만 전환 가능 | 하드웨어 인터럽트로 전환   |

- 사용자 프로그램이 파일을 읽으려면 system call을 통해 커널에 요청하고, 커널이 Kernel Mode로 전환하여 디스크에서 읽은 후 결과를 반환함

<br/><br/>

## Linux

### Linux란

- **Linux는 Linus Torvalds가 1991년에 개발한 오픈 소스 커널**임
- 이를 바탕으로 다양한 배포판(Ubuntu, CentOS, Debian 등)이 존재함

### Linux 커널 아키텍처

- Linux 커널은 **모놀리식 구조**(Monolithic Kernel)를 기본으로 함

  ```
  ┌────────────────────────────────────────────┐
  │        System Call Interface               │
  ├────────────────────────────────────────────┤
  │    Process    │  Memory   │  File System   │
  │  Management   │ Management │  Management   │
  ├────────────────────────────────────────────┤
  │    Networking │  Device   │  IPC (Inter-   │
  │     Unit      │ Drivers   │ Process Comm)  │
  ├────────────────────────────────────────────┤
  │              Hardware Abstraction Layer    │
  └────────────────────────────────────────────┘
  ```

### 프로세스 관리

- **프로세스와 ㄴ스레드**

  - **프로세스**
    - 독립적인 메모리 공간을 가진 실행 단위
  - **스레드**
    - 같은 프로세스 내에서 메모리를 공유하는 실행 단위

- Linux는 커널 스케줄러(CFS - Completely Fair Scheduler)를 사용하여 모든 프로세스에 공평한 CPU 시간을 할당함

- **PCB (Process Control Block)**
  - 각 프로세스는 커널이 다음 정보를 관리함
    - **신원**
      - PID(Process ID), PPID(Parent PID), UID(User ID), GID(Group ID)
    - **상태**
      - RUNNING, READY, WAITING, STOPPED, ZOMBIE
    - **메모리**
      - 할당된 메모리 주소 범위
    - **스케줄링**
      - 우선순위(Priority), CPU 사용 시간
    - **리소스**
      - 열린 파일, 신호, 제한값

### 프로세스 스케줄링과 Context Switching

- **Scheduling의 필요성**

  - CPU는 한 번에 하나의 프로세스만 실행 가능한데, 여러 프로세스가 동시에 실행되는 것처럼 보이게 하려면 OS가 시간을 분할하여 각 프로세스에 할당해야 함

  ![image](/assets/img/linux/image2.png)

- Context Switching의 과정
  - **현재 프로세스 상태 저장**
  - CPU 레지스터 값, PC(Program Counter) 등을 PCB에 저장
- **다음 프로세스 선택**
  - 스케줄러가 Ready Queue에서 다음 실행할 프로세스 선택
- **새 프로세스 상태 복원**
  - 선택된 프로세스의 PCB에서 상태를 CPU에 로드
- **새 프로세스 실행 재개**

- Context Switching의 오버헤드
  - Context Switching은 매우 빠르지만(마이크로초 단위), 빈번하면 성능 저하를 유발함
  - 따라서 Time Quantum(각 프로세스가 CPU를 사용할 수 있는 시간)을 적절히 설정해야 함

### 메모리 관리

- Linux의 메모리 관리는 **가상 메모리(Virtual Memory)**를 기반으로 함

- 왜 가상 메모리가 필요한가

  - **주소 공간 보호**
    - 각 프로세스가 다른 프로세스의 메모리를 건드리지 못하도록 격리
  - **실제보다 큰 메모리 사용**
    - 4GB RAM이 있어도 8GB 프로그램을 실행 가능 (디스크를 보조 메모리로 사용)
  - **동적 할당**
    - 프로그램 실행 중 메모리를 동적으로 요청 가능

- Paging과 Swapping

  - **Paging**
    - RAM이 부족할 때 **페이지 단위(보통 4KB)로 메모리의 일부를 디스크의 Swap 영역으로 이동**. 실제로 필요할 때 다시 RAM으로 로드
  - **Swapping**
    - 구형 방식으로 **프로세스 전체를 Swap으로 이동**. 현대 Linux는 거의 사용하지 않음

- 메모리 실제 모니터링
  ```bash
  free -h
  # output:
  #            total  used  free  shared buff/cache available
  # Mem:       15Gi  4.0G  2.5G   100M      8.5G      10.0G
  # Swap:       4Gi  1.2G  2.8G
  ```
  - `used`
    - 실제로 사용 중인 메모리
  - `buff/cache`
    - 파일 캐싱용 메모리 (프로세스가 필요하면 즉시 반환 가능)
  - `available`
    - 새 프로세스에 할당 가능한 메모리
  - **중요**
    - Linux는 여유 메모리를 파일 캐싱(OS가 자주 사용하는 파일을 메모리에 유지)에 사용하므로, **free 메모리가 0에 가까워도 문제없음**. 대신 Swap 사용이 활발하면 성능 저하가 심각함

### 파일 시스템

- Linux는 **모든 것을 파일로 취급**함
  | 파일/경로 | 설명 |
  |-----------|------|
  | `/dev/sda` | 하드 드라이브 (블록 파일) |
  | `/dev/tty` | 터미널 (문자 파일) |
  | `/proc/123` | PID 123 프로세스 정보 (가상 파일시스템) |
  | `/sys/...` | 커널 파라미터 제어 (가상 파일시스템) |
  | `regular file` | 일반 파일 (데이터) |

- **VFS (Virtual File System)**

- VFS의 역할
  - 다양한 파일시스템(ext4, XFS, NTFS 등)을 통일된 인터페이스로 제공함

### Namespace

- Linux 컨테이너(Docker 등)의 기반이 되는 기술임

  | Namespace   | 격리 대상             | 예시                               |
  | ----------- | --------------------- | ---------------------------------- |
  | **PID**     | 프로세스 ID           | 컨테이너 내에서만 PID가 1부터 시작 |
  | **Network** | 네트워크 인터페이스   | 각 컨테이너가 독립적인 IP/포트     |
  | **Mount**   | 파일시스템 마운트     | 컨테이너별 다른 루트 디렉토리      |
  | **UTS**     | 호스트명/도메인       | 컨테이너마다 다른 호스트명         |
  | **IPC**     | 메시지 큐/공유 메모리 | 컨테이너 간 통신 차단              |
  | **User**    | 사용자 ID             | 호스트와 다른 UID 매핑             |

<br/><br/>

## Linux Boot Process

- Linux 시스템이 켜지는 전체 과정

  ![image](/assets/img/linux/image4.png)

<br/><br/>

## 성능 문제 진단 순서

![image](/assets/img/linux/image5.png)

### Context Switching 과다

- Context switching이 많으면 성능 저하
  ```bash
  vmstat 1 | awk '{print $12}' # cs (context switches) 컬럼 확인
  ```
- 높은 값은
  - 과도한 프로세스 수
  - 우선순위 역전
  - I/O 대기로 인한 빈번한 스위칭

### Memory Leak 감지

```bash
# 프로세스 메모리가 계속 증가하는가?
while true; do
  ps aux | grep [process_name]
  sleep 10
done
```

- RSS가 계속 증가면 메모리 누수 (컨테이너 재시작 필요할 수 있음)

<br/><br/>

## 리눅스 기본 구성 요소

### Run Level (SysVinit)

- 부팅 레벨 (0~6)
- 리눅스 시스템 관리의 용이함을 위하여 서비스의 실행을 단계별 구분해 적용한 것

| Run Level |         Mode         |                          Description                          |  명령어  |
| :-------: | :------------------: | :-----------------------------------------------------------: | :------: |
|   **0**   |         halt         |                          시스템 종료                          | `init 0` |
|   **1**   |   single user mode   | 시스템 복구 모드, 관리자 권한 default (예: windows 안전 모드) | `init 1` |
|   **2**   |   multi user mode    |             NFS 미지원 다중 사용자 모드, TUI 환경             | `init 2` |
|   **3**   | full multi user mode |   CLI 다중 사용자 모드, graphic user mode 미지원, TUI 환경    | `init 3` |
|   **4**   |        unused        |       임의로 정의해 사용 가능한 레벨, 기본적으로 미사용       | `init 4` |
|   **5**   |  graphic user mode   |                  다중 사용자 모드, GUI 환경                   | `init 5` |
|   **6**   |        reboot        |                         시스템 재부팅                         | `init 6` |

> **참고**: 최신 리눅스 시스템(CentOS 7+, Ubuntu 16.04+)에서는 **Systemd**를 사용하며 Run Level 대신 **Target** 개념을 사용합니다.
>
> - Run Level 3 = `multi-user.target` (CLI 다중 사용자 모드)
> - Run Level 5 = `graphical.target` (GUI 다중 사용자 모드)
> - 호환성을 위해 `init` 명령어는 여전히 동작하지만, 권장되는 방식은 `systemctl isolate [target]`입니다.

### UI (User Interface)

- **GUI (Graphical user interface)**

  - 그래픽 환경
    - 그래픽으로 사용자와 상호 작용
  - 정보 저장소
    - 폴더(folder)

- **TUI (Text user interface)**
  - 텍스트 환경
    - 텍스트로 사용자와 상호 작용
  - 정보 저장소
    - 디렉토리(directory)

### Shell

- **언어 변환기(명령어 전달 도구)**

  - 사용자가 쓰는 명령어, 언어를 Kernel에 전달해주는 언어 변환기

- **sh**
  - 커널 기본 shell
- **bash**
  - Linux shell
- **csh**
  - C program 전용 shell
- **ksh**
  - korn shell (Unix shell)
- **zsh**
  - Z Shell, 확장성이 뛰어난 현대적 shell (macOS Catalina 이후 기본 shell)

### Linux Directory 구조

- 트리 구조

![image](/assets/img/linux/linux-directory.jpg)

- `/root`
  - **관리자(root 사용자) 홈 디렉토리**
    - ex) Windows의 C:\Users\Administrator
  - 주의
    - `/` (루트 디렉토리, 최상위)와 혼동하지 말것
- `/sbin`
  - **필수적인 system 명령어 저장소**
    - ex) C:\Windows\wow64
- `/bin`
  - **필수적인 기본 명령어 저장소**
    - ex) C:\Windows\system32
- `/boot`
  - **부팅 파일 저장소**
    - 부팅 과정에서 필요한 모든 구성 요소 존재
- `/home`
  - **사용자 홈 디렉토리 저장소**
    - ex) C\users\사용자명
- `/usr`
  - **사용자 애플리케이션 및 시스템 리소스 저장소**
  - Unix System Resources의 약자 (실행 파일, 라이브러리, 문서 등)
  - ex)
    - Windows의 C:\Program Files
- `/var`
  - **자주 변경되는 비휘발성 데이터**
    - 로그 파일 저장소 (log, 메일, 상태 메세지 등)
- `/etc`
  - **서버 관리 및 시스템 설정 파일 저장소**
- `/proc`
  - **자주 변경되는 program 동작 정보 저장소** (휘발성 데이터)
  - `/proc/cpuinfo`: 프로세서 정보
- `/lib`
  - **라이브러리 저장소** (언어 관련 파일, 컴파일러 등)
- `/tmp`
  - 임시저장소 (시스템 reboot 후 보존되지 않음)
- `/dev`
  - 장치 파일 저장소
- `/media`
  - 자동 장치 연결 시 기본 장치가 연결되는 장소
- `/mnt`
  - 자동 장치 연결 시 원격 장치가 연결되는 장소

<br/><br/>

## 정리

- **OS**
  - 하드웨어와 애플리케이션 사이의 중개자, 멀티태스킹/보안/리소스 관리 담당
- **커널**
  - OS의 핵심으로 하드웨어와 직접 상호작용 (Kernel Mode)
- **Linux**
  - 모놀리식 커널을 기반으로 한 오픈 소스 OS
- **프로세스 관리**
  - CPU 공유를 위해 Context Switching으로 시분할
- **메모리 관리**
  - 가상 메모리를 통해 주소 공간 격리 및 메모리 부족 해결
- **파일시스템**
  - 모든 리소스를 파일로 추상화
- **Namespace**
  - 컨테이너 격리의 기반

<br/><br/>

## Reference

- [Wikipedia: Operating System](https://en.wikipedia.org/wiki/Operating_system)
- [MakeLinux: Linux Kernel Map](https://makelinux.github.io/kernel/map/)
- [The Linux Kernel Archives](https://kernel.org/)
- [Wikipedia: Monolithic Kernel](https://en.wikipedia.org/wiki/Monolithic_kernel)
- [GeeksforGeeks: Context Switch](https://www.geeksforgeeks.org/context-switch-in-operating-system/)

- [Linux Ate My RAM](https://www.linuxatemyram.com/)
- [Stack Overflow: RSS and VSZ](https://stackoverflow.com/questions/7880784/what-is-rss-and-vsz-in-linux-memory-management)
