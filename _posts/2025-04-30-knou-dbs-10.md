---
title: "[데이터베이스 시스템] 10강 - 데이터 저장과 파일"
author:
  name: mxxikr
  link: https://github.com/mxxikr
date: 2025-04-30 00:00:00 +0900
category:
  - [Database, Theory]
tags:
  - [knou, database]
math: true
mermaid: true
---

**<center>💡해당 게시글은 방송통신대학교 정재화 교수님의 '데이터베이스 시스템' 강의를 개인 공부 목적으로 메모하였습니다. </center>**

<br/><br/>

# 학습 개요

---

- 현대의 DBMS는 사용자에게 물리적 저장 세부 사항을 숨기고, 논리적 관점에서 데이터를 정의하고 조작할 수 있도록 다양한 추상화 계층을 제공함
- 이러한 추상화 덕분에 응용 개발자나 일반 사용자는 저장 장치의 구조나 접근 방식에 대해 직접 고려하지 않아도 되며, 데이터 모델과 질의 언어 수준에서 시스템을 이용할 수 있음
- 그러나 데이터의 실제 저장 방식, 파일 구조, 접근 방식 등은 데이터베이스 성능에 직접적인 영향을 미치기 때문에, 데이터베이스 관리자(DBA)는 이러한 물리적 저장 계층에 대한 깊은 이해를 바탕으로 적절한 설계를 수행하고 운영 전략을 결정해야 함
- DBMS가 파일 시스템을 기반으로 데이터를 어떻게 저장하고 관리하는 지를 이해하기 위해, 저장 장치의 계층 적 구조, 데이터 파일의 구성 방식, 레코드의 조직 방법, 저장 장치 접근 기법 등 물리적 저장 관련 개념들을 살펴봄
- 이를 통해 논리적 수준에서 설계된 데이터베이스가 실제 저장 장치 상에서 어떻게 표현되고 동작하는 지를 파악할 수 있음

<br/><br/>

# 주요 용어

---

- **파일**
    - 디스크에 데이터를 저장하고 사용하기 위해 접근 되는 가장 기초적인 논리적 저장 단위
- **블록**
    - 디스크에 데이터를 저장하는 고정적 크기의 물리적 저장 단위
- **레코드**
    - 블록을 구성하는 요소로 더 이상 분리될 수 없는 최소 데이터 저장 단위
- **멀티 셋**
    - 한 레코드의 컬럼 값이 여러 개인 컬럼

<br/><br/>

# 강의록

---

## 물리적 저장 장치와 파일

### 물리적 저장 장치의 구성

- 물리적 저장장치는 데이터 접근 속도, 용량을 기준으로 다양한 장치로 **계층 적(hierarchical) 구성**
    
    ![image.png](/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image.png)
    

### 물리적 저장 장치 별 특징

- 기억 지속성 관점으로 **휘발성**과 **비 휘발성**으로 구분
- **휘발성 저장 장치**
    - **캐시**
        - CPU 내부에 위치하여 자주 사용될 것으로 예상되는 데이터를 저장
    - **메인 메모리**
        - 임의 접근이 가능한 고속의 저장 공간
- **비 휘발성 저장 장치**
    - **플래시 메모리**
        - 메인 메모리와 유사하나 비 휘발성
    - **자기 디스크**
        - 자성체를 통해 영구적으로 데이터를 저장
    - **광학 디스크 드라이브**
        - CD, DVD, Blu-ray 등
    - **테이프**
        - 용량이 크고 저렴하나 순차 접근 방식으로 접근 속도가 매우 느림

### 데이터베이스 저장 구조

![image.png](/assets/img/knou/dbs/2025-04-30-knou-dbs-10/ee38fc91-c9b1-4004-98e2-6721d70d7b2c.png)

- 데이터베이스는 하나 이상의 파일로 구성될 수 있음
- 각 파일은 여러 블럭으로 나뉨
- 블럭 내에는 레코드들이 저장됨
1. 사용자가 원하는 부분을 DBMS에 요청
2. DBMS가 내부 관리하고 있는 파일의 데이터에 접근 · 전달

### 데이터베이스 구성 요소

- **파일**
    - 데이터를 영구적으로 저장하기 위해 사용되는 가장 기초적인 논리적 구조
- **블럭**
    - 파일을 고정적인 길이로 분할하여 생기는 균등한 크기의 데이터 묶음
    - 일반적으로 메모리와 디스크 간 데이터 전송 단위로 결정
        - 데이터 전송 단위(page size)
- **레코드**
    - 블럭에 저장되는 요소
    - 관계형 모델에서 분리될 수 없는 최소 데이터 저장 단위
        - 입출력은 최소 단위인 레코드 단위로만
    - 상황에 따라 **두 가지 타입**으로 구분
        - 테이블에 존재하는 **모든 레코드가 항상 길이가 같을 때 → 고정 길이 레코드**
        - 테이블에 존재하는 **레코드마다 길이가 모두 다를 때 → 가변 길이 레코드**

### 고정 길이 레코드

- **고정적인 바이트 수를 갖는 레코드** 저장 시 고려되는 기법
    
    * 사원 릴레이션

        | 사번 (CHAR(8)) | 이름 (VARCHAR(20)) | 부서명 (CHAR(10)) | 연봉 (INT) |
        |---|---|---|---|
        | 12012 | 홍길동 | 인사부 | 90,000,000 |
        | 12034 | 임꺽정 | 재무부 | 80,000,000 |
        | 13019 | 이순신 | 법무지원부 | 90,000,000 |
        | 13030 | 장보고 | 인사부 | 75,000,000 |
        | 13044 | 나철수 | 시설관리부 | 80,000,000 |
        | 14001 | 김영희 | 마케팅부 | 90,000,000 |
        | 14004 | 유관순 | 총무부 | 92,000,000 |
        | 14017 | 안창호 | 생산부 | 98,000,000 |    

    ![image.png](/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image2.png)
    
- **데이터 접근**
    - 모든 레코드는 42 바이트 크기로 구성
    - i번째 레코드 접근
        - (i - 1) * 42 + 1 번째 바이트부터 42개의 바이트를 읽어 접근

### 고정 길이 레코드 할당

- 블럭의 길이가 레코드 길이로 정확히 나눠지지 않아 잔여 공간을 비워두는 방법
    - 블럭 내의 남은 공간 낭비
    
    ![image.png](/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image3.png)
    
    - 레코드 k + 1을 저장하고자 함 → 블럭 1에 충분한 공간이 없음 → 남겨놓고 다음 블럭에 저장
- 블럭의 길이가 레코드 길이로 정확히 나눠지지 않아 한 레코드를 두 블럭에 나누어 저장하는 방법
    - 레코드 접근 시 **두 개의 블럭**에 접근 필요
    
    ![image.png](/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image4.png)
    

### 고정 길이 레코드 할당 시 고려 사항

- 레코드 삭제 시
    - 해당 레코드가 저장 된 위치에 빈 공간이 생성
    - 장시간 레코드의 삽입 및 삭제 발생 시, 저장 공간에 많은 낭비가 발생
- 레코드 삭제 시 대체 방안
    - 마지막 레코드로 공백 대체
    - 삭제 레코드 이후의 레코드를 이동
    - 가용 리스트 관리

### 레코드 삭제 대처

1. 마지막 레코드로 공백 대체
    
    | <u>사번</u> | <u>이름</u> | 부서명 | 연봉 |
    |---|---|---|---|
    | 12012 | 정용호 | 인사부 | 90,000,000 |
    | 12034 | 임꺽정 | 재무부 | 80,000,000 |
    | 13019 | 이순신 | 법무지원부 | 90,000,000 |
    | 13030 | 장보고 | 인사부 | 75,000,000 |
    | 13044 | 나철수 | 시설관리부 | 80,000,000 |
    | 14001 | 김영희 | 마케팅부 | 90,000,000 |
    | 14004 | 유관순 | 총무부 | 92,000,000 |
    | 14017 | 안창호 | 생산부 | 98,000,000 |

    - 속도 저하는 없으나 **삽입과 접근의 순서**가 달라질 수도 있음
2. 삭제 레코드 이후의 레코드를 이동
    
    | <u>사번</u> | <u>이름</u> | 부서명 | 연봉 |
    |---|---|---|---|
    | 12012 | 정용호 | 인사부 | 90,000,000 |
    | 12034 | 임꺽정 | 재무부 | 80,000,000 |
    | 13019 | 이순신 | 법무지원부 | 90,000,000 |
    | 13044 | 나철수 | 시설관리부 | 80,000,000 |
    | 14001 | 김영희 | 마케팅부 | 90,000,000 |
    | 14004 | 유관순 | 총무부 | 92,000,000 |
    | 14017 | 안창호 | 생산부 | 98,000,000 |  

    - 레코드 4번 삭제 후 이동

        | <u>사번</u> | <u>이름</u> | 부서명 | 연봉 |
        |---|---|---|---|
        | 13030 | 장보고 | 인사부 | 75,000,000 |
    
    - 저장의 순서와 접근의 순서가 크게 달라지지 않음
    - 순서는 유지되나 **성능 저하**가 크게 일어날 수도 있음
3. 가용 리스트 관리
    
    ![image.png](/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image7.png)
    
    - 새로운 레코드가 들어오려 할 때 가용 리스트의 첫 번째 헤더에 할당해 저장 시킴
    - **포인터의 정보**를 연속적으로 유지, 보유해야 함

### 가변 길이 레코드

- 블럭에 저장 되는 레코드의 길이가 **서로 다른(가변적)레코드를 할당**하는 방법
    - 가변 길이 레코드는 길이를 예상할 수가 없음 → 수식을 통해 데이터에 접근할 수 없음
- 가변 길이 레코드가 고려되어야 하는 상황
    - 한 블럭 내에 저장 되는 레코드 유형이 둘 이상
    - 길이가 고정되지 않은 컬럼의 개수가 하나 이상
    - 레코드가 멀티 셋을 허용하는 컬럼을 가질 때
        - 멀티셋
            - 레코드의 컬럼 값이 여러 개인 컬럼
    
    ![image.png](/assets/img/knou/dbs/2025-04-30-knou-dbs-10/71c5fcb1-e3e9-4ece-b4e5-d46bfcd9b267.png)
    
    - 가변 길이에 해당하는 컬럼은 맨 뒤에 배치시킴
    - 가변 길이 컬럼이 시작하는 시작 포인터와 길이를 레코드 맨 앞에 위치 시킴
    - NULL
        - 가변 길이와 고정 길이를 구분하기 위해 추가
        - 1byte

### 슬롯 페이지 구조

- 가변길이 레코드를 관리하기에 최적의 방법

![image.png](/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image8.png)

- 블럭 헤더
    - 몇 번째 레코드를 읽어와야 하는 지를 파악

### 파일 구조화 방법

- 파일 구조화
    - 파일 수준에서 레코드를 관리(순서 등)하는 기법
    
    ![image.png](/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image9.png)
    
    - 테이블에 존재하는 블록 중 어느 순서에 저장해야 할까?(어디에)

### 파일 구조화 방법의 종류

- 힙 파일 구조
    - 저장 순서 고려 없이 파일 내 임의 블럭에 배치
    - 장점
        - 저장 순서가 빠름
    - 단점
        - 검색의 속도가 떨어짐
        - 어느 블록에 있는지 일일이 확인해야 함
- 순차 파일 구조
    - 레코드가 탐색 키 기준으로 정렬되어 저장
    - 장점
        - 검색 순서가 빠름
    - 단점
        - 힙 파일 구조보다는 저장 속도가 떨어짐
- 해시 파일 구조
    - 해시 함수를 사용하여 블럭 주소를 계산
    - 힙 파일 구조와 순차 파일 구조의 중간 지점에 해당

![image.png](/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image10.png)

### 순차 파일 구조의 예

![image.png](/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image11.png)

### 순차 파일 구조

- 레코드가 **탐색 키 순서대로** 정렬
- 레코드가 파일에 삽입 되는 시점에서 키 값이 부여
- 장점
    - 검색 키에 대한 정렬 연산이 불 필요, 키 값들의 순서로 레코드를 판독하는 연산에 효율적
    - 현재 레코드에서 정렬 된 키 순서로 다음 레코드를 찾을 때 부가적인 블럭 접근이 불필요
    - 이진 탐색을 사용하면 더 빠르게 레코드를 검색
- 단점
    - 레코드 삽입, 삭제에 많은 비용 소요

### 오버 플로우 블럭

- 순차 파일 구조에서 **레코드의 정렬 된 상태 유지**를 위해 삽입 된 신규 블럭
    
    ![image.png](/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image12.png)
    
    - 신규 데이터를 삽입할 때 기존 저장 공간에 여유가 없거나 데이터의 순서를 유지하기 위해 데이터가 원래의 블럭에 적합하지 않을 경우, 이를 저장하기 위해 새롭게 생성되는 추가 블럭
        1. 새로운 래코드가 삽입 되어야 할 위치가 정해져 있지만 해당 블럭에 여유 공간이 없는 경우 새로운 블럭을 생성하여 데이터를 생성함
        2. 기존 블럭과 오버 플로우 블럭을 포인터로 연결해 기존의 순차성을 유지하면서 추가 데이터 검색할 수 있음
    - 단점
        - 데이터 접근 속도와 검색 효율성 저하

## 저장 장치 관리

### 저장 장치 접근

- 파일은 논리적 관점에서의 저장 객체
- 실제 저장 될 때에는 여러 개의 물리적 단위인 **블럭**으로 저장
    - 블럭은 메모리와 디스크 간 데이터의 전송 단위
    - 일반적으로 2KB ~ 32KB 사용
    - 블럭 전송을 최소화할 수록 입출력 소요 시간이 단축
        - 사용 중인 블럭을 지속적으로 메모리에 적재
        - 한정적 공간으로 인하여 필요에 따라 특정 블럭 할당을 해지
        - 메모리 내부에 버퍼라는 공간에 블럭을 저장하고, 이를 관리하기 위한 버퍼 관리자를 사용
    
    ![image.png](/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image13.png)
    

### 버퍼 관리자

- DBMS가 메모리 내부의 공간인 버퍼(buffer)를 효율적으로 관리하기 위한 하위 시스템
    - 계속 사용하고 잇는 **블럭을 고정**시켜 **효율적으로 메모리를 사용**
- DBMS 상의 소프트웨어는 필요한 블럭이 있을 때 버퍼 관리자에게 해당 블럭을 요청
    - 요청 된 블럭이 버퍼에 있다면, 버퍼 관리자는 블럭이 위치한 메모리 주소를 프로그램에게 전달
    - 요청 된 블럭이 없는 경우, 버퍼 관리자는 버퍼 내의 새로운 공간을 할당하고 해당 블럭을 적재
    - 더 이상 적재할 공간이 없다면, 버퍼에 있는 기존 블럭을 선택하여 할당을 해지하고 해당 블럭을 적재

### 버퍼 교체 전략

![image.png](/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image14.png)

- **교체의 우선순위**를 조작

### 버퍼 관리자의 기능

- 버퍼 교체
    - 가용 공간을 확보 하기 위해 기존에 적재 된 블록을 특정 기준에 의하여 해지
    - 미래에 가장 적게 사용 될 블록을 선택하여 디스크로 내보내는 것이 이상적인 버퍼 교체 전략
    - 버퍼 교체 전략
        - LRU(Least Recently Used)
            - 최근에 가장 적게 참조 된 블럭을 교체
        - MFU(Most Frequently Used)
            - 특정 기간 동안 가장 여러 번 사용 된 블럭을 선택하여 블럭을 교체
- 블럭 고정
    - 장애로 메모리의 데이터가 손실 되어 작업이 중단될 경우, 중단 된 작업의 결과물이 디스크에 기록되는 것을 방지
    - 디스크 블럭이 교체되는 것을 제한
- 블럭 강제 출력
    - 시스템 로그와 같이 중요한 데이터는 디스크에 영구적으로 기록되어야 할 필요
    - 버퍼 공간이 필요 없어도 강제로 디스크에 기록

### 고정 블럭과 블럭 강제 출력

![image.png](/assets/img/knou/dbs/2025-04-30-knou-dbs-10/image15.png)

<br/><br/>

# 연습 문제

---

1. 다음 물리적 저장 장치들 중 휘발성과 비휘발성 장치를 올바르게 짝지은 것은?
    
    ```
    디스크, 메인 메모리, 자기 테이프, 캐시
    ```
    
    a. 휘발성-<캐시, 메인 메모리>,  비휘발성-<디스크, 자기 테이프>
    
    - 전원 공급이 없을 때 데이터가 사라지는 휘발성 저장장치로는 주로 CPU가 이용하는 주 기억 장치인 레지스터, 캐시, 메인 메모리가 있음
    - 전원 공급이 없어도 데이터가 보존되는 비 휘발성 저장장치는 디스크와 같이 주 기억 장치보다 하위에 위치하는 보조 기억 장치와 3차 기억 장치인 광학 디스크 드라이브와 자기 테이프가 있음
2. 다음은 어떤 파일 구조에 대한 설명인가?
    
    ```
    모든 레코드를 파일 내 임의의 위치에 저장하며, 저장하는 순서를 고려하지 않는 파일 구조
    ```
    
    a. 힙 파일 구조
    
    - 순차 파일 구조에서는 레코드들이 특정 컬럼에 대한 값을 기준으로 정렬되어 저장이 됨
    - 해시 파일 구조에서는 레코드가 입력 되면 레코드가 저장 될 블록 주소를 반환해주는 해시 함수를 사용함
    - 다중 테이블 클러스터링 파일 구조는 빈번히 조인 되는 테이블을 하나의 파일에 저장하기 위해 미리 테이블이 조인 되어 저장 되어있는 구조임
3. 다음은 어떤 버퍼 교체 전략에 관한 설명인가?
    
    ```
    미래에 가장 적게 사용될 블록을 선택하여 버퍼에 적재하기 위해 특정 기간동안 가장 여러 번 사용된 블럭을 선택하여 블럭을 교체
    ```
    
    a. MFU

    - LRU의 경우 최근에 참조된 블록은 다시 참조 될 가능성이 높다고 판단하여 가장 최근에 적게 참조 된 블록을 교체하는 전략임
    - SJF(최단 작업 우선 스케줄링)와 FCFS(선입 선처리 스케줄링)는 CPU에 프로세스를 할당하기 위한 전략임

<br/><br/>

# 정리 하기

---

- 물리적 저장 장치들은 데이터 접근 속도 관점에서 계층 적으로 분류됨
    - 상위 계층은 접근 속도가 빠르지만 고가의 장비이며, 하위 계층은 접근 속도가 느리지만 저가의 장비임
- 일반적으로 상위의 저장 장치들은 전원 공급이 차단되면 데이터가 소멸되는 휘발성이며, 하위의 저장장치들은 전원 공급이 차단되어도 데이터가 소멸되지 않는 비 휘발성임
- 데이터베이스는 여러 파일로 구현됨
    - 파일이란 데이터를 영구적으로 저장하기 위해 사용하는 구조임
    - 파일은 물리적으로 여러 블럭으로 나뉘어 저장되기도 함
    - 하나의 파일은 다수의 레코드를 저장하고 있음
- 레코드의 형식은 고정 길이 레코드와 가변 길이 레코드가 있음
    - 레코드의 형식에 따라 파일 및 블럭에서 레코드를 관리하는 방식이 달라짐
    - 특히 슬롯 페이지 구조는 가변 길이 레코드를 관리할 때 이용되는 블럭 구조임
- 특정 필드에 대한 빠른 접근이 요구되는 경우, 파일에 저장되는 레코드를 구조화하는 것이 좋음
    - 파일 구조화 방법으로는 힙 파일 구조화, 순차 파일 구조화, 해시 파일 구조화가 있음
    - 파일 구조 중 다중 테이블 군집 파일 구조는 여러 개의 테이블을 하나의 파일에서 관리하는 특수한 파일 구조임
- 메모리와 디스크는 블럭 단위로 데이터를 주고받음
    - 이때 데이터베이스 시스템에서는 블럭의 입출력을 최소화하기 위해 메모리 내에 버퍼라는 공간을 만들며, 버퍼를 효율적으로 관리하기 위해 버퍼 관리자를 사용함
- 버퍼 관리자는 버퍼 공간에 대한 추가적인 공간 요청 시 버퍼 교체 전략을 사용하여 사용 된 블록을 디스크로 내보내어 공간을 확보함

<br/><br/>

# 체크 포인트

---

1. 데이터베이스 저장 구조에 대한 설명으로 옳지 않은 것은?
    
    a. 해싱 파일은 각 레코드의 속성에 해싱 함수를 적용한 후 레코드들을 정렬하여 저장
    
    - 레코드를 정렬하지는 않음
    - 데이터베이스 저장 구조에 대한 설명으로 옳은 것은?
        - 힙 파일은 파일에서 빈 공간이 있다면 레코드를 어느 위치에나 저장
        - 순차 파일은 검색키 값의 순서에 따라 정렬된 형태로 레코드들을 저장
        - 다중테이블 클러스터링 파일은 서로 다른 릴레이션들의 관련 레코드들을 같은 블록에 저장
2. 다음 중 가변 길이 레코드 방식이 필요한 이유가 아닌 것은?
    
    a. 레코드의 수정이 매우 자주 발생할 때
    
    - 가변 길이 레코드 방식이 필요한 이유
        - 레코드가 멀티셋(multiset)을 이용하는 컬럼을 가질 때
        - 한 블록 내에 저장되는 레코드 유형이 둘 이상일 때
        - 길이가 고정되지 않은 컬럼이 한 개 이상일 때