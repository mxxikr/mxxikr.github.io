---
title:  "[데이터베이스 시스템] 13강 - 트랜잭션"
author:
  name: mxxikr
  link: https://github.com/mxxikr"
date: 2025-05-14 00:00:00 +0900
category:
  - [Database]
tags:
  - [knou, database]
math: true
mermaid: true
---

**<center>💡해당 게시글은 방송통신대학교 정재화 교수님의 '데이터베이스 시스템' 강의를 개인 공부 목적으로 메모하였습니다. </center>**

<br/><br/>

# 학습 개요

---

- DBMS의 핵심 기능 중 하나는 여러 사용자가 동시에 데이터를 공유하더라도 데이터의 일관성과 무결성이 손상되지 않도록 보장하는 것임
- 데이터에 대한 동시 접근이 이루어질 경우, 적절한 제어가 없다면 불일치나 손실과 같은 문제가 발생할 수 있으며, 이는 시스템 전체의 신뢰성을 저하시킬 수 있음
- 이러한 문제를 해결하기 위해 DBMS는 트랜잭션(transaction)이라는 단위 작업 개념을 도입하여, 데이터베이스 연산이 원자적으로 수행되고 데이터가 일관 된 상태를 유지할 수 있도록 지원함
- 트랜잭션의 기본 개념과 트랜잭션 수행의 4가지 핵심 속성인 ACID 특성을 중심으로 살펴 봄
- 은행 계좌 이체와 같은 사례를 통해 트랜잭션의 처리 과정을 구체적으로 이해하고, 트랜잭션 간의 충돌을 방지하기 위한 직렬성 개념과 시스템 장애 발생 시 일관 된 상태로 복구하기 위한 회복 메커니즘의 기초에 대해 학습함

<br/><br/>

# 주요 용어

---

- ACID 특성
    - 트랜잭션이 안전하게 수행되는 것을 보장하기 위해 만족 되어야 하는 트랜잭션의 특성으로 원자성, 일관성, 고립성 및 지속성이 있음
- 동시성 제어
    - 다중 사용자 환경을 지원하는 데이터베이스 시스템에서 데이터의 일관성을 유지하면서 동시에 실행 될 수 있도록 트랜잭션을 제어하는 기능
- 직렬 스케줄
    - 하나의 트랜잭션에 대해 트랜잭션에 포함 된 모든 연산이 연속적으로 실행 되는 스케줄
- 병렬 스케줄
    - 하나의 트랜잭션이 완료되기 전에 다른 트랜잭션이 실행 되는 스케줄

<br/><br/>

# 강의록

---

## 트랜잭션의 이해

### 데이터 동시 접근의 문제

- 동일 데이터에 다수 사용자의 접근 허용 시 **일관성이 훼손**
    
    ![image.png](/assets/img/knou/dbs/2025-05-14-knou-dbs-13/image.png)
    
    - 동시 처리 요청을 받았지만 상황 고려 없이 개별적인 작업에만 치중해 발생한 문제
        - 일관성과 무결성을 지키기 위해 DBMS는 **작업 처리 순서**를 일부 조정해야 함

### 트랜잭션의 개념

- 트랜잭션의 정의
    - 데이터베이스를 조작하기 위한 하나의 논리적 단위를 이루는 일련의 데이터베이스 연산의 집합
- ex) 예금 인출
    - 작업 단위
        - 예금 1000원 인출
    - 일련의 연산
        - Read(A), A=A-1000, Write(A)
- ex) 출금의 순서
    1. 계좌의 기존 잔고 읽기(read)
    2. 일정 금액 차감
- 데이터베이스를 사용하여 처리하는 작업을 **하나의 묶음으로 인식**하여 묶음 단위로 실행된 것과 동일한 결과가 도출되도록 정의한 개념

### 데이터 읽기와 쓰기

- 데이터베이스의 두 연산
- Read(X)
    - 데이터베이스에서 데이터 X를 읽고, 트랜잭션이 실행되는 메모리의 변수 X에 값을 저장하는 연산
- Write(X)
    - 트랜잭션이 실행되는 메모리에 있는 변수 X의 값을 데이터베이스에 저장하는 연산
- ex) 계좌 A에서 B로 1,000원을 이체하는 트랜잭션
    
    ![image.png](/assets/img/knou/dbs/2025-05-14-knou-dbs-13/image1.png)
    

### 트랜잭션의 특징

- 다수의 연산으로 구성된 트랜잭션이 사용자에게 단일 작업처럼 다뤄지도록 ACID 특징을 준수해야 함
- **ACID 특성**
    - **원자성 (Atomicity)**
        - 하나의 트랜잭션에 포함 된 모든 연산은 완전히 수행되거나 전혀 수행되지 않음
    - **일관성 (Consistency)**
        - 특정 트랜잭션이 수행되기 전과 후에 데이터베이스가 일관 된 상태를 유지
    - **고립성 (Isolation)**
        - 특정 트랜잭션이 데이터베이스를 갱신하는 동안 다른 트랜잭션에 의해 방해 받지 않음
    - **지속성 (Durability)**
        - 완료 된 트랜잭션의 결과는 어떠한 시스템의 장애에도 데이터베이스에 반영되어야 함

### ACID 특성 유지

- **원자성**
    
    ![image.png](/assets/img/knou/dbs/2025-05-14-knou-dbs-13/image2.png)
    
    - 6개 연산이 모두 성공하거나, 하나라도 실패하면 모두 취소되어야 함
    - `Write(A)` 후 시스템이 다운되면, 이체는 없었던 것처럼 처리되어야 함
- **일관성**
    - 이체 전 A와 B의 총액이 20000원이었다면, 이체 후에도 A와 B의 총액은 20000원으로 유지되어야 함
    - 중간 단계에서 A:=A-1000만 수행되고 시스템이 멈추면 일시적으로 총액이 19000원이 될 수 있으나, 트랜잭션이 원자성에 의해 완전히 성공하거나 완전히 실패함으로써 최종적으로 일관성을 보장함
    
    ![image.png](/assets/img/knou/dbs/2025-05-14-knou-dbs-13/image3.png)
    
- **고립성**
    - `Write(A)`는 수행되었지만 `Write(B)`는 아직 수행되지 않은 상태를 다른 트랜잭션이 관찰할 수 없어야 함
    - 다른 트랜잭션이 이체 중간에 A의 잔액을 조회하면 이체 전 또는 이체 후의 값 중 하나를 보아야 함
    
    ![image.png](/assets/img/knou/dbs/2025-05-14-knou-dbs-13/image4.png)
    
- 지속성
    - `Write(A)`와 `Write(B)` 연산이 성공적으로 수행되어 트랜잭션이 커밋된 후에는, A 잔고 9000원, B 잔고 21000원이라는 상태가 어떤 상황에서도 보존됨
    
    ![image.png](/assets/img/knou/dbs/2025-05-14-knou-dbs-13/image5.png)
    

### 트랜잭션 실행 연산자

- 트랜잭션 실행의 연산
    - 커밋(commit)
        - 트랜잭션 연산에 의해 갱신 된 데이터
    - 롤백(rollback)
        - 트랜잭션이 중단되기 이전까지 수행한 연산에 의해 갱신 된 모든 데이터 항목의 값을 무효화하여 일관성을 확보

### 트랜잭션의 5가지 상태 변화

- 트랜잭션의 상태
    
    ![image.png](/assets/img/knou/dbs/2025-05-14-knou-dbs-13/743a3e3d-8b33-422b-a26d-ed2d2e148e8b.png)
    
    - 동작
        - 트랜잭션이 시작을 준비 또는 실행 중인 상태
    - 부분 커밋
        - 마지막 연산을 실행한 직후의 상태
    - 커밋
        - 모든 실행이 성공적으로 완료 된 후의 상태
    - 실패
        - 실행이 정상적으로 진행될 수 없는 상태
    - 중단
        - 실행 실패로 롤백 되고 시작 이전의 상태로 환원 된 상태
- 5가지 상태 변화를 통해 ACID 특성을 유지

## 트랜잭션의 동시성

### 동시성 고려

- DBMS는 다수의 사용자가 데이터베이스를 공용으로 사용하기 위한 목적으로 도입
    - 여러 사용자들이 조직의 업무를 효율적으로 하기 위해 만들어놓은 DBMS
    - 시스템 성능을 극대화한 활용은 **거의 불가능**
        - 시스템 유휴 자원들이 많음
    - 자원 활용률을 높이기 위해 여러 작업을 동시에 해 줄 필요가 있음
- 다중 사용자 환경에서 트랜잭션의 동시 실행으로 데이터 갱신 시, **일관성 훼손 문제**가 발생
    - 일관성을 훼손시키지 않는 선에서 여러 트랜잭션을 동시에 실행하는 것은 **자원 활용율**과 **고객 만족도 관점**에서 이점
- 트랜잭션 동시 실행의 이점
    - 트랜잭션 처리율과 자원 이용률을 향상
    - 트랜잭션의 대기 시간을 감소
- 동시성 제어(concurrency control)
    - 다수의 트랜잭션이 성공적으로 동시에 실행되어도 일관성을 유지할 수 있도록 지원하는 기법
    - 트랜잭션이 동시에 실행 된다면 각각의 연산을 어떤 순서로 처리할지 결정해야 함

### 스케줄의 개념

- 예제 트랜잭션
    - A와 B에 각각 10,000과 20,000원 잔액
    - T₁
        - 1000원을 계좌 A에서 B로 이체
    - T₂
        - 계좌 A의 잔고에서 20%를 B로 이체
    
    ![image.png](/assets/img/knou/dbs/2025-05-14-knou-dbs-13/image6.png)
    
- 스케줄(schedule)
    - 다수의 트랜잭션에 포함 된 연산의 실행 순서를 명시한 것

### 직렬 스케줄

- T₁과 T₂가 순차적으로 실행 되는 경우
    
    ![image.png](/assets/img/knou/dbs/2025-05-14-knou-dbs-13/image7.png)
    
- 직렬 스케줄
    - 각 트랜잭션에 속한 모든 연산이 순차적으로 실행 되는 스케줄

### 병렬 스케줄

- T₀과 T₁의 비순차적 실행 되는 스케줄
    
    ![image.png](/assets/img/knou/dbs/2025-05-14-knou-dbs-13/image8.png)
    
- 병렬 스케줄
    - 하나의 트랜잭션이 완료 되기 전에 다른 트랜잭션이 실행 되는 스케줄
- 병렬 스케줄의 순서로 연산을 수행할 경우 일관성 훼손 문제가 발생할 가능성 내포

### 트랜잭션의 직렬화

![image.png](/assets/img/knou/dbs/2025-05-14-knou-dbs-13/image9.png)

- 직렬 가능 스케줄
    - 복수 개의 트랜잭션이 동시에 수행 된 결과가 직렬 스케줄의 결과와 동일한 스케줄
    - **직렬**로 실행 된 것과 다름이 없는 스케줄
    - 동시에 실행되었으나 일관성 문제 없음

### 직렬 가능 스케줄

- 트랜잭션 간 연산 순서를 교환하여 트랜잭션을 직렬 스케줄과 동등하게 변환이 가능한 스케줄
- 사용 된 Read와 Write 연산 교환 시 상황에 따라 실행 결과에 일관성이 훼손 되는 현상(충돌)이 발생
- 연산 순서의 교환(단, Iᵢ는 Tᵢ의 연산)
    - ~~Iᵢ = Read(Q)    Iⱼ=Read(Q)~~
    - Iᵢ = Read(Q)    Iⱼ=Write(Q)
    - Iᵢ = Write(Q)    Iⱼ=Read(Q)
    - Iᵢ = Write(Q)    Iⱼ=Write(Q)
    - 어느 한 곳에 쓰기 연산이 있으면 순서를 바꾸지 못함

### 충돌 동등

- 특정 스케줄 S에서 충돌이 일어나지 않은 연산의 순서를 바꿔 스케줄 S'으로 변환이 가능한 상태
    
    ![image.png](/assets/img/knou/dbs/2025-05-14-knou-dbs-13/image10.png)
    
    - 스케줄 S와 스케줄 S'은 충돌 관점에서 동등

### 충돌 직렬성

- 순서 교환이 가능한 연산을 교환하여 직렬 스케줄의 연산과 동등하게 변환이 가능한 스케줄
    
    ![image.png](/assets/img/knou/dbs/2025-05-14-knou-dbs-13/image11.png)
    
    - Tⱼ가 Write(A)를 실행하고 Tⱼ가 Write(B)를 실행하려고 함
        - **서로 다른 항목을 쓰는 것**은 연산의 순서를 바꾸어도 문제가 발생하지 않음
        - **서로 다른 데이터 항목**은 어떤 작업이라도 **순서**를 바꿔도 괜찮음
        - **무결성, 일관 훼손 여부**를 파악
        - 충돌 직렬적

## 트랜잭션의 회복

### 회복의 개념

- 트랜잭션 실패 시, 원자성을 보장하기 위해 실행 된 모든 연산을 실행 이전 상태로 복원하는 기법
    - 스케줄에 포함 된 트랜잭션의 수가 매우 많으면 원상복구가 쉽지 않음
- 회복 불가능한 스케줄
    - T₆가 T₅가 기록한 A를 읽고 커밋한 상태
        - T₆는 T₅에 종속적(dependent)
    - 커밋한 T₅는 롤백 불가능
    
    ![image.png](/assets/img/knou/dbs/2025-05-14-knou-dbs-13/image12.png)
    

### 회복 가능한 스케줄

- Tᵢ와 Tⱼ에 대해, Tᵢ가 기록한 데이터를 Tⱼ가 읽을 떄, Tᵢ의 커밋이 Tⱼ보다 먼저 나타나는 스케줄
- 연쇄적 롤백 유발 가능
    - T₇의 롤백으로 인하여 연쇄적으로 다른 트랜잭션도 롤백 되는 현상
    
    ![image.png](/assets/img/knou/dbs/2025-05-14-knou-dbs-13/92a4dc7b-a301-4048-a0a0-dd54b4c52b91.png)
    

### 비연쇄적 스케줄

- 대량의 회복 연산이 발생하는 연쇄적 롤백을 방지하기 위해 **연쇄적이지 않은 연산 순서**로 구성 된 스케줄
- Tᵢ가 기록한 데이터를 읽을 때 Tᵢ의 커밋이 Tⱼ의 읽기 연산보다 먼저 나타나는 스케줄
    
    ![image.png](/assets/img/knou/dbs/2025-05-14-knou-dbs-13/image13.png)
    

<br/><br/>

# 연습 문제

---

1. 아래 그림과 같이 시스템 오류 이후, 트랜잭션 T1에 대해 실행 결과가 데이터베이스에 반영이 되었는지를 확인하고, 반영이 되어있지 않았다면, T1을 재실행한다. 이는 트랜잭션의 어떤 특성을 만족 시키기 위한 것인가?
    
    a. 지속성
    
    - 한 번 정상적으로 실행이 완료 된 트랜잭션의 결과는 데이터베이스의 어떠한 소프트웨어적, 하드웨어적 오류에도 반드시 데이터베이스에 반영되어야 함
    - 이러한 트랜잭션의 특성을 지속성(durability)라고 함
2. 다음 중 **트랜잭션을 동시에 실행시키는 이유**에 대한 설명으로 옳지 않은 것은?
    
    a. 데이터베이스의 일관성이 향상된다.
    
    - 서로 다른 두 트랜잭션이 같은 데이터 항목에 대하여 연산을 수행할 경우 데이터베이스의 일관성이 보장되지 않을 수 있음
    - 따라서 트랜잭션을 동시 수행하기 위해서는 추가적인 고려 사항이 필요함
3. 다음은 무엇에 대한 설명인가?
    
    ```
    모든 트랜잭션 순서쌍 Ti와 Tj에 대해, Ti가 기록한 데이터 항목을 Tj가 읽는다면, Ti의 커밋이 Tj의 커밋보다 먼저 나타나는 스케줄
    ```
    
    a. 회복 가능한 스케줄(recoverable schedule)

<br/><br/>

# 정리 하기

---

- 트랜잭션은 데이터베이스를 조작하기 위한 하나의 논리적 작업 단위를 이루는 일련의 연산들의 집합으로, 트랜잭션이 실행 중에 멈추거나 중단되지 않는 최소 작업 단위임
- 트랜잭션은 ACID 특성이라고 하는 원자성, 일관성, 고립성, 지속성이라는 특성을 갖고 있으며 DBMS는 트랜잭션의 ACID 특성을 만족시키기 위해 지속적으로 명령의 실행과 데이터의 상태를 모니터링함
- 데이터베이스에 접근 연산을 수행하는 트랜잭션은 트랜잭션 내부에 포함되는 연산의 실행 가능성 여부에 따라 동작, 부분 커밋, 실패, 중단, 커밋 등 다섯 가지 상태 중 하나에 있게 됨
- 다수의 사용자가 접근하는 데이터베이스에서 동시에 동일한 데이터에 접근할 가능성이 있으며 이러한 상황에서 데이터베이스의 무결성을 보장하고, 트랜잭션의 일관성을 유지하기 위해서는 동시성 제어를 통해 다중 사용자 환경에서 데이터에 대한 접근과 갱신을 통제할 필요가 있음
- 트랜잭션의 동시 실행 가능 여부를 판단하기 위해서는 해당 트랜잭션으로 작성되는 스케줄 내부에서 트랜잭션 간 연산 순서를 교환하여 트랜잭션을 직렬 스케줄과 동등하게 변환이 가능해야 함
- 트랜잭션의 원자성을 위해 트랜잭션이 시작 된 이후 중간에 실패하는 경우 트랜잭션이 시작되기 전까지의 상태로 회복시켜야 함
    - 이를 트랜잭션의 회복화라고 함
- 한 트랜잭션이 수정한 데이터를 다른 트랜잭션이 읽을 경우 데이터를 수정한 트랜잭션의 커밋이 데이터 읽기보다 먼저 실행되는 스케줄을 회복 가능 스케줄이라고 함

<br/><br/>

# 체크 포인트

---

1. 트랜잭션의 상태 중 트랜잭션의 수행이 실패하여 Rollback 연산을 실행한 상태는?
    
    a. 철회(abort)

2. 데이터베이스 트랜잭션이 올바르게 수행된다는 것을 보장하기 위해 지원해야 하는 트랜잭션 성질에 대한 설명으로 옳지 않은 것은?
    
    a. 트랜잭션이 실행되는 동안의 값은 다른 트랜잭션이 접근할 수 있어야 한다. 
    
    - 고립성 확보되지 않아 일관성 훼손 됨
    - 데이터베이스 트랜잭션이 올바르게 수행된다는 것을 보장하기 위해 지원해야 하는 트랜잭션의 성질에 대한 설명으로 옳은 것
        - 각 트랜잭션의 모든 연산이 정상적으로 수행 완료되거나, 아니면 어떠한 연산도 수행되지 않은 원래 상태가 되어야 함
            - 원자성
        - 트랜잭션이 실행되는 동안의 값은 다른 트랜잭션이 접근할 수 없어야 함
            - 고립성
        - 트랜잭션이 성공적으로 끝난 뒤에는, 시스템에 오류가 발생하더라도 트랜잭션에 의해 변경 된 데이터베이스 내용은 계속 유지되어야 함
            - 지속성
        - 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변화 함
            - 일관성