---
title:  "[컴퓨터과학 개론] 2강 - 컴퓨터와 데이터"
author:
  name: mxxikr
  link: https://github.com/mxxikr"
date: 2023-09-07 00:28:00 +0900
category:
  - [Knou, 컴퓨터과학 개론]
tags:
  - [knou, cs]
math: true
mermaid: true
---

**<center>💡해당 게시글은 방송통신대학교 이관용, 정광식 교수님의 '컴퓨터과학 개론' 강의를 개인 공부 목적으로 메모하였습니다. </center>**

<br/><br/>

# 학습 목표
---
1. 데이터와 정보의 개념적 차이, 데이터 표현 단위 등을 이해하고 설명 가능
2. 다양한 진법 간의 변환 수행 가능
3. 정수와 실수의 표현 방법 이해하고 설명 가능
4. 문자 표현의 개념과 문자 코드의 종류 이해하고 설명 가능
<br/><br/>

# 데이터와 정보
---
### **데이터와 정보의 관계**
- I = P(D)
  ![image](/assets/img/knou/cs/2-1.jpg)

### **데이터의 표현 형태**
- 데이터의 유형과 무관하게 일관된 표현 방식
    - 문자, 정수/실수, 이미지, 오디오, 비디오 등
    - 비트 패턴
    - 메모리에 저장된 데이터 유형에 맞는 해석과 처리가 필요
        - 입출력 장치나 프로그램의 책임

### **데이터의 표현 단위**
- 비트(binaryd digit)
  - (ex) 0 1
- 바이트(byte)
  - (ex) 0 1 1 0 0 0 0 1
- KB(2^10≑10^3), MB(2^20≑10^6), GB(2^30≑10^9), TB(2^40≑10^12), PB(2^50≑10^15), EB(2^60), ZB(2^70), YB(2^80)
- 워드(word)
    - 컴퓨터 연산의 기본 단위가 되는 정보의 양
    - 32 bit, 64 bit
<br/><br/>

# 진법
---
### **진법(number system)**
- 수를 세는 방법 또는 단위
- r진수 → 0, 1, ⋯, (r-1)까지의 숫자만을 사용해서 표현한 수  

  | 2진법 | 0, 1 | 1010(2) 1001(b) |
  | --- | --- | --- |
  | 8진법 | 0, 1, …, 7 | 720(8) 257(o) |
  | 10진법 | 0, 1, 2, …, 9 | 99(10) 123(d) |
  | 16진법 | 0, 1, …, 9, A, B, C, D, E, F | 2CF(16) FF30(h) |  

- 각 위치에 따른 서로 다른 가중치(자릿값) 존재
  - 123 = 1 * 10^2 + 2 * 10^1 + 3 * 10^0
  - 이진수 1 0 1 1 1 . 0 1 1
  - 가중치 2^4 2^3 2^2 2^1 2^0 2^-1 2^-2 2^-3

### **2진수 → 10진수**
- 10진수 = (각 비트값 * 해당 비트 위치의 가중치)의 합
- 가중치
  - 2^4 2^3 2^2 2^1 2^0 . 2^-1 2^-2 2^-3 2^-4
  - 16 8 4 2 1 . 1/2 1/4 1/8 1/16
- 101.1001(2) = 1 * 2^2 + 0 * 2^1 + 1 * 2^0 + 1 * 2^-1 + 0 * 2^-2 + 0 * 2^-3 + 1 * 2^-4 = 5.5615(10)

### **8진수, 16진수 → 10진수**
- 10진수 = (각 숫자값 * 해당 위치의 가중치)의 합
- 3456(8) = 3 * 8^3 + 4 * 8^2 + 5 * 8^1 + 6 * 8^0 = 1838
- AE7(16) = A * 16^2 + E * 16^1 + 7 * 16^0 = 10 * 16^2 + 14 * 16^1 + 7 * 16^0 = 2791  

### **10진수 → r진수(r = 2, 8, 16)**
- 정수 부분과 소수 부분을 구분하여 각각 처리한 후, 각 결과를 단순히 연결해서 나열
- 60.6875
  - 정수 부분 111100 + 소수 부분 1011 = 111100.1011

### **10진수_정수부분 → r 진수 (r = 2, 6, 18)**
```
입력값 = 10진수(정수 부분); i = 0;

몫 = 입력값 / r; 
나머지 = 입력값 mod(%) r;
결과(i) = 나머지;

while (몫 ≠ 0)
	입력값 = 몫; i = i+1;
	몫 = 입력값 / r;
	나머지 = 입력값 mod r;
	결과(i) = 나머지
end
출력[결과(i), 결과(i-1), …, 결과(0)];
```
  ![image](/assets/img/knou/cs/2-2.jpg) 


### **10진수_소수부분 → r 진수 (r = 2, 6, 18)**
```
입력값 = 10진수(소수 부분);
i = 0;

while (입력값 ≠ 0)
	임시변수 = 입력값 * r;
	결과(i) = 임시변수의 정수 부분;
	i = i+1;
	입력값 = 임시변수의 소수 부분;
end

출력[0.결과(0), 결과(1), …, 결과(i)];
```
  ![image](/assets/img/knou/cs/2-3.jpg)
  ![image](/assets/img/knou/cs/2-4.jpg)
  ![image](/assets/img/knou/cs/2-5.jpg)

### **2진수 ↔ 8진수/16진수**
- 2 진수의 3 자릿수 = 8 진수의 1 자릿수
- 2 진수의 4 자릿수 = 16 진수의 1 자릿수
  ![image](/assets/img/knou/cs/2-6.jpg)
<br/><br/>

# 정수 표현
---
### **정수 표현 방법**
- **부호 없는 정수**
    - 부호(+,-) 비트 미존재
    - n비트 → 0~ 2^n -1
- **부호 있는 정수**
    - 최상위 비트 = 부호 비트 (0: 양수, 1: 음수)
    - 양의 정수는 모두 동일, 음의 정수는 서로 다른 형태 가짐
    - **부호화-크기**
        - 절대값으로 표현
        - -(2^(n-1) -1) ~ +(2^(n-1) -1)
        - +0(00000000) -0(10000000)
    - **1의 보수**
        - 양수에 대한 보수로서 표현
        - -(2^(n-1) -1) ~ +(2^(n-1) -1)
        - +0(00000000) -0(11111111)
    - **2의 보수**
        - (1의 보수+1)로 음수 표현
        - -2^(n-1) ~ +(2^(n-1) -1)

### **부호 없는 정수**
- 주어진 수 → 2진수 변환 → n 비트 할당(n = 8)
    - 115 → 1110011 → 01110011
    - 275 → 100010011 → 1/00010011 (overflow 발생)

### **부호 있는 정수**
- n = 8 비트인 경우
    - 양수 : 0
    - 음수 : 1
    - 124 : 01111100
- -124
    - **부호화-크기**
        - 절대값
        - 11111100
    - **1의 보수**
        - 0 → 1, 1 → 0
        - 1000011
    - **2의 보수**
        - (1의 보수) + 1
        - 1000011 + 1 = 1000100

### **8비트 정수 표현 방법의 비교**

| 이진 표현 | 부호 없는 정수 | 부호 있는 정수(부호화-크기) | 부호 있는 정수(1의 보수) | 부호 있는 정수(2의 보수) |
| --- | --- | --- | --- | --- |
| 00000000 | 0 | +0 | +0 | +0 |
| 00000001 | 1 | +1 | +1 | +1 |
| 00000010 | 2 | +2 | +2 | +2 |
| 00000011 | 3 | +3 | +3 | +3 |
| … | … | … | … | … |
| 01111100 | 124 | +124 | +124 | +124 |
| 01111101 | 125 | +125 | +125 | +125 |
| 01111110 | 126 | +126 | +126 | +126 |
| 01111111 | 127 | +127 | +127 | +127 |
| 10000000 | 128 | -0 | -127 | -128 |
| 10000001 | 129 | -1 | -126 | -127 |
| 10000010 | 130 | -2 | -125 | -126 |
| 10000011 | 131 | -3 | -124 | -125 |
| … | … | … | … | … |
| 11111100 | 252 | -124 | -3 | -4 |
| 11111101 | 253 | -125 | -2 | -3 |
| 11111110 | 254 | -126 | -1 | -2 |
| 11111111 | 255 | -127 | -0 | -1 |

### **2의 보수 방식의 응용**
- 24-17
  - A - B → A + (-B)
    - B에 대한 2의 보수를 취한 후 덧셈 수행
  - 00011000(+24) - 00010001(+17)  -2의 보수→ 00011000(+24) - 11101111(-17)  = **1(무시)**00000111(+7)
- 이진수 10001100 → 십진수
    - 8비트, 2의 보수 방식 사용
        1. 10001101 - 1 = 10001100
        2. 보수 계산
            - 11110011
        3. 십진수 변환
            - -115
<br/><br/>

# 실수 표현
---
### **실수 표현**

- 과학적 표기법을 활용한 부동 소수점 방식으로 표현
    - 1,234,000,000,000 → 1.234 * 10^12
    - -0.0000000005678 → -5.678×10^-10
- **(-1)^S×M×B^E**
    ![image](/assets/img/knou/cs/2-7.jpg)
    
  | 부호 S | 0 | 1 |
  | --- | --- | --- |
  | 가수 M | 1.234 | 5.678 |
  | 기저 B | 10 | 10 |
  | 지수 E | 12 | -10 |  

    - **S**
        - **부호**
        - 1비트
    - **M**
        - **가수**
        - n 비트
        - 정규화 (normalization)
    - **E**
        - **지수**
        - m 비트 → 초과 표기법 (excess notation)

### **초과 표기법**

- 부동 소수점 방식의 지수 부분만을 표현하기 위한 방법
    ![image](/assets/img/knou/cs/2-8.jpg)
    - 매직 넘버
        - m비트 → 2^(m-1) 또는 2^(m-1) -1
        - m = 8
            - 2^(8-1) = 2^7 = **128** (초과_128)
            - 2^(8-1) - 1= 2^7 - 1 = **127** (초과_127)
    - (-1)^0/1 * 1010.0011 * 2^-32, 초과_127
        - 0/1
            - 1비트
        - -32(**지수**) + 127(**매직 넘버**) = 95 → 01011111(8비트)
        - 가수(n비트)

### **정규화**

- 가수를 표현할 때 표준화된 형식 필요
- -1.01000110011 * 2^6 정규화
    - -1010.00110011 * 2^3
    - -10.1000110011 * 2^5
    - -101000110.011 * 2^-2
    - -0.0101000110011 * 2^8
- 1.1011 * 2^-6
    - 0.0000011011 * 2^0
- 1.01110100101 * 2^7
    - 10111010.0101 * 2^0

### **실수 표현 정규화**

- 60.6875 → 111100.1011 → 정규화 → 1.111001011 * 2^5 → 0/1

### **IEEE 부동 소수점 방식의 표준 형식**

- 단정도(single precision) → 4바이트
    ![image](/assets/img/knou/cs/2-9.jpg)
    
- 배정도(double precision) → 8바이트
    ![image](/assets/img/knou/cs/2-10.jpg)
<br/><br/>

# 문자 표현

---

### **문자 표현**

- 키보드를 통해 입력되는 문자도 2진수로 표현되어 처리
    - 각 문자마다 유일한 값으로써 코드를 할당할 수 있는 약속된 문자 체계가 필요
- 문자 체계의 종류
    - ASCII, 유니코드, …

### **ASCII**

- American Standard Code for Information Interchange
- 미국 표준 협회(ANSI)
- 7비트 코드 → 128개(2^7)의 서로 다른 문자 표현
    - 확장된 아스키(Extended ASCII) → 1비트 + 7비트
        - 1비트
            - 0
            - 패러티(parity) 비트
                - 짝수 패러티 → **1**1001100
                - 홀수 패러티 → **0**1001100
- **A**(1000001) **S**(1010011) **C**(1000011) **I**(1001001) **I**(1001001)
    ![image](/assets/img/knou/cs/2-11.jpg)
    

### **유니코드**

- 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준
    - 1990년 애플 컴퓨터, IBM, MS 등의 컨소시엄으로 설립한 유니코드(Unicode)가 첫 버전 발표
        - 1995년 국제 표준으로 제정 → 공식 명칭: ISO/IC 10646-1
        - 사용 중인 플랫폼, 프로그램, 언어에 무관
        - 16비트 코드 체계 → 65,636개(216)의 서로 다른 문자 표현

### **EBCDIC, BCD**

- EBCDIC(Extended Binary Coded Decimal Interchange Code)
    - IBM 개발
        - IBM 메인 프레임에서만 사용
    - 8비트 코드
        - 실제 사용되는 문자 코드는 127개
- BCD(Binary Coded Decimal)
    - 4비트로 구성된 열 개의 코드로 10진수를 표현 → 8421 코드
    - 295 → 0010 1001 0101

<br/><br/>

# 학습 정리
---
1. 데이터와 정보
    - **I=P(D)**
        - 데이터와 정보의 관계
        - 데이터를 대상으로 처리기에서 처리해서 얻은 결과가 정보
    - **데이터 처리**(정보 처리)
        - 데이터를 정보로 가공하고 변환하는 일련의 과정
    - **데이터**
        - 현실 세계로부터 관찰이나 측정을 통해 단순히 얻어지는 사실이나 값
    - **정보**
        - 어떤 상황에 대해 적절한 의사 결정을 수행할 수 있게 하는 지식
    - 모든 데이터는 유형에 무관하게 비트 패턴이라는 일관된 방식으로 표현
    - **데이터의 표현 단위**
        - bit, byte, KB, MB, GB, TB, PB, EB, ZB, YB
    - **word**
        - 컴퓨터 연산의 기본 단위가 되는 정보의 양
2. 진법
    - **r진법**
        - 0, 1, …, (r-1)까지의 숫자만을 사용해서 수를 표현하는 방식/단위
    - 2 진법, 8 진법, 10 진법, 16 진법 간의 변환이 필요
        - **2 진수/8 진수/16 진수를 10 진수로 변환**
            - 각 위치에서의 숫자 값과 해당 위치에서의 가중치(자릿값)를 곱한 후, 그 결과들을 모두 더함
        - **10 진수를 r진수로 변환**
            - 정수 부분과 소수 부분을 나눠서 각각 변환한 후, 그 결과를 단순히 연결해서 표현함
        - **2 진수와 8 진수/16 진수의 관계**
            - 2 진수의 3 자릿수 = 8 진수의 1 자릿수
            - 2 진수의 4 자릿수 = 16 진수의 1 자릿수
3. 정수 표현
    - 정수 표현 방법의 종류
        - **부호 없는 정수, 부호 있는 정수**
        - 부호 있는 정수의 표현
            - 종류: 부호화-크기 방식, 1의 보수 방식, 2의 보수 방식 → 양의 정수는 모두 동일한 형태를 갖지만, 음의 정수의 경우에는 서로 다른 형태를 가짐
        - 부호 없는 정수
            - 부호 비트가 없으며, 주어진 n비트 전체를 사용해서 정수(0~2n-1)를 표현
    - **부호화-크기 방식**
        - 최상위 1비트를 부호 비트로 사용하고, 음의 정수는 음수에 대한 절대 값으로 표현
    - **1의 보수 방식**
        - 부호 비트 사용
        - 음의 정수는 양의 정수 표현에 대한 보수(0 → 1, 1 → 0)를 취해서 표현
    - **2의 보수 방식**
        - 부호 비트 사용
        - 음의 정수는 1의 보수 방식의 결과에 1을 더해서 표현
4. 실수 표현
    - **부동 소수점 방식**을 사용해서 표현
    - 표현 형식
        - (-1)부호×가수×2지수, (-1)^S×M×2^E
        - 부호(1비트)+지수(m비트)+가수(n비트)
    - **지수의 표현**
        - **초과 표기법**
            - 부동 소수점의 지수 부분만을 위한 표기 방법으로, m비트가 할당된 경우 두 개의 매직 넘버(2m-1, 2m-1-1)가 존재
        - **지수 값을 저장하는 경우**
            - 지수 값 + 매직 넘버를 2 진수로 표현/저장
        - **저장된 지수 값을 해석하는 경우**
            - 지수 부분의 2 진수를 10 진수로 변환한 값에서 매직 넘버를 뺀다.
    - **가수의 표현**
        - **정규화**
            - 소수점 바로 왼쪽에 오직 하나의 1만 있도록 소수점의 위치를 조정
            - 가수 값을 저장하는 경우에는 소수점 이하 부분만 저장
5. 문자 표현
    - 각 문자마다 유일한 코드가 부여되며, 이를 위해 약속된 문자 체계가 필요
    - 대표적인 문자 체계의 종류
        - ASCII (또는 확장된 ASCII)
        - 유니코드
<br/><br/>

# 연습문제
---
### **Q1**.
- 주어진 여러 진법의 수 중에서 가장 작은 값을 나타내는 것은?  
  ```
  1. 0.59375(10)
  2. 0.43(8)
  3. 0.98(16)
  4. 0.10011(2)
  ``
- **A1.** 2. 0.43(8)

  ```
  0.59375(10)
  0.43(8) = 4 * 8^-1 + 3 * 8^-2 = 0.546875(10)
  0.98(16) = 9 * 16^-1 + 8 * 16^-2 = 0.59375(10)
  0.10011(2) = 1 * 2^-1 + 0 * 2^-2 + 0 * 2^-3 + 1 * 2^-4 + 1 * 2^-5 = 0.59375(10)
  ```

### **Q2**.
- 이진수 1100101.10011을 8진수와 16진수로 각각 올바르게 변환한 것은?

  ```
  1. 145.46  65.98
  2. 145.23  65.13
  3. 621.46  C5.98
  4. 621.23  C5.13
  ```

- **A2.** 1. 145.46  65.98

  ```
  2진수를 8진수 또는 16진수로 변환하기 위해서는 2진수 표현에서 소수점을 기준으로 정수 부분에 대해서는 왼쪽 방향, 소수 부분에 대해서는 오른쪽 방향으로 세 자리씩 묶어서 나타내면 8진수의 한 자릿수가 되고, 
  네 자리씩 묶어서 나타내면 16진수의 한 자릿수가 된다.
  
  8진수로의 변환: 1100101.10011 → 001 100 101 . 100 110 → 1 4 5 . 4 6 (8)
  16진수로의 변환: 1100101.10011 → 0110 0101 . 1001 1000 → 6 5 . 9 8 (16)
  ```  

### **Q3**.
- 2의 보수 방식을 사용해서 8비트로 표현된 정수 10100001은 10진수로 얼마인가? 
  ```
  1. -110
  2. -105
  3. -100
  4. -95
  ```
- **A3.** 4. -95

  ```
  주어진 음수를 2의 보수 방식으로 표현하기 위해서는 
  1. 주어진 음수의 절대값을 이진수로 변환
  2. 이진수의 각 비트에 대해서 보수(0은 1로, 1은 0으로 바꿈)를 취함
  3. 그 결과에 1을 더하면 된다.

  하지만 주어진 문제는 반대의 경우이다. 
  따라서 위의 과정(주어진 음의 정수를 2의 보수 방법으로 변환하는 과정)의 역순으로 처리하면 된다. 
  즉 2의 보수로 표현된 수에서 1을 빼고(10100001-1=10100000), 
  그 결과에 대해서 보수를 취하면 01011111이 되고, 이것을 십진수로 변환하면 95가 되는데, 2의 보수 방식으로 표현된 수의 부호 비트가 1이므로 음의 정수 -95가 된다
  ```

### **Q4**.
- 십진수 53.625를 부동 소수점 방식의 실수 표현으로 올바르게 것은? (단, 주어진 부동소수점은 16비트를 사용한다. 이 중에서 지수를 위해 5비트를 할당하며 초과_15 표기법을 사용한다.)

  ```
  1. 0 10100 1010110100
  2. 0 01111 1101011010
  3. 0 10100 1101011010
  4. 0 01111 1010110100
  ```  

- **A4.** 1. 0 10100 1010110100

  ```
  주어진 실수를 이진수로 변환(정수 부분과 소수 부분으로 구분하여 처리)하면 110101.101가 되고, 
  이에 대해 정규화를 수행하면 1.10101101*2^5가 된다.
  부호 비트(1비트) → 주어진 수가 0보다 크므로 0이 된다.
  지수 → 지수값 5와 매직넘버 15를 더한 값 20을 이진수로 변환해서 5비트에 할당하면 10100이 된다.
  가수 → 소수점의 왼쪽 1을 제외한 나머지 부분(10101101)을 10비트(16비트 중에서 부호 1비트와 지수 5비트를 사용하고 남은 비트)에 할당하면 1010110100이 된다.
  ```  

### **Q5**.
- 다음 설명에 해당하는 문자 코드 체계는 무엇인가?

  ```
  1995년 국제 표준으로 제정되었으며, 공식 명칭은 ISO/IEC 10646-1이다.
  16비트 코드 체계로서, 세계의 모든 문자를 표현할 수 있다.

  1. ASCII 코드
  2. EBCDIC 코드
  3. 유니코드
  4. 확장된 ASCII 코드
  ```  

- **A5.** 3. 유니코드

  ```
  유니코드는 애플 컴퓨터, IBM, MS 등의 컨소시엄을 통해 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준으로, 사용 중인 플랫폼, 프로그램 등에 무관한 특징을 갖는다.
  ```  