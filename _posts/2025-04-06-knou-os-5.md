---
title:  "[운영 체제] 5강 - 병행 프로세스"
author:
  name: mxxikr
  link: https://github.com/mxxikr"
date: 2025-04-06 00:00:00 +0900
category:
  - [OS, Operating System]
tags:
  - [knou, os]
math: true
mermaid: true
---

**<center>💡해당 게시글은 방송통신대학교 김진욱 교수님의 '운영 체제' 강의를 개인 공부 목적으로 메모하였습니다. </center>**

<br/><br/>

# 학습 개요

---

- 병행 프로세스 중 협력 프로세스에서 발생할 수 있는 구체적인 문제로 생산자-소비자 문제와 판독기-기록기 문제가 있음
- 협력 프로세스 사이에는 데이터를 공유하기 위해 통신이 필수인데, 이 과정에서도 다양한 문제가 발생할 수 있음
- 생산자-소비자 문제, 판독기-기록기 문제의 예를 통해 협력 프로세스의 일반적 구현 방법을 학습함
- 병행 프로세스 사이의 통신을 위한 방법에 대해 논리적 측면에서 살펴봄

<br/><br/>

# 학습 목표

---

- 생산자-소비자 문제를 알아보고, 세마포어를 이용하여 해결할 수 있음
- 판독기-기록기 문제를 알아보고, 세마포어를 이용하여 해결할 수 있음
- 프로세스 간 통신을 위한 논리적 구조를 설명할 수 있음

<br/><br/>

# 강의록

---

## 생산자-소비자 문제

### 생산자-소비자 문제 정의

- 두 협력 프로세스 사이에 버퍼를 두고 생산자와 소비자의 상황을 다루는 문제
    
    ![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/image.png)
    
    - **생산자**
        - 데이터를 넣는 프로세스
    - **소비자**
        - 데이터를 꺼내는 프로세스

### 생산자-소비자 문제 조건

- 버퍼에 여러 프로세스가 동시에 접근할 수 없음
    - 버퍼에 데이터를 넣는 동안에는 데이터를 꺼낼 수 없음
    - 버퍼에서 데이터를 꺼내는 동안에는 데이터를 넣을 수 없음
    - **상호 배제 필요**
- 버퍼의 크기가 유한 (유한 버퍼 문제)
    - 버퍼가 가득 찬 경우 생산자는 대기해야 함
    - 버퍼가 빈 경우 소비자는 대기해야 함
    - **동기화 필요**

### 세마포어를 이용한 해결

- **상호 배제: 세마포어 `mutex` (초깃 값 1)**
    
    ![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/image1.png)
    
    - `P(mutex)`
        - 세마포어 변수 S의 값을 1 감소 시킴
        - 만약 S 값이 0보다 작아지면 해당 프로세스는 S 값이 0 이상이 될 때까지 대기(block)
    - `V(mutex)`
        - 세마포어 변수 S의 값을 1 증가 시킴
        - 만약 이 증가로 인해 S 값이 0보다 커지면 대기 중인 프로세스 중 하나를 깨움
    - **생산자의 코드**
        
        ```c
        While (true) {
            데이터를 생산
        	
            P(mutex);	// 진입 영역
            버퍼에 데이터를 넣음 // 임계 영역
            V(mutex); // 해제 영역
        
        }
        ```
        
    - **소비자의 코드**
        
        ```c
        While(true) {
            
            P(mutex); // 진입 영역
            버퍼에서 데이터를 꺼냄 // 임계 영역
            V(mutex); // 해제 영역
            
            데이터를 소비
        }
        ```
        
- **버퍼가 가득 찬 경우 동기화: 세마포어 `empty`(초깃 값 n)**
    
    ![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/image2.png)
    
    - n
        - 버퍼 크기
    - **생산자의 코드**
        
        ```c
        While (true) {
            데이터를 생산
            P(empty); // 버퍼에 빈 공간이 있는지 확인
            P(mutex); // 버퍼 접근 권한 획득 (다른 프로세스 접근 금지)
            버퍼에 데이터를 넣음
            V(mutex);
        
        }
        ```
        
    - **소비자의 코드**
        
        ```c
        While(true) {
        
            P(mutex);
            버퍼에서 데이터를 꺼냄
            V(mutex);
            V(empty); // 빈 공간이 생겼음을 알림
            데이터를 소비
            
        }
        ```
        
- **버퍼가 빈 경우 동기화: 세마포어 `full`(초깃 값 0)**
    
    ![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/image3.png)
    
    - **생산자의 코드**
        
        ```c
        While (true) {
            데이터를 생산
            P(empty);
            P(mutex);
            버퍼에 데이터를 넣음
            V(mutex);
            V(full); // 버퍼에 데이터가 채워졌음을 알림
        }
        ```
        
    - **소비자의 코드**
        
        ```c
        While(true) {
            P(full); // 버퍼에 데이터가 있는지 확인
            P(mutex);
            버퍼에서 데이터를 꺼냄
            V(mutex);
            V(empty);
            데이터를 소비
        }
        ```
        
- **3개의 세마포어: `mutex`(초깃 값  1), `empty`(초깃 값  n), `full`(초깃 값  0)**
    
    ![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/image4.png)
    
    - `mutex`
        - 상호 배제를 위한 이진 세마포어 (초깃 값 1)
        - 버퍼 자체에 동시에 접근하는 것을 막음
    - `empty`
        - 비어있는 버퍼 슬롯의 개수를 나타내는 계수 세마포어 (초깃 값 n, n=버퍼 크기)
    - `full`
        - 채워진 버퍼 슬롯의 개수를 나타내는 계수 세마포어 (초깃 값 0)

## 판독기-기록기 문제

### 판독기-기록기 문제 정의

- 여러 협력 프로세스 사이에 공유 자원을 두고 판독기와 기록기의 상황을 다루는 문제
    
    ![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/d5c540ef-d8a6-4764-9ec7-29b367bf0a71.png)
    
    - **판독기(Reader)**
        - 데이터를 읽는 프로세스
    - **기록기(Writer)**
        - 데이터를 쓰는 프로세스

### 판독기-기록기 문제 조건

- 하나의 기록기가 공유 자원에 데이터를 쓰는 중에는 다른 기록기나 판독기는 공유 자원에 접근할 수 없음
    - 공유 자원에 데이터를 쓰는 동안에는 누구도 접근할 수 없음 (기록기 배타적 접근)
    - 공유 자원에서 데이터를 읽는 동안에는 데이터를 쓸 수 없음 (판독 중 기록 불가)
        - **상호 배제 필요**
- 여러 판독기는 동시에 공유 자원에서 데이터를 읽을 수 있음
    - 판독기가 읽는 중 새로운 판독기 읽기 시도 → **가능**
    - 판독기가 읽는 중 기록기 대기 → 새로운 판독기 읽기 시도 → 가능/불가능

### 제1 판독기 - 기록기 문제

- 판독기가 공유 자원에 접근 중이라면 기록기보다 판독기에 우선 순위를 줌
- 즉, 새로운 판독기는 즉시 공유 자원에 접근 가능
- 문제점
    - 기록기의 기아 상태 유발 가능

### 세마포어를 이용한 해결(판독기 우선)

- **상호 배제: 세마포어 `wrt` (초깃값 1)**
    
    ![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/57fcf19c-26e5-424e-824f-132aa999152b.png)
    
    - **기록기의 코드**
        
        ```c
        P(wrt);
        공유자원에 쓰기
        V(wrt);
        ```
        
    - **판독기의 코드**
        
        ```c
        P(wrt);
        공유자원에서 읽기
        V(wrt);
        ```
        
    - 문제점
        - 판독기 간 병행성 없음
        - 한 번에 하나의 판독기만 가능
- **판독기 우선 :** 일반 변수 `rcount`(초깃 값 0), 세마포어 `mutex`(초깃 값 1)
    
    ![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/a413d2e5-1b0d-46bd-8c0f-293537e1966d.png)
    
    ![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/48dd4060-e411-4105-964e-acf7f88ae86d.png)
    
    - 2개의 세마포어 `wrt`(초깃 값 1), `mutex`(초깃 값 1), 일반 변수 `rcount`(초깃 값 0)
        
        ```c
        P(wrt);
        // 공유 자원에 쓰기
        V(wrt);
        ```
        
    - **판독기의 코드**
        
        ```c
        P(mutex); // rcount 보호 임계 영역
        rcount = rcount + 1; // 읽으려는 판독기의 개수 표현
        if (rcount == 1) P(wrt); // 판독기가 이미 읽고 있는 상황이면 P연산자 바이패스 가능
        V(mutex);
        
        공유자원에서 읽기
        
        P(mutex); // rcount 보호 임계 영역
        rcount = rcount - 1;
        if (rcount == 0) V(wrt); // 마지막 판독기가 쓰기 허용
        V(mutex);
        ```
        
    - 문제점
        - 기록기 기아 상태 발생 가능
        - 판독기가 계속 들어오면 기록기 영원히 대기

### 제2 판독기 - 기록기 문제

- 판독기가 공유 자원에 접근 중이라면 판독기보다 기록기에 우선 순위를 줌
- 즉, 대기 중인 기록기가 있다면 새로운 판독기는 공유 자원에 접근 불가능
- 문제점
    - 판독기의 병행성이 떨어짐
    - 판독기의 기아 상태 유발 가능

### 세마포어를 이용한 해결(기록기 우선)

- 5개의 세마포어 `rd`(초깃 값 1), `wrt`(초깃 값 1), `mutex1`(초깃 값 1), `mutex2`(초깃 값 1), `mutex3`(초깃 값 1)
    
    ![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/b8e190ac-1e87-441b-aad0-eeadb77f2a99.png)
    
    - **기록기의 코드**
        
        ```c
        P(mutex2); // wcount 보호
        wcount = wcount + 1;
        if (wcount == 1) P(rd); // 첫 기록기가 판독 금지
        V(mutex2);
        
        P(wrt); // 쓰기 작업 자체 보호
        공유자원에 쓰기
        V(wrt);
        
        P(mutex2); // wcount 보호
        wcount = wcount - 1;
        if (wcount == 0) V(rd); // 마지막 기록기가 판독 허용
        V(mutex2);
        ```
        
    - **판독기의 코드**
        
        ```c
        P(mutex3); // 판독기 진입 경쟁 관리
        P(rd);     // 기록기가 없을 때만 진입 허용
        P(mutex1); // rcount 보호
        rcount = rcount + 1;
        if (rcount == 1) P(wrt); // 첫 판독기가 쓰기 금지
        V(mutex1);
        V(rd);
        V(mutex3);
        
        공유자원에서 읽기
        
        P(mutex1); // rcount 보호
        rcount = rcount - 1;
        if (rcount == 0) V(wrt); // 마지막 판독기가 쓰기 허용
        V(mutex1);
        ```
        

## 프로세스 간 통신

### 프로세스 간 통신 (IPC)

- Inter-Process Communication
- 병행 프로세스가 데이터를 서로 공유하는 방법
    - **공유 메모리 방법**
    - **메시지 전달 방법**
- 하나의 운영 체제에서 두 방법 함께 사용 가능

### 공유 메모리 방법

![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/image5.png)

- 협력 프로세스가 동일한 변수를 사용
    - 동일한 변수 : 공유 자원인 메모리 공간 사용
- ex)
    - 생산자-소비자 문제의 유한 버퍼
    - 판독기-기록기 문제의 공유 자원
- 대량 데이터 교환
    - 고속 통신 가능
- 통신 상 발생 가능 문제 해결
    - 응용 프로그래머

### 메시지 전달 방법

![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/image6.png)

- 협력 프로세스가 메세지를 주고 받음
    - 시스템 호출 `send()`, `receive()` 사용
- 소량 데이터 교환에 적합
    - 인자 값으로 데이터 전달
- 통신 상 발생 가능 문제 해결
    - 운영 체제

### 메세지 전달 방법의 논리적 구조

- 통신 링크
    
    ![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/image7.png)
    
    - 메시지가 지나다니는 통로
- 통신 링크의 구현 형태
    - 연결 대상
        - 두 프로세스, 셋 이상 프로세스
    - 두 프로세스 사이 링크 개수
        - 하나, 둘 이상
    - 방향성
        - 단방향 , 양방향
    - 용량
        - 무한, 유한, 0

### **통신 링크의 용량**

- 무한
    
    ![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/image8.png)
    
    - 송신자는 대기 없음
- 유한
    
    ![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/image9.png)
    
    - 송신자는 큐가 가득 차면 대기
- 0
    
    ![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/image10.png)
    
    - 송신자는 수신자가 메시지를 받을 수 있을 때까지 대기

### 직접 통신

- 두 프로세스가 직접 서로를 지정하여 메세지 전달
    
    ![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/image11.png)
    
    - 송수신 시 명시적으로 상대방 프로세스 지정
        - `send(B, message)`
            - 프로세스 B에게 메시지를 보냄
        - `receive(A, message)`
            - 프로세스 A로부터 메시지를 받음
    - 오직 하나의 통신 링크가 자동 설정
    - 하나의 통신 링크는 오직 두 프로세스 사이에만 연관
    - 통신 링크는  양방향
- **대칭형 주소 지정**
    
    ![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/image12.png)
    
- **비대칭 주소 지정**
    
    ![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/image13.png)
    
    - 수신자가 여러 송신자와 통신 링크를 갖는 경우 사용

### 간접 통신

- 프로세스 사이에 둔 우편함을 통해 메세지 전달
    
    ![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/image14.png)
    
    - `send(X, message)`
        - 우편함 X에 메시지를 보냄
    - `receive(X, message)`
        - 우편함 X에서 메시지를 받음
    - 같은 우편함을 이용하는 경우 통신 링크 설정
    - 여러 우편함을 이용하면 여러 개의 통신 링크 존재
    - 하나의 통신 링크가 여러 프로세스와 연관 가능
    - 통신 링크는 단방향 또는 양방향
- **우편함이 수신 프로세스에 소속**
    
    ![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/image15.png)
    
    - 수신자 하나
    - 통신 링크는 단방향
    - 수신 프로세스가 종료하면 우편함도 사라짐
- **우편함이 운영 체제에 소속**
    
    ![image.png](/assets/img/knou/os/2025-04-06-knou-os-5/image16.png)
    
    - 수신자 여럿
    - 한순간에 하나의 수신자만 가능
    - 운영 체제가 수신자 관리
    - 통신 링크는 양방향

<br/><br/>

# 정리 하기

---

- 생산자-소비자 문제는 상호 배제와 동기화가 필요한 문제로 세마포어를 이용하여 구현할 수 있음
- 판독기-기록기 문제는 기록기는 상호 배제가 필요하나 판독기는 상황에 따라 다른 처리가 필요한 문제로 세마포어를 이용하여 구현할 수 있음
- 판독기-기록기 문제는 특정 상황에서 판독기에 우선순위를 주는 형태의 문제와 기록기에 우선순위를 주는 형태의 문제로 정의할 수 있음
- 프로세스 간 통신 방법에는 공유 메모리 방법과 메시지 전달 방법이 있음
- 공유 메모리 방법은 협력 프로세스가 공유 메모리를 이용하는 동일한 변수를 사용함으로써 데이터를 서로 공유하는 방법임
- 메시지 전달 방법은 협력 프로세스가 메시지를 주고받으면서 데이터를 서로 공유하는 방법임
- 메시지 전달 방법에는 송신자와 수신자가 직접 서로를 지정하여 메시지를 주고받는 직접 통신 방법과 우편함을 통하여 메시지를 주고받는 간접 통신 방법이 있음