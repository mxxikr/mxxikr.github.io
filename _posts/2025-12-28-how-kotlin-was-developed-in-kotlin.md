---
title: Kotlin은 어떻게 Kotlin으로 개발되었는가?
author: {name: mxxikr, link: 'https://github.com/mxxikr'}
date: 2025-12-28 12:00:00 +0900
category: [Language, Kotlin]
tags: [kotlin, bootstrapping, compiler, self-hosting, jetbrains]
math: false
mermaid: false
---
# 개요

- 프로그래밍 언어의 컴파일러를 그 언어 자신으로 작성하는 과정을 부트스트래핑(Bootstrapping)이라고 함
- Kotlin은 처음에는 Java로 컴파일러를 개발했으나, 현재는 Kotlin으로 작성된 컴파일러가 자기 자신을 컴파일하는 자가 호스팅(Self-Hosting) 시스템을 완성함
- 이 과정은 언어의 실용성과 성숙도를 증명하는 중요한 지표임

<br/><br/>

## 부트스트래핑의 개념

### 닭과 달걀 문제

- 새로운 언어 X를 만들고 싶을 때 "X 컴파일러를 X로 작성"하면 순환 논리에 빠짐
- X 컴파일러를 실행하려면 X 컴파일러가 필요하고, X 컴파일러를 만들려면 X 언어가 필요한 모순
- 이 문제를 해결하는 주요 전략이 부트스트래핑임

### 부트스트래핑의 정의

- 다른 언어로 최소한의 컴파일러를 만든 후, 그것을 이용해 자신의 언어로 작성된 더 나은 컴파일러를 만드는 과정임
- "부츠의 끈을 잡고 자신을 들어올린다"는 뜻에서 유래한 용어로, 외부 도움 없이 자립하는 것을 의미함
- 언어가 자기 자신을 컴파일할 수 있다는 것은 복잡한 시스템을 구현할 수 있다는 신뢰성의 증거임

### 용어 정리

- **부트스트래핑**
  - 다른 언어로 시작해서 자신의 언어로 전환하는 전체 과정
- **자가 호스팅 (Self-Hosting)**
  - 자신의 언어로 작성된 컴파일러가 자신을 컴파일하는 상태

### 일반적인 부트스트래핑 과정

| Phase       | 무엇을 하는가                | 누가 하는가             | 결과                        |
| :---------- | :--------------------------- | :---------------------- | :-------------------------- |
| **Phase 1** | 언어 X를 다른 언어 Y로 구현  | Y를 사용하는 X의 개발자 | X가 작동 가능해짐 (Y 필요)  |
| **Phase 2** | X의 컴파일러를 X로 다시 작성 | X의 개발자              | X가 자기 자신을 컴파일 가능 |
| **Phase 3** | X로 더 나은 X 컴파일러 작성  | X 커뮤니티              | X는 계속 진화함 (Y 불필요)  |

- 한 번에 완성하는 것이 아니라 각 버전마다 조금씩 더 나아짐
- v1은 기본 기능만 제공하고, v2는 최적화를 추가하며, v3는 더 빠른 컴파일을 지원함
- v4는 더 똑똑한 에러 메시지를 제공하는 식으로 순환적으로 개선됨
- 이 과정은 진화론의 "작은 변화의 누적"과 유사한 패턴임

<br/><br/>

## Kotlin의 부트스트래핑 과정

![Kotlin 부트스트래핑 흐름](/assets/img/kotlin/bootstrapping_flow.png)

### Phase 1 - Java로 첫 컴파일러 만들기 (2010-2012)

- JetBrains 팀은 Kotlin이 없는 상태에서 Java를 사용하여 Kotlin 컴파일러의 첫 버전을 작성함
- Java 코드로 작성된 컴파일러 소스를 Java 컴파일러로 컴파일하여 실행 가능한 Kotlin 컴파일러를 생성함
- 이 컴파일러는 Kotlin 소스 코드를 입력받아 **JVM 바이트코드**(.class 파일)를 출력하는 최소한의 기능을 제공함
- Kotlin 컴파일러는 현재 다양한 타겟을 지원함
  - JVM
    - .class 파일 (바이트코드)
  - JavaScript
    - .js 파일
  - Native
    - 네이티브 바이너리 (LLVM 백엔드)
  - Wasm
    - WebAssembly 모듈 (실험적)

### Phase 2 - 첫 번째 자가 호스팅 (2015-2016, Kotlin 1.0 출시 전후)

- Kotlin 컴파일러의 소스 코드 자체를 Kotlin으로 다시 작성하는 작업을 진행함
- Java로 만든 원본 컴파일러로 Kotlin으로 작성된 컴파일러를 컴파일함
- 이후 반복적으로 자신을 컴파일하며 개선함
- 이 과정에서 만들어진 컴파일러가 Kotlin 1.x의 기본 컴파일러 (후에 K1으로 명명됨)

### Phase 3 - K2 컴파일러 프로젝트 (2022-2024)

- JetBrains 주도로 컴파일러를 아키텍처 수준에서 재설계함
- 기존 컴파일러를 K1으로, 새 컴파일러를 K2로 명명함
- 여전히 Kotlin으로 작성되었으며, Frontend와 Backend의 완전한 분리를 통한 성능 최적화를 목표로 함
- K2는 Kotlin 2.0에서 기본 컴파일러로 채택됨
- 구체적 개선 사항 ([Kotlin 2.0 Release Notes](https://kotlinlang.org/docs/whatsnew20.html) 기준)

  | 측정 항목               | K1 (기존) | K2 (신규) | 개선 폭       | 조건                     |
  | ----------------------- | --------- | --------- | ------------- | ------------------------ |
  | Clean Build             | 100초     | 70-75초   | 25-30% 빠름   | ~50만 라인 중형 프로젝트 |
  | 증분 빌드 (소규모 변경) | 10초      | 5-7초     | 30-50% 빠름   | 10개 파일 변경           |
  | 증분 빌드 (대규모 변경) | 40초      | 20-25초   | 최대 2배 빠름 | 100개 이상 파일 변경     |

  - IDE 실시간 코드 분석 속도 향상
  - 더 정확한 에러 위치 및 해결책 제안
  - 주의
    - 실제 개선 폭은 프로젝트 구조, 의존성 수, 인라인 함수 사용 등에 따라 크게 달라질 수 있음

<br/><br/>

## 다른 언어들의 부트스트래핑

### 부트스트래핑 역사

| 언어        | 초기 컴파일러     | 자가 호스팅 시점                                                 |
| :---------- | :---------------- | :--------------------------------------------------------------- |
| **Java**    | C (Sun, 1995)     | 초기에는 C로 작성, 현재 javac는 Java로 자가 호스팅 (JVM은 C/C++) |
| **GCC (C)** | 이전 버전의 GCC   | 3단계 부트스트래핑                                               |
| **Python**  | C (CPython, 주류) | PyPy는 Python으로 작성된 대안 구현체                             |
| **Kotlin**  | Java (2010-2012)  | 2015년경 (Kotlin 1.0 전)                                         |
| **Rust**    | OCaml (2010)      | 2011년 Rust로 재작성                                             |

### GCC의 3단계 부트스트래핑

- **Stage 1**
  - 시스템에 설치된 기존 GCC 버전 (또는 다른 C 컴파일러)으로 새 GCC 소스를 컴파일
- **Stage 2**
  - Stage 1 결과물(GCC)로 자신을 다시 컴파일
- **Stage 3**
  - Stage 2 결과물로 자신을 한 번 더 컴파일하여 Stage 2와 동일한지 **비교 검증**(bootstrap comparison)
- Stage 3의 목적은 최적화가 아니라 컴파일러의 정확성을 검증하는 것임

<br/><br/>

## Kotlin의 부트스트래핑

### 언어의 신뢰성 증명

- 자가 호스팅이 가능하다는 것은 그 언어가 실제 프로덕션 코드를 작성할 수 있다는 증명임
- Kotlin 컴파일러는 파서, 형 검사, 코드 생성 등 매우 복잡한 소프트웨어임
- 이를 Kotlin으로 작성할 수 있다는 것은 Kotlin이 엔터프라이즈급 애플리케이션에 적합하다는 증거임
- 부트스트랩되지 않은 언어는 학술적으로만 존재하는 경우가 많으며 안정성이 불확실함

### 개발 속도 향상

- 자가 호스팅 이전에는 컴파일러 개선을 위해 Java 코드를 수정하고 Java 컴파일러로 빌드해야 했음
- 자가 호스팅 이후에는 Kotlin 코드만으로 컴파일러를 개선할 수 있어 더 빠른 반복 개발이 가능함
- Kotlin 팀이 Kotlin 언어의 새로운 기능을 Kotlin으로만 작성하고 테스트할 수 있게 됨
- 개발자들이 Kotlin에 익숙하므로 컴파일러 코드베이스에 더 쉽게 기여할 수 있음

### 순환 개선

- K2 컴파일러가 좋은 예시로, Kotlin으로 Kotlin 컴파일러를 다시 작성하며 다음을 달성함
- 더 나은 에러 메시지를 추가하여 개발자 경험을 개선함
- IDE 지원(자동완성, 리팩토링)을 강화함
- 컴파일 속도를 향상시킴
- 모든 개선 사항이 Kotlin 코드로만 구현되므로 개발자들이 쉽게 이해하고 기여 가능함

### 부트스트래핑의 한계

- 자가 호스팅은 언어 설계의 복잡성을 컴파일러 개발자 스스로 감내해야 함
- 초기 단계에서 언어 스펙이 바뀔 때마다 컴파일러를 두 번씩 수정해야 하는 관리 비용이 발생함
- 부트스트랩 과정 중 컴파일러 버그가 컴파일러 자체를 빌드하지 못하게 만들 수 있어 신중한 관리가 필요함
- 이러한 복잡성에도 불구하고 장기적으로는 개발 생산성과 언어 신뢰성 측면에서 큰 이점을 제공함

### Kotlin이 얻은 장점

- Kotlin은 프로덕션 언어임
  - 자가 호스팅 컴파일러를 보유한 언어는 실제 업무를 하도록 설계되었음
- Java와 상호운용 가능
  - JVM 바이트코드를 생성하므로 Java와 상호운용이 가능함
  - Java 생태계(Spring, Hibernate 등)를 활용할 수 있음
- 계속 진화 중
  - K2 컴파일러 도입으로 Kotlin은 더 빠르고 안정적으로 발전할 예정임

### 부트스트래핑 여부와 언어의 성숙도

- 부트스트래핑은 언어의 성숙도를 보여주는 중요한 지표 중 하나이지만, 유일한 기준은 아님
- 부트스트랩된 언어 예시
  - Kotlin, Java, Go, C, Rust
- 부트스트랩되지 않았지만 프로덕션인 언어 예시
  - TypeScript (JavaScript로 작성)
  - Clojure (Java로 작성)

<br/><br/>

## 요약 정리

- 부트스트래핑은 "닭과 달걀 문제를 다른 동물에서 시작해서 해결하는 기술"임

  - 1단계
    - 다른 언어(Java)로 원하는 언어(Kotlin)의 컴파일러를 만듦
  - 2단계
    - 그 컴파일러로 원하는 언어로 작성된 더 나은 컴파일러를 만듦
  - 3단계
    - 반복하여 언어가 자립적으로 진화 가능해짐

- Kotlin의 부트스트래핑 흐름
  - 2010-2012
    - Java로 Kotlin 컴파일러 v1 개발
  - Java 컴파일러로 Kotlin 컴파일러 v1을 컴파일
  - 2015-2016
    - Kotlin 컴파일러 v1으로 Kotlin으로 작성된 v2를 컴파일
  - 이후
    - Kotlin 컴파일러가 자기 자신을 계속 개선 가능해짐

<br/><br/>

## Reference

- [Kotlin Official Website](https://kotlinlang.org/)
- [JetBrains Blog - Kotlin History](https://blog.jetbrains.com/kotlin/)
