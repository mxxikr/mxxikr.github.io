---
title: "[컴퓨터과학 개론] 12강 - 프로그래밍 언어"
author:
  name: mxxikr
  link: https://github.com/mxxikr
date: 2025-11-23 00:00:00 +0900
category:
  - [Computer Science, CS Theory]
tags:
  - [knou, cs]
math: true
mermaid: true
---

**<center>💡해당 게시글은 방송통신대학교 이관용, 정광식 교수님의 '컴퓨터과학 개론' 강의를 개인 공부 목적으로 메모하였습니다. </center>**

<br/><br/>

# 학습 개요

---

- 프로그래밍 언어의 구문과 구조, 부프로그램과 매개 변수 등에 대해서 이해함
- 변수와 기억 장소의 관계에 대해서 이해하며, 객체 지향 프로그램의 특성에 대해서 공부함

<br/><br/>

# 학습 목표

---

- 프로그래밍 언어의 기본적이고 공통적인 여러 요소들의 개념을 이해할 수 있음
- 함수의 매개 변수로 형식 매개 변수와 실 매개 변수의 관계, 그리고 값 호출과 참조 호출의 차이를 이해함
- 객체 지향 프로그램의 추상화와 캡슐화에 대해서 공부함

<br/><br/>

# 강의록

---

## 블록과 변수

### 블록과 변수의 유효 범위

- **개요**
    - **변수나 기타 식별자가 프로그램 코드의 유효 범위** 존재 여부를 결정하는 **유효 범위 결정 문제**는 프로그램의 실행과 깊은 관련을 가짐
    - 변수의 유효 범위 문제는 **변수에 대한 기억 장소의 할당 및 유지**에 대한 문제임
    - 블록들은 중첩되는 구조도 가질 수 있어서 **블록 안에 다른 블록이 들어가 있을 수 있음**
    - **전역 변수**(global variable)는 프로그램 코드의 모든 영역에서 기억 장소의 할당이 유효하며 **지역 변수**(local variable)는 그 변수가 정의된 블록 안에서만 기억 장소의 할당이 유효함
    - 특정 블록에서 변수가 선언되면, 블록에서 사용될 지역 변수에 대한 기억 장소의 할당이 이루어지고 종료되면 해당 지역 변수는 기억 장소에서 삭제됨
- **예**
    
    ![image.png](/assets/img/knou/cs/2025-11-23-knou-cs-12/image.png)
    
    - 수행 결과 및 출력
        - [블록 2: 변수 y]의 값: 2
        - [블록 1: 변수 gx]의 값: 10
        - [블록 2: 변수로 재 정의 된 gx]의 값: 20
        - [블록 1: 변수 gx]의 원래 값: 10
- **변수의 유효 범위 문제**
    - 여러 단계로 중첩된 블록들 사이에서 특정 블록에 정의되지 않은 변수의 접근 유효성의 결정 문제
    - **블록 사이에서의 변수의 유효 범위를 결정하는 기준**이 필요함
- **정적 유효 범위 규칙**
    - 변수의 유효 범위 결정은 컴파일이 이루어지는 시기에 코드에서 가장 가까이 정의된 것으로 유효 범위가 결정됨
- **동적 유효 범위 규칙**
    - 코드의 실제 실행 환경에 따라 변수의 유효 범위가 결정됨
- **유효 범위**
    - 같은 이름의 변수가 프로그램의 여러 곳에서 정의되어 사용될 때, 어디서 정의된 어떤 변수의 값을 참조하고 접근할 것인가는 유효 범위 규칙에 따라 결정됨
- **고급 언어들**
    - 대부분 여러 개의 명령문이 모여 **하나의 명령문을 만드는 복합문** 및 **여러 개의 명령문이 모여 있는 블록**을 프로그래밍 언어 내에서 구현함
    - 블록을 기초로 **변수의 유효 범위**를 결정함
        
        ![image.png](/assets/img/knou/cs/2025-11-23-knou-cs-12/image1.png)
        

## 함수의 기념

### 부프로그램: 함수와 프로시저

- **개요**
    - 반복 사용되는 코드 부분을 하나의 단위로 묶어서, 이에 대해 고유의 이름을 정의하고 그 이름을 일반 명령처럼 사용할 수 있도록 만든 것을 부프로그램이라 함
    - **부프로그램은 함수와 프로시저로 구분됨**
    - 함수와 프로시저는 기능적으로 유사함
        - **함수**
            - **함수의 코드 부분의 실행 결과 값을 돌려줌(return)**
        - **프로시저**
            - **실행 결과 값을 돌려주지 않음**
    - C언어나 C++언어 같은 프로그래밍 언어에서는 함수와 프로시저의 구분이 모두 함수로 취급됨
- **함수는 기본적으로 다음과 같은 요구 조건을 가짐**
    - 제어의 시작이 되는 **제어 진입점**이 한 곳으로 한정됨
    - 함수의 호출이 발생되면, 함수를 호출한 프로그램의 수행이 일시 중단되고 **호출된 함수로 실행 제어가 이전**됨
    - 호출된 함수(피호출 함수)의 실행 중에 함수 종료 조건이 만족되면 **실행 제어가 호출한 함수나 호출한 프로그램으로 돌아감**

### 함수 호출과 제어의 이동

- **함수의 호출**
    
    ![image.png](/assets/img/knou/cs/2025-11-23-knou-cs-12/image2.png)
    
    - 호출 함수는 '1번 구역'의 명령들을 수행하다가 '2번 구역'에서 피호출 함수를 호출함
    - 피호출 함수의 '함수 호출'이 실행되는 순간, 호출 함수는 실행을 멈추고, 실행 제어는 피호출 함수의 첫 줄인 '함수 시작(3번 구역)'으로 이동되어 '4번 구역'의 명령들이 수행됨
    - 피호출 함수의 실행 중에 '5번 구역'의 **반환(return) 조건이 만족 되면 피호출 함수의 실행이 멈춰지고 호출 함수로 실행 제어가 되돌아감**
    - 실행 제어가 호출 함수로 돌아오고 나면, 호출 함수의 '함수 호출' 명령의 다음 명령 ('6번 구역')부터 수행됨
    - **함수의 제어 진입점은 항상 첫 줄이지만 제어 종료(반환(return))는 여러 조건에 따라 여러 곳에서 이루어질 수 있음**

### 함수의 매개 변수

- **매개 변수**
    - **호출하는 프로그램(호출 함수)과 호출되는 함수(피호출 함수)는 서로 주고 받을 정보**가 필요함
    - 호출하는 프로그램은 피호출 함수의 실행 대상이 되는 데이터를 알려줄 수 있는 매개 변수가 있어야 함
    - **매개 변수**(parameter)
        - 호출하는 프로그램과 호출되는 함수 사이에서 주고받는 데이터임
    - 함수를 호출하는 프로그램은 **호출 될 함수 이름만을 지정하기도 하지만**, 일반적인 경우에는 피호출 함수에 여러 가지 다른 조건이나 데이터를 전달하고, 이에 따라 피호출 함수가 다양한 기능을 수행할 수 있도록 함
    - 피호출 함수에서 처리 될 값을 전달하는 매개 변수 역할을 하고, 매개 변수는 특정 데이터 형을 가짐
    - 피호출 함수의 정의에 사용된 매개 변수(`x`)를 **형식 매개 변수**(formal parameter)라고 함
        
        ```c
        int f (int x) {
            return x + 2;
        }
        ```
        
    - 호출 프로그램에서 피호출 함수를 호출하기 위해 사용 된 매개 변수(`val`)를 **실 매개 변수**(actual parameter)라고 함
        
        ```c
        int val; // 변수 val 선언
        int func_val; // 변수 func_val 선언
        val = 10; // 변수 val 초기화
        func_val = f (val); // 함수 f(x) 호출
        ```
        
        - `val`이 실 매개 변수이고 그에 상응하는 형식 매개 변수가 `int f(int x)`에서의 `x`임
        - 결과 값은 12이고, 그 값이 대입 문을 통해 `func_val` 변수에 저장 됨

### 반환 값

- 피호출 함수의 실행 결과를 돌려주는 **반환 값도 특정 데이터 형을 가짐**
- C언어와 유사한 의사 코드로 함수를 표현하면 다음과 같은 기본 형태를 가질 수 있음
    
    ```c
    int f (int x) {
        return x + 2;
    }
    ```
    

### 함수의 매개 변수 전달 방식

- **호출 방식**
    - 호출하는 프로그램과 호출되는 함수 사이의 매개 변수를 전달하는 방식에 따라 **값 호출 방식**과 **참조 호출 방식**으로 나뉨
        
        ```c
        void swap(int x, int y) { // x와 y의 값을 교환하는 함수
            int tmp; // swap 함수 내에서만 접근 가능한 지역 변수 tmp 선언
            tmp = x; // 매개 변수 x값을 지역 변수 tmp에 저장
            x = y;   // 매개 변수 x에 매개 변수 y의 값을 대입
            y = tmp; // 매개 변수 y에 지역 변수 tmp의 값을 대입
        }
        ```
        

### 값 호출 방식

- **개요**
    - `swap(x, y)`를 정의하고, 프로그램에서 `swap` 함수를 호출함
        
        ```c
        int a = 2;
        int b = 3;
        swap(a, b);
        ```
        
        ```c
        void swap(int x, int y) { // x와 y의 값을 교환하는 함수
            int tmp; // swap 함수 내에서만 접근 가능한 지역 변수 tmp 선언
            tmp = x; // 매개 변수 x값을 지역 변수 tmp에 저장
            x = y;   // 매개 변수 x에 매개 변수 y의 값을 대입
            y = tmp; // 매개 변수 y에 지역 변수 tmp의 값을 대입
        }
        ```
        
    - 프로그램에서는 a와 b 변수가 각각 2와 3으로 저장되었고, `swap(x, y)` 함수를 `swap(2, 3)`으로 호출함
    - C 언어로 컴파일해서 수행하면 함수 호출 후, 프로그램에서 `a`와 `b`를 출력하면 `swap` 함수의 실행에도 불구하고 변수 `a`와 변수 `b` 값의 교환이 이루어지지 않음
    - 교환이 이루어지지 않은 이유는 C 언어에서 함수 호출의 실 매개 변수를 전달할 때 매개 변수 주소를 전달하는 것이 아니고 **실 매개 변수의 값만을 형식 매개 변수에 복사하는 방식**을 취하기 때문임
        - 값만 보내는 것과 같음
    - `swap(2, 3)`을 보내게 되는 것과 같다고 할 수 있음
    - `swap` 함수의 `x`, `y` 매개 변수는 `a`와 `b`는 전혀 신경을 쓰지 않고 받은 값 2와 3만을 가지고 실행을 하게 됨
    - **`swap(x,y)` 함수 안에서 변수 `a`와 변수 `b`의 교환은 복사 된 형식 매개 변수의 값들 간에 교환이 이루어졌기 때문**에, 프로그램 안에서의 실 매개 변수의 값에는 아무런 영향을 주지 않음
    - 이런 방식을 **값 호출(call-by-value) 방식**이라고 함
    
    ![image.png](/assets/img/knou/cs/2025-11-23-knou-cs-12/image3.png)
    
    ![image.png](/assets/img/knou/cs/2025-11-23-knou-cs-12/image4.png)
    

### 참조 호출 방식

- **개요**
    - 실 매개 변수가 형식 매개 변수 자리를 취해서 함수 안에서 형식 매개 변수에 행해진 모든 조작이 그 그대로 실 매개 변수에 반영되는 방식을 **참조 호출(call-by-reference) 방식**이라고 함
    - C 언어에서 함수의 실행 결과를 실 매개 변수에 반영하기 위해서는 실 매개 변수의 주소를 호출 함수의 매개 변수로 전달함
    
    ```c
    void swap(int* x, int* y) { // 매개 변수의 포인터 값(주소)을 매개 변수로 전달받음
        int* tmp; // 함수 내에서만 접근 가능한 지역 포인터 변수 tmp 선언
        tmp = *x; // 매개 변수 x값을 지역 변수 tmp에 저장
        *x = *y;  // y값을 x에 대입
        *y = *tmp; // tmp값을 y에 대입
    }
    ```
    
    - 앞에서 `*`연산자가 두 가지 다른 용도로 사용됨
    - 매개 변수와 `tmp` 정의 시에는 정수 포인터 타입(`int*`)임을 명시함
    - 마지막 두 줄에서는 변수 `x`의 주소가 가리키는 위치에 담긴 내용을 지정하는 용도로 쓰임
    - 함수를 호출할 때는
        
        ```c
        int a = 2;
        int b = 3;
        swap(&a, &b);
        ```
        
    - `&`연산자를 사용해서 `a`와 `b`의 주소를 계산한 후 그 주소 값을 함수 호출에 사용함
    - `swap` 함수의 결과가 실 매개 변수에 반영되어, `a = 3, b = 2`로 원하는 결과를 얻을 수 있음
    
    ![image.png](/assets/img/knou/cs/2025-11-23-knou-cs-12/image5.png)
    
    ![image.png](/assets/img/knou/cs/2025-11-23-knou-cs-12/image6.png)
    

## 변수의 수명

### 변수의 수명

- **개요**
    - **변수의 수명**이란 **변수가 값을 저장하기 위해 기억 장소를 할당 받고 있는 시간**을 의미함
    - 변수의 수명은 **그 변수 이름으로 기억 장소의 할당되면서부터 할당된 기억 장소 해제될 때까지의 시간**임
    - 변수의 속성으로 **자동 할당, 정적 할당, 프로그래머 지정 할당** 등을 이용하여 기억 장소가 할당될 수 있음

### 자동 할당 방식

- **개념**
    - C 언어에서 주로 사용되는 변수를 선언하는 방법임
    - **자동 할당 방식에서 변수의 수명은 그 변수가 포함된 블록의 범위와 같음**
    - 한 변수가 선언된 블록이 시작할 때, 변수는 기억 장소를 할당 받고 블록이 끝나면 변수의 기억 장소는 자동적으로 회수 됨

### 정적 할당 방식

- **개념**
    - 프로그램이 시작될 때, 기억 장소가 할당되며 블록이 끝나더라도 기억 장소는 그대로 유지되고 프로그램 종료 시 회수 됨

### 프로그래머 지정 할당 방식

- **개념**
    - 프로그램의 실행 도중에 프로그래머가 기억 장소를 요청하여 할당 받고, 프로그래머가 직접 할당 받은 기억 장소를 해제하여 운영 체제에게 기억 장소를 회수 시킬 때까지 기억 장소가 유지됨

## 객체 지향 프로그램을 위한 추상 자료형

### 추상화

- **개요**
    - **프로그래밍 언어에서 추상화라는 개념은 필수적인 속성만을 가지고 주어진 것을 묘사함으로써 나머지 부수적이거나 불필요한 속성들은 숨겨지거나 삭제**됨
    - 공통의 유사성을 표현하고 차이점을 삭제함으로써 동일한 부류의 객체들을 하나로 묶어서 표현하는 방법임

### 프로시저의 추상화

- **개요**
    - 프로시저의 추상화는 **수행 방법을 기술하지 않고 무엇이 수행 되는 가를 묘사함으로써 추상화 시켜 주는 실행 과정의 추상화 기법**임
    - 프로시저 `sort_int(list, list_len)`을 이용하여 정수 배열의 정렬 작업을 수행했다면, 호출문은 정렬 작업에 대한 구체적 알고리즘의 명세 없이 정렬 작업을 추상화하여 수행한 것임
    - 프로시저 `sort_int`의 필수적인 속성은 **정렬할 배열 이름, 배열 원소의 자료형, 배열의 크기**이며, 필수적인 부분만을 프로그래머에게 제공하며 프로그래머는 실제로 부프로그램 `sort_int`의 내부 구현 방법이나 알고리즘에 대해서는 몰라도 됨
    - 부차적인 속성(구현 소스 코드, 알고리즘)은 구현된 정렬 알고리즘으로서 프로그래머의 입장에서 중요하지 않음

### 자료의 캡슐화

- **개요**
    - 자료 추상화 또는 자료 캡슐화 개념은 프로그램의 재사용을 위해 다양한 이름으로 여러 프로그래밍 언어에 구현되어 있음
    - 캡슐화는 프로그래머에게 추상 자료형의 정의된 이름을 통해 객체를 호출하여 사용하도록 하는 윈도우(window)를 제공함
    - 윈도우를 통해서 객체의 호출을 외부에 알려주는 부분을 **공용부(public part)** 또는 **가시부(visible part)**라 부르고, 캡슐화를 통해 보호되는 구현 부분을 **전용부(private part)**라 부름

## 정리 하기

- **변수의 유효 범위**
    - 변수나 기타 식별자가 코드의 어떤 범위에서 유효한가는 유효 범위 결정 문제
- **함수의 매개 변수**
    - **매개 변수**
        - 호출하는 프로그램과 호출되는 함수 사이에서 주고받는 데이터
    - **형식 매개 변수**
        - 호출되는 함수의 정의에 사용된 매개 변수
    - **실 매개 변수**
        - 호출하는 프로그램에서 함수를 호출하기 위해 사용된 매개 변수
- **변수의 수명**
    - 변수 값을 저장하기 위해 기억 장소를 할당 받고 있는 시간
- **객체 지향 프로그램을 위한 추상 자료형**
    - 자료와 그 자료를 처리할 연산을 함께 선언할 수 있어야 하며 선언은 구현에 의존적이어서는 안 되며 연산의 선언에는 의미에 대한 명세가 포함되어야 함

<br/><br/>

# 연습 문제

---

1. C언어에서 int x = 10 + “hello”; 의 명령이 주어졌을 때 어떤 오류나 경고가 뜨는가? 
    
    a. 형 (type) 경고 
    
    - 변수 형은 연산에 사용되는 상수(constant)나 변수(variable)의 종류를 지정해서 연산 수행 시에 호환성이 없는 변수 형 간의 연산을 막아서 연산의 결과로 얻게 되는 정보의 손실을 최소화하기 위해 사용됨
    - 정수를 문자열로 나눈다거나 복잡한 구조체(struct) 타입으로 곱하는 것은 연산의 의미가 없음
    - 정수와 실수의 덧셈에서 정수 형으로 연산을 수행하면 실수 값의 일부분을 잃게 됨
    - 변수 형이 호환되지 않는 연산을 찾아내는 것을 형 검사(type checking)라고 함
    - 형 검사는 컴파일 과정에서 이루어지는 정적(static) 형 검사 방식과 프로그램의 실행(run-time) 중에 이루어지는 동적(dynamic) 형 검사 방식이 있음
2. 다음 중 프로그램에 관한 사고를 간소화하기 위한 방법이 아닌 것은? 
    
    a. 암호화
    
    - 추상화라는 개념은 필수적인 속성만을 가지고 주어진 것을 묘사함으로써 나머지 부수적이거나 불필요한 속성들은 숨겨지거나 삭제됨
    - 즉, 공통의 유사성을 표현하고 차이점을 삭제함으로써 동일한 부류의 객체들을 하나로 묶어서 표현하는 방법임
    - 프로그래밍 언어에서의 자료 추상화란 자료형의 표현과 그에 관련된 연산들을 함께 묶어 캡슐화(encapsulation)하는 기법임
    - 이런 캡슐화는 부적당한 사용으로부터 자료형을 보호하기 위한 기법임
    - 캡슐화는 프로그래머에게 추상 자료형의 정의된 이름을 통해 객체를 호출하여 사용하도록 하는 윈도우(window)를 제공함
    - 윈도우를 통해서 객체의 호출을 외부에 알려주는 부분을 공용부(public part) 또는 가시부(visible part)라 부르고, 캡슐화를 통해 보호되는 구현 부분을 전용부(private part)라 부름
    - 프로그램에 관한 사고를 간소화하기 위한 방법
        - 추상화
        - 코드 숨기기
        - 캡슐화
3. 프로그래머에게 추상 자료형의 정의된 이름을 통해 객체를 호출하여 사용하도록 하는 윈도우(window)를 제공하는 것은 ? 
    
    a. 캡슐화 
    
    - 추상 자료형이란 객체들의 집합과 이들 객체들에 적용되는 연산들의 집합을 말함
    - 프로그래밍 언어에서의 자료 추상화란 자료형의 표현과 그에 관련된 연산들을 함께 묶어 캡슐화(encapsulation)하는 기법임
    - 캡슐화는 프로그래머에게 추상 자료형의 정의 된 이름을 통해 객체를 호출하여 사용하도록 하는 윈도우(window)를 제공함
    - 윈도우를 통해서 객체의 호출을 외부에 알려주는 부분을 공용부(public part) 또는 가시부(visible part)라 부르고, 캡슐화를 통해 보호되는 구현 부분을 전용부(private part)라 부름
    - 예를 들면 자동차를 구성하고 있는 모든 부품들의 기능을 알지 못하더라도 운전자는 운전을 할 수 있음
    - 엑셀을 밟으면 앞으로 전진하고, 브레이크를 밟으면 차가 멈춘다는 사실은 알고 있음
    - 하지만, 시동을 걸고 엑셀을 밟는 과정에서 엔진의 기능의 상세하게 아는 사람은 많지 않을 것임
    - 꼭 운전자가 알고 있어야 하는 기본적인 기능들은 공용부에 해당한다고 할 수 있고, 운전자가 몰라도 되는 엔진의 기능과 같은 상세하고 전문적인 기능들은 전용부라고 생각할 수 있음

<br/><br/>

# 정리 하기

---

- 변수의 유효 범위
    - 변수나 기타 식별자가 코드의 어떤 범위에서 유효한지 결정하는 문제
        - 변수에 대한 저장 장치의 할당이 유지 되는가에 대한 문제
- 함수의 매개 변수
    - 매개 변수(parameter)
        - 호출하는 프로그램과 함수 사이에서 주고받는 데이터
    - 형식 매개 변수
        - 함수 정의에 사용된 매개 변수
    - 실 매개 변수
        - 함수를 호출할 때 실제로 사용하는 값
- 변수의 수명
    - 변수가 값을 저장하기 위해 기억 장소를 할당 받고 있는 시간
- 객체 지향 프로그램을 위한 추상 자료형
    - 자료와 그 자료를 처리할 연산을 함께 선언할 수 있어야 하며 선언은 구현에 의존하면 안 되며 연산의 선언에는 의미에 대한 명세가 포함되어야 함
    - 정보 은닉(information hiding) 개념을 도입하여 프로그램을 쉽게 읽을 수 있어야 하고 유지 보수를 용이하게 해야 함
- 디스크 스케줄링 기법
    - FCFS(First-Come First Served) 스케줄링 기법
        - 먼저 도착한 디스크 접근 요청이 가장 먼저 서비스를 받는 방법
    - SSTF(Shortest Seek Time First) 스케줄링 기법
        - 현재 디스크 헤드의 위치에서 가장 짧은 트랙 탐색 거리(또는 탐색 시간)를 가진 디스크 접근 요청을 먼저 처리하는 방식
    - SCAN 스케줄링 기법
        - 한쪽 방향에서 가장 짧은 탐색 거리의 디스크 접근 요청을 먼저 서비스하는 방식
    - SLTF(Shortest Latency Time First) 스케줄링 기법
        - 디스크 헤드가 특정 실린더에 도착하면 그 실린더 내의 모든 요구를 검사한 후 가장 짧은 회전 지연을 갖는 요구들에게 우선적으로 서비스하는 방식
- 파일 구조
    - 파일을 구성하는 레코드들이 보조 기억 장치에서의 배치 방법
- 디스크 공간 할당 방식
    - 연속 할당(contiguous allocation)
        - 파일이 보조 기억 장치에 저장될 때 연속 된 물리적 공간을 할당 받는 기법
    - 불연속 할당(noncontiguous allocation)
        - 파일을 작은 단위로 나누고 보조 기억 장치의 불연속적인 공간을 나누어 할당 받는 기법