---
title: "LVM (Logical Volume Manager)"
author:
  name: mxxikr
  link: https://github.com/mxxikr
date: 2022-11-01 03:55:00 +0900
category:
  - [OS, Linux]
tags:
  - [os, linux, disk, partition, lvm, storage, devops]
math: true
mermaid: true
---

<br/><br/>

## LVM 개요


### LVM이란

- **Logical Volume Manager의 약자**
- 물리적 디스크를 논리적 볼륨으로 추상화하여 관리하는 스토리지 관리 솔루션
- DevOps 엔지니어에게 가장 강력한 스토리지 관리 도구
- 런타임 중 무중단 디스크 용량 증설 가능


### LVM의 장점

- **유연한 용량 관리**
  - 서비스 중단 없이 온라인 확장 가능
  - 여러 디스크를 하나로 통합하거나 분할 자유롭게 조정

- **스냅샷 기능**
  - 특정 시점의 데이터 상태 저장
  - 빠른 백업 및 복구

- **고급 RAID 기능**
  - Striping으로 성능 향상
  - Mirroring으로 안정성 향상

- **확장성**
  - 나중에 디스크 추가 시 기존 VG에 쉽게 확장
  - 다운타임 최소화


<br/><br/>

## LVM 아키텍처


### 3계층 구조

![mermaid-diagram](/assets/img/linux/2022-11-01-lvm-diagram-1.png)

![image](/assets/img/linux/lvm-3layer.png)


### 구성 요소 관계

![image](/assets/img/linux/lvm-component-flow.png)


### 핵심 구성 요소

| 계층 | 명칭 | 명령어 접두사 | 설명 | 예시 |
|------|------|---------------|------|------|
| **물리 레벨** | PV (Physical Volume) | `pv...` | 실제 디스크 또는 파티션 | `/dev/sda6`, `/dev/sdb1` |
| **추상화 레벨** | VG (Volume Group) | `vg...` | 여러 PV를 합친 스토리지 풀 | `vol_grp1` (3.72GB) |
| **논리 레벨** | LV (Logical Volume) | `lv...` | VG에서 할당받은 가상 파티션 | `/dev/vol_grp1/logical_vol1` |


### Physical Extent (PE)

- LVM의 최소 할당 단위
- 기본 크기: 4MB
- 모든 데이터는 PE 단위로 관리


#### PE 개념

- **PV 구성**
  - 하나의 PV는 여러 개의 PE로 구성
  - 예시: 1.86GB PV = 약 465개 PE (1.86GB ÷ 4MB)

- **LV 할당**
  - LV는 VG로부터 필요한 PE를 할당받음
  - 예시: 80MB LV = 20개 PE (80MB ÷ 4MB)

- **Logical Extent (LE)**
  - LV의 최소 단위
  - PE와 1:1 매핑


<br/><br/>

## LVM 설정 단계


### 전체 워크플로우

![image](/assets/img/linux/lvm-setup-workflow.png)


<br/><br/>

## PV (Physical Volume) 관리


### PV 생성

- 파티션을 LVM에서 사용할 수 있도록 초기화

```bash
# 단일 PV 생성
sudo pvcreate /dev/sda6

# 여러 PV 한 번에 생성
sudo pvcreate /dev/sda6 /dev/sda7 /dev/sdb1
```


### PV 확인

```bash
# 간단한 목록
sudo pvs

# 상세 정보
sudo pvdisplay

# 특정 PV 상세 정보
sudo pvdisplay /dev/sda6

# PV 스캔
sudo pvscan
```


### PV 정보 해석

- **pvdisplay 출력 예시**
  ```
  --- Physical volume ---
  PV Name               /dev/sda6
  VG Name               vol_grp1
  PV Size               1.86 GiB
  Allocatable           yes
  PE Size               4.00 MiB
  Total PE              476
  Free PE               256
  Allocated PE          220
  PV UUID               abc123-def456...
  ```

- **주요 필드**
  - PV Name: 물리 볼륨 장치 경로
  - VG Name: 소속된 볼륨 그룹
  - Total PE: 전체 PE 개수
  - Free PE: 미할당 PE 개수
  - Allocated PE: 할당된 PE 개수


<br/><br/>

## VG (Volume Group) 관리


### VG 생성

- 여러 PV를 하나의 스토리지 풀로 통합

```bash
# 단일 PV로 VG 생성
sudo vgcreate vol_grp1 /dev/sda6

# 여러 PV로 VG 생성
sudo vgcreate vol_grp1 /dev/sda6 /dev/sda7
```


### VG 확장

- 기존 VG에 새 PV 추가

```bash
# 새 디스크 추가
sudo pvcreate /dev/sdb1

# VG에 PV 추가
sudo vgextend vol_grp1 /dev/sdb1

# 확인
sudo vgs
```


### VG 축소

- VG에서 PV 제거

```bash
# 사용 중이지 않은 PV 제거
sudo vgreduce vol_grp1 /dev/sdb1

# 손상된 PV 강제 제거
sudo vgreduce --removemissing vol_grp1
```


### VG 확인

```bash
# 간단한 목록
sudo vgs

# 상세 정보
sudo vgdisplay

# VG와 PV, LV 모두 표시
sudo vgdisplay -v vol_grp1

# VG 스캔
sudo vgscan
```


### VG 속성 변경

```bash
# VG 활성화/비활성화
sudo vgchange -a y vol_grp1  # 활성화
sudo vgchange -a n vol_grp1  # 비활성화

# 최대 LV 개수 제한 설정
sudo vgchange -l 100 vol_grp1

# VG 제거
sudo vgremove vol_grp1
```


<br/><br/>

## LV (Logical Volume) 관리


### LV 생성

- VG에서 필요한 용량만큼 LV 할당


#### 크기 지정 방법

```bash
# 방법 1: 절대 크기 지정 (-L, 대문자)
sudo lvcreate -L 80M -n logical_vol1 vol_grp1
sudo lvcreate -L 1G -n data_lv vol_grp1
sudo lvcreate -L 500M -n logs_lv vol_grp1

# 방법 2: PE 개수 지정 (-l, 소문자)
sudo lvcreate -l 20 -n logical_vol1 vol_grp1
# 20 PE = 80MB (PE가 4MB인 경우)

# 방법 3: VG 전체 용량 사용
sudo lvcreate -l 100%FREE -n full_lv vol_grp1

# 방법 4: VG의 퍼센트 지정
sudo lvcreate -l 50%FREE -n half_lv vol_grp1
```


### LV 확인

```bash
# 간단한 목록
sudo lvs

# 상세 정보
sudo lvdisplay

# 특정 LV 상세 정보
sudo lvdisplay /dev/vol_grp1/logical_vol1

# 매핑 정보 포함
sudo lvdisplay -m /dev/vol_grp1/logical_vol1

# LV 스캔
sudo lvscan
sudo lvscan -v  # 상세 정보
```


<br/><br/>

## LV 확장 및 축소


### 온라인 확장 (추천)

- **LVM의 가장 강력한 기능**
- 서비스 중단 없이 용량 증설 가능

```bash
# 1. VG에 여유 공간 확인
sudo vgs

# 2. 여유 공간 없으면 새 PV 추가
sudo pvcreate /dev/sdb1
sudo vgextend vol_grp1 /dev/sdb1

# 3. LV 크기 증가
sudo lvextend -L +500M /dev/vol_grp1/logical_vol1
# 또는 전체 여유 공간 사용
sudo lvextend -l +100%FREE /dev/vol_grp1/logical_vol1

# 4. 파일 시스템 크기 조정 (중요!)
# ext4의 경우
sudo resize2fs /dev/vol_grp1/logical_vol1

# XFS의 경우
sudo xfs_growfs /dev/vol_grp1/logical_vol1

# 5. 확인
df -h | grep logical_vol1
```


### 주의사항

- **LV 확장 후 반드시 파일 시스템 리사이징 필요**
  - `resize2fs` (ext2/ext3/ext4)
  - `xfs_growfs` (XFS)
  - 파일 시스템 크기를 조정하지 않으면 새 공간 사용 불가


### LV 축소 (위험)

- **데이터 손실 위험 있음**
- 백업 필수
- 마운트 해제 상태에서 작업

> **중요 경고**: 
> 1. **순서 준수**: 반드시 `파일 시스템 축소` -> `LV 축소` 순서를 지켜야 합니다. 반대로 하면 데이터가 손실됩니다.
> 2. **XFS 불가**: **XFS 파일 시스템은 축소(Shrink)를 지원하지 않습니다.** 실수로 크게 잡으면 데이터를 백업하고 재생성해야 합니다.

```bash
# 1. 마운트 해제
sudo umount /mnt/data

# 2. 파일 시스템 검사 (필수)
sudo fsck -f /dev/vol_grp1/logical_vol1

# 3. 파일 시스템 축소 (가장 먼저 실행!)
sudo resize2fs /dev/vol_grp1/logical_vol1 500M

# 4. LV 축소
sudo lvreduce -L 500M /dev/vol_grp1/logical_vol1

# 5. 확인 및 재마운트
sudo lvdisplay /dev/vol_grp1/logical_vol1
sudo mount /dev/vol_grp1/logical_vol1 /mnt/data
```


### LV 리사이즈

```bash
# 절대 크기로 조정
sudo lvresize -L 1G /dev/vol_grp1/logical_vol1

# 상대 크기로 조정
sudo lvresize -L +200M /dev/vol_grp1/logical_vol1
sudo lvresize -L -100M /dev/vol_grp1/logical_vol1

# 파일 시스템도 함께 조정 (편리, ext만 가능)
sudo lvresize -L 1G -r /dev/vol_grp1/logical_vol1
```


### LV 제거

```bash
# 1. 마운트 해제
sudo umount /mnt/data

# 2. /etc/fstab에서 항목 제거 (영구 마운트 설정한 경우)
sudo vi /etc/fstab

# 3. LV 제거
sudo lvremove /dev/vol_grp1/logical_vol1

# 확인 필요 메시지 표시
# 강제 제거 (주의!)
sudo lvremove -f /dev/vol_grp1/logical_vol1
```


<br/><br/>

## LVM 스냅샷 (Snapshot)


### 스냅샷 개념

- 특정 시점의 LV 상태를 '얼려서' 저장
- **CoW (Copy-on-Write) 방식 사용**
  - 스냅샷 생성 시점부터 원본 변경 시 해당 블록만 스냅샷에 복사
  - 매우 빠르고 공간 효율적
  - **주의**: 스냅샷 공간이 가득 차면 스냅샷은 **Invalid(무효)** 상태가 되어 사용할 수 없습니다.
  - **성능**: 원본 볼륨에 쓰기 발생 시 복사 작업(CoW)으로 인해 **쓰기 성능이 약간 저하**될 수 있습니다.


### 스냅샷 동작 방식

![image](/assets/img/linux/lvm-snapshot-cow.png)


### 스냅샷 생성

```bash
# 5GB 크기의 스냅샷 생성
sudo lvcreate -L 5G -s -n lv_snapshot /dev/vol_grp1/logical_vol1

# 옵션 설명
# -L 5G: 스냅샷 크기 (원본 변경량만큼만 필요)
# -s: 스냅샷 생성
# -n lv_snapshot: 스냅샷 이름

# 원본 크기의 20%로 스냅샷 생성
sudo lvcreate -l 20%ORIGIN -s -n lv_snapshot /dev/vol_grp1/logical_vol1
```


### 스냅샷 사용

```bash
# 1. 스냅샷 마운트 (읽기 전용 권장)
sudo mkdir -p /mnt/lv_snapshot
sudo mount -o ro /dev/vol_grp1/lv_snapshot /mnt/lv_snapshot

# 2. 백업 수행
tar -czf /backup/lv_backup_$(date +%Y%m%d).tar.gz /mnt/lv_snapshot

# 또는 rsync로 백업
rsync -av /mnt/lv_snapshot/ /backup/lv_data/

# 3. 스냅샷 언마운트
sudo umount /mnt/lv_snapshot

# 4. 스냅샷 삭제 (백업 완료 후)
sudo lvremove /dev/vol_grp1/lv_snapshot
```


### 스냅샷 복구

```bash
# 1. 원본 LV 언마운트
sudo umount /mnt/data

# 2. 스냅샷으로 복구 (Merge)
sudo lvconvert --merge /dev/vol_grp1/lv_snapshot

# 3. 재부팅 후 자동 merge
# 또는 LV 비활성화 후 즉시 merge
sudo lvchange -an /dev/vol_grp1/logical_vol1
sudo lvconvert --merge /dev/vol_grp1/lv_snapshot
sudo lvchange -ay /dev/vol_grp1/logical_vol1

# 4. 재마운트
sudo mount /dev/vol_grp1/logical_vol1 /mnt/data
```


### 스냅샷 장점

- **빠른 생성**
  - 몇 초 내에 스냅샷 생성 완료
  - 전체 복사가 아닌 메타데이터만 생성

- **공간 효율성**
  - 변경된 블록만 저장
  - 원본 크기의 작은 비율만 필요

- **무중단 백업**
  - 원본 LV는 계속 사용 가능
  - 백업 중에도 서비스 정상 운영

- **빠른 복구**
  - 스냅샷으로 즉시 롤백 가능
  - 재해 복구 시간 최소화


<br/><br/>

## LVM RAID 기능


### RAID 0 (Striping) - 성능 향상

- 데이터를 여러 디스크에 분산 저장
- 병렬 I/O로 성능 향상

```bash
# 2개 디스크에 스트라이핑
sudo lvcreate -i 2 -L 500M -n striped_lv vol_grp1 /dev/sda6 /dev/sda7

# 옵션 설명
# -i 2: 2개 디스크에 분산 (stripe count)
# -I: stripe size 지정 (기본 64KB)

# Stripe size 지정 예시
sudo lvcreate -i 2 -I 128 -L 1G -n striped_lv vol_grp1
```


#### RAID 0 특징

- **장점**
  - 읽기/쓰기 속도 향상
  - 용량 100% 활용

- **단점**
  - 한 디스크라도 실패하면 전체 데이터 손실
  - 안정성 낮음

- **권장 용도**
  - 임시 데이터
  - 캐시 스토리지
  - 성능이 중요한 비중요 데이터


### RAID 1 (Mirroring) - 안정성 향상

- 데이터를 여러 디스크에 복제
- 중복성으로 안정성 향상

```bash
# 2개 디스크에 미러링
sudo lvcreate -m 1 -L 500M -n mirrored_lv vol_grp1 /dev/sda6 /dev/sda7

# 옵션 설명
# -m 1: 1개 미러 (총 2개 복사본)
# -m 2: 2개 미러 (총 3개 복사본)

# 특정 PV 지정
sudo lvcreate -m 1 -L 1G -n mirrored_lv vol_grp1 /dev/sda6 /dev/sda7
```


#### RAID 1 특징

- **장점**
  - 한 디스크 실패해도 데이터 안전
  - 읽기 성능 향상 가능

- **단점**
  - 용량 절반만 사용 가능
  - 쓰기 성능 약간 저하

- **권장 용도**
  - 중요 데이터
  - 데이터베이스
  - 시스템 파티션


<br/><br/>

## LVM 명령어 참조


### 명령어 패턴

| 접두사 | 대상 | 예시 명령어 |
|--------|------|-------------|
| **pv** | Physical Volume | `pvcreate`, `pvdisplay`, `pvs`, `pvscan` |
| **vg** | Volume Group | `vgcreate`, `vgdisplay`, `vgs`, `vgscan` |
| **lv** | Logical Volume | `lvcreate`, `lvdisplay`, `lvs`, `lvscan` |


### 명령어 접미사

| 접미사 | 동작 | 예시 |
|--------|------|------|
| **create** | 생성 | `pvcreate`, `vgcreate`, `lvcreate` |
| **remove** | 삭제 | `pvremove`, `vgremove`, `lvremove` |
| **display** | 상세 정보 표시 | `pvdisplay`, `vgdisplay`, `lvdisplay` |
| **s** | 간단한 목록 | `pvs`, `vgs`, `lvs` |
| **scan** | 스캔 | `pvscan`, `vgscan`, `lvscan` |
| **extend** | 확장 | `vgextend`, `lvextend` |
| **reduce** | 축소 | `vgreduce`, `lvreduce` |
| **resize** | 크기 조정 | `lvresize` |
| **change** | 속성 변경 | `vgchange`, `lvchange` |


<br/><br/>

## LVM 실습 예제


### 전체 설정 과정

```bash
# 1. 디스크 추가 및 인식
# VMware: VM Settings → Hardware → Add HDD
find /sys -name scan
echo "- - -" > /sys/class/scsi_host/host2/scan

# 2. 디스크 확인
lsblk
fdisk -l

# 3. 파티션 생성
sudo fdisk /dev/sdc
  n  # 새 파티션
  p  # Primary
  1  # 파티션 번호
     # (Enter - 기본값)
     # (Enter - 기본값)
  t  # 타입 변경
  8e # LVM 타입
  w  # 저장

# 4. PV 생성
sudo pvcreate /dev/sdc1
sudo pvs

# 5. VG 생성
sudo vgcreate lvmtest /dev/sdc1
sudo vgdisplay lvmtest

# 6. LV 생성
sudo lvcreate -L 1000M -n lovolume lvmtest
sudo lvs

# 7. 포맷
sudo mkfs.ext4 /dev/lvmtest/lovolume

# 8. 마운트
sudo mkdir -p /mount
sudo mount /dev/lvmtest/lovolume /mount
df -h

# 9. 영구 마운트 설정
sudo blkid /dev/lvmtest/lovolume
sudo vi /etc/fstab
# UUID=xxx /mount ext4 defaults 0 0

# 10. 테스트
sudo mount -a
df -h
```


<br/><br/>

## 트러블슈팅


### 일반적인 문제 해결

| 문제 | 원인 | 해결 방법 |
|------|------|-----------|
| **디스크 용량 부족** | VG에 여유 공간 없음 | 새 PV 추가 후 VG 확장 |
| **LV 확장 후 용량 안 늘어남** | 파일 시스템 리사이징 안 함 | `resize2fs` 또는 `xfs_growfs` 실행 |
| **PV 제거 실패** | PV가 사용 중 | LV 제거 또는 이동 후 재시도 |
| **스냅샷 용량 부족** | 원본 변경량이 스냅샷 크기 초과 | 스냅샷 크기 증가 또는 백업 후 삭제 |
| **LV 활성화 실패** | VG 비활성화 상태 | `vgchange -ay VG명` 실행 |
| **파일 시스템 손상** | 비정상 종료, 하드웨어 오류 | `fsck` 또는 `xfs_repair` 실행 |


### LV 상태 확인

```bash
# 상세 매핑 정보
sudo lvdisplay -m /dev/vol_grp1/logical_vol1

# PE 할당 상태 확인
sudo lvs -o+seg_pe_ranges

# VG 전체 상태
sudo vgdisplay -v vol_grp1
```


### 메타데이터 복구

```bash
# VG 메타데이터 백업 확인
sudo ls -l /etc/lvm/backup/

# 메타데이터 복구
sudo vgcfgrestore -f /etc/lvm/backup/vol_grp1 vol_grp1

# VG 활성화
sudo vgchange -ay vol_grp1
```


<br/><br/>

## 사용 시나리오


### 설계 단계

- **VG 이름 규칙 수립**
  - 용도별로 명확한 이름 사용
  - 예시: `data_vg`, `logs_vg`, `backup_vg`

- **적절한 PE 크기 선택**
  - 기본값 4MB 대부분 적합
  - 대용량 스토리지는 8MB 또는 16MB 고려

- **여유 공간 확보**
  - VG에 최소 10-20% 여유 공간 유지
  - 스냅샷 및 확장을 위한 버퍼


### 운영 단계

- **정기 모니터링**
  - VG, LV 사용률 주기적 확인
  - `vgs`, `lvs` 명령어로 용량 체크

- **백업 전략**
  - 중요 데이터는 스냅샷 + 외부 백업 병행
  - 스냅샷은 임시 백업용으로만 사용

- **확장 계획**
  - 용량 부족 전에 미리 확장
  - 온라인 확장으로 서비스 무중단


### 보안 강화

- **민감 데이터 암호화**
  - LUKS (Linux Unified Key Setup) 사용
  - LV 레벨에서 암호화 적용

- **권한 관리**
  - LV 장치 파일 권한 적절히 설정
  - 불필요한 사용자 접근 차단


<br/><br/>

## 요약 및 빠른 참조


### 상황별 해결책

| 상황 | 명령어 흐름 | 비고 |
|------|-------------|------|
| **디스크 추가 및 LVM 구성** | `fdisk` → `pvcreate` → `vgcreate` → `lvcreate` → `mkfs` → `mount` | 기본 설정 |
| **용량 부족 시 확장** | `pvcreate` → `vgextend` → `lvextend` → `resize2fs` | 온라인 확장 가능 |
| **백업 필요** | `lvcreate -s` → `mount` → `tar`/`rsync` → `lvremove` | 스냅샷 활용 |
| **성능 향상** | `lvcreate -i N` (Striping) | RAID 0 |
| **안정성 향상** | `lvcreate -m N` (Mirroring) | RAID 1 |


### 권장 구성 및 운영

```bash
# 생성
pvcreate /dev/sdX        # PV 생성
vgcreate VG명 PV명       # VG 생성
lvcreate -L 크기 -n LV명 VG명  # LV 생성

# 확인
pvs / vgs / lvs          # 간단 목록
pvdisplay / vgdisplay / lvdisplay  # 상세 정보

# 확장
vgextend VG명 PV명       # VG 확장
lvextend -L +크기 LV경로 # LV 확장
resize2fs LV경로         # 파일 시스템 확장

# 스냅샷
lvcreate -L 크기 -s -n 스냅샷명 LV경로  # 스냅샷 생성
lvremove 스냅샷경로      # 스냅샷 삭제

# 삭제
lvremove LV경로          # LV 삭제
vgremove VG명            # VG 삭제
pvremove PV명            # PV 삭제
```


### 핵심 기억 사항

- **3계층 구조**
  - PV (물리) → VG (풀) → LV (논리)

- **온라인 확장 가능**
  - 서비스 중단 없이 용량 증설
  - LVM의 최대 장점

- **확장 후 리사이징 필수**
  - `lvextend` 후 반드시 `resize2fs` 실행
  - 그렇지 않으면 새 공간 사용 불가

- **스냅샷은 임시용**
  - CoW 방식으로 빠르고 효율적
  - 장기 백업은 외부 저장소 사용

- **RAID 기능 활용**
  - Striping: 성능 중시
  - Mirroring: 안정성 중시


<br/><br/>

## Reference
- [Red Hat LVM 관리자 가이드](https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/8/html-single/configuring_and_managing_logical_volumes/index)
- [LVM HOWTO](https://tldp.org/HOWTO/LVM-HOWTO/)
- [Ubuntu LVM 가이드](https://ubuntu.com/server/docs/lvm)
- [ArchWiki LVM](https://wiki.archlinux.org/title/LVM)
# Linux Volume 구조
---
### **LVM**
* **LVM(Logical Volume Manager)**  
- 논리적인 공간을 생성, 관리해주는 프로그램
- 저장 장치를 파티션(하나의 하드디스크에서 나누어진 구역)이 아닌 논리 볼륨으로 할당
- 관리 쉽고 확장성이 뛰어남
- 파티션을 원하는 대로 추가하거나 제거하고 크기 조절할 수 있도록 하는 방법

### **LVM의 사용**
- 여러개의 디스크 공간을 합쳐서 하나의 디스크로 사용하기 위해 사용
- 사용하기 애매한 공간의 디스크 파티션들을 활용하기 위해 사용
- 기존에 사용 중인 디스크 공간을 확장할 수 있게 사용

### **PV(Physical Volume)**
- 각각의 파티션을 LVM에서 사용하기 위해 나눈 물리적 공간
- 디스크 공간이 PE라는 단위로 이루어져있음
- 실제로 나눈 파티션

### **PE(Physical Extent)**
- 물리적 저장공간인 PV의 최소 단위
- 기본 단위는 4MB
- 실제 데이터가 저장되는 공간

### **VG(Volume Group)**
- PV들을 하나의 그룹으로 합친 것
- PV로 되어 있는 파티션을 그룹으로 설정

### **LV(Logical Volume)**
- mount point로 사용할 실질적인 파티션
- 크기 확장 및 축소 가능
- LVM에서 사용하기 위한 논리적인 공간

### **LE(Logical Extent)**
- 논리적 공간인 LV의 최소 단위
<br/><br/>

# LVM 설정
---
### **LVM 명령어**
* 명령어 기본 베이스
  ```plaintext
  create  생성
  remove  삭제
  scan  검색
  display  확인
  extend  확장
  reduce  축소
  change  속성 변경
  ```  

* 물리 볼륨 관련 명령어
  ```bash
  pvcreate {DEVICE_NAME}  # fdisk로 만든 파티션을 물리 볼륨(PV)로 생성
  pvscan  # 물리 볼륨에 해당하는 시스템에 있는 모든 lvm 블록 장치 스캔
  pvdisplay  # 각각의 물리 볼륨에 대해 상세 출력 가능 (크기, extend, volume group)
  ```    

* 볼륨 그룹 관련 명령어   
  ```bash
  vgcreate {VOLUME_NAME} {DEVICE_NAME}  # 볼륨 그룹 설정
  vgscan  # 디스크에 있는 볼륨 그룹 (VG)을 검색하여 출력
  vgdisplay {-v} {DEVICE_NAME}  # 볼륨 그룹의 속성과 정보를 보여주는 명령어
  vgreduce {VOLUME_NAME} {DELETE_DEVICE_NAME}  # 볼륨 그룹에서 물리 볼륨 (장치) 삭제
  vgextend {VOLUME_NAME} {ADD_DEVICE_NAME}  # 볼륨 그룹에 추가로 물리 볼륨 추가
  vgchange { -a, -l} {VOLUME_GROUP}  # 볼륨 그룹 속성 변경 (볼륨 그룹 사용 여부, 최대 LV갯수) 
  vgremove {VOLUME_GROUP}  # 볼륨 그룹을 제거
  ```
  * `vgdisplay -v`
    * logical volume과 physical volume도 같이 자세히 보여주는 옵션
  * `vgchange -a {Y/N}`
    * 볼륨 그룹의 사용 여부 지정
  * `vgchange -l​ {COUNT}`
    * 해당 볼륨 그룹에 생성할 수 있는 최대 논리 볼륨 수 지정  

* 논리 볼륨 관련 명령어
  ```bash
  lvcreate {-L,-l,-n} {VOLUME_GROUP}  # 볼륨 그룹 안에 논리 볼륨(LV) 생성
  lvscan {-v}  # 디스크에 있는 논리 볼륨 스캔
  lvdisplay {-v} {LV_PATH}  # 논리볼륨의 정보 출력
  lvreduce {-L,-l} {LV_PATH}  # 논리 볼륨 용량 줄이기
  lvextend {-L,-l} {LV_PATH}  # 논리 볼륨 용량 확장
  lvresize {-L,-l} {LV_PATH}   # 논리 볼륨 용량 조정
  lvremove {LV_PATH}   # 논리 볼륨 제거
  ```  
  * `lvcreate -L {size}`
    * LV의 사이즈 지정 (kb, mb, gb, tb)
  * `lvcreate -l {PE COUNT}`
    * LV의 사이즈 지정
    * pe 개수로 용량 지정 (1MB = 4MB) 
    * `{ % }FREE`
      * 볼륨 그룹에 있는 나머지 여유 공간 퍼센트 지정
  * `lvcreate -n {VOLUME_NAME}`
    * LV의 이름 지정
  * `lvscan -v`
    * 정보 자세히 출력  
  * `lvdisplay -v`
    * 정보 자세히 출력
  * `lvreduce -L {-SIZE}`
    * 지정한 사이즈만큼 용량 줄이기 (default : MB)
  * `lvreduce -l  {-SIZE}`
    * 지정한 pe수 만큼 용량 줄이기
  * `lvextend -L {+SIZE}`
    * 지정한 사이즈만큼 용량 확장 (default : MB)
  * `lvextend -l  {+SIZE}`
    * 지정한 pe수 만큼 용량 확장
  * `lvresize -L {+/-SIZE}`
    * 지정한 사이즈만큼 용량 확장/줄이기 (default : MB)
  * `lvresize -l  {+/-SIZE}`
    * 지정한 pe수 만큼 용량 확장/줄이기  

### **LVM 설정**
1. Virtual Machine Settings → Hardware → HDD 추가
2. 추가한 하드 디스크 재부팅 없이 인식
  ```bash
  find /sys -name scan  # 가장 마지막 host 내용 드래그 
  echo "- - -" >/sys/devices/~~  # 마지막 host 내용 붙이기
  ```
3. 파티션 생성 및 속성 변환
  ```bash
  fdisk -l  # 추가한 하드 디스크 list 확인  ex) /dev/sdc
  fdisk /dev/sdc  # 추가한 /dev/sdc를 fdisk 명령어를 이용하여 실행
    n  # 새로운 파티션 추가
    p  # primary 파티션 생성
    # 파티션 넘버 default
    # Enter
    # Enter
    t  # 파티션 속성(시스템 ID) 변경
    L  # 시스템 ID list 확인
    8e  # LVM 속성으로 변경
    w  # 파티션 정보 저장
  fdisk -l  # 속성 변경한 하드 디스크 list 확인
  ```
4. 물리적 볼륨 생성
  ```bash
  pvcreate /dev/sdc1  # 물리적 볼륨 생성
  ```
5. 볼륨 그룹 설정
  ```bash
  vgcreate lvmtest /dev/sdc1  # 생성된 PV를 특정 볼륨 그룹에 추가
  vgdisplay -v lvmtest  # lvmtest 볼륨 그룹의 속성, 정보 자세히 출력
  ```
6. 논리 볼륨 생성
  ```bash
  lvcreate -L 1000M -n lovolume lvmtest  # lvmtest 볼륨 그룹 안에 1000M 크기의 lovolume 논리 볼륨 생성
  lvscan  # 디스크에 있는 논리 볼륨 스캔 및 경로 확인
  lvdisplay -v /dev/lvmtest/lovolume  # 논리 볼륨의 정보 자세히 출력 
  ```
7. 정보 확인
  ```bash
  vgdisplay -v lvmtest  # lvmtest 볼륨 그룹의 속성,정보 자세히 출력
  # vg 속성 정보 확인
  # lv 속성 정보 (경로, lv 속한 vg) 확인
  # # pv 속성 정보 확인
  ```
8. 포맷 후 마운트
  ```bash
  mkfs -t ext4 /dev/lvmtest/lovolume   # /dev/sdc1 파티션을 포맷
  mount -t ext4 /dev/lvmtest/lovolume /mount  # ext4 파일시스템 형식으로 /dev/lvmtest/lovolume을 /mount 디렉토리에 mount
  df -h  # mount 정보 출력
  blkid  # 영구 mount하기 위해 디바이스 UUID 검색
  vi /etc/fstab   # 영구 mount하기 위한 file 수정
  ```  
  ```bash
  # /etc/fstab
  UUID=fa29083a-72e5-4e3d-a9c0-1b3c616e56c1 /mount ext4 defaults 0 0
  # UUID=파일시스템 DEVICE_NAME mout point filesystem type mount option 로그기록여부 오류체크
  ```